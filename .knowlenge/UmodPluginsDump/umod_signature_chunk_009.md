# uMod Plugins Dataset - Code Abstractions (Continued)

Chunk 9 - Generated: 2025-07-06 20:25:18

## TankCommander by k1lly0u - Drive tanks, shoot stuff

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Globalization;
using Rust;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("Tank Commander", "k1lly0u", "0.2.3")]
[Description("Drive tanks, shoot stuff")]
 class TankCommander : RustPlugin
{
    [PluginReference]
    private Plugin Friends;
    private Plugin Clans;
    private Plugin Godmode;
    private static TankCommander ins;
    private List<APCController> controllers;
    private Dictionary<CommandType, BUTTON> controlButtons;
    private int rocketId;
    private int mgId;
    private const string APC_PREFAB;
    private const string CHAIR_PREFAB;
    private const string UI_HEALTH;
    private const string UI_AMMO_MG;
    private const string UI_AMMO_ROCKET;
    private const int TARGET_LAYERS;
    private void Loaded();
    private void OnServerInitialized();
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnPlayerInput(BasePlayer player, InputState input);
    private object CanDismountEntity(BasePlayer player, BaseMountable mountable);
    private void OnPlayerDisconnected(BasePlayer player);
    private object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity entity);
    private void Unload();
    private bool IsOnboardAPC(BasePlayer player);
    private bool IsOnboardAPC(BasePlayer player, APCController controller);
    private T ParseType(string type);
    private bool HasPermission(BasePlayer player, string perm);
    private void ConvertControlButtons();
    private void OpenTankInventory(BasePlayer player, APCController controller);
    private class APCController : MonoBehaviour
    {
        public BradleyAPC entity;
        private Rigidbody rigidBody;
        private BaseMountable[] mountables;
        private WheelCollider[] leftWheels;
        private WheelCollider[] rightWheels;
        public ItemContainer inventory;
        private float accelTimeTaken;
        private float accelTimeToTake;
        private float forwardTorque;
        private float maxBrakeTorque;
        private float turnTorque;
        private float lastFireCannon;
        private float lastFireMG;
        private float lastFireCoax;
        private bool isDying;
        private RaycastHit eyeRay;
        private Vector3 mouseInput;
        private Vector3 aimVector;
        private Vector3 aimVectorTop;
        private Dictionary<CommandType, BUTTON> controlButtons;
        private ConfigData.WeaponOptions.WeaponSystem cannon;
        private ConfigData.WeaponOptions.WeaponSystem mg;
        private ConfigData.WeaponOptions.WeaponSystem coax;
        private ConfigData.CrushableTypes crushables;
        public bool HasCommander { get; set; }
        public BasePlayer Commander { get; set; }
        private void Awake();
        private void OnDestroy();
        private void Update();
        private void LateUpdate();
        private void OnCollisionEnter(Collision collision);
        private float CalculateImpactForce(Collision col);
        private bool IsPassenger(BasePlayer player);
        private List<KeyValuePair<Vector3, Vector3>> mountOffsets;
        private void CreateMountPoints();
        private void CreateMountPoint(int index);
        public bool CanMountPlayer();
        public void MountPlayer(BasePlayer player);
        public void DismountPlayer(BasePlayer player);
        private void DismountAll();
        private void OnEntityMounted(BasePlayer player, bool isOperator);
        private void SetInitialAimDirection();
        private void DoWeaponControls();
        private void AdjustAiming();
        private const float DDRAW_UPDATE_TIME;
        private void DrawTargeting();
        private void FireCannon();
        private void FireCoax();
        private void FireMG();
        private void FireSideGuns();
        private void ApplyDamage(BaseCombatEntity hitEntity, float damage, Vector3 point, Vector3 normal);
        private void DoMovementControls();
        private void SetThrottleSpeed(float acceleration, float steering, bool boost);
        private void ApplyBrakes(float amount);
        private void ApplyBrakeTorque(float amount, bool rightSide);
        private void ApplyMotorTorque(float torque, bool rightSide);
        private void ToggleLights();
        public void ManageDamage(HitInfo info);
        private void OnDeath();
    }

    [ChatCommand("spawntank")]
     void cmdTank(BasePlayer player, string command, string[] args);
    [ConsoleCommand("spawntank")]
     void ccmdSpawnTank(ConsoleSystem.Arg arg);
    private bool AreFriends(ulong playerId, ulong friendId);
    private bool IsClanmate(ulong playerId, ulong friendId);
    public static class UI
    {
        static public CuiElementContainer ElementContainer(string panelName, string color, UI4 dimensions, bool useCursor, string parent);
        static public void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor);
        static public void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align);
        public static string Color(string hexColor, float alpha);
    }

    public class UI4
    {
        public float xMin;
        public float yMin;
        public float xMax;
        public float yMax;
        public UI4(float xMin, float yMin, float xMax, float yMax);
        public string GetMin();
        public string GetMax();
    }

    private static void CreateHealthUI(BasePlayer player, APCController controller);
    private static void CreateMGAmmoUI(BasePlayer player, APCController controller);
    private static void CreateRocketAmmoUI(BasePlayer player, APCController controller);
    private static void DestroyUI(BasePlayer player, string panel);
    private static void DestroyAllUI(BasePlayer player);
    private static ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Movement Settings")]
        public MovementSettings Movement { get; set; }
        [JsonProperty(PropertyName = "Button Configuration")]
        public ButtonConfiguration Buttons { get; set; }
        [JsonProperty(PropertyName = "Crushable Types")]
        public CrushableTypes Crushables { get; set; }
        [JsonProperty(PropertyName = "Passenger Options")]
        public PassengerOptions Passengers { get; set; }
        [JsonProperty(PropertyName = "Inventory Options")]
        public InventoryOptions Inventory { get; set; }
        [JsonProperty(PropertyName = "Weapon Options")]
        public WeaponOptions Weapons { get; set; }
        public class CrushableTypes
        {
            [JsonProperty(PropertyName = "Can crush buildings")]
            public bool Buildings { get; set; }
            [JsonProperty(PropertyName = "Can crush resources")]
            public bool Resources { get; set; }
            [JsonProperty(PropertyName = "Can crush loot containers")]
            public bool Loot { get; set; }
            [JsonProperty(PropertyName = "Can crush animals")]
            public bool Animals { get; set; }
            [JsonProperty(PropertyName = "Can crush players")]
            public bool Players { get; set; }
            [JsonProperty(PropertyName = "Amount of force required to crush various building grades")]
            public Dictionary<string, float> GradeForce { get; set; }
            [JsonProperty(PropertyName = "Amount of force required to crush external walls")]
            public float WallForce { get; set; }
            [JsonProperty(PropertyName = "Amount of force required to crush resources")]
            public float ResourceForce { get; set; }
        }

        public class ButtonConfiguration
        {
            [JsonProperty(PropertyName = "Enter/Exit vehicle")]
            public string Enter { get; set; }
            [JsonProperty(PropertyName = "Toggle light")]
            public string Lights { get; set; }
            [JsonProperty(PropertyName = "Open inventory")]
            public string Inventory { get; set; }
            [JsonProperty(PropertyName = "Speed boost")]
            public string Boost { get; set; }
            [JsonProperty(PropertyName = "Fire Cannon")]
            public string Cannon { get; set; }
            [JsonProperty(PropertyName = "Fire Coaxial Gun")]
            public string Coax { get; set; }
            [JsonProperty(PropertyName = "Fire MG")]
            public string MG { get; set; }
        }

        public class MovementSettings
        {
            [JsonProperty(PropertyName = "Forward torque (nm)")]
            public float ForwardTorque { get; set; }
            [JsonProperty(PropertyName = "Rotation torque (nm)")]
            public float TurnTorque { get; set; }
            [JsonProperty(PropertyName = "Brake torque (nm)")]
            public float BrakeTorque { get; set; }
            [JsonProperty(PropertyName = "Time to reach maximum acceleration (seconds)")]
            public float Acceleration { get; set; }
            [JsonProperty(PropertyName = "Boost torque (nm)")]
            public float BoostTorque { get; set; }
        }

        public class PassengerOptions
        {
            [JsonProperty(PropertyName = "Allow passengers")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Number of allowed passengers (Max 4)")]
            public int Max { get; set; }
            [JsonProperty(PropertyName = "Require passenger to be a friend (FriendsAPI)")]
            public bool UseFriends { get; set; }
            [JsonProperty(PropertyName = "Require passenger to be a clan mate (Clans)")]
            public bool UseClans { get; set; }
        }

        public class InventoryOptions
        {
            [JsonProperty(PropertyName = "Enable inventory system")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Drop inventory on death")]
            public bool DropInv { get; set; }
            [JsonProperty(PropertyName = "Drop loot on death")]
            public bool DropLoot { get; set; }
            [JsonProperty(PropertyName = "Inventory size (max 36)")]
            public int Size { get; set; }
        }

        public class WeaponOptions
        {
            [JsonProperty(PropertyName = "Cannon")]
            public WeaponSystem Cannon { get; set; }
            [JsonProperty(PropertyName = "Coaxial")]
            public WeaponSystem Coax { get; set; }
            [JsonProperty(PropertyName = "Machine Gun")]
            public WeaponSystem MG { get; set; }
            [JsonProperty(PropertyName = "Enable Crosshair")]
            public bool EnableCrosshair { get; set; }
            [JsonProperty(PropertyName = "Crosshair Color")]
            public SerializedColor CrosshairColor { get; set; }
            [JsonProperty(PropertyName = "Crosshair Size")]
            public int CrosshairSize { get; set; }
            public class SerializedColor
            {
                public float R { get; set; }
                public float G { get; set; }
                public float B { get; set; }
                public float A { get; set; }
                private Color _color;
                private bool _isInit;
                public SerializedColor(float r, float g, float b, float a);
                [JsonIgnore]
                public Color Color { get; set; }
            }

            public class WeaponSystem
            {
                [JsonProperty(PropertyName = "Enable weapon system")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Require ammunition in inventory")]
                public bool RequireAmmo { get; set; }
                [JsonProperty(PropertyName = "Ammunition type (item shortname)")]
                public string Type { get; set; }
                [JsonProperty(PropertyName = "Fire rate (seconds)")]
                public float Interval { get; set; }
                [JsonProperty(PropertyName = "Aim cone (smaller number is more accurate)")]
                public float Accuracy { get; set; }
                [JsonProperty(PropertyName = "Damage")]
                public float Damage { get; set; }
            }

        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private static string msg(string key, string playerId);
    private Dictionary<string, string> Messages;
}

private class APCController : MonoBehaviour
{
    public BradleyAPC entity;
    private Rigidbody rigidBody;
    private BaseMountable[] mountables;
    private WheelCollider[] leftWheels;
    private WheelCollider[] rightWheels;
    public ItemContainer inventory;
    private float accelTimeTaken;
    private float accelTimeToTake;
    private float forwardTorque;
    private float maxBrakeTorque;
    private float turnTorque;
    private float lastFireCannon;
    private float lastFireMG;
    private float lastFireCoax;
    private bool isDying;
    private RaycastHit eyeRay;
    private Vector3 mouseInput;
    private Vector3 aimVector;
    private Vector3 aimVectorTop;
    private Dictionary<CommandType, BUTTON> controlButtons;
    private ConfigData.WeaponOptions.WeaponSystem cannon;
    private ConfigData.WeaponOptions.WeaponSystem mg;
    private ConfigData.WeaponOptions.WeaponSystem coax;
    private ConfigData.CrushableTypes crushables;
    public bool HasCommander { get; set; }
    public BasePlayer Commander { get; set; }
    private void Awake();
    private void OnDestroy();
    private void Update();
    private void LateUpdate();
    private void OnCollisionEnter(Collision collision);
    private float CalculateImpactForce(Collision col);
    private bool IsPassenger(BasePlayer player);
    private List<KeyValuePair<Vector3, Vector3>> mountOffsets;
    private void CreateMountPoints();
    private void CreateMountPoint(int index);
    public bool CanMountPlayer();
    public void MountPlayer(BasePlayer player);
    public void DismountPlayer(BasePlayer player);
    private void DismountAll();
    private void OnEntityMounted(BasePlayer player, bool isOperator);
    private void SetInitialAimDirection();
    private void DoWeaponControls();
    private void AdjustAiming();
    private const float DDRAW_UPDATE_TIME;
    private void DrawTargeting();
    private void FireCannon();
    private void FireCoax();
    private void FireMG();
    private void FireSideGuns();
    private void ApplyDamage(BaseCombatEntity hitEntity, float damage, Vector3 point, Vector3 normal);
    private void DoMovementControls();
    private void SetThrottleSpeed(float acceleration, float steering, bool boost);
    private void ApplyBrakes(float amount);
    private void ApplyBrakeTorque(float amount, bool rightSide);
    private void ApplyMotorTorque(float torque, bool rightSide);
    private void ToggleLights();
    public void ManageDamage(HitInfo info);
    private void OnDeath();
}

public static class UI
{
    static public CuiElementContainer ElementContainer(string panelName, string color, UI4 dimensions, bool useCursor, string parent);
    static public void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor);
    static public void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align);
    public static string Color(string hexColor, float alpha);
}

public class UI4
{
    public float xMin;
    public float yMin;
    public float xMax;
    public float yMax;
    public UI4(float xMin, float yMin, float xMax, float yMax);
    public string GetMin();
    public string GetMax();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Movement Settings")]
    public MovementSettings Movement { get; set; }
    [JsonProperty(PropertyName = "Button Configuration")]
    public ButtonConfiguration Buttons { get; set; }
    [JsonProperty(PropertyName = "Crushable Types")]
    public CrushableTypes Crushables { get; set; }
    [JsonProperty(PropertyName = "Passenger Options")]
    public PassengerOptions Passengers { get; set; }
    [JsonProperty(PropertyName = "Inventory Options")]
    public InventoryOptions Inventory { get; set; }
    [JsonProperty(PropertyName = "Weapon Options")]
    public WeaponOptions Weapons { get; set; }
    public class CrushableTypes
    {
        [JsonProperty(PropertyName = "Can crush buildings")]
        public bool Buildings { get; set; }
        [JsonProperty(PropertyName = "Can crush resources")]
        public bool Resources { get; set; }
        [JsonProperty(PropertyName = "Can crush loot containers")]
        public bool Loot { get; set; }
        [JsonProperty(PropertyName = "Can crush animals")]
        public bool Animals { get; set; }
        [JsonProperty(PropertyName = "Can crush players")]
        public bool Players { get; set; }
        [JsonProperty(PropertyName = "Amount of force required to crush various building grades")]
        public Dictionary<string, float> GradeForce { get; set; }
        [JsonProperty(PropertyName = "Amount of force required to crush external walls")]
        public float WallForce { get; set; }
        [JsonProperty(PropertyName = "Amount of force required to crush resources")]
        public float ResourceForce { get; set; }
    }

    public class ButtonConfiguration
    {
        [JsonProperty(PropertyName = "Enter/Exit vehicle")]
        public string Enter { get; set; }
        [JsonProperty(PropertyName = "Toggle light")]
        public string Lights { get; set; }
        [JsonProperty(PropertyName = "Open inventory")]
        public string Inventory { get; set; }
        [JsonProperty(PropertyName = "Speed boost")]
        public string Boost { get; set; }
        [JsonProperty(PropertyName = "Fire Cannon")]
        public string Cannon { get; set; }
        [JsonProperty(PropertyName = "Fire Coaxial Gun")]
        public string Coax { get; set; }
        [JsonProperty(PropertyName = "Fire MG")]
        public string MG { get; set; }
    }

    public class MovementSettings
    {
        [JsonProperty(PropertyName = "Forward torque (nm)")]
        public float ForwardTorque { get; set; }
        [JsonProperty(PropertyName = "Rotation torque (nm)")]
        public float TurnTorque { get; set; }
        [JsonProperty(PropertyName = "Brake torque (nm)")]
        public float BrakeTorque { get; set; }
        [JsonProperty(PropertyName = "Time to reach maximum acceleration (seconds)")]
        public float Acceleration { get; set; }
        [JsonProperty(PropertyName = "Boost torque (nm)")]
        public float BoostTorque { get; set; }
    }

    public class PassengerOptions
    {
        [JsonProperty(PropertyName = "Allow passengers")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Number of allowed passengers (Max 4)")]
        public int Max { get; set; }
        [JsonProperty(PropertyName = "Require passenger to be a friend (FriendsAPI)")]
        public bool UseFriends { get; set; }
        [JsonProperty(PropertyName = "Require passenger to be a clan mate (Clans)")]
        public bool UseClans { get; set; }
    }

    public class InventoryOptions
    {
        [JsonProperty(PropertyName = "Enable inventory system")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Drop inventory on death")]
        public bool DropInv { get; set; }
        [JsonProperty(PropertyName = "Drop loot on death")]
        public bool DropLoot { get; set; }
        [JsonProperty(PropertyName = "Inventory size (max 36)")]
        public int Size { get; set; }
    }

    public class WeaponOptions
    {
        [JsonProperty(PropertyName = "Cannon")]
        public WeaponSystem Cannon { get; set; }
        [JsonProperty(PropertyName = "Coaxial")]
        public WeaponSystem Coax { get; set; }
        [JsonProperty(PropertyName = "Machine Gun")]
        public WeaponSystem MG { get; set; }
        [JsonProperty(PropertyName = "Enable Crosshair")]
        public bool EnableCrosshair { get; set; }
        [JsonProperty(PropertyName = "Crosshair Color")]
        public SerializedColor CrosshairColor { get; set; }
        [JsonProperty(PropertyName = "Crosshair Size")]
        public int CrosshairSize { get; set; }
        public class SerializedColor
        {
            public float R { get; set; }
            public float G { get; set; }
            public float B { get; set; }
            public float A { get; set; }
            private Color _color;
            private bool _isInit;
            public SerializedColor(float r, float g, float b, float a);
            [JsonIgnore]
            public Color Color { get; set; }
        }

        public class WeaponSystem
        {
            [JsonProperty(PropertyName = "Enable weapon system")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Require ammunition in inventory")]
            public bool RequireAmmo { get; set; }
            [JsonProperty(PropertyName = "Ammunition type (item shortname)")]
            public string Type { get; set; }
            [JsonProperty(PropertyName = "Fire rate (seconds)")]
            public float Interval { get; set; }
            [JsonProperty(PropertyName = "Aim cone (smaller number is more accurate)")]
            public float Accuracy { get; set; }
            [JsonProperty(PropertyName = "Damage")]
            public float Damage { get; set; }
        }

    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class CrushableTypes
{
    [JsonProperty(PropertyName = "Can crush buildings")]
    public bool Buildings { get; set; }
    [JsonProperty(PropertyName = "Can crush resources")]
    public bool Resources { get; set; }
    [JsonProperty(PropertyName = "Can crush loot containers")]
    public bool Loot { get; set; }
    [JsonProperty(PropertyName = "Can crush animals")]
    public bool Animals { get; set; }
    [JsonProperty(PropertyName = "Can crush players")]
    public bool Players { get; set; }
    [JsonProperty(PropertyName = "Amount of force required to crush various building grades")]
    public Dictionary<string, float> GradeForce { get; set; }
    [JsonProperty(PropertyName = "Amount of force required to crush external walls")]
    public float WallForce { get; set; }
    [JsonProperty(PropertyName = "Amount of force required to crush resources")]
    public float ResourceForce { get; set; }
}

public class ButtonConfiguration
{
    [JsonProperty(PropertyName = "Enter/Exit vehicle")]
    public string Enter { get; set; }
    [JsonProperty(PropertyName = "Toggle light")]
    public string Lights { get; set; }
    [JsonProperty(PropertyName = "Open inventory")]
    public string Inventory { get; set; }
    [JsonProperty(PropertyName = "Speed boost")]
    public string Boost { get; set; }
    [JsonProperty(PropertyName = "Fire Cannon")]
    public string Cannon { get; set; }
    [JsonProperty(PropertyName = "Fire Coaxial Gun")]
    public string Coax { get; set; }
    [JsonProperty(PropertyName = "Fire MG")]
    public string MG { get; set; }
}

public class MovementSettings
{
    [JsonProperty(PropertyName = "Forward torque (nm)")]
    public float ForwardTorque { get; set; }
    [JsonProperty(PropertyName = "Rotation torque (nm)")]
    public float TurnTorque { get; set; }
    [JsonProperty(PropertyName = "Brake torque (nm)")]
    public float BrakeTorque { get; set; }
    [JsonProperty(PropertyName = "Time to reach maximum acceleration (seconds)")]
    public float Acceleration { get; set; }
    [JsonProperty(PropertyName = "Boost torque (nm)")]
    public float BoostTorque { get; set; }
}

public class PassengerOptions
{
    [JsonProperty(PropertyName = "Allow passengers")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Number of allowed passengers (Max 4)")]
    public int Max { get; set; }
    [JsonProperty(PropertyName = "Require passenger to be a friend (FriendsAPI)")]
    public bool UseFriends { get; set; }
    [JsonProperty(PropertyName = "Require passenger to be a clan mate (Clans)")]
    public bool UseClans { get; set; }
}

public class InventoryOptions
{
    [JsonProperty(PropertyName = "Enable inventory system")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Drop inventory on death")]
    public bool DropInv { get; set; }
    [JsonProperty(PropertyName = "Drop loot on death")]
    public bool DropLoot { get; set; }
    [JsonProperty(PropertyName = "Inventory size (max 36)")]
    public int Size { get; set; }
}

public class WeaponOptions
{
    [JsonProperty(PropertyName = "Cannon")]
    public WeaponSystem Cannon { get; set; }
    [JsonProperty(PropertyName = "Coaxial")]
    public WeaponSystem Coax { get; set; }
    [JsonProperty(PropertyName = "Machine Gun")]
    public WeaponSystem MG { get; set; }
    [JsonProperty(PropertyName = "Enable Crosshair")]
    public bool EnableCrosshair { get; set; }
    [JsonProperty(PropertyName = "Crosshair Color")]
    public SerializedColor CrosshairColor { get; set; }
    [JsonProperty(PropertyName = "Crosshair Size")]
    public int CrosshairSize { get; set; }
    public class SerializedColor
    {
        public float R { get; set; }
        public float G { get; set; }
        public float B { get; set; }
        public float A { get; set; }
        private Color _color;
        private bool _isInit;
        public SerializedColor(float r, float g, float b, float a);
        [JsonIgnore]
        public Color Color { get; set; }
    }

    public class WeaponSystem
    {
        [JsonProperty(PropertyName = "Enable weapon system")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Require ammunition in inventory")]
        public bool RequireAmmo { get; set; }
        [JsonProperty(PropertyName = "Ammunition type (item shortname)")]
        public string Type { get; set; }
        [JsonProperty(PropertyName = "Fire rate (seconds)")]
        public float Interval { get; set; }
        [JsonProperty(PropertyName = "Aim cone (smaller number is more accurate)")]
        public float Accuracy { get; set; }
        [JsonProperty(PropertyName = "Damage")]
        public float Damage { get; set; }
    }

}

public class SerializedColor
{
    public float R { get; set; }
    public float G { get; set; }
    public float B { get; set; }
    public float A { get; set; }
    private Color _color;
    private bool _isInit;
    public SerializedColor(float r, float g, float b, float a);
    [JsonIgnore]
    public Color Color { get; set; }
}

public class WeaponSystem
{
    [JsonProperty(PropertyName = "Enable weapon system")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Require ammunition in inventory")]
    public bool RequireAmmo { get; set; }
    [JsonProperty(PropertyName = "Ammunition type (item shortname)")]
    public string Type { get; set; }
    [JsonProperty(PropertyName = "Fire rate (seconds)")]
    public float Interval { get; set; }
    [JsonProperty(PropertyName = "Aim cone (smaller number is more accurate)")]
    public float Accuracy { get; set; }
    [JsonProperty(PropertyName = "Damage")]
    public float Damage { get; set; }
}


```

---

## TankTurrets by  - Spawns tanks at saved points

```csharp
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using System;
using System.Text;
using Oxide;
using Oxide.Game;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("TankTurrets", "Shadow", "1.0.10")]
[Description("use tank for turret")]
 class TankTurrets : RustPlugin
{
    [PluginReference]
     Plugin Vanish;
    private const string permissionNameKILL;
    private const string permissionNamePOINT;
    private const string permissionNameSPAWN;
    private const string permissionNameREMOVE;
    private Dictionary<string, int> TankTurret;
    private Dictionary<uint, string> npcCreated;
    private string npcPrefab;
     int npcCoolDown;
    protected override void LoadDefaultConfig();
    private void Init();
     void Unload();
     void Delete();
     void startSpawn(string position);
    private bool CanBradleyApcTarget(BradleyAPC bradley, BaseEntity target);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    [ConsoleCommand("tankspawn")]
     void CmdBotCount(ConsoleSystem.Arg arg);
    [ConsoleCommand("killtank")]
     void CmdBotKill(ConsoleSystem.Arg arg);
    [ConsoleCommand("wipepoint")]
     void CmdBotWipe(ConsoleSystem.Arg arg);
    [ChatCommand("tankspawn")]
     void npcSpawn(BasePlayer player);
    [ChatCommand("wipepoint")]
     void npcWipe(BasePlayer player);
    [ChatCommand("tankpoint")]
     void npcMain(BasePlayer player, string command, string[] args);
    [ChatCommand("killtank")]
     void BotKill(BasePlayer player, string command, string[] args);
     string msg(string key, string id);
     object GetVariable(string menu, string datavalue, object defaultValue);
}


```

---

## TargetableDrones by WhiteThunder - Allows RC drones to be targeted by Auto Turrets, SAM Sites and NPCs

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;
using VLB;
using static SamSite;
using HumanNpc = global::HumanNPC;

Oxide.Plugins
[Info("Targetable Drones", "WhiteThunder", "1.2.8")]
[Description("Allows RC drones to be targeted by Auto Turrets and SAM Sites.")]
internal class TargetableDrones : CovalencePlugin
{
    [PluginReference]
    private readonly Plugin Clans;
    private readonly Plugin Friends;
    private readonly Plugin DroneScaleManager;
    private readonly Plugin IQGuardianDrone;
    private const string PermissionUntargetable;
    private const BaseEntity.Flags UntargetableFlag;
    private Configuration _config;
    private readonly object True;
    private float? SqrScanRadius;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnEntitySpawned(Drone drone);
    private object OnEntityEnter(TriggerBase trigger, Drone drone);
    private static ulong GetDroneControllerOrOwnerId(Drone drone);
    private object OnTurretTarget(AutoTurret turret, Drone drone);
    private void OnSamSiteTargetScan(SamSite samSite, List<ISamSiteTarget> targetList);
    private object OnSamSiteTarget(SamSite samSite, SAMTargetComponent droneComponent);
    private void OnEntityTakeDamage(Drone drone, HitInfo hitInfo);
    private void OnDroneScaled(Drone drone, BaseEntity rootEntity, float scale, float previousScale);
    private static class ExposedHooks
    {
        public static object OnSamSiteTarget(SamSite samSite, Drone drone);
    }

    public static void LogInfo(string message);
    public static void LogWarning(string message);
    public static void LogError(string message);
    private static bool SameTeam(ulong userId, ulong otherUserId);
    private static bool IsDroneEligible(Drone drone);
    private static Drone GetParentDrone(BaseEntity entity);
    private static AutoTurret GetDroneTurret(Drone drone);
    private static void RemoveFromAutoTurretTriggers(BaseEntity entity);
    private bool IsTargetableIQGuardianDrone(Drone drone);
    private bool IsDroneBeingControlled(Drone drone);
    private bool IsPlayerTargetExempt(ulong userId);
    private bool IsTargetExempt(Drone drone);
    private BaseEntity GetRootEntity(Drone drone);
    private bool HasFriend(ulong userId, ulong otherUserId);
    private bool SameClan(ulong userId, ulong otherUserId);
    private bool AreAllies(ulong userId, ulong otherUserId);
    private bool ShouldTurretTargetDrone(AutoTurret turret, Drone drone);
    private bool ShouldSamSiteTargetDrone(SamSite samSite, Drone drone);
    private class NPCTargetTriggerComponent : TriggerBase
    {
        public static NPCTargetTriggerComponent AddToDrone(TargetableDrones plugin, Drone drone, GameObject host);
        private const int LayerMask;
        private TargetableDrones _plugin;
        private Drone _drone;
        private Action _checkTriggerContents;
        private NPCTargetTriggerComponent();
        public void CheckTriggerContents();
        public override GameObject InterestedInObject(GameObject obj);
        public override void OnEntityEnter(BaseEntity entity);
        public override void OnEntityLeave(BaseEntity entity);
        private SimpleAIMemory GetMemory(BaseEntity entity, AIBrainSenses senses);
        private SimpleAIMemory GetMemory(BaseEntity entity);
        private bool IsTargetableBy(HumanNpc humanNpc);
        private bool AddToMemory(SimpleAIMemory memory, AIBrainSenses senses);
        private bool RemoveFromMemory(SimpleAIMemory memory);
        private void OnDestroy();
    }

    private class NPCTargetComponent : FacepunchBehaviour
    {
        public static void AddToDrone(TargetableDrones plugin, Drone drone);
        public static void RemoveFromDrone(Drone drone);
        private NPCTargetTriggerComponent _trigger;
        private void OnDestroy();
    }

    private class TurretTargetComponent : EntityComponent<BaseEntity>
    {
        public static void AddToRootEntityIfMissing(Drone drone, BaseEntity rootEntity);
        public static void AddToDroneIfMissing(TargetableDrones plugin, Drone drone);
        private static void RemoveFromEntity(BaseEntity entity);
        public static void RemoveFromDrone(TargetableDrones plugin, Drone drone);
        private Drone _ownerDrone;
        private GameObject _child;
        private TurretTargetComponent InitForDrone(Drone drone);
        private void AddChildLayerForAutoTurrets();
        private void OnDestroy();
    }

    private class SAMTargetComponent : FacepunchBehaviour, ISamSiteTarget
    {
        public static HashSet<SAMTargetComponent> DroneComponents;
        public static void AddToDroneIfMissing(TargetableDrones plugin, Drone drone);
        public static void RemoveFromDrone(Drone drone);
        public Drone Drone { get; set; }
        private TargetableDrones _plugin;
        private Transform _transform;
        private void Awake();
        public Vector3 Position { get; set; }
        public SamTargetType SAMTargetType { get; set; }
        public bool isClient { get; set; }
        public bool IsValidSAMTarget(bool isStaticSamSite);
        public Vector3 CenterPoint();
        public Vector3 GetWorldVelocity();
        public bool IsVisible(Vector3 position, float distance);
        private void OnDestroy();
    }

    private class CaseInsensitiveDictionary : Dictionary<string, TValue>
    {
        public CaseInsensitiveDictionary();
        public CaseInsensitiveDictionary(IEnumerable<KeyValuePair<string, TValue>> collection);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class NPCTargetingSettings
    {
        [JsonProperty("MaxRange")]
        public float MaxRange;
        [JsonProperty("DamageMultiplier")]
        public float DamageMultiplier;
        [JsonProperty("EnabledByNpcPrefab")]
        private CaseInsensitiveDictionary<bool> EnabledByNpcPrefabName;
        private Dictionary<uint, bool> EnabledByNpcPrefabId;
        public bool Enabled { get; set; }
        public bool DamageMultiplierEnabled { get; set; }
        public bool IsAllowed(BaseEntity entity);
        public bool OnServerInitialized();
        private bool AddMissingNpcPrefabs();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class SharingSettings
    {
        [JsonProperty("Team")]
        public bool Team;
        [JsonProperty("Friends")]
        public bool Friends;
        [JsonProperty("Clan")]
        public bool Clan;
        [JsonProperty("Allies")]
        public bool Allies;
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : BaseConfiguration
    {
        [JsonProperty("EnableTurretTargeting")]
        public bool EnableTurretTargeting;
        [JsonProperty("EnablePlayerSAMTargeting")]
        public bool EnablePlayerSAMTargeting;
        [JsonProperty("EnableStaticSAMTargeting")]
        public bool EnableStaticSAMTargeting;
        [JsonProperty("EnableSAMTargeting")]
        public bool DeprecatedEnableSAMTargeting { get; set; }
        [JsonProperty("NPCTargeting")]
        public NPCTargetingSettings NPCTargetingSettings;
        [JsonProperty("DefaultSharingSettings")]
        public SharingSettings DefaultSharingSettings;
        [JsonIgnore]
        public bool EnableSamTargeting { get; set; }
        public bool OnServerInitialized();
    }

    private Configuration GetDefaultConfig();
    [JsonObject(MemberSerialization.OptIn)]
    private class BaseConfiguration
    {
        public bool UsingDefaults;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

private static class ExposedHooks
{
    public static object OnSamSiteTarget(SamSite samSite, Drone drone);
}

private class NPCTargetTriggerComponent : TriggerBase
{
    public static NPCTargetTriggerComponent AddToDrone(TargetableDrones plugin, Drone drone, GameObject host);
    private const int LayerMask;
    private TargetableDrones _plugin;
    private Drone _drone;
    private Action _checkTriggerContents;
    private NPCTargetTriggerComponent();
    public void CheckTriggerContents();
    public override GameObject InterestedInObject(GameObject obj);
    public override void OnEntityEnter(BaseEntity entity);
    public override void OnEntityLeave(BaseEntity entity);
    private SimpleAIMemory GetMemory(BaseEntity entity, AIBrainSenses senses);
    private SimpleAIMemory GetMemory(BaseEntity entity);
    private bool IsTargetableBy(HumanNpc humanNpc);
    private bool AddToMemory(SimpleAIMemory memory, AIBrainSenses senses);
    private bool RemoveFromMemory(SimpleAIMemory memory);
    private void OnDestroy();
}

private class NPCTargetComponent : FacepunchBehaviour
{
    public static void AddToDrone(TargetableDrones plugin, Drone drone);
    public static void RemoveFromDrone(Drone drone);
    private NPCTargetTriggerComponent _trigger;
    private void OnDestroy();
}

private class TurretTargetComponent : EntityComponent<BaseEntity>
{
    public static void AddToRootEntityIfMissing(Drone drone, BaseEntity rootEntity);
    public static void AddToDroneIfMissing(TargetableDrones plugin, Drone drone);
    private static void RemoveFromEntity(BaseEntity entity);
    public static void RemoveFromDrone(TargetableDrones plugin, Drone drone);
    private Drone _ownerDrone;
    private GameObject _child;
    private TurretTargetComponent InitForDrone(Drone drone);
    private void AddChildLayerForAutoTurrets();
    private void OnDestroy();
}

private class SAMTargetComponent : FacepunchBehaviour, ISamSiteTarget
{
    public static HashSet<SAMTargetComponent> DroneComponents;
    public static void AddToDroneIfMissing(TargetableDrones plugin, Drone drone);
    public static void RemoveFromDrone(Drone drone);
    public Drone Drone { get; set; }
    private TargetableDrones _plugin;
    private Transform _transform;
    private void Awake();
    public Vector3 Position { get; set; }
    public SamTargetType SAMTargetType { get; set; }
    public bool isClient { get; set; }
    public bool IsValidSAMTarget(bool isStaticSamSite);
    public Vector3 CenterPoint();
    public Vector3 GetWorldVelocity();
    public bool IsVisible(Vector3 position, float distance);
    private void OnDestroy();
}

private class CaseInsensitiveDictionary : Dictionary<string, TValue>
{
    public CaseInsensitiveDictionary();
    public CaseInsensitiveDictionary(IEnumerable<KeyValuePair<string, TValue>> collection);
}

[JsonObject(MemberSerialization.OptIn)]
private class NPCTargetingSettings
{
    [JsonProperty("MaxRange")]
    public float MaxRange;
    [JsonProperty("DamageMultiplier")]
    public float DamageMultiplier;
    [JsonProperty("EnabledByNpcPrefab")]
    private CaseInsensitiveDictionary<bool> EnabledByNpcPrefabName;
    private Dictionary<uint, bool> EnabledByNpcPrefabId;
    public bool Enabled { get; set; }
    public bool DamageMultiplierEnabled { get; set; }
    public bool IsAllowed(BaseEntity entity);
    public bool OnServerInitialized();
    private bool AddMissingNpcPrefabs();
}

[JsonObject(MemberSerialization.OptIn)]
private class SharingSettings
{
    [JsonProperty("Team")]
    public bool Team;
    [JsonProperty("Friends")]
    public bool Friends;
    [JsonProperty("Clan")]
    public bool Clan;
    [JsonProperty("Allies")]
    public bool Allies;
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : BaseConfiguration
{
    [JsonProperty("EnableTurretTargeting")]
    public bool EnableTurretTargeting;
    [JsonProperty("EnablePlayerSAMTargeting")]
    public bool EnablePlayerSAMTargeting;
    [JsonProperty("EnableStaticSAMTargeting")]
    public bool EnableStaticSAMTargeting;
    [JsonProperty("EnableSAMTargeting")]
    public bool DeprecatedEnableSAMTargeting { get; set; }
    [JsonProperty("NPCTargeting")]
    public NPCTargetingSettings NPCTargetingSettings;
    [JsonProperty("DefaultSharingSettings")]
    public SharingSettings DefaultSharingSettings;
    [JsonIgnore]
    public bool EnableSamTargeting { get; set; }
    public bool OnServerInitialized();
}

[JsonObject(MemberSerialization.OptIn)]
private class BaseConfiguration
{
    public bool UsingDefaults;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## TargetPractice by k1lly0u - Score hits to reactive targets relative to hit position with popup GUI and leader boards

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

Oxide.Plugins
[Info("TargetPractice", "k1lly0u", "0.2.2")]
 class TargetPractice : RustPlugin
{
    private StatisticsData statistics;
    private Hash<ulong, Queue<TargetHitInfo>> playerUI;
    private readonly Vector3 localBullseye;
    private const float RADIUS_BULLSEYE;
    private const float RADIUS_INNER_1;
    private const float RADIUS_INNER_2;
    private const float RADIUS_INNER_3;
    private const float RADIUS_OUTER;
    private const uint TARGET_BONE_ID;
    private const uint BULLSEYE_BONE_ID;
    private const string POPUP_ELEMENT;
    private const string POPUP_FORMAT;
    private const string ADMIN_PERMISSION;
    private static string[] HitColors;
    private FieldInfo _knockdownHealth;
    private FieldInfo _lastToggleTime;
    private void Loaded();
    private void OnServerInitialized();
    private void OnServerSave();
    private void OnEntitySpawned(ReactiveTarget reactiveTarget);
    private void OnEntityTakeDamage(ReactiveTarget reactiveTarget, HitInfo info);
    private void Unload();
    private float EvaluateScore(float f, Hit hit);
    private void ResetTarget(ReactiveTarget reactiveTarget);
    private string FormatWeaponName(Item item);
    private void ChatMessage(BasePlayer player, string key, object[] args);
    private void BroadcastTopScore(string playerName, TargetHitInfo targetHitInfo);
    private PlayerInterface GetUIComponent(BasePlayer player);
    private class PlayerInterface : MonoBehaviour
    {
        internal BasePlayer Player { get; set; }
        internal List<TimedPopup> queue;
        internal List<string> elements;
        private void Awake();
        private void OnDestroy();
        internal void Enqueue(TargetHitInfo targetHitInfo);
        private void TimedRefresh();
    }

    public static class UI
    {
        public static CuiElementContainer Container(string panelName, string color, UI4 dimensions, bool useCursor, string parent);
        public static void Image(CuiElementContainer container, string panel, string url, UI4 dimensions);
        public static void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions);
        public static void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align);
        public static string Color(string hexColor, float alpha);
    }

    public class UI4
    {
        public float xMin;
        public float yMin;
        public float xMax;
        public float yMax;
        public UI4(float xMin, float yMin, float xMax, float yMax);
        public string GetMin();
        public string GetMax();
    }

    private static readonly UI4 IconPosition;
    private static readonly UI4 TextPosition;
    private static string CreatePopup(BasePlayer player, TargetHitInfo info, int position);
    private static UI4 CalculateAnchor(int index, float xMin, float yMin, float xDim, float yDim, float spacing);
    [ChatCommand("target")]
    private void cmdTarget(BasePlayer player, string command, string[] args);
    private static ConfigData Configuration;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Score Values")]
        public Hash<Hit, float> Scores { get; set; }
        [JsonProperty(PropertyName = "Popup Options")]
        public PopupOptions Popup { get; set; }
        [JsonProperty(PropertyName = "Target Options")]
        public TargetOptions Target { get; set; }
        [JsonProperty(PropertyName = "Send server wide notification if the top server score has been beaten")]
        public bool Notify { get; set; }
        [JsonProperty(PropertyName = "Weapons allowed to be used for scoring")]
        public string[] Weapons { get; set; }
        [JsonProperty(PropertyName = "Bullseye image URL")]
        public string Bullseye { get; set; }
        public class TargetOptions
        {
            [JsonProperty(PropertyName = "Amount of damage to take to be knocked down")]
            public float KnockdownHealth { get; set; }
            [JsonProperty(PropertyName = "Amount of time it takes to reset the target")]
            public float ResetTime { get; set; }
        }

        public class PopupOptions
        {
            [JsonProperty(PropertyName = "Popup lifetime (seconds)")]
            public int Lifetime { get; set; }
            [JsonProperty(PropertyName = "Maximum active popup elements")]
            public int Limit { get; set; }
        }

        public class ScoreValues
        {
            public int Bullseye { get; set; }
            public int Yellow { get; set; }
            public int Red { get; set; }
            public int Blue { get; set; }
            public int Edge { get; set; }
        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private void SaveData();
    private void LoadData();
    [ProtoContract]
    private class StatisticsData
    {
        [ProtoMember(1)]
        public Hash<ulong, List<TargetHitInfo>> _players;
        [ProtoMember(2)]
        public List<TargetHitInfo> _sortedScores;
        [JsonIgnore]
        private CompareScore comparer;
        public StatisticsData();
        public bool AddScore(BasePlayer player, TargetHitInfo targetHitInfo);
        public bool GetUserTopHits(ulong playerId, List<TargetHitInfo> list);
        public bool FindUserScores(ulong playerId, string format);
        private class CompareScore : IComparer<TargetHitInfo>
        {
            public int Compare(TargetHitInfo a, TargetHitInfo b);
        }

    }

    private string Msg(string key, string playerId);
    private readonly Dictionary<string, string> Messages;
}

private class PlayerInterface : MonoBehaviour
{
    internal BasePlayer Player { get; set; }
    internal List<TimedPopup> queue;
    internal List<string> elements;
    private void Awake();
    private void OnDestroy();
    internal void Enqueue(TargetHitInfo targetHitInfo);
    private void TimedRefresh();
}

public static class UI
{
    public static CuiElementContainer Container(string panelName, string color, UI4 dimensions, bool useCursor, string parent);
    public static void Image(CuiElementContainer container, string panel, string url, UI4 dimensions);
    public static void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions);
    public static void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align);
    public static string Color(string hexColor, float alpha);
}

public class UI4
{
    public float xMin;
    public float yMin;
    public float xMax;
    public float yMax;
    public UI4(float xMin, float yMin, float xMax, float yMax);
    public string GetMin();
    public string GetMax();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Score Values")]
    public Hash<Hit, float> Scores { get; set; }
    [JsonProperty(PropertyName = "Popup Options")]
    public PopupOptions Popup { get; set; }
    [JsonProperty(PropertyName = "Target Options")]
    public TargetOptions Target { get; set; }
    [JsonProperty(PropertyName = "Send server wide notification if the top server score has been beaten")]
    public bool Notify { get; set; }
    [JsonProperty(PropertyName = "Weapons allowed to be used for scoring")]
    public string[] Weapons { get; set; }
    [JsonProperty(PropertyName = "Bullseye image URL")]
    public string Bullseye { get; set; }
    public class TargetOptions
    {
        [JsonProperty(PropertyName = "Amount of damage to take to be knocked down")]
        public float KnockdownHealth { get; set; }
        [JsonProperty(PropertyName = "Amount of time it takes to reset the target")]
        public float ResetTime { get; set; }
    }

    public class PopupOptions
    {
        [JsonProperty(PropertyName = "Popup lifetime (seconds)")]
        public int Lifetime { get; set; }
        [JsonProperty(PropertyName = "Maximum active popup elements")]
        public int Limit { get; set; }
    }

    public class ScoreValues
    {
        public int Bullseye { get; set; }
        public int Yellow { get; set; }
        public int Red { get; set; }
        public int Blue { get; set; }
        public int Edge { get; set; }
    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class TargetOptions
{
    [JsonProperty(PropertyName = "Amount of damage to take to be knocked down")]
    public float KnockdownHealth { get; set; }
    [JsonProperty(PropertyName = "Amount of time it takes to reset the target")]
    public float ResetTime { get; set; }
}

public class PopupOptions
{
    [JsonProperty(PropertyName = "Popup lifetime (seconds)")]
    public int Lifetime { get; set; }
    [JsonProperty(PropertyName = "Maximum active popup elements")]
    public int Limit { get; set; }
}

public class ScoreValues
{
    public int Bullseye { get; set; }
    public int Yellow { get; set; }
    public int Red { get; set; }
    public int Blue { get; set; }
    public int Edge { get; set; }
}

[ProtoContract]
private class StatisticsData
{
    [ProtoMember(1)]
    public Hash<ulong, List<TargetHitInfo>> _players;
    [ProtoMember(2)]
    public List<TargetHitInfo> _sortedScores;
    [JsonIgnore]
    private CompareScore comparer;
    public StatisticsData();
    public bool AddScore(BasePlayer player, TargetHitInfo targetHitInfo);
    public bool GetUserTopHits(ulong playerId, List<TargetHitInfo> list);
    public bool FindUserScores(ulong playerId, string format);
    private class CompareScore : IComparer<TargetHitInfo>
    {
        public int Compare(TargetHitInfo a, TargetHitInfo b);
    }

}

private class CompareScore : IComparer<TargetHitInfo>
{
    public int Compare(TargetHitInfo a, TargetHitInfo b);
}


```

---

## Taser by Kopter - Transforms a Semi-Automatic Pistol into a Taser

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;

Oxide.Plugins
[Info("Taser", "Kopter", "2.0.2")]
[Description("Transforms a Semi-Automatic Pistol into a Taser")]
public class Taser : RustPlugin
{
    private ItemDefinition taserAmmoType;
    private const string useTaserPermission;
    private const string taserAffectPermission;
    private const string lootPlayerPermission;
    private const string revivePlayerPermission;
    private const string semiAutoPistolShortname;
    private const string screamSound;
    private const string shockEffect;
    private List<ulong> woundedPlayers;
    private void Init();
    private void OnWeaponReload(BaseProjectile projectile, BasePlayer player);
    private object OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo);
    private object CanLootPlayer(BasePlayer target, BasePlayer looter);
    private object OnPlayerAssist(BasePlayer target, BasePlayer reviver);
    private void Unload();
    private ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Number Of Taser Rounds")]
        public int NumberOfRounds;
        [JsonProperty(PropertyName = "Wounded Time (In Seconds)")]
        public float WoundedTime;
        [JsonProperty(PropertyName = "Max Distance where the Taser will work (If 0, a max distance will not be applied)")]
        public int MaxDistance;
        [JsonProperty(PropertyName = "Play a Scream Sound while the player is tased")]
        public bool PlayScream;
        [JsonProperty(PropertyName = "Requires a permission to be affected by the taser")]
        public bool AffectPermissionNeeded;
        [JsonProperty(PropertyName = "Requires permission to loot a player affected by the taser")]
        public bool LootPermissionNeeded;
        [JsonProperty(PropertyName = "Requires permission to revive a player affected by the taser")]
        public bool RevivePermissionNeeded;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Number Of Taser Rounds")]
    public int NumberOfRounds;
    [JsonProperty(PropertyName = "Wounded Time (In Seconds)")]
    public float WoundedTime;
    [JsonProperty(PropertyName = "Max Distance where the Taser will work (If 0, a max distance will not be applied)")]
    public int MaxDistance;
    [JsonProperty(PropertyName = "Play a Scream Sound while the player is tased")]
    public bool PlayScream;
    [JsonProperty(PropertyName = "Requires a permission to be affected by the taser")]
    public bool AffectPermissionNeeded;
    [JsonProperty(PropertyName = "Requires permission to loot a player affected by the taser")]
    public bool LootPermissionNeeded;
    [JsonProperty(PropertyName = "Requires permission to revive a player affected by the taser")]
    public bool RevivePermissionNeeded;
}


```

---

## TcExtender by MJSU - Extends the range of the tool cupboard

```csharp
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Rust;

Oxide.Plugins
[Info("Tool Cupboard Extender", "MJSU", "0.0.1")]
[Description("Extends the range of the tool cupboard")]
internal class TcExtender : RustPlugin
{
    private PluginConfig _pluginConfig;
    private const string UsePermission;
    private float _maxRange;
    private readonly Hash<ulong, float> _playerRangeCache;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private PluginConfig AdditionalConfig(PluginConfig config);
    private void OnServerInitialized();
    private void OnUserPermissionGranted(string playerId, string permName);
    private void OnUserPermissionRevoked(string playerId, string permName);
    private void OnUserGroupAdded(string playerId, string groupName);
    private void OnUserGroupRemoved(string playerId, string groupName);
    private void OnGroupPermissionGranted(string groupName, string permName);
    private void OnGroupPermissionRevoked(string groupName, string permName);
    private BuildingPrivlidge OnBuildingPrivilege(BaseEntity entity, OBB obb);
    private float GetPlayerRange(ulong playerId);
    private bool HasPermission(ulong playerId, string perm);
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Permission Ranges (Meters)")]
        public Hash<string, float> Ranges { get; set; }
    }

}

private class PluginConfig
{
    [JsonProperty(PropertyName = "Permission Ranges (Meters)")]
    public Hash<string, float> Ranges { get; set; }
}


```

---

## TCManager by S0N0FBISCUIT - Remote management of tool cupboard

```csharp
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("TC Manager", "S0N_0F_BISCUIT", "1.0.4")]
[Description("Manage your tool cupboard remotely")]
 class TCManager : RustPlugin
{
    [PluginReference]
     Plugin MasterLock;
     Plugin GameTipAPI;
    protected override void LoadDefaultMessages();
    private void Init();
    protected override void LoadDefaultConfig();
    private object ConfigValue(string value);
    [ChatCommand("upkeep")]
     void CalculateUpkeepCost(BasePlayer player, string command, string[] args);
    [ChatCommand("taxrate")]
     void GetTaxBracket(BasePlayer player, string command, string[] args);
    [ChatCommand("tcinv")]
     void OpenToolCupboard(BasePlayer player, string command, string[] args);
    [ChatCommand("tcauth")]
     void AuthorizePlayer(BasePlayer player, string command, string[] args);
    [ChatCommand("tcunauth")]
     void UnauthorizePlayer(BasePlayer player, string command, string[] args);
     void OnEntitySpawned(BaseNetworkable entity);
    private string Lang(string key, string userId, object[] args);
    private double CalculateTaxRate(BuildingPrivlidge privlidge);
    private bool LootContainer(BasePlayer player, StorageContainer container);
    private List<BasePlayer> FindPlayer(string name);
    private void DisplayTooltips(BasePlayer player);
}


```

---

## TCMap by Wolfleader101 - Shows all tool cupboards and authorized players on the map

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("TCMap", "TheBandolero", "1.0.1", ResourceId = 0)]
[Description("Shows all tool cupboards in the game map, and hovering over the TC mark shows a tooltip with the name of the players authorized in it.")]
public class TCMap : RustPlugin
{
    private const string Prefab;
    private List<BaseEntity> listOfTCs;
    private List<AuthPlayer> listOfAuthPlayers;
    private List<int> listMarkersIDs;
    private bool showToAllPlayers;
     void Init();
     void OnServerInitialized();
     object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player);
     object OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player);
     object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player);
     void OnEntityKill(BaseNetworkable entity);
     void Unload();
    private void DoTheMagic();
    private List<BaseEntity> GetTCList();
    private bool IsCupboardEntity(BaseEntity entity);
    private List<AuthPlayer> GetAuthList(BaseEntity tc, int count);
    private bool IsPlayerOnline(ulong tcPlayerID);
    private class AuthPlayer
    {
        private ulong playerID;
        private string playerName;
        private bool isOwner;
        private bool playerOnline;
        public AuthPlayer(ulong pID, string pName, bool pIsOwner, bool pOnline);
        public ulong GetAuthPlayerID();
        public void SetAuthPlayerID(ulong pID);
        public string GetAuthPlayerName();
        public void SetAuthPlayerID(string pName);
        public bool GetPlayerIsOwner();
        public void SetPlayerIsOwner(bool pIsOwner);
        public bool GetAuthPlayerOnline();
        public void SetAuthPlayerOnline(bool pOnline);
    }

    private void PutTCMarksOnMap(Vector3 tcPos, string markerAuthNames);
     object CanNetworkTo(BaseNetworkable entity, BasePlayer player);
    private void KillAllMarkers();
    [ChatCommand("tcmap"), Permission("tcmap.admin")]
    private void TCMapChatCommands(BasePlayer player, string command, string[] args);
}

private class AuthPlayer
{
    private ulong playerID;
    private string playerName;
    private bool isOwner;
    private bool playerOnline;
    public AuthPlayer(ulong pID, string pName, bool pIsOwner, bool pOnline);
    public ulong GetAuthPlayerID();
    public void SetAuthPlayerID(ulong pID);
    public string GetAuthPlayerName();
    public void SetAuthPlayerID(string pName);
    public bool GetPlayerIsOwner();
    public void SetPlayerIsOwner(bool pIsOwner);
    public bool GetAuthPlayerOnline();
    public void SetAuthPlayerOnline(bool pOnline);
}


```

---

## TcMapMarkers by 1AK1 - Shows custom map markers for all cupboards on the server

```csharp
using UnityEngine;
using CompanionServer.Handlers;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("TC Map Markers", "1AK1", "1.1.2")]
[Description("Shows custom map markers for all cupboards on the server.")]
internal class TcMapMarkers : CovalencePlugin
{
    [PluginReference]
    private Plugin Friends;
    private Plugin Clans;
    private int count;
    private const string permUse;
    public List<MapMarkerGenericRadius> TCMarkers;
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Map Marker Options")]
        public MapMarkerOptions MapMarker { get; set; }
        [JsonProperty(PropertyName = "Owned Markers Options")]
        public OwnedMarkersOptions OwnedMarkers { get; set; }
        [JsonProperty(PropertyName = "Other Markers Options")]
        public OtherMarkersOptions OtherMarkers { get; set; }
        [JsonProperty(PropertyName = "Teams Markers Options")]
        public TeamsMarkersOptions TeamsMarkers { get; set; }
        [JsonProperty(PropertyName = "Friends Markers Options")]
        public FriendsMarkersOptions FriendsMarkers { get; set; }
        [JsonProperty(PropertyName = "Clans Markers Options")]
        public ClansMarkersOptions ClansMarkers { get; set; }
        public class MapMarkerOptions
        {
            [JsonProperty(PropertyName = "Prefab Path")]
            public string PREFAB_MARKER { get; set; }
            [JsonProperty(PropertyName = "Show to all? (true/false)")]
            public bool visibleToAll { get; set; }
            [JsonProperty(PropertyName = "Enable Teams? (true/false)")]
            public bool TeamsUse { get; set; }
            [JsonProperty(PropertyName = "Enable Friends? (true/false)")]
            public bool FriendsUse { get; set; }
            [JsonProperty(PropertyName = "Enable Clans? (true/false)")]
            public bool ClansUse { get; set; }
        }

        public class OwnedMarkersOptions
        {
            [JsonProperty(PropertyName = "Color1 (hex)")]
            public string OwnedColor1 { get; set; }
            [JsonProperty(PropertyName = "Color2 (hex)")]
            public string OwnedColor2 { get; set; }
            [JsonProperty(PropertyName = "Alpha")]
            public float OwnedAlpha { get; set; }
            [JsonProperty(PropertyName = "Radius")]
            public float OwnedRadius { get; set; }
        }

        public class OtherMarkersOptions
        {
            [JsonProperty(PropertyName = "Color1 (hex)")]
            public string OtherColor1 { get; set; }
            [JsonProperty(PropertyName = "Color2 (hex)")]
            public string OtherColor2 { get; set; }
            [JsonProperty(PropertyName = "Alpha")]
            public float OtherAlpha { get; set; }
            [JsonProperty(PropertyName = "Radius")]
            public float OtherRadius { get; set; }
        }

        public class TeamsMarkersOptions
        {
            [JsonProperty(PropertyName = "Color1 (hex)")]
            public string TeamsColor1 { get; set; }
            [JsonProperty(PropertyName = "Color2 (hex)")]
            public string TeamsColor2 { get; set; }
            [JsonProperty(PropertyName = "Alpha")]
            public float TeamsAlpha { get; set; }
            [JsonProperty(PropertyName = "Radius")]
            public float TeamsRadius { get; set; }
        }

        public class FriendsMarkersOptions
        {
            [JsonProperty(PropertyName = "Color1 (hex)")]
            public string FriendsColor1 { get; set; }
            [JsonProperty(PropertyName = "Color2 (hex)")]
            public string FriendsColor2 { get; set; }
            [JsonProperty(PropertyName = "Alpha")]
            public float FriendsAlpha { get; set; }
            [JsonProperty(PropertyName = "Radius")]
            public float FriendsRadius { get; set; }
        }

        public class ClansMarkersOptions
        {
            [JsonProperty(PropertyName = "Color1 (hex)")]
            public string ClansColor1 { get; set; }
            [JsonProperty(PropertyName = "Color2 (hex)")]
            public string ClansColor2 { get; set; }
            [JsonProperty(PropertyName = "Alpha")]
            public float ClansAlpha { get; set; }
            [JsonProperty(PropertyName = "Radius")]
            public float ClansRadius { get; set; }
        }

    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void Init();
    private void OnServerInitialized(bool initial);
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
     object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer player);
    private void OnEntityBuilt(Planner plan, GameObject go);
    private void OnEntityKill(BaseNetworkable entity);
    private void LoadMapMarkers();
    private void RemoveMapMarkers();
    private void CreateMapMarker(BuildingPrivlidge cupboard, string type, string color1, string color2, float alpha, float radius);
    private void CommandTCMap(IPlayer player, string command, string[] args);
    private void Message(IPlayer player, string key, object[] args);
    private string Lang(string key, string id, object[] args);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Map Marker Options")]
    public MapMarkerOptions MapMarker { get; set; }
    [JsonProperty(PropertyName = "Owned Markers Options")]
    public OwnedMarkersOptions OwnedMarkers { get; set; }
    [JsonProperty(PropertyName = "Other Markers Options")]
    public OtherMarkersOptions OtherMarkers { get; set; }
    [JsonProperty(PropertyName = "Teams Markers Options")]
    public TeamsMarkersOptions TeamsMarkers { get; set; }
    [JsonProperty(PropertyName = "Friends Markers Options")]
    public FriendsMarkersOptions FriendsMarkers { get; set; }
    [JsonProperty(PropertyName = "Clans Markers Options")]
    public ClansMarkersOptions ClansMarkers { get; set; }
    public class MapMarkerOptions
    {
        [JsonProperty(PropertyName = "Prefab Path")]
        public string PREFAB_MARKER { get; set; }
        [JsonProperty(PropertyName = "Show to all? (true/false)")]
        public bool visibleToAll { get; set; }
        [JsonProperty(PropertyName = "Enable Teams? (true/false)")]
        public bool TeamsUse { get; set; }
        [JsonProperty(PropertyName = "Enable Friends? (true/false)")]
        public bool FriendsUse { get; set; }
        [JsonProperty(PropertyName = "Enable Clans? (true/false)")]
        public bool ClansUse { get; set; }
    }

    public class OwnedMarkersOptions
    {
        [JsonProperty(PropertyName = "Color1 (hex)")]
        public string OwnedColor1 { get; set; }
        [JsonProperty(PropertyName = "Color2 (hex)")]
        public string OwnedColor2 { get; set; }
        [JsonProperty(PropertyName = "Alpha")]
        public float OwnedAlpha { get; set; }
        [JsonProperty(PropertyName = "Radius")]
        public float OwnedRadius { get; set; }
    }

    public class OtherMarkersOptions
    {
        [JsonProperty(PropertyName = "Color1 (hex)")]
        public string OtherColor1 { get; set; }
        [JsonProperty(PropertyName = "Color2 (hex)")]
        public string OtherColor2 { get; set; }
        [JsonProperty(PropertyName = "Alpha")]
        public float OtherAlpha { get; set; }
        [JsonProperty(PropertyName = "Radius")]
        public float OtherRadius { get; set; }
    }

    public class TeamsMarkersOptions
    {
        [JsonProperty(PropertyName = "Color1 (hex)")]
        public string TeamsColor1 { get; set; }
        [JsonProperty(PropertyName = "Color2 (hex)")]
        public string TeamsColor2 { get; set; }
        [JsonProperty(PropertyName = "Alpha")]
        public float TeamsAlpha { get; set; }
        [JsonProperty(PropertyName = "Radius")]
        public float TeamsRadius { get; set; }
    }

    public class FriendsMarkersOptions
    {
        [JsonProperty(PropertyName = "Color1 (hex)")]
        public string FriendsColor1 { get; set; }
        [JsonProperty(PropertyName = "Color2 (hex)")]
        public string FriendsColor2 { get; set; }
        [JsonProperty(PropertyName = "Alpha")]
        public float FriendsAlpha { get; set; }
        [JsonProperty(PropertyName = "Radius")]
        public float FriendsRadius { get; set; }
    }

    public class ClansMarkersOptions
    {
        [JsonProperty(PropertyName = "Color1 (hex)")]
        public string ClansColor1 { get; set; }
        [JsonProperty(PropertyName = "Color2 (hex)")]
        public string ClansColor2 { get; set; }
        [JsonProperty(PropertyName = "Alpha")]
        public float ClansAlpha { get; set; }
        [JsonProperty(PropertyName = "Radius")]
        public float ClansRadius { get; set; }
    }

}

public class MapMarkerOptions
{
    [JsonProperty(PropertyName = "Prefab Path")]
    public string PREFAB_MARKER { get; set; }
    [JsonProperty(PropertyName = "Show to all? (true/false)")]
    public bool visibleToAll { get; set; }
    [JsonProperty(PropertyName = "Enable Teams? (true/false)")]
    public bool TeamsUse { get; set; }
    [JsonProperty(PropertyName = "Enable Friends? (true/false)")]
    public bool FriendsUse { get; set; }
    [JsonProperty(PropertyName = "Enable Clans? (true/false)")]
    public bool ClansUse { get; set; }
}

public class OwnedMarkersOptions
{
    [JsonProperty(PropertyName = "Color1 (hex)")]
    public string OwnedColor1 { get; set; }
    [JsonProperty(PropertyName = "Color2 (hex)")]
    public string OwnedColor2 { get; set; }
    [JsonProperty(PropertyName = "Alpha")]
    public float OwnedAlpha { get; set; }
    [JsonProperty(PropertyName = "Radius")]
    public float OwnedRadius { get; set; }
}

public class OtherMarkersOptions
{
    [JsonProperty(PropertyName = "Color1 (hex)")]
    public string OtherColor1 { get; set; }
    [JsonProperty(PropertyName = "Color2 (hex)")]
    public string OtherColor2 { get; set; }
    [JsonProperty(PropertyName = "Alpha")]
    public float OtherAlpha { get; set; }
    [JsonProperty(PropertyName = "Radius")]
    public float OtherRadius { get; set; }
}

public class TeamsMarkersOptions
{
    [JsonProperty(PropertyName = "Color1 (hex)")]
    public string TeamsColor1 { get; set; }
    [JsonProperty(PropertyName = "Color2 (hex)")]
    public string TeamsColor2 { get; set; }
    [JsonProperty(PropertyName = "Alpha")]
    public float TeamsAlpha { get; set; }
    [JsonProperty(PropertyName = "Radius")]
    public float TeamsRadius { get; set; }
}

public class FriendsMarkersOptions
{
    [JsonProperty(PropertyName = "Color1 (hex)")]
    public string FriendsColor1 { get; set; }
    [JsonProperty(PropertyName = "Color2 (hex)")]
    public string FriendsColor2 { get; set; }
    [JsonProperty(PropertyName = "Alpha")]
    public float FriendsAlpha { get; set; }
    [JsonProperty(PropertyName = "Radius")]
    public float FriendsRadius { get; set; }
}

public class ClansMarkersOptions
{
    [JsonProperty(PropertyName = "Color1 (hex)")]
    public string ClansColor1 { get; set; }
    [JsonProperty(PropertyName = "Color2 (hex)")]
    public string ClansColor2 { get; set; }
    [JsonProperty(PropertyName = "Alpha")]
    public float ClansAlpha { get; set; }
    [JsonProperty(PropertyName = "Radius")]
    public float ClansRadius { get; set; }
}


```

---

## TcOptions by SapnuPuas - Adds a codelock and optional loot to tool cupboards when placed by a player with permission

```csharp
using System;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Collections.Generic;

Oxide.Plugins
[Info("Tc Options", "Sapnu Puas", "1.0.4")]
[Description("Add a code lock and loot to tc when placed")]
public class TcOptions : RustPlugin
{
    private const string PermissionUse;
    private void Init();
    private void OnServerInitialized();
     void OnNewSave(string filename);
    private void Unload();
    private const string codelockprefab;
    private const string Prefab_CodeLock_UnlockEffect;
    private const string Prefab_CodeLock_LockEffect;
    protected override void LoadDefaultMessages();
     void OnEntitySpawned(BaseEntity ent);
     void OnEntityKill(BaseLock baseLock);
     object CanUseLockedEntity(BasePlayer player, BaseLock baseLock);
     object CanUnlock(BasePlayer player, BaseLock baseLock);
     object CanPickupLock(BasePlayer player, BaseLock baseLock);
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("Settings")]
        public _tcsettings Tcsettings;
        [JsonProperty("Loot for")]
        public Dictionary<string, List<Loot>> Tc;
        public class _tcsettings
        {
            [JsonProperty("Add Codelock ?")]
            public bool AddLock;
            [JsonProperty("Add loot to toolcupboard ?")]
            public bool AddLoot;
        }

        public static Configuration DefaultConfig();
    }

    public class Loot
    {
        [JsonProperty("ShortName")]
        public string ShortName;
        [JsonProperty("Amount")]
        public int Amount;
    }

     void AddLock(BaseEntity ent, ulong playerid);
    private void Unlock(BaseLock baseLock);
    private void SpawnTcLoot(StorageContainer container);
    private void SaveLockData();
    private void LoadLockData();
    [JsonProperty("lock ids")]
    private List<NetworkableId> LocknetID;
}

public class Configuration
{
    [JsonProperty("Settings")]
    public _tcsettings Tcsettings;
    [JsonProperty("Loot for")]
    public Dictionary<string, List<Loot>> Tc;
    public class _tcsettings
    {
        [JsonProperty("Add Codelock ?")]
        public bool AddLock;
        [JsonProperty("Add loot to toolcupboard ?")]
        public bool AddLoot;
    }

    public static Configuration DefaultConfig();
}

public class _tcsettings
{
    [JsonProperty("Add Codelock ?")]
    public bool AddLock;
    [JsonProperty("Add loot to toolcupboard ?")]
    public bool AddLoot;
}

public class Loot
{
    [JsonProperty("ShortName")]
    public string ShortName;
    [JsonProperty("Amount")]
    public int Amount;
}


```

---

## TeamBattlefield by k1lly0u - Two teams, adjustable friendly-fire, kits, individual team items, spectator mode

```csharp
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Reflection;
using System;

Oxide.Plugins
[Info("TeamBattlefield", "BodyweightEnergy / k1lly0u", "2.1.45"), Description("Two teams, adjustable friendly-fire, kits, individual team items, spectator mode")]
 class TeamBattlefield : RustPlugin
{
    [PluginReference]
     Plugin Spawns;
    private List<TBPlayer> TBPlayers;
    private Dictionary<ulong, PlayerData> DCPlayers;
    private Dictionary<ulong, Timer> DCTimers;
    private bool UseTB;
    private int TeamA_Score;
    private int TeamB_Score;
    private const string UIMain;
    private const string UIScoreboard;
    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor);
        static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
        static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
    }

    private void OpenTeamSelection(BasePlayer player);
    public void Scoreboard(BasePlayer player);
     void OnServerInitialized();
    private void OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo);
    private void OnEntityDeath(BasePlayer victim, HitInfo hitInfo);
    private void RefreshScoreboard();
    private void OnPlayerInit(BasePlayer player);
    private void InitPlayer(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    private object OnPlayerChat(ConsoleSystem.Arg arg);
     void Unload();
    private bool CheckDependencies();
    private bool CheckSpawnfiles();
    static void MovePlayerPosition(BasePlayer player, Vector3 destination);
    private void StartSpectating(BasePlayer player, BasePlayer target);
    private void EndSpectating(BasePlayer player);
    private void AddPoints(BasePlayer player, BasePlayer victim);
    private void GivePlayerWeapons(BasePlayer player);
    private void GivePlayerGear(BasePlayer player, Team team);
    private Item BuildItem(string shortname, int amount, ulong skin);
    private Item BuildWeapon(Weapon newWeapon);
    public void GiveItem(BasePlayer player, Item item, string container);
    [ConsoleCommand("tbf.list")]
    private void cmdList(ConsoleSystem.Arg arg);
    [ConsoleCommand("tbf.clearscore")]
    private void cmdClearscore(ConsoleSystem.Arg arg);
    [ConsoleCommand("tbf.assign")]
    private void cmdAssign(ConsoleSystem.Arg arg);
    [ConsoleCommand("tbf.version")]
    private void cmdVersion(ConsoleSystem.Arg arg);
    [ConsoleCommand("tbf.help")]
    private void cmdHelp(ConsoleSystem.Arg arg);
    [ConsoleCommand("tbf.purge")]
    private void cmdPurge(ConsoleSystem.Arg arg);
    [ChatCommand("switchteam")]
    private void cmdChangeTeam(BasePlayer player, string command, string[] args);
     bool isAuth(ConsoleSystem.Arg arg);
    [ChatCommand("t")]
    private void cmdTeamChat(BasePlayer player, string command, string[] args);
    [ConsoleCommand("TBUI_TeamSelect")]
    private void cmdTeamSelectA(ConsoleSystem.Arg arg);
    private Team ConvertStringToTeam(string team);
    private List<BasePlayer> FindPlayer(string arg);
    private int CountPlayers(Team team);
    private void AssignPlayerToTeam(BasePlayer player, Team team);
    private BasePlayer GetRandomTeammate(BasePlayer player);
     string GetPlayerTeam(ulong playerID);
     Dictionary<ulong, string> GetTeams();
    private ConfigData configData;
     class TeamOptions
    {
        public string Spawnfile { get; set; }
        public string Chat_Prefix { get; set; }
        public string Chat_Color { get; set; }
        public List<Gear> Gear { get; set; }
    }

     class Options
    {
        public int MaximumTeamCountDifference { get; set; }
        public int RemoveSleeper_Timer { get; set; }
        public float FF_DamageScale { get; set; }
        public bool UsePluginChatControl { get; set; }
        public bool BroadcastDeath { get; set; }
    }

     class GUI
    {
        public float XPosition { get; set; }
        public float YPosition { get; set; }
        public float XDimension { get; set; }
        public float YDimension { get; set; }
    }

     class ConfigGear
    {
        public List<Gear> CommonGear { get; set; }
        public List<Weapon> StartingWeapons { get; set; }
    }

     class Spectators
    {
        public bool EnableSpectators { get; set; }
        public string Chat_Color { get; set; }
        public string Chat_Prefix { get; set; }
    }

     class ConfigData
    {
        public TeamOptions TeamA { get; set; }
        public TeamOptions TeamB { get; set; }
        public TeamOptions Admin { get; set; }
        public ConfigGear Gear { get; set; }
        public Options Options { get; set; }
        public Spectators Spectators { get; set; }
        public GUI ScoreboardUI { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     class TBPlayer : MonoBehaviour
    {
        public BasePlayer player;
        public int kills;
        public Team team;
         void Awake();
    }

     class PlayerData
    {
        public int kills;
        public Team team;
    }

     class Gear
    {
        public string name;
        public string shortname;
        public ulong skin;
        public int amount;
        public string container;
    }

     class Weapon
    {
        public string name;
        public string shortname;
        public ulong skin;
        public string container;
        public int amount;
        public int ammo;
        public string ammoType;
        public string[] contents;
    }

}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor);
    static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
    static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
}

 class TeamOptions
{
    public string Spawnfile { get; set; }
    public string Chat_Prefix { get; set; }
    public string Chat_Color { get; set; }
    public List<Gear> Gear { get; set; }
}

 class Options
{
    public int MaximumTeamCountDifference { get; set; }
    public int RemoveSleeper_Timer { get; set; }
    public float FF_DamageScale { get; set; }
    public bool UsePluginChatControl { get; set; }
    public bool BroadcastDeath { get; set; }
}

 class GUI
{
    public float XPosition { get; set; }
    public float YPosition { get; set; }
    public float XDimension { get; set; }
    public float YDimension { get; set; }
}

 class ConfigGear
{
    public List<Gear> CommonGear { get; set; }
    public List<Weapon> StartingWeapons { get; set; }
}

 class Spectators
{
    public bool EnableSpectators { get; set; }
    public string Chat_Color { get; set; }
    public string Chat_Prefix { get; set; }
}

 class ConfigData
{
    public TeamOptions TeamA { get; set; }
    public TeamOptions TeamB { get; set; }
    public TeamOptions Admin { get; set; }
    public ConfigGear Gear { get; set; }
    public Options Options { get; set; }
    public Spectators Spectators { get; set; }
    public GUI ScoreboardUI { get; set; }
}

 class TBPlayer : MonoBehaviour
{
    public BasePlayer player;
    public int kills;
    public Team team;
     void Awake();
}

 class PlayerData
{
    public int kills;
    public Team team;
}

 class Gear
{
    public string name;
    public string shortname;
    public ulong skin;
    public int amount;
    public string container;
}

 class Weapon
{
    public string name;
    public string shortname;
    public ulong skin;
    public string container;
    public int amount;
    public int ammo;
    public string ammoType;
    public string[] contents;
}


```

---

## TeamChat by Waggy - Send private messages to all the players in your team

```csharp
using UnityEngine;
using System.Text;
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info( "Team Chat", "Waggy", "1.0.2" )]
[Description( "Allows you to send messages to only those in your team" )]
 class TeamChat : RustPlugin
{
    [ChatCommand( "team" )]
     void SendMessageToTeam(BasePlayer player, string command, string[] args);
     void MessageToTeam(BasePlayer player, string command, string[] args);
    public void SendChatMessage(BasePlayer speaker, ulong target, string message);
    private ConfigData config;
    protected override void LoadDefaultConfig();
    private void Init();
    private new void SaveConfig();
    public class ConfigData
    {
        [JsonProperty( "Team Header Color ( the (TEAM) part of the message )" )]
        public string TeamHeaderColor;
        [JsonProperty( "Error Message Color" )]
        public string ErrorMessageColor;
        [JsonProperty( "Player Name Color (non-admin)" )]
        public string PlayerNameColor;
        [JsonProperty( "Admin Name Color" )]
        public string AdminNameColor;
        [JsonProperty( "Enable /t ( works the same as /team )" )]
        public bool TeamShorthandCommand;
    }

    protected override void LoadDefaultMessages();
}

public class ConfigData
{
    [JsonProperty( "Team Header Color ( the (TEAM) part of the message )" )]
    public string TeamHeaderColor;
    [JsonProperty( "Error Message Color" )]
    public string ErrorMessageColor;
    [JsonProperty( "Player Name Color (non-admin)" )]
    public string PlayerNameColor;
    [JsonProperty( "Admin Name Color" )]
    public string AdminNameColor;
    [JsonProperty( "Enable /t ( works the same as /team )" )]
    public bool TeamShorthandCommand;
}

public static class TeamChatEx
{
    private static StringBuilder coloredTextBuilder;
    public static string ChangeColor(string text, Color color);
}

TeamChatEx
public static class TeamChatEx
{
    private static StringBuilder coloredTextBuilder;
    public static string ChangeColor(string text, Color color);
}


```

---

## TeamDeathmatch by k1lly0u - Team deathmatch event for Event Manager

```csharp
using Newtonsoft.Json;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("TeamDeathmatch", "k1lly0u", "0.4.2"), Description("Team Deathmatch event mode for EventManager")]
 class TeamDeathmatch : RustPlugin, IEventPlugin
{
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private void Unload();
    public bool InitializeEvent(EventManager.EventConfig config);
    public bool CanUseClassSelector { get; set; }
    public bool RequireTimeLimit { get; set; }
    public bool RequireScoreLimit { get; set; }
    public bool UseScoreLimit { get; set; }
    public bool UseTimeLimit { get; set; }
    public bool IsTeamEvent { get; set; }
    public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, string score1, string score2);
    public List<EventManager.EventParameter> AdditionalParameters { get; set; }
    public string ParameterIsValid(string fieldName, object value);
    public class TeamDeathmatchEvent : EventManager.BaseEventGame
    {
        public EventManager.Team winningTeam;
        private int teamAScore;
        private int teamBScore;
        internal override void PrestartEvent();
        protected override void StartEvent();
        protected override EventManager.Team GetPlayerTeam(BasePlayer player);
        internal override int GetTeamScore(EventManager.Team team);
        internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo);
        internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker, HitInfo info);
        protected override void GetWinningPlayers(List<EventManager.BaseEventPlayer> winners);
        protected override void BuildScoreboard();
        protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer);
        protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer);
        protected override void SortScores(List<EventManager.ScoreEntry> list);
    }

    private static ConfigData Configuration;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Respawn time (seconds)")]
        public int RespawnTime { get; set; }
        [JsonProperty(PropertyName = "Friendly fire damage modifier (0.0 is no damage, 1.0 is normal damage)")]
        public float FriendlyFireModifier { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    public string Message(string key, ulong playerId);
    private static Func<string, ulong, string> GetMessage;
    private readonly Dictionary<string, string> Messages;
}

public class TeamDeathmatchEvent : EventManager.BaseEventGame
{
    public EventManager.Team winningTeam;
    private int teamAScore;
    private int teamBScore;
    internal override void PrestartEvent();
    protected override void StartEvent();
    protected override EventManager.Team GetPlayerTeam(BasePlayer player);
    internal override int GetTeamScore(EventManager.Team team);
    internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo);
    internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker, HitInfo info);
    protected override void GetWinningPlayers(List<EventManager.BaseEventPlayer> winners);
    protected override void BuildScoreboard();
    protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer);
    protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer);
    protected override void SortScores(List<EventManager.ScoreEntry> list);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Respawn time (seconds)")]
    public int RespawnTime { get; set; }
    [JsonProperty(PropertyName = "Friendly fire damage modifier (0.0 is no damage, 1.0 is normal damage)")]
    public float FriendlyFireModifier { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}


```

---

## TeamInfo by Bazz3l - Check the team members and other team info of a player

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Team Info", "Lorddy", "0.1.7")]
[Description("Get Team Info")]
public class TeamInfo : RustPlugin
{
    private const string PERMISSION_USE;
    protected override void LoadDefaultMessages();
    private void Init();
    private string FormatSeconds(double seconds);
    [ChatCommand("teaminfo")]
    private void TeamInfoCommand(BasePlayer player, string command, string[] args);
}


```

---

## TeamLeaderOnline by PureForce - Ensures the team leader position is always held by an online team member.

```csharp
using Oxide.Core;
using System.Collections.Generic;
using ProtoBuf;
using UnityEngine;
using System.Linq;
using CompanionServer.Handlers;

Oxide.Plugins
[Info("Team Leader Online", "PureForce", "1.0.0")]
[Description("Ensures the team leader position is always held by an online team member.")]
internal class TeamLeaderOnline : RustPlugin
{
    private Dictionary<ulong, ulong> teamPendingLeader;
    private Dictionary<ulong, ulong> teamLeaderPriority;
    protected override void LoadDefaultMessages();
    private string GetMessage(string key, BasePlayer player);
    private bool dataChanged;
    private const string FILE_LEADER_PRIORITY;
    private void SaveData();
    private void LoadData();
    private void OnServerSave();
    private void WriteObject(string name, T value);
    private T ReadObject(string name);
    private const string PERM_ADMIN;
    private const string PERM_CLAIM;
    private bool HasAdminPermission(BasePlayer player);
    private bool HasPermissionToClaim(BasePlayer player);
    [ChatCommand("tlo.claim")]
    private void ChatCommand_ClaimLeader(BasePlayer player, string command, string[] args);
    [ChatCommand("tlo.promote")]
    private void ChatCommand_Promote(BasePlayer player, string command, string[] args);
    [ConsoleCommand("tlo.promote")]
    private void ConsoleCommand_Promote(ConsoleSystem.Arg arg);
    private void Init();
    private void OnServerInitialized(bool initial);
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team);
    private void OnTeamDisbanded(RelationshipManager.PlayerTeam team);
    private void OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer candidate);
    private void OnTeamUpdated(ulong teamId, PlayerTeam team, BasePlayer player);
    private object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target);
    private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player);
    private bool ShouldWipeTeamData();
    private bool TeamHasPriorityLeader(ulong teamId);
    private bool HasLeaderPriority(RelationshipManager.PlayerTeam team, ulong userId);
    private bool IsLeaderOnline(RelationshipManager.PlayerTeam team);
    private Network.Connection GetEligibleOnlineTeammate(RelationshipManager.PlayerTeam team);
    private bool SetTeamLeader(RelationshipManager.PlayerTeam team, ulong userid, bool setPriority);
    private void SetLeaderPriority(ulong teamId, ulong playerId);
    private void RemoveLeaderPriority(ulong teamId);
}


```

---

## TeamLoot by synvy - Prevents players outside of your team from looting your body

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Team Loot", "Synvy", "1.1.1")]
[Description("Prevents players outside of your team from looting your body.")]
public class TeamLoot : RustPlugin
{
    private const string bypass;
    private void Init();
    protected override void LoadDefaultMessages();
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty("Show warning message")]
        public bool showWarningMessage;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private object CanLootPlayer(BasePlayer target, BasePlayer looter);
    private object CanLootEntity(BasePlayer player, DroppedItemContainer container);
    private object CanLootEntity(BasePlayer player, LootableCorpse corpse);
    private bool HasPerm(string id, string perm);
    private string GetLang(string langKey, string playerId, object[] args);
    private void PrintWarningMessage(BasePlayer player, string message);
}

private class Configuration
{
    [JsonProperty("Show warning message")]
    public bool showWarningMessage;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## TeamManager by Quantum - Adds the ability to invite, promote or create a team via commands

```csharp
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch.Extend;
using Oxide.Core;
using UnityEngine;
using UnityEngine.UI;

Oxide.Plugins
[Info("Team Manager", "Quantum", "1.0.6")]
[Description("Manage teams from commands")]
 class TeamManager : RustPlugin
{
    protected override void LoadDefaultMessages();
    [ChatCommand("team")]
     void Team(BasePlayer player, string command, string[] args);
     void Promote(BasePlayer player, string targetPlayer);
     void Remove(BasePlayer player, string targetPlayer);
     void Invite(BasePlayer player, string targetPlayer);
     void CreateTeam(BasePlayer player);
    private static List<BasePlayer> FindPlayersOnline(string nameOrIdOrIp);
}


```

---

## TeaModifiers by MJSU - Modifies the buffs that each tea grants

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;

Oxide.Plugins
[Info("Tea Modifiers", "MJSU", "2.1.2")]
[Description("Allows the modification of tea buffs on items")]
internal class TeaModifiers : RustPlugin
{
    private PluginConfig _pluginConfig;
    private const string BasePermission;
    private const string UsePermission;
    private readonly Hash<ulong, float> _playerGlobalDurationCache;
    private readonly Hash<Modifier.ModifierType, Hash<ulong, float>> _globalTypeValueCache;
    private readonly Hash<ulong, float> _playerGlobalValueCache;
    private readonly Hash<string, Hash<ulong, float>> _playerDurationCache;
    private readonly Hash<string, Hash<ulong, float>> _playerValueCache;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private PluginConfig AdditionalConfig(PluginConfig config);
    private void OnServerInitialized();
    private void RegisterPermissions();
    private void OnUserPermissionGranted(string playerId, string permName);
    private void OnUserPermissionRevoked(string playerId, string permName);
    private void OnUserGroupAdded(string playerId, string groupName);
    private void OnUserGroupRemoved(string playerId, string groupName);
    private void OnGroupPermissionGranted(string groupName, string permName);
    private void OnGroupPermissionRevoked(string groupName, string permName);
    private object OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable);
    private bool HasModifiers(string shortName);
    private float GetTeaDuration(BasePlayer player, string shortName, Modifier.ModifierType type);
    private float GetTeaValue(BasePlayer player, string shortName, Modifier.ModifierType type);
    public float GetPlayerDuration(BasePlayer player, string shortName, ModifierData modifier);
    public float GetPlayerValue(BasePlayer player, string shortName, ModifierData modifier);
    public ModifierData GetDataForItemType(string shortName, Modifier.ModifierType type);
    public float GetPermissionValue(BasePlayer player, Hash<string, float> permissions, float defaultValue, Hash<ulong, float> cache);
    public bool HasPermission(BasePlayer player, string perm);
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Global Duration Multiplier")]
        public Hash<string, float> GlobalDurationMultiplier { get; set; }
        [JsonProperty(PropertyName = "Global Amount Multiplier")]
        public Hash<string, float> GlobalAmountMultiplier { get; set; }
        [JsonProperty(PropertyName = "Global Modifier Type Amount Multiplier")]
        public Hash<Modifier.ModifierType, Hash<string, float>> GlobalModifierMultiplier { get; set; }
        [JsonProperty(PropertyName = "Item List Modifiers")]
        public Hash<string, List<ModifierData>> Modifiers { get; set; }
    }

    public class ModifierData
    {
        [JsonProperty(PropertyName = "Modifier Duration (Seconds)")]
        public Hash<string, float> Duration { get; set; }
        [JsonProperty(PropertyName = "Modifier Amount")]
        public Hash<string, float> Amount { get; set; }
        [JsonProperty(PropertyName = "Modifer Type")]
        [JsonConverter(typeof(StringEnumConverter))]
        public Modifier.ModifierType Type { get; set; }
        [JsonIgnore]
        public float DefaultDuration { get; set; }
        [JsonIgnore]
        public float DefaultAmount { get; set; }
    }

}

private class PluginConfig
{
    [JsonProperty(PropertyName = "Global Duration Multiplier")]
    public Hash<string, float> GlobalDurationMultiplier { get; set; }
    [JsonProperty(PropertyName = "Global Amount Multiplier")]
    public Hash<string, float> GlobalAmountMultiplier { get; set; }
    [JsonProperty(PropertyName = "Global Modifier Type Amount Multiplier")]
    public Hash<Modifier.ModifierType, Hash<string, float>> GlobalModifierMultiplier { get; set; }
    [JsonProperty(PropertyName = "Item List Modifiers")]
    public Hash<string, List<ModifierData>> Modifiers { get; set; }
}

public class ModifierData
{
    [JsonProperty(PropertyName = "Modifier Duration (Seconds)")]
    public Hash<string, float> Duration { get; set; }
    [JsonProperty(PropertyName = "Modifier Amount")]
    public Hash<string, float> Amount { get; set; }
    [JsonProperty(PropertyName = "Modifer Type")]
    [JsonConverter(typeof(StringEnumConverter))]
    public Modifier.ModifierType Type { get; set; }
    [JsonIgnore]
    public float DefaultDuration { get; set; }
    [JsonIgnore]
    public float DefaultAmount { get; set; }
}


```

---

## TeamOfflineDoors by  - Closes team doors and stashes when the last team member goes offline

```csharp
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Team Offline Doors", "Gargoyle", "0.8.5")]
[Description("Closes team doors and stashes when the last team member goes offline")]
 class TeamOfflineDoors : RustPlugin
{
    private bool CloseDoors;
    private bool HideStash;
    private void OnPlayerDisconnected(BasePlayer player);
    private void DoClose(ulong playerId);
    private void DoHide(ulong playerId);
}


```

---

## TeamPing by DevGonzi - Creates a Ping with name of the player who sent the ping and distance to it for all team members.

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("Team Ping", "Gonzi", "2.0.2")]
[Description("Creates a Ping with name of the player who sent the ping and distance to it for all team members.")]
public class TeamPing : RustPlugin
{
    private float mapSize;
    private string permName;
    private readonly Hash<string, float> cooldowns;
    private Configuration config;
    public class Configuration
    {
        public bool requiresPermission;
        public int pingCooldown;
        public int timeToShow;
        public int maxDistance;
        public string pluginChatPrefix;
        public static Configuration DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void Init();
    protected override void LoadDefaultMessages();
    [ConsoleCommand("teamping")]
    private void Ping(ConsoleSystem.Arg arg);
    private bool CheckSameTeam(ulong ply1Id, ulong ply2Id);
    private void SetAdminFlag(BasePlayer player, bool state);
    private Ray DetermineHeadRay(BasePlayer player);
    private string Lang(string key, string id, object[] args);
}

public class Configuration
{
    public bool requiresPermission;
    public int pingCooldown;
    public int timeToShow;
    public int maxDistance;
    public string pluginChatPrefix;
    public static Configuration DefaultConfig();
}


```

---

## TeamsLogger by  - Additional logging of teams to log into files, console output, or Discord

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Teams Logger", "Ujiou", "1.5.1")]
[Description("Simple plugin to log team events.")]
 class TeamsLogger : CovalencePlugin
{
    private class PluginData
    {
        public bool FirstStart { get; set; }
    }

    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "CONSOLE SETTINGS")]
        public ConsoleSettings conSettings { get; set; }
        [JsonProperty(PropertyName = "FILE SETTINGS")]
        public FileSettings fileSettings { get; set; }
        [JsonProperty(PropertyName = "DISCORD SETTINGS")]
        public DiscordSettings disSettings { get; set; }
        public class ConsoleSettings
        {
            [JsonProperty(PropertyName = "Log to Console")]
            public bool logToConsole { get; set; }
            [JsonProperty(PropertyName = "On Logged Colors (1 - Red, 2 - Yellow, 3 - White)")]
            public int consColorScheme;
            [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
            public float conAntiSpamMeasure { get; set; }
        }

        public class FileSettings
        {
            [JsonProperty(PropertyName = "Log to Files")]
            public bool logToFile { get; set; }
            [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
            public float fileAntiSpamTime { get; set; }
        }

        public class DiscordSettings
        {
            [JsonProperty(PropertyName = "Log to Discord")]
            public bool logToDiscord { get; set; }
            [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
            public float discordTime { get; set; }
            [JsonProperty(PropertyName = "Discord Rate Limit")]
            public int discordTimeout { get; set; }
            [JsonProperty("Webhook URL")]
            public string discordURL { get; set; }
        }

    }

    protected override void LoadConfig();
     void SaveConfig();
    protected override void LoadDefaultConfig();
    private ConfigData LoadBaseConfig();
    private void Init();
    protected override void LoadDefaultMessages();
    private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team);
    private void OnTeamInvite(BasePlayer inviter, BasePlayer target);
    private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player);
    private void OnTeamRejectInvite(BasePlayer rejector, RelationshipManager.PlayerTeam team);
    private void OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader);
    private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player);
    private void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target);
    private void OnTeamDisbanded(RelationshipManager.PlayerTeam team);
     List<ulong> discordID;
     List<ulong> fileID;
     List<ulong> playerId;
    private readonly Dictionary<string, string> headers;
    private void PrintToConsole(BasePlayer player, string log);
    private void PrintToFile(BasePlayer player, string log);
    private void PrintToDiscord(BasePlayer player, string log);
    private void KeyType(BasePlayer player, string key, object[] args);
    private void PrintingMessages(BasePlayer player, string log);
    private void OtherType(string key, object[] args);
    private bool IsFirstRun();
    private string GetUserInfo(ulong userId);
    private void LogCurrentTeams();
    private void OtherPrintToFile(string log);
    private void OtherPrintToDiscord(string log);
    private void OtherPrintToConsole(string log);
    private void OtherMessages(string log);
    private class DefaultLocalization : Dictionary<string, string>
    {
        public DefaultLocalization();
    }

}

private class PluginData
{
    public bool FirstStart { get; set; }
}

 class ConfigData
{
    [JsonProperty(PropertyName = "CONSOLE SETTINGS")]
    public ConsoleSettings conSettings { get; set; }
    [JsonProperty(PropertyName = "FILE SETTINGS")]
    public FileSettings fileSettings { get; set; }
    [JsonProperty(PropertyName = "DISCORD SETTINGS")]
    public DiscordSettings disSettings { get; set; }
    public class ConsoleSettings
    {
        [JsonProperty(PropertyName = "Log to Console")]
        public bool logToConsole { get; set; }
        [JsonProperty(PropertyName = "On Logged Colors (1 - Red, 2 - Yellow, 3 - White)")]
        public int consColorScheme;
        [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
        public float conAntiSpamMeasure { get; set; }
    }

    public class FileSettings
    {
        [JsonProperty(PropertyName = "Log to Files")]
        public bool logToFile { get; set; }
        [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
        public float fileAntiSpamTime { get; set; }
    }

    public class DiscordSettings
    {
        [JsonProperty(PropertyName = "Log to Discord")]
        public bool logToDiscord { get; set; }
        [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
        public float discordTime { get; set; }
        [JsonProperty(PropertyName = "Discord Rate Limit")]
        public int discordTimeout { get; set; }
        [JsonProperty("Webhook URL")]
        public string discordURL { get; set; }
    }

}

public class ConsoleSettings
{
    [JsonProperty(PropertyName = "Log to Console")]
    public bool logToConsole { get; set; }
    [JsonProperty(PropertyName = "On Logged Colors (1 - Red, 2 - Yellow, 3 - White)")]
    public int consColorScheme;
    [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
    public float conAntiSpamMeasure { get; set; }
}

public class FileSettings
{
    [JsonProperty(PropertyName = "Log to Files")]
    public bool logToFile { get; set; }
    [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
    public float fileAntiSpamTime { get; set; }
}

public class DiscordSettings
{
    [JsonProperty(PropertyName = "Log to Discord")]
    public bool logToDiscord { get; set; }
    [JsonProperty(PropertyName = "Anti-Spam Measure (Seconds)")]
    public float discordTime { get; set; }
    [JsonProperty(PropertyName = "Discord Rate Limit")]
    public int discordTimeout { get; set; }
    [JsonProperty("Webhook URL")]
    public string discordURL { get; set; }
}

private class DefaultLocalization : Dictionary<string, string>
{
    public DefaultLocalization();
}


```

---

## TechTreeControl by WhiteThunder - Allows customizing Tech Tree research requirements

```csharp
using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using static TechTreeData;

Oxide.Plugins
[Info("Tech Tree Control", "WhiteThunder", "0.5.0")]
[Description("Allows customizing Tech Tree research requirements.")]
internal class TechTreeControl : CovalencePlugin
{
    [PluginReference]
    private readonly Plugin PopupNotifications;
    private const string PermissionAnyOrderLevel1;
    private const string PermissionAnyOrderLevel2;
    private const string PermissionAnyOrderLevel3;
    private const string PermissionAnyOrderIO;
    private readonly object True;
    private readonly object False;
    private Configuration _config;
    private void Init();
    private void OnServerInitialized();
    private object OnTechTreeNodeUnlock(Workbench workbench, NodeInstance node, BasePlayer player);
    private object CanUnlockTechTreeNode(BasePlayer player, NodeInstance node, TechTreeData techTree);
    private object CanUnlockTechTreeNodePath(BasePlayer player, NodeInstance node, TechTreeData techTree);
    private object OnResearchCostDetermine(ItemDefinition itemDefinition);
    public static void LogError(string message);
    public static void LogWarning(string message);
    private static bool HasUnlockPath(BasePlayer player, NodeInstance node, TechTreeData techTree, BlueprintRuleset blueprintRuleset);
    private bool HasPermissionToUnlockAny(BasePlayer player, TechTreeData techTree);
    [JsonObject(MemberSerialization.OptIn)]
    private class CustomCurrency
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
        [JsonProperty("Item short name")]
        public string ItemShortName;
        [JsonIgnore]
        public int ItemId;
        [JsonIgnore]
        public bool IsEnabledAndValid { get; set; }
        public void Init();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class BlueprintRuleset
    {
        public static readonly BlueprintRuleset DefaultRuleset;
        [JsonProperty("Name")]
        private string Name;
        [JsonProperty("Optional blueprints")]
        private string[] OptionalBlueprints;
        [JsonProperty("OptionalBlueprints")]
        private string[] DeprecatedOptionalBlueprints { get; set; }
        [JsonProperty("Allowed blueprints", DefaultValueHandling = DefaultValueHandling.Ignore)]
        private string[] AllowedBlueprints;
        [JsonProperty("AllowedBlueprints")]
        private string[] DeprecatedAllowedBlueprints { get; set; }
        [JsonProperty("Disallowed blueprints", DefaultValueHandling = DefaultValueHandling.Ignore)]
        private string[] DisallowedBlueprints;
        [JsonProperty("DisallowedBlueprints")]
        private string[] DeprecatedDisallowedBlueprints { get; set; }
        [JsonProperty("Blueprints with no prerequisites")]
        private string[] BlueprintsWithNoPrerequisites;
        [JsonProperty("BlueprintsWithNoPrerequisites")]
        private string[] DeprecatedBlueprintsWithNoPrerequisites { get; set; }
        public string Permission { get; set; }
        private HashSet<int> _optionalBlueprints;
        private HashSet<int> _allowedBlueprints;
        private HashSet<int> _disallowedBlueprints;
        private HashSet<int> _blueprintsWithNoPrerequisites;
        public void Init(TechTreeControl plugin);
        public bool HasPrerequisites(ItemDefinition itemDefinition);
        public bool IsAllowed(ItemDefinition itemDefinition);
        public bool IsOptional(ItemDefinition itemDefinition);
        private static void CacheItemIds(IEnumerable<string> shortNameList, HashSet<int> cachedItemIds);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : BaseConfiguration
    {
        [JsonProperty("Enable chat feedback")]
        public bool EnableChatFeedback;
        [JsonProperty("Enable PopupNotifications integration")]
        public bool EnablePopupNotifications;
        [JsonProperty("Research costs")]
        private Dictionary<string, int> ResearchCosts;
        [JsonProperty("Custom currency")]
        public CustomCurrency CustomCurrency;
        [JsonProperty("ResearchCosts")]
        private Dictionary<string, int> DeprecatedResearchCosts { get; set; }
        [JsonProperty("Blueprint rulesets")]
        private BlueprintRuleset[] BlueprintRulesets;
        [JsonProperty("BlueprintRulesets")]
        private BlueprintRuleset[] DeprecatedBlueprintRulesets { get; set; }
        private Dictionary<int, object> _researchCostByItemId;
        [JsonIgnore]
        public bool IsCustomCurrencyEnabledAndValid { get; set; }
        public void Init(TechTreeControl plugin);
        public object GetResearchCostOverride(ItemDefinition itemDefinition);
        public BlueprintRuleset GetPlayerBlueprintRuleset(TechTreeControl plugin, string userIdString);
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class LangEntry
    {
        public static readonly List<LangEntry> AllLangEntries;
        public static readonly LangEntry BlueprintDisallowed;
        public static readonly LangEntry BlueprintDisallowedOptional;
        public string Name;
        public string English;
        public LangEntry(string name, string english);
    }

    private string GetMessage(string playerId, LangEntry langEntry);
    private void ChatMessage(BasePlayer player, LangEntry langEntry);
    protected override void LoadDefaultMessages();
}

[JsonObject(MemberSerialization.OptIn)]
private class CustomCurrency
{
    [JsonProperty("Enabled")]
    public bool Enabled;
    [JsonProperty("Item short name")]
    public string ItemShortName;
    [JsonIgnore]
    public int ItemId;
    [JsonIgnore]
    public bool IsEnabledAndValid { get; set; }
    public void Init();
}

[JsonObject(MemberSerialization.OptIn)]
private class BlueprintRuleset
{
    public static readonly BlueprintRuleset DefaultRuleset;
    [JsonProperty("Name")]
    private string Name;
    [JsonProperty("Optional blueprints")]
    private string[] OptionalBlueprints;
    [JsonProperty("OptionalBlueprints")]
    private string[] DeprecatedOptionalBlueprints { get; set; }
    [JsonProperty("Allowed blueprints", DefaultValueHandling = DefaultValueHandling.Ignore)]
    private string[] AllowedBlueprints;
    [JsonProperty("AllowedBlueprints")]
    private string[] DeprecatedAllowedBlueprints { get; set; }
    [JsonProperty("Disallowed blueprints", DefaultValueHandling = DefaultValueHandling.Ignore)]
    private string[] DisallowedBlueprints;
    [JsonProperty("DisallowedBlueprints")]
    private string[] DeprecatedDisallowedBlueprints { get; set; }
    [JsonProperty("Blueprints with no prerequisites")]
    private string[] BlueprintsWithNoPrerequisites;
    [JsonProperty("BlueprintsWithNoPrerequisites")]
    private string[] DeprecatedBlueprintsWithNoPrerequisites { get; set; }
    public string Permission { get; set; }
    private HashSet<int> _optionalBlueprints;
    private HashSet<int> _allowedBlueprints;
    private HashSet<int> _disallowedBlueprints;
    private HashSet<int> _blueprintsWithNoPrerequisites;
    public void Init(TechTreeControl plugin);
    public bool HasPrerequisites(ItemDefinition itemDefinition);
    public bool IsAllowed(ItemDefinition itemDefinition);
    public bool IsOptional(ItemDefinition itemDefinition);
    private static void CacheItemIds(IEnumerable<string> shortNameList, HashSet<int> cachedItemIds);
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : BaseConfiguration
{
    [JsonProperty("Enable chat feedback")]
    public bool EnableChatFeedback;
    [JsonProperty("Enable PopupNotifications integration")]
    public bool EnablePopupNotifications;
    [JsonProperty("Research costs")]
    private Dictionary<string, int> ResearchCosts;
    [JsonProperty("Custom currency")]
    public CustomCurrency CustomCurrency;
    [JsonProperty("ResearchCosts")]
    private Dictionary<string, int> DeprecatedResearchCosts { get; set; }
    [JsonProperty("Blueprint rulesets")]
    private BlueprintRuleset[] BlueprintRulesets;
    [JsonProperty("BlueprintRulesets")]
    private BlueprintRuleset[] DeprecatedBlueprintRulesets { get; set; }
    private Dictionary<int, object> _researchCostByItemId;
    [JsonIgnore]
    public bool IsCustomCurrencyEnabledAndValid { get; set; }
    public void Init(TechTreeControl plugin);
    public object GetResearchCostOverride(ItemDefinition itemDefinition);
    public BlueprintRuleset GetPlayerBlueprintRuleset(TechTreeControl plugin, string userIdString);
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private class LangEntry
{
    public static readonly List<LangEntry> AllLangEntries;
    public static readonly LangEntry BlueprintDisallowed;
    public static readonly LangEntry BlueprintDisallowedOptional;
    public string Name;
    public string English;
    public LangEntry(string name, string english);
}


```

---

## TelegramBotAPI by NoxiousPluK - Send messages using the Telegram Bot API

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Telegram Bot API", "NoxiousPluK", "0.1.2")]
[Description("Send messages using the Telegram Bot API")]
public class TelegramBotAPI : CovalencePlugin
{
    private Configuration config;
    private class Configuration
    {
        [JsonProperty("Telegram Bot API Key")]
        public string TelegramBotAPIKey;
        [JsonProperty("Default ID for messages")]
        public long DefaultID;
        [JsonProperty("ID for error messages")]
        public long ErrorID;
        [JsonProperty("Try sending error messages to Telegram")]
        public bool SendErrors;
        [JsonProperty("Announce plugin (re)load to Telegram")]
        public bool AnnounceLoad;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     void OnServerInitialized(bool initial);
    private void SendTelegramMessage(string message, long chatID, bool escape, string parseMode);
    private string Escape(string Input);
    private void SendTelegramError(string message);
}

private class Configuration
{
    [JsonProperty("Telegram Bot API Key")]
    public string TelegramBotAPIKey;
    [JsonProperty("Default ID for messages")]
    public long DefaultID;
    [JsonProperty("ID for error messages")]
    public long ErrorID;
    [JsonProperty("Try sending error messages to Telegram")]
    public bool SendErrors;
    [JsonProperty("Announce plugin (re)load to Telegram")]
    public bool AnnounceLoad;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## Telekinesis by WhiteThunder - Allows players to move/rotate entities without picking them up

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Telekinesis", "WhiteThunder", "3.3.0")]
[Description("Allows players to move and rotate objects in place.")]
internal class Telekinesis : CovalencePlugin
{
    private static Telekinesis _pluginInstance;
    private static Configuration _config;
    private const string PermissionAdmin;
    private const string PermissionRulesetFormat;
    private TelekinesisManager _telekinesisManager;
    private UndoManager _undoManager;
    private readonly object True;
    private readonly object False;
    public Telekinesis();
    private void Init();
    private void Unload();
    [HookMethod(nameof(API_IsBeingControlled))]
    public object API_IsBeingControlled(Component component);
    [HookMethod(nameof(API_IsUsingTelekinesis))]
    public object API_IsUsingTelekinesis(BasePlayer player);
    [HookMethod(nameof(API_StartAdminTelekinesis))]
    public bool API_StartAdminTelekinesis(BasePlayer player, Component component);
    [HookMethod(nameof(API_StopPlayerTelekinesis))]
    public void API_StopPlayerTelekinesis(BasePlayer player);
    [HookMethod(nameof(API_StopTargetTelekinesis))]
    public void API_StopTargetTelekinesis(Component target);
    private static class ExposedHooks
    {
        public static Component OnTelekinesisFindFailed(BasePlayer player);
        public static Tuple<Component, Component> OnTelekinesisStart(BasePlayer player, Component component);
        public static bool CanStartTelekinesis(BasePlayer player, Component moveComponent, Component rotateComponent, string errorMessage);
        public static void OnTelekinesisStarted(BasePlayer player, Component moveComponent, Component rotateComponent);
        public static void OnTelekinesisStopped(BasePlayer player, Component moveComponent, Component rotateComponent);
    }

    [Command("telekinesis", "tls")]
    private void CommandTelekinesis(IPlayer player, string cmd, string[] args);
    private static Vector3 TransformPoint(Vector3 origin, Vector3 localPosition, Quaternion rotation);
    private static Vector3 InverseTransformPoint(Vector3 origin, Vector3 worldPosition, Quaternion rotation);
    private static BaseEntity GetLookEntity(BasePlayer player, int layerMask, float maxDistance);
    private static void BroadcastEntityTransformChange(BaseEntity entity, Transform transform);
    private static void RemoveActiveItem(BasePlayer player);
    private static bool IsBuildingBlocked(BasePlayer player, Component component);
    private class TelekinesisManager
    {
        private UndoManager _undoManager;
        private Dictionary<BasePlayer, TelekinesisComponent> _playerComponents;
        public TelekinesisManager(UndoManager undoManager);
        public void Register(TelekinesisComponent component);
        public void Unregister(TelekinesisComponent component);
        public bool IsBeingControlled(Component component);
        public bool IsUsingTelekinesis(BasePlayer player);
        public bool TryStartTelekinesis(BasePlayer player, Component component, PlayerRuleset ruleset);
        public void StopPlayerTelekinesis(BasePlayer player);
        public void StopTargetTelekinesis(Component component);
        public void StopAll();
        private TelekinesisComponent GetPlayerTelekinesisTarget(BasePlayer player);
    }

    private class RestorePoint
    {
        private static bool IsComponentValid(Component component);
        private const float ExpirationSeconds;
        public bool IsValid { get; set; }
        private PluginTimers _pluginTimers;
        private Component _moveComponent;
        private Component _rotateComponent;
        private Vector3 _localPosition;
        private Quaternion _localRotation;
        private Action _cleanup;
        private Timer _timer;
        public RestorePoint(PluginTimers pluginTimers, Component moveComponent, Component rotateComponent, Action cleanup);
        public bool TryRestore(Component moveComponent, Component rotateComponent);
        public void StartExpirationTimer();
        public void Destroy();
    }

    private class UndoManager
    {
        private Dictionary<ulong, RestorePoint> _playerRestorePoints;
        private PluginTimers _pluginTimers;
        public UndoManager(PluginTimers pluginTimers);
        public RestorePoint SavePosition(ulong userId, Component moveComponent, Component rotateComponent);
        public bool TryUndo(ulong userId, Component moveComponent, Component rotateComponent);
        private RestorePoint GetRestorePoint(ulong userId);
    }

    private class TelekinesisComponent : FacepunchBehaviour
    {
        private class RigidbodyRestorePoint
        {
            private Rigidbody _rigidBody;
            private bool _useGravity;
            private bool _isKinematic;
            public static RigidbodyRestorePoint CreateRestore(Rigidbody rigidbody);
            public void Restore();
        }

        private const float ModeChangeDelay;
        public static void AddToComponent(Component moveComponent, Component rotateComponent, TelekinesisManager manager, BasePlayer player, PlayerRuleset ruleset, RestorePoint restorePoint);
        public static TelekinesisComponent GetForComponent(Component component);
        public Component MoveComponent { get; set; }
        public Component RotateComponent { get; set; }
        public BasePlayer Player { get; set; }
        private Transform _moveTransform;
        private Transform _rotateTransform;
        private PlayerRuleset _ruleset;
        private TelekinesisManager _manager;
        private RestorePoint _restorePoint;
        private float _maxDistanceSquared;
        private TelekinesisMode _mode;
        private float _lastBuildingBlockCheck;
        private bool _wasDestroyedForExplicitReason;
        private Vector3 _headOffset;
        private float _lastMoved;
        private float _lastChangedMode;
        private RigidbodyRestorePoint _rigidbodyRestore;
        public TelekinesisComponent Init(Component moveComponent, Component rotateComponent, TelekinesisManager manager, BasePlayer player, PlayerRuleset ruleset, RestorePoint restorePoint);
        public void DestroyImmediate(string reason);
        private void MaybeSwitchMode(float now);
        private float GetSensitivityMultiplier(SpeedSettings speedSettings);
        private void SetHeadOffset(Vector3 newHeadOffset);
        private float GetMoveAdjustment(float deltaTimeAndDirection);
        private float GetRotationAdjustment(float deltaTimeAndDirection);
        private void RotateViewAngles(BasePlayer rotatePlayer);
        private void MaybeMoveOrRotate(float now);
        private void DoUpdate();
        private void TrackedUpdate();
        private void OnDestroy();
    }

    private class PlayerRuleset
    {
        public static PlayerRuleset AdminRuleset;
        [JsonProperty("Permission suffix")]
        public string PermissionSuffix;
        [JsonProperty("Can move players")]
        public bool CanMovePlayers;
        [JsonProperty("Can use while building blocked")]
        public bool CanUseWhileBuildingBlocked;
        [JsonProperty("Requires ownership")]
        public bool RequiresOwnership;
        [JsonProperty("Max distance")]
        public float MaxDistance;
        private string _cachedPermission;
        [JsonIgnore]
        public string Permission { get; set; }
    }

    private class SpeedSettings
    {
        [JsonProperty("Slow")]
        public float Slow;
        [JsonProperty("Normal")]
        public float Normal;
        [JsonProperty("Fast")]
        public float Fast;
    }

    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("Enable message prefix")]
        public bool EnableMessagePrefix;
        [JsonProperty("Idle timeout (seconds)")]
        public float IdleTimeout;
        [JsonProperty("Building privilege check frequency (seconds)")]
        public float BuildingBlockedCheckFrequency;
        [JsonProperty("Move sensitivity")]
        public SpeedSettings MoveSensitivity;
        [JsonProperty("Rotate sensitivity")]
        public SpeedSettings RotateSensitivity;
        [JsonProperty("Rulesets")]
        public PlayerRuleset[] Rulesets;
        public PlayerRuleset GetPlayerRuleset(Permission permission, string userIdString);
    }

    private Configuration GetDefaultConfig();
    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(string playerId, string messageName, object[] args);
    private string GetMessageWithPrefix(string playerId, string messageName, object[] args);
    private string GetMessageWithPrefix(BasePlayer player, string messageName, object[] args);
    private void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    private void ChatMessageWithPrefix(BasePlayer player, string messageName, object[] args);
    private string GetModeLangKey(TelekinesisMode mode);
    private string GetModeName(BasePlayer player, TelekinesisMode mode);
    private string GetModeMessage(BasePlayer player, TelekinesisMode mode);
    private void SendModeChatMessage(BasePlayer player, TelekinesisMode mode);
    private static class Lang
    {
        public const string ErrorNoPermission;
        public const string ErrorNoEntityFound;
        public const string ErrorAlreadyBeingControlled;
        public const string ErrorAlreadyUsingTelekinesis;
        public const string ErrorBlockedByPlugin;
        public const string ErrorCannotMovePlayers;
        public const string ErrorNotOwned;
        public const string ErrorBuildingBlocked;
        public const string ErrorMaxDistance;
        public const string MessagePrefix;
        public const string InfoEnabled;
        public const string InfoDisabled;
        public const string InfoDisableInactivity;
        public const string InfoDisableBuildingBlocked;
        public const string ErrorUndoNotFound;
        public const string UndoSuccess;
        public const string ModeChanged;
        public const string MovePlayerOffset;
        public const string ModeMoveY;
        public const string ModeRotateX;
        public const string ModeRotateY;
        public const string ModeRotateZ;
    }

    protected override void LoadDefaultMessages();
}

private static class ExposedHooks
{
    public static Component OnTelekinesisFindFailed(BasePlayer player);
    public static Tuple<Component, Component> OnTelekinesisStart(BasePlayer player, Component component);
    public static bool CanStartTelekinesis(BasePlayer player, Component moveComponent, Component rotateComponent, string errorMessage);
    public static void OnTelekinesisStarted(BasePlayer player, Component moveComponent, Component rotateComponent);
    public static void OnTelekinesisStopped(BasePlayer player, Component moveComponent, Component rotateComponent);
}

private class TelekinesisManager
{
    private UndoManager _undoManager;
    private Dictionary<BasePlayer, TelekinesisComponent> _playerComponents;
    public TelekinesisManager(UndoManager undoManager);
    public void Register(TelekinesisComponent component);
    public void Unregister(TelekinesisComponent component);
    public bool IsBeingControlled(Component component);
    public bool IsUsingTelekinesis(BasePlayer player);
    public bool TryStartTelekinesis(BasePlayer player, Component component, PlayerRuleset ruleset);
    public void StopPlayerTelekinesis(BasePlayer player);
    public void StopTargetTelekinesis(Component component);
    public void StopAll();
    private TelekinesisComponent GetPlayerTelekinesisTarget(BasePlayer player);
}

private class RestorePoint
{
    private static bool IsComponentValid(Component component);
    private const float ExpirationSeconds;
    public bool IsValid { get; set; }
    private PluginTimers _pluginTimers;
    private Component _moveComponent;
    private Component _rotateComponent;
    private Vector3 _localPosition;
    private Quaternion _localRotation;
    private Action _cleanup;
    private Timer _timer;
    public RestorePoint(PluginTimers pluginTimers, Component moveComponent, Component rotateComponent, Action cleanup);
    public bool TryRestore(Component moveComponent, Component rotateComponent);
    public void StartExpirationTimer();
    public void Destroy();
}

private class UndoManager
{
    private Dictionary<ulong, RestorePoint> _playerRestorePoints;
    private PluginTimers _pluginTimers;
    public UndoManager(PluginTimers pluginTimers);
    public RestorePoint SavePosition(ulong userId, Component moveComponent, Component rotateComponent);
    public bool TryUndo(ulong userId, Component moveComponent, Component rotateComponent);
    private RestorePoint GetRestorePoint(ulong userId);
}

private class TelekinesisComponent : FacepunchBehaviour
{
    private class RigidbodyRestorePoint
    {
        private Rigidbody _rigidBody;
        private bool _useGravity;
        private bool _isKinematic;
        public static RigidbodyRestorePoint CreateRestore(Rigidbody rigidbody);
        public void Restore();
    }

    private const float ModeChangeDelay;
    public static void AddToComponent(Component moveComponent, Component rotateComponent, TelekinesisManager manager, BasePlayer player, PlayerRuleset ruleset, RestorePoint restorePoint);
    public static TelekinesisComponent GetForComponent(Component component);
    public Component MoveComponent { get; set; }
    public Component RotateComponent { get; set; }
    public BasePlayer Player { get; set; }
    private Transform _moveTransform;
    private Transform _rotateTransform;
    private PlayerRuleset _ruleset;
    private TelekinesisManager _manager;
    private RestorePoint _restorePoint;
    private float _maxDistanceSquared;
    private TelekinesisMode _mode;
    private float _lastBuildingBlockCheck;
    private bool _wasDestroyedForExplicitReason;
    private Vector3 _headOffset;
    private float _lastMoved;
    private float _lastChangedMode;
    private RigidbodyRestorePoint _rigidbodyRestore;
    public TelekinesisComponent Init(Component moveComponent, Component rotateComponent, TelekinesisManager manager, BasePlayer player, PlayerRuleset ruleset, RestorePoint restorePoint);
    public void DestroyImmediate(string reason);
    private void MaybeSwitchMode(float now);
    private float GetSensitivityMultiplier(SpeedSettings speedSettings);
    private void SetHeadOffset(Vector3 newHeadOffset);
    private float GetMoveAdjustment(float deltaTimeAndDirection);
    private float GetRotationAdjustment(float deltaTimeAndDirection);
    private void RotateViewAngles(BasePlayer rotatePlayer);
    private void MaybeMoveOrRotate(float now);
    private void DoUpdate();
    private void TrackedUpdate();
    private void OnDestroy();
}

private class RigidbodyRestorePoint
{
    private Rigidbody _rigidBody;
    private bool _useGravity;
    private bool _isKinematic;
    public static RigidbodyRestorePoint CreateRestore(Rigidbody rigidbody);
    public void Restore();
}

private class PlayerRuleset
{
    public static PlayerRuleset AdminRuleset;
    [JsonProperty("Permission suffix")]
    public string PermissionSuffix;
    [JsonProperty("Can move players")]
    public bool CanMovePlayers;
    [JsonProperty("Can use while building blocked")]
    public bool CanUseWhileBuildingBlocked;
    [JsonProperty("Requires ownership")]
    public bool RequiresOwnership;
    [JsonProperty("Max distance")]
    public float MaxDistance;
    private string _cachedPermission;
    [JsonIgnore]
    public string Permission { get; set; }
}

private class SpeedSettings
{
    [JsonProperty("Slow")]
    public float Slow;
    [JsonProperty("Normal")]
    public float Normal;
    [JsonProperty("Fast")]
    public float Fast;
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("Enable message prefix")]
    public bool EnableMessagePrefix;
    [JsonProperty("Idle timeout (seconds)")]
    public float IdleTimeout;
    [JsonProperty("Building privilege check frequency (seconds)")]
    public float BuildingBlockedCheckFrequency;
    [JsonProperty("Move sensitivity")]
    public SpeedSettings MoveSensitivity;
    [JsonProperty("Rotate sensitivity")]
    public SpeedSettings RotateSensitivity;
    [JsonProperty("Rulesets")]
    public PlayerRuleset[] Rulesets;
    public PlayerRuleset GetPlayerRuleset(Permission permission, string userIdString);
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private static class Lang
{
    public const string ErrorNoPermission;
    public const string ErrorNoEntityFound;
    public const string ErrorAlreadyBeingControlled;
    public const string ErrorAlreadyUsingTelekinesis;
    public const string ErrorBlockedByPlugin;
    public const string ErrorCannotMovePlayers;
    public const string ErrorNotOwned;
    public const string ErrorBuildingBlocked;
    public const string ErrorMaxDistance;
    public const string MessagePrefix;
    public const string InfoEnabled;
    public const string InfoDisabled;
    public const string InfoDisableInactivity;
    public const string InfoDisableBuildingBlocked;
    public const string ErrorUndoNotFound;
    public const string UndoSuccess;
    public const string ModeChanged;
    public const string MovePlayerOffset;
    public const string ModeMoveY;
    public const string ModeRotateX;
    public const string ModeRotateY;
    public const string ModeRotateZ;
}


```

---

## Teleport by Orf1 - Lets players with permission teleport to any position on the map using /teleport [x] [y] [z]

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Teleport", "Orf1", "1.0.1")]
[Description("Lets players with permission teleport to any specified position.")]
 class Teleport : CovalencePlugin
{
    private void Init();
    [Command("teleport")]
    private void SetCommand(IPlayer player, string command, string[] args);
    protected override void LoadDefaultMessages();
}


```

---

## TeleportGun by 2CHEVSKII - Allows teleporting by shooting guns

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Teleport Gun", "2CHEVSKII", "0.2.0")]
[Description("Shoot something to teleport to it!")]
 class TeleportGun : CovalencePlugin
{
     void Init();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
     void OnPlayerAttack(BasePlayer attacker, HitInfo info);
     void OnActiveItemChanged(BasePlayer player);
     bool autodisable;
     int autodisabletimer;
    const string PERMISSION_USE;
    const string CHAT_PREFIX;
    const string ENABLED;
    const string DISABLED;
    const string WRONG_ITEM;
    const string NO_PERMISSION;
     Dictionary<string, string> defaultMessages;
     Dictionary<IPlayer, Item> enabledplayers;
     Dictionary<BasePlayer, Timer> timers;
    [Command("tpgun")]
     void CmdTpGun(IPlayer player, string command, string[] args);
     void Enable(BasePlayer player);
     void Disable(BasePlayer player);
     void LoadConfigVariables();
     void CheckConfig(string key, T value);
     void Replier(BasePlayer player, string message);
     void Replier(IPlayer player, string message);
}


```

---

## TeleportMarker by Talha - Allows authorized players can teleport to map markers

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

Oxide.Plugins
[Info("Teleport Marker", "Talha", "1.0.6")]
[Description("Authorized players can teleport to map markers with that plugin.")]
public class TeleportMarker : RustPlugin
{
    private const string permUse;
    private ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Admins can teleport without permission")]
        public bool admins;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Message(BasePlayer player, string key, object[] args);
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private void TP(BasePlayer player, MapNote note);
    private void OnMapMarkerAdded(BasePlayer player, MapNote note);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Admins can teleport without permission")]
    public bool admins;
}


```

---

## TellMeC by  - Tell the correct color match you see, and get ammo and RP , Eco points or Battlepass points

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Globalization;
using Oxide.Core;

Oxide.Plugins
[Info("Tell Me C", "Krungh Crow", "1.1.4")]
[Description("Tell THE correct color combination you see, and get Ammo and RP or Eco Points")]
public class TellMeC : RustPlugin
{
    [PluginReference]
     Plugin Battlepass;
     Plugin ServerRewards;
     Plugin Economics;
     Plugin GUIAnnouncements;
     string ColorToFind;
     string WinWord;
     List<ulong> TellMeCPlayerIDs;
    private bool ConfigChanged;
    private string ItemWon;
    private string ItemToWin;
     int QuantityToWin;
     bool TellMeCIsOn;
     string MixC;
     string finalsentence;
     float TellMeCRate;
     float TellMeCLength;
    private string ToWait;
     bool debug;
     string Prefix;
     ulong SteamIDIcon;
     string WinnerColor;
    private bool UseServerRewards;
    private bool UseEconomics;
    private bool UseBattlepass;
     bool useBattlepass1;
     bool useBattlepass2;
     bool useBattlepassloss;
     int battlepassWinReward1;
     int battlepassWinReward2;
     int battlepassLossReward1;
     int battlepassLossReward2;
     int PointsOnWin;
     int PointsOnLoss;
     int MinPlayer;
    private bool UseGUI;
     Dictionary<int, string> Item;
     Dictionary<int, int> Quantity;
     Dictionary<string, string> colorRGB;
     Dictionary<string, string> randomed;
     List<String> mixRGB;
     List<String> mixTOSEE;
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    private void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
     void Loaded();
     void Unload();
     void TellMeCExpired();
    private void Init();
    private void OnServerInitialized();
    private void StartTellMeC();
    public void BuildMix();
     string Randomizer();
     void BroadcastSentence(bool start);
    [ChatCommand("color")]
     void TellMeCCommand(BasePlayer player, string command, string[] args);
     void GivePlayerGift(BasePlayer player, string gift);
}


```

---

## TellMeX by  - Calculate X and get a ammo, RP points, Economics or Battlepass points rewarded

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Tell Me X", "Krungh Crow", "1.0.1")]
[Description("Calculate X and get Bonus Ammo, RP Points, Economics")]
public class TellMeX : RustPlugin
{
    [PluginReference]
     Plugin Battlepass;
     Plugin ServerRewards;
     Plugin Economics;
     Plugin GUIAnnouncements;
     float TellMeXRate;
     float TellMeXLength;
     int MinPlayer;
     float TellMeXEndTime;
     float NextTellMeXTime;
     bool TellMeXIsOn;
     bool OnReloading;
     int QuantityToWin;
     List<ulong> TellMeXPlayerIDs;
    private string Math;
    private string XToFind;
    private string ItemWon;
    private string ItemToWin;
    private string ToWait;
    private bool ConfigChanged;
    private string Prefix;
    private string PrefixColor;
    private string ChatColor;
     ulong SteamIDIcon;
    private string WinnerColor;
    private string MathColor;
    private bool UseServerRewards;
    private bool UseEconomics;
    private bool UseBattlepass;
     bool useBattlepass1;
     bool useBattlepass2;
     bool useBattlepassloss;
     int battlepassWinReward1;
     int battlepassWinReward2;
     int battlepassLossReward1;
     int battlepassLossReward2;
    private bool UseGUI;
     int RPOnWin;
     int RPOnLose;
     int EcoOnWin;
     int EcoOnLose;
    private Dictionary<int, string> Item;
    private Dictionary<int, int> Quantity;
    private Dictionary<int, string> Calculs;
     void LoadDefaultMessages();
     void Loaded();
     void Unload();
    protected override void LoadDefaultConfig();
    private void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private void OnServerInitialized();
     void OnTick();
     void TellMeXExpired();
    private void StartTellMeX();
    private string DoMath(int X, int Y, int Z, int RandomCalcul);
    [ChatCommand("x")]
    private void TellMeXCommand(BasePlayer player, string command, string[] args);
    private void BroadcastMath(bool start);
    private void GivePlayerGift(BasePlayer player, string gift);
}


```

---

## TellMyVote by Spiikesan - A GUI panel with up to 4 polls / 3 answers to vote and easy start/end/clear/vote

```csharp
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Tell My Vote", "Spiikesan", "1.2.2")]
[Description("A Cui panel for players to vote at admin polls")]
public class TellMyVote : RustPlugin
{
    const float MARGIN_LR;
    const float MARGIN_TB;
    const float SEP_POLL;
    const float SEP_IN;
    const float SIZE_SUBCOL_1;
    const float SIZE_SUBCOL_2;
    const float SIZE_ROW;
    const float PollWidth;
    const float PollHeight;
     string[] pos_rows;
     string[] pos_cols;
    const string HelpButtonTxt;
    const string HelpButtonColor;
    const string PanelColor;
    const string buttonCloseColor;
    const string QuestionColor;
    const string AnswerColor;
    const string CountColor;
    const bool debug;
    const string TMVAdmin;
    const string DataFilename;
     bool ClearDataOnWipe;
     string MyVotePanel;
     string MyVoteInfoPanel;
     string Prefix;
     string PrefixColor;
     string ChatColor;
     string PanelTitle;
     string PanelCommand;
     string BannerColor;
     float BannerSizeX;
     float BannerSizeY;
     float BannerPositionX;
     float BannerPositionY;
     bool BannerMsgEnabled;
     bool ChatMsgEnabled;
     string BannerAnchorMin;
     string BannerAnchorMax;
     ulong SteamIDIcon;
     float VoteDurationMax;
    private bool ConfigChanged;
     float BannerShowTimer;
     float BannerHideTimer;
     string[,] polls;
    private Timer tmvbanner;
     void Init();
    protected override void LoadDefaultConfig();
    private void OnNewSave(string filename);
    private void GenerateCoordinates();
    private void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private void SetConfig(string menu, string datavalue, string value);
     void Loaded();
     void Unload();
    protected override void LoadDefaultMessages();
     class StoredData
    {
        public List<ulong>[,] votes;
        public bool myVoteIsON;
        public StoredData();
    }

    private StoredData storedData;
    [ChatCommand("myvote_poll")]
    private void TellMyVotePollSet(BasePlayer player, string command, string[] args);
     void PlayerMessage(BasePlayer player, string poll, string answer, string sentence);
    private bool VoteNeeded(ulong playerID, int pollNum);
    private bool VoteNeeded(ulong playerID);
    [ConsoleCommand("TellMyVote")]
    private void MySurveySpotOnly(ConsoleSystem.Arg arg);
    private void RefreshMyVotePanel(BasePlayer player);
    [ConsoleCommand("TellMyVoteChangeStatus")]
    private void TellMyVoteChangeStatus(ConsoleSystem.Arg arg);
    private void Purge();
    private void PopUpPlayer(BasePlayer player, string state);
    private void PopUpVote(string newstate);
    private void TellMyVoteInfoPanel(BasePlayer player);
    private void TellMyVotePanel(BasePlayer player, string command, string[] args);
    private string FormatFloat(float f);
}

 class StoredData
{
    public List<ulong>[,] votes;
    public bool myVoteIsON;
    public StoredData();
}


```

---

## TemperatureExtender by MJSU - Extends the range of temperature and comfort

```csharp
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Temperature Extender", "MJSU", "1.0.2")]
[Description("Extends the range of temperature and comfort")]
public class TemperatureExtender : RustPlugin
{
    private PluginConfig _pluginConfig;
    private readonly Hash<string, EntitySettings> _defaultSettings;
    private bool _init;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private PluginConfig AdditionalConfig(PluginConfig config);
    private void OnServerInitialized();
    private void AddSetting(Hash<string, EntitySettings> settings, BaseCombatEntity entity, bool enabled);
    private void Unload();
    private void OnEntitySpawned(BaseCombatEntity entity);
    private void UpdateAllEntities(Hash<string, EntitySettings> settings);
    private void UpdateEntity(BaseCombatEntity entity, Hash<string, EntitySettings> settings);
    private TemperatureSettings GetTemperatureSettings(TriggerTemperature temp);
    private ComfortSettings GetComfortSettings(TriggerComfort comfort);
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Entity Settings")]
        public Hash<string, EntitySettings> EntitySettings { get; set; }
    }

    private class EntitySettings
    {
        public TemperatureSettings Temperature { get; set; }
        public ComfortSettings Comfort { get; set; }
        public bool Enabled { get; set; }
    }

    private class TemperatureSettings
    {
        [JsonProperty(PropertyName = "Max temperature")]
        public float Temperature { get; set; }
        [JsonProperty(PropertyName = "Temperature range (Meters)")]
        public float TriggerRadius { get; set; }
        [JsonProperty(PropertyName = "Temperature falloff rate multiplier ( > 1 falls off slower < 1 falls off quicker)")]
        public float FalloffRate { get; set; }
        [JsonProperty(PropertyName = "Minimum range from entity before temperature takes effect")]
        public float MinRange { get; set; }
    }

    private class ComfortSettings
    {
        [JsonProperty(PropertyName = "Max comfort")]
        public float BaseComfort { get; set; }
        [JsonProperty(PropertyName = "Comfort range (Meters)")]
        public float TriggerRadius { get; set; }
        [JsonProperty(PropertyName = "Comfort falloff rate multiplier ( > 1 falls off slower < 1 falls off quicker)")]
        public float FalloffRate { get; set; }
        [JsonProperty(PropertyName = "Minimum range from entity before temperature takes effect")]
        public float MinRange { get; set; }
    }

}

private class PluginConfig
{
    [JsonProperty(PropertyName = "Entity Settings")]
    public Hash<string, EntitySettings> EntitySettings { get; set; }
}

private class EntitySettings
{
    public TemperatureSettings Temperature { get; set; }
    public ComfortSettings Comfort { get; set; }
    public bool Enabled { get; set; }
}

private class TemperatureSettings
{
    [JsonProperty(PropertyName = "Max temperature")]
    public float Temperature { get; set; }
    [JsonProperty(PropertyName = "Temperature range (Meters)")]
    public float TriggerRadius { get; set; }
    [JsonProperty(PropertyName = "Temperature falloff rate multiplier ( > 1 falls off slower < 1 falls off quicker)")]
    public float FalloffRate { get; set; }
    [JsonProperty(PropertyName = "Minimum range from entity before temperature takes effect")]
    public float MinRange { get; set; }
}

private class ComfortSettings
{
    [JsonProperty(PropertyName = "Max comfort")]
    public float BaseComfort { get; set; }
    [JsonProperty(PropertyName = "Comfort range (Meters)")]
    public float TriggerRadius { get; set; }
    [JsonProperty(PropertyName = "Comfort falloff rate multiplier ( > 1 falls off slower < 1 falls off quicker)")]
    public float FalloffRate { get; set; }
    [JsonProperty(PropertyName = "Minimum range from entity before temperature takes effect")]
    public float MinRange { get; set; }
}


```

---

## TemporaryBags by misticos - One-time use sleeping bags

```csharp
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("TemporaryBags", "Kappasaurus", "1.0.1")]
 class TemporaryBags : RustPlugin
{
    private const string SleepingBag;
    private const string ExcludePermission;
     void Init();
     void OnEntityBuilt(Planner plan, GameObject go);
     void OnPlayerRespawned(BasePlayer player);
}


```

---

## TemporaryBarricades by  - Removes defensive barricades built outside of cupboard range after a set time.

```csharp
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Temporary Barricades", "Norn", "0.0.4")]
[Description("Remove defensive barricades after a set time")]
public class TemporaryBarricades : RustPlugin
{
    private void Init();
    private ConfigFile config;
    public class ConfigFile
    {
        [JsonProperty(PropertyName = "BarricadePrefabs")]
        public List<string> barricadePrefabs;
        [JsonProperty(PropertyName = "RemoveAfter")]
        public int removeAfter;
        [JsonProperty(PropertyName = "DebugMode")]
        public bool debugMode;
        public static ConfigFile DefaultConfig();
    }

    private void VerifyConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnEntityBuilt(Planner builder, GameObject gameObject);
}

public class ConfigFile
{
    [JsonProperty(PropertyName = "BarricadePrefabs")]
    public List<string> barricadePrefabs;
    [JsonProperty(PropertyName = "RemoveAfter")]
    public int removeAfter;
    [JsonProperty(PropertyName = "DebugMode")]
    public bool debugMode;
    public static ConfigFile DefaultConfig();
}


```

---

## TerrainBlocker by ctv - Blocks building on specific colliders

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Terrain Blocker", "Slut", "2.0.0")]
 class TerrainBlocker : RustPlugin
{
     Configuration config;
    public class Configuration
    {
        [JsonProperty("Blocked Colliders")]
        public string[] BlockedColliders { get; set; }
        [JsonProperty("Blacklist/Whitelist")]
        public Blacklist blacklist;
        public class Blacklist
        {
            [JsonProperty("Prefabs (Leave empty to ignore)")]
            public string[] Prefabs { get; set; }
            [JsonProperty("Blacklist = True | Whitelist = False")]
            public bool _Blacklist { get; set; }
        }

        public static Configuration LoadDefaults();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Loaded();
    const string adminPermission;
    private object CanBuild(Planner plan, Construction prefab);
}

public class Configuration
{
    [JsonProperty("Blocked Colliders")]
    public string[] BlockedColliders { get; set; }
    [JsonProperty("Blacklist/Whitelist")]
    public Blacklist blacklist;
    public class Blacklist
    {
        [JsonProperty("Prefabs (Leave empty to ignore)")]
        public string[] Prefabs { get; set; }
        [JsonProperty("Blacklist = True | Whitelist = False")]
        public bool _Blacklist { get; set; }
    }

    public static Configuration LoadDefaults();
}

public class Blacklist
{
    [JsonProperty("Prefabs (Leave empty to ignore)")]
    public string[] Prefabs { get; set; }
    [JsonProperty("Blacklist = True | Whitelist = False")]
    public bool _Blacklist { get; set; }
}


```

---

## TerrainViolationFix by Tryhard - Disables "Inside terrain violation 200" kicks for players with permission

```csharp

Oxide.Plugins
[Info("Terrain Violation Fix", "Tryhard", "1.0.3")]
[Description("Disables inside terrain violation 200 kicks for admins")]
public class TerrainViolationFix : RustPlugin
{
    private void Init();
    private object OnPlayerViolation(BasePlayer player, AntiHackType type);
}


```

---

## TheGathering by Razor - Gives players a gather multiplier for wearing certain clothes

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;

Oxide.Plugins
[Info("The Gathering", "Razor", "2.1.0")]
[Description("Gives players a gather multiplier for wearing certain clothes")]
public class TheGathering : RustPlugin
{
    public bool debug;
     ItemTypes itemData;
    private DynamicConfigFile ITEMDATA;
    private const string adminAllow;
    static TheGathering _instance;
    private new void LoadDefaultMessages();
    private void RegisterPermissions();
     void Unload();
     void Init();
     void LoadData();
     class ItemTypes
    {
        public Dictionary<ulong, ItemInfo> Items;
    }

     class ItemInfo
    {
        public string ItemName;
        public int ItemID;
        public int RateMultiplier;
        public int SpawnChance;
        public bool SpawnInContainers;
        public float ConditionLoss;
        public List<string> LootContainers;
    }

     void SaveItemData();
     void OnLootSpawn(LootContainer container);
    private bool? CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem);
    private bool? CanStackItem(Item item, Item targetItem);
     void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity);
     void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item);
     void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
    [ChatCommand("tg")]
     void MasterGatherItems(BasePlayer player, string command, string[] args);
}

 class ItemTypes
{
    public Dictionary<ulong, ItemInfo> Items;
}

 class ItemInfo
{
    public string ItemName;
    public int ItemID;
    public int RateMultiplier;
    public int SpawnChance;
    public bool SpawnInContainers;
    public float ConditionLoss;
    public List<string> LootContainers;
}


```

---

## ThiefAPI by  - Adds the ability to pick locks

```csharp
using System;
using System.Reflection;
using System.Data;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;

Oxide.Plugins
[Info("Thief", "Alphawar", "0.5.0", ResourceId = 1503)]
[Description("Mod for handling Thief class.")]
 class ThiefAPI : RustPlugin
{
    private int Cooldown;
    private int Pass;
    private int LPchance;
    private int RandomNumber;
    private int DamageTicks;
    private int pickCostFM;
    private int pickCostSE;
    private float DamageAmount;
    private string NotAllowed;
    private string Allowed;
    private string Failed;
    private string Success;
    private string MaxedAttempts;
    private string ChatPrefixColor;
    private string ChatPrefix;
    private string PickEnabledMessage;
    private string PickDisabledMessage;
    private string CooldownMessage;
    private bool PickEnabled;
     object GetConfig(string menu, string dataValue, object defaultValue);
    protected override void LoadDefaultConfig();
     void LoadVariables();
     Hash<ulong, PlayerInfo> Thiefs;
     class PlayerInfo
    {
        public string UserId;
        public string Name;
        public PlayerInfo();
        public PlayerInfo(BasePlayer player);
        public ulong GetUserId();
    }

     class StoredData
    {
        public Dictionary<ulong, double> canpick;
        public HashSet<PlayerInfo> Thiefs;
        public StoredData();
    }

     StoredData storedData;
     System.Reflection.FieldInfo whitelistPlayers;
    private void Loaded();
    [ChatCommand("lp")]
     void picklock(BasePlayer player, string cmd, string[] args);
    [ChatCommand("lpwipe")]
     void picklockwipe(BasePlayer player, string cmd, string[] args);
     object CanUseDoor(BasePlayer player, BaseLock codeLock);
    private bool lockPickCost(BasePlayer player);
     bool LPRoll();
     bool IsAllowed(BasePlayer player, string perm, string reason);
     double GetTimeStamp();
     void DisableThiefMode(BasePlayer player);
     void EnableThiefMode(BasePlayer player);
     void SendChatMessage(BasePlayer player, string message, string args);
}

 class PlayerInfo
{
    public string UserId;
    public string Name;
    public PlayerInfo();
    public PlayerInfo(BasePlayer player);
    public ulong GetUserId();
}

 class StoredData
{
    public Dictionary<ulong, double> canpick;
    public HashSet<PlayerInfo> Thiefs;
    public StoredData();
}


```

---

## ThirdPerson by Rick6 - Allows any player with permission to use third-person view.

```csharp
using System;

Oxide.Plugins
[Info("ThirdPerson", "Wulf,Rick", "0.1.5", ResourceId = 1424)]
[Description("Allows any player with permission to use third-person view.")]
 class ThirdPerson : RustPlugin
{
     string ChatCommand { get; set; }
     string NoPermission { get; set; }
    protected override void LoadDefaultConfig();
     void Loaded();
     void OnPlayerConnected(BasePlayer player);
     void ViewChatCmd(BasePlayer player);
     T GetConfig(string name, T defaultValue);
     bool HasPermission(BasePlayer player, string perm);
}


```

---

## TicketFines by McJackson164 - A police-like system to issue tickets and impose fines.

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Ticket Fines", "McJackson164", "1.1.4")]
[Description("A police-like system to issue tickets and impose fines.")]
internal sealed class TicketFines : CovalencePlugin
{
    private const string PermissionTicketsIssue;
    private const string PermissionTicketsDemand;
    private const string PermissionTicketsClose;
    private const string PermissionTicketsEdit;
    [PluginReference]
    private Plugin Economics;
    [PluginReference]
    private Plugin ServerRewards;
    private StoredData storedData;
    private Configuration config;
    private Dictionary<Ticket, string> demandedTickets;
    private string currency;
    private void Init();
    private void Loaded();
    private void OnServerSave();
    private void Unload();
    [Command("fine")]
    private void CommandTicket(IPlayer iplayer, string command, string[] args);
    private Ticket IssueTicket(string issuer, IPlayer target, double fine, string note);
    private Ticket IssueTicket(IPlayer player, IPlayer target, double fine, string note);
    private bool DemandTicket(IPlayer player, Ticket ticket);
    private bool PayTicket(IPlayer player, Ticket ticket);
    private bool CloseTicket(Ticket ticket, string closedBy);
    private bool EditTicket(Ticket ticket, TicketEditField field, object value);
    private bool DeleteTicket(Ticket ticket);
    private Ticket GetTicketByID(uint ticketID);
    private Ticket GetTicketByIDString(string ticketIDString);
    private List<Ticket> GetUnpaidTickets(IPlayer player, int limit);
    private bool HasTickets(IPlayer player);
    private bool IsTicketDemanded(Ticket ticket);
    private List<Dictionary<string, object>> API_GetAllTicketsOfPlayer(IPlayer player);
    private List<Dictionary<string, object>> API_GetUnpaidTicketsOfPlayer(IPlayer player);
    private List<Dictionary<string, object>> API_GetPaidTicketsOfPlayer(IPlayer player);
    private uint API_IssueTicket(string issuer, IPlayer target, double amount);
    private uint API_IssueTicket(string issuer, IPlayer target, double amount, string note);
    private bool API_PayTicketByID(IPlayer player, string ticketID, bool withdraw);
    private bool API_PayOldestTicketOfPlayer(IPlayer player);
    private bool API_CloseTicketByID(string ticketID, string closedBy);
    private bool API_DeleteTicketByID(string ticketID);
    private List<Dictionary<string, object>> TicketListToDictionary(IEnumerable<Ticket> ticketList);
    private IPlayer GetActivePlayerByUserID(string userID);
    private float GenericDistance(GenericPosition a, GenericPosition b);
    private class Configuration
    {
        [JsonProperty("Enable fines (requires Economics OR Server Rewards OR custom currency item)")]
        public bool EnableFines;
        [JsonProperty("Use 'Economics' plugin for payment (requires Economics)")]
        public bool UseEconomics;
        [JsonProperty("Use 'Server Rewards' plugin for payment (requires Server Rewards)")]
        public bool UseServerRewards;
        [JsonProperty("Use custom currency for payment")]
        public bool UseCustomCurrency;
        [JsonProperty("Custom Currency Item (requires 'Use custom currency' to be true. Use item shortname)")]
        public string CustomCurrencyItem;
        [JsonProperty("Enable automatic withdraw of fines (requires 'Enable fines' to be true)")]
        public bool AutoWithdraw;
        [JsonProperty("The demandent will receive a paid fine. (if false, the fine amount will be deleted)")]
        public bool DemandantReceiveFine;
        [JsonProperty("Maximum fine per ticket (default 1000.0)")]
        public double MaxFine;
        [JsonProperty("Currency (requires 'Use custom currency' to be true)")]
        public string FineCurrency;
        [JsonProperty("Enable notes (descriptive note attached to a ticket)")]
        public bool EnableNotes;
        [JsonProperty("Tickets require note (tickets won't be issued without a note)")]
        public bool RequireNote;
        [JsonProperty("Maximum note length (0 = unlimited)")]
        public int MaxNoteLength;
        [JsonProperty("Maximum distance in which you are able to demand a ticket (0 = unlimited)")]
        public int MaxDemandDistance;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class StoredData
    {
        public Dictionary<string, List<Ticket>> Tickets;
        public StoredData();
    }

    private class Ticket
    {
        public static uint CurrentID;
        public uint TicketID { get; set; }
        public string IssuerID { get; set; }
        public string ReceiverID { get; set; }
        public double Fine { get; set; }
        public string Note { get; set; }
        public bool IsClosed { get; set; }
        public string ClosedBy { get; set; }
        public DateTime IssueDate { get; set; }
        public DateTime CloseDate { get; set; }
        [JsonConstructor]
        public Ticket(uint ticketID, string issuerID, string receiverID, double fine, DateTime issueDate, string note, bool isClosed, string closedBy, DateTime? closeDate);
        public Ticket(string issuerID, string receiverID, double fine, string note);
        public Dictionary<string, object> ToDictionary();
    }

    private void SaveData();
    private string GetMessageFormatted(string key, IPlayer player, object[] args);
    protected override void LoadDefaultMessages();
}

private class Configuration
{
    [JsonProperty("Enable fines (requires Economics OR Server Rewards OR custom currency item)")]
    public bool EnableFines;
    [JsonProperty("Use 'Economics' plugin for payment (requires Economics)")]
    public bool UseEconomics;
    [JsonProperty("Use 'Server Rewards' plugin for payment (requires Server Rewards)")]
    public bool UseServerRewards;
    [JsonProperty("Use custom currency for payment")]
    public bool UseCustomCurrency;
    [JsonProperty("Custom Currency Item (requires 'Use custom currency' to be true. Use item shortname)")]
    public string CustomCurrencyItem;
    [JsonProperty("Enable automatic withdraw of fines (requires 'Enable fines' to be true)")]
    public bool AutoWithdraw;
    [JsonProperty("The demandent will receive a paid fine. (if false, the fine amount will be deleted)")]
    public bool DemandantReceiveFine;
    [JsonProperty("Maximum fine per ticket (default 1000.0)")]
    public double MaxFine;
    [JsonProperty("Currency (requires 'Use custom currency' to be true)")]
    public string FineCurrency;
    [JsonProperty("Enable notes (descriptive note attached to a ticket)")]
    public bool EnableNotes;
    [JsonProperty("Tickets require note (tickets won't be issued without a note)")]
    public bool RequireNote;
    [JsonProperty("Maximum note length (0 = unlimited)")]
    public int MaxNoteLength;
    [JsonProperty("Maximum distance in which you are able to demand a ticket (0 = unlimited)")]
    public int MaxDemandDistance;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class StoredData
{
    public Dictionary<string, List<Ticket>> Tickets;
    public StoredData();
}

private class Ticket
{
    public static uint CurrentID;
    public uint TicketID { get; set; }
    public string IssuerID { get; set; }
    public string ReceiverID { get; set; }
    public double Fine { get; set; }
    public string Note { get; set; }
    public bool IsClosed { get; set; }
    public string ClosedBy { get; set; }
    public DateTime IssueDate { get; set; }
    public DateTime CloseDate { get; set; }
    [JsonConstructor]
    public Ticket(uint ticketID, string issuerID, string receiverID, double fine, DateTime issueDate, string note, bool isClosed, string closedBy, DateTime? closeDate);
    public Ticket(string issuerID, string receiverID, double fine, string note);
    public Dictionary<string, object> ToDictionary();
}


```

---

## Tickets by LaserHydra - Allows players to send tickets to admin

```csharp
using Oxide.Plugins.TicketsExtensions;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Reflection;
using System.Linq;
using Oxide.Core;
using System;

Oxide.Plugins
[Info("Tickets", "LaserHydra", "3.1.3")]
[Description("Allows players to send tickets to admin")]
public class Tickets : CovalencePlugin
{
    [PluginReference]
    private Plugin Slack;
    private Plugin PushAPI;
    private Plugin EmailAPI;
    public static Tickets Instance;
    public string ChatTitle;
    public string SlackChannel;
    public bool UseSlack;
    public bool UseEmailAPI;
    public bool UsePushAPI;
    public bool NotifyReply;
    public bool NotifyCreated;
    public bool NotifyClosed;
    public bool NotifyWiped;
    public string OpenStatus;
    public string ClosedStatus;
    [AttributeUsage(AttributeTargets.Method)]
    private class CommandInfo : Attribute
    {
        protected string[] Commands;
        public static string[] GetCommands(IPlayer player, MethodBase method);
        public CommandInfo(string[] commands);
    }

    private class AdminCommandInfo : CommandInfo
    {
        public AdminCommandInfo(string[] commands);
    }

    private class Ticket
    {
        public static List<Ticket> All;
        public static List<Ticket> Unread { get; set; }
        public static List<Ticket> GetPlayerTickets(IPlayer player);
        public static List<Ticket> GetOpenTickets();
        public static List<Ticket> GetClosedTickets();
        public int ID;
        public bool Closed;
        public bool Read;
        public AuthorInfo Creator;
        public Position Position;
        public List<Reply> Replies;
        internal string FormattedReplies { get; set; }
        public static int LastID { get; set; }
        public static Ticket Find(int id);
        public static Ticket Find(IPlayer player, int id);
        public static Ticket Create(IPlayer player, string message);
        public void Reply(IPlayer player, string message, bool justCreated);
        public void Close(IPlayer player);
        public string InsertDataToString(string str);
        public static void Updated();
        public Ticket();
        public Ticket(IPlayer player);
    }

    private class Position
    {
        public float X;
        public float Y;
        public float Z;
        public GenericPosition ToGeneric();
        public static Position FromGeneric(GenericPosition genericPosition);
    }

    private class Date
    {
        public int Second;
        public int Minute;
        public int Hour;
        public int Day;
        public int Month;
        public int Year;
        internal DateTime DateTime { get; set; }
        internal static Date Now { get; set; }
        internal static Date FromDateTime(DateTime dateTime);
        public override string ToString();
    }

    private void Loaded();
    private void OnTicketReplied(Ticket ticket, Reply reply);
    private void OnTicketCreated(Ticket ticket, Reply reply);
    private void OnTicketClosed(Ticket ticket, IPlayer player);
    protected override void LoadDefaultConfig();
    private new void LoadConfig();
    private void LoadMessages();
    [Command("ticket"),
         CommandInfo("view <ID> | view ticket", "create <Message> | write a new ticket", "reply <ID> <Message> | reply to a ticket", "list | list tickets"),
         AdminCommandInfo("listclosed | list closed tickets", "close <ID> | close a ticket", "teleport <ID> | teleport to a ticket's source position")]
    private void ticketCmd(IPlayer player, string cmd, string[] args);
    public static string StripTags(string original);
    public static string FormatText(string original);
    private string LangMsg(string key, string id);
    private string GetCommandInfo(IPlayer player, string command);
    private static void Notify(string message);
    private static void MessageAdmins(string message);
    private static void MessageOther(string message);
    private T GetConfig(object[] pathAndValue);
    private string DataFileName { get; set; }
    private void LoadData(T data, string filename);
    private void SaveData(T data, string filename);
}

[AttributeUsage(AttributeTargets.Method)]
private class CommandInfo : Attribute
{
    protected string[] Commands;
    public static string[] GetCommands(IPlayer player, MethodBase method);
    public CommandInfo(string[] commands);
}

private class AdminCommandInfo : CommandInfo
{
    public AdminCommandInfo(string[] commands);
}

private class Ticket
{
    public static List<Ticket> All;
    public static List<Ticket> Unread { get; set; }
    public static List<Ticket> GetPlayerTickets(IPlayer player);
    public static List<Ticket> GetOpenTickets();
    public static List<Ticket> GetClosedTickets();
    public int ID;
    public bool Closed;
    public bool Read;
    public AuthorInfo Creator;
    public Position Position;
    public List<Reply> Replies;
    internal string FormattedReplies { get; set; }
    public static int LastID { get; set; }
    public static Ticket Find(int id);
    public static Ticket Find(IPlayer player, int id);
    public static Ticket Create(IPlayer player, string message);
    public void Reply(IPlayer player, string message, bool justCreated);
    public void Close(IPlayer player);
    public string InsertDataToString(string str);
    public static void Updated();
    public Ticket();
    public Ticket(IPlayer player);
}

private class Position
{
    public float X;
    public float Y;
    public float Z;
    public GenericPosition ToGeneric();
    public static Position FromGeneric(GenericPosition genericPosition);
}

private class Date
{
    public int Second;
    public int Minute;
    public int Hour;
    public int Day;
    public int Month;
    public int Year;
    internal DateTime DateTime { get; set; }
    internal static Date Now { get; set; }
    internal static Date FromDateTime(DateTime dateTime);
    public override string ToString();
}

Oxide.Plugins.TicketsExtensions
internal static class Extend
{
    public static void ReplySafe(IPlayer player, string message);
}


```

---

## TickrateLimiter by 2CHEVSKII - Limits current maximum tickrate based on player count to improve overall server performance

```csharp
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Tickrate Limiter", "2CHEVSKII", "0.1.2")]
[Description("Limits current maximum tickrate based on player count to improve overall performance")]
internal class TickrateLimiter : CovalencePlugin
{
    private int _defaultClValue;
    private int _defaultSvValue;
    private Dictionary<int, TickrateValues> TickrateCurve { get; set; }
    private Dictionary<int, TickrateValues> GetDefaultCurve { get; set; }
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void OnPlayerConnected();
    private void OnPlayerDisconnected();
    private void Unload();
    private void OnPlayerCountUpdate();
    private class TickrateValues
    {
        public readonly int Client;
        public readonly int Server;
        public TickrateValues(int server, int client);
    }

}

private class TickrateValues
{
    public readonly int Client;
    public readonly int Server;
    public TickrateValues(int server, int client);
}


```

---

## Tides by regr3tti - Brings realistic high and low tides to your server's ocean

```csharp
using System;
using ConVar;
using System.Collections.Generic;
using Random = System.Random;

Oxide.Plugins
[Info("Tides", "Regr3tti", "0.1.7")]
[Description("Adds natural tides to rust")]
public class Tides : RustPlugin
{
     bool debug;
     bool storms;
     bool currentstorm;
     Timer stormTimer;
     string variance;
     double amt_variance;
     float variance_max;
     float variance_min;
     float tideheight_raw;
     float Tideheight_plus(float variance_low, float variance_high);
     float period;
     float offset;
     float tideamplitude;
     float stormtideheight;
     float stormchance;
    private bool Changed;
     float refresh;
     Random random;
     float GetOceanLevel(float tideheight, float period, float offset);
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
     void Init();
     void OnServerInitialized();
     void OceanLevelUpdater();
     void CheckForLowTide();
     void DestroyTimer(Timer timer);
     void ChanceOfStorm();
     void ChangeHighTide();
     float GetHighTide(float period, float tideamplitude, float occurance);
     void CheckVariance();
     void SetVariance();
     void CreateStorms();
}


```

---

## TimedCommandBlocker by MONaH - Block player commands temporarily or permanently

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Text;
using System;
using UnityEngine;

Oxide.Plugins
[Info("Timed Command Blocker", "MON@H", "1.3.1")]
[Description("Block commands temporarily or permanently")]
public class TimedCommandBlocker : RustPlugin
{
    private const string PermissionUse;
    private const string PermissionImmunity;
    private readonly List<BlockedCommand> _blockedCommands;
    private readonly StringBuilder _sb;
    private class BlockedCommand
    {
        public string Command { get; set; }
        public double BlockDuration { get; set; }
        public TimeSpan GetTimeUntilUnlock();
    }

    private void Init();
    private void OnServerInitialized();
    private ConfigData _configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Enable logging")]
        public bool LoggingEnabled;
        [JsonProperty(PropertyName = "Chat steamID icon")]
        public ulong SteamIDIcon;
        [JsonProperty(PropertyName = "Сommand color")]
        public string ChatCommandColor;
        [JsonProperty(PropertyName = "Remaining blocking time color")]
        public string ChatCommandArgumentColor;
        [JsonProperty(PropertyName = "Blocked commands (command: seconds)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<BlockedCommand> BlockedCommands;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private string Lang(string key, string userIDString, object[] args);
    private static class LangKeys
    {
        public static class Format
        {
            private const string Base;
            public const string Days;
            public const string Hours;
            public const string Minutes;
            public const string Day;
            public const string Hour;
            public const string Minute;
            public const string Prefix;
            public const string Second;
            public const string Seconds;
        }

        public static class Info
        {
            private const string Base;
            public const string Blocked;
            public const string Timed;
        }

    }

    protected override void LoadDefaultMessages();
    private object OnPlayerCommand(BasePlayer player, string command, string[] args);
    private object OnServerCommand(ConsoleSystem.Arg arg);
    private object HandleCommand(BasePlayer player, string command);
    private void UnsubscribeHooks();
    private void SubscribeHooks();
    private string GetFormattedDurationTime(TimeSpan time, string id);
    private void BuildTime(StringBuilder sb, string lang, string playerId, int value);
    private void PlayerSendMessage(BasePlayer player, string message);
    private void Log(string text);
}

private class BlockedCommand
{
    public string Command { get; set; }
    public double BlockDuration { get; set; }
    public TimeSpan GetTimeUntilUnlock();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Enable logging")]
    public bool LoggingEnabled;
    [JsonProperty(PropertyName = "Chat steamID icon")]
    public ulong SteamIDIcon;
    [JsonProperty(PropertyName = "Сommand color")]
    public string ChatCommandColor;
    [JsonProperty(PropertyName = "Remaining blocking time color")]
    public string ChatCommandArgumentColor;
    [JsonProperty(PropertyName = "Blocked commands (command: seconds)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<BlockedCommand> BlockedCommands;
}

private static class LangKeys
{
    public static class Format
    {
        private const string Base;
        public const string Days;
        public const string Hours;
        public const string Minutes;
        public const string Day;
        public const string Hour;
        public const string Minute;
        public const string Prefix;
        public const string Second;
        public const string Seconds;
    }

    public static class Info
    {
        private const string Base;
        public const string Blocked;
        public const string Timed;
    }

}

public static class Format
{
    private const string Base;
    public const string Days;
    public const string Hours;
    public const string Minutes;
    public const string Day;
    public const string Hour;
    public const string Minute;
    public const string Prefix;
    public const string Second;
    public const string Seconds;
}

public static class Info
{
    private const string Base;
    public const string Blocked;
    public const string Timed;
}


```

---

## TimedEvents by Mevent - Triggers various types of events like Airdrops, Helicopters and same

```csharp
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Timed Events", "Orange", "1.1.5")]
[Description("Triggers various types of events like Airdrops, Helicopters and same")]
public class TimedEvents : RustPlugin
{
    private const string prefabCH47;
    private const string prefabPlane;
    private const string prefabShip;
    private const string prefabPatrol;
    private void OnServerInitialized();
    private object OnEventTrigger(TriggeredEventPrefab info);
    private void SpawnTank(bool skipSpawn);
    private void SpawnShip(bool skipSpawn);
    private void SpawnPatrol(bool skipSpawn);
    private void SpawnPlane(bool skipSpawn);
    private void SpawnCH47(bool skipSpawn);
    private int Online();
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "1. Cargo plane settings:")]
        public EventSettings plane;
        [JsonProperty(PropertyName = "2. Patrol Helicopter settings:")]
        public EventSettings patrol;
        [JsonProperty(PropertyName = "3. Bradley APC settings:")]
        public EventSettings tank;
        [JsonProperty(PropertyName = "4. CH47 settings:")]
        public EventSettings ch47;
        [JsonProperty(PropertyName = "5. Cargo ship settings:")]
        public EventSettings ship;
    }

    private class EventSettings
    {
        [JsonProperty(PropertyName = "1. Disable default spawns")]
        public bool disableDefault;
        [JsonProperty(PropertyName = "2. Minimal respawn time (in seconds)")]
        public int timerMin;
        [JsonProperty(PropertyName = "3. Maximal respawn time (in seconds)")]
        public int timerMax;
        [JsonProperty(PropertyName = "4. Minimal amount that spawned by once")]
        public int spawnMin;
        [JsonProperty(PropertyName = "5. Maximal amount that spawned by once")]
        public int spawnMax;
        [JsonProperty(PropertyName = "6. Minimal players to start event")]
        public int playersMin;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "1. Cargo plane settings:")]
    public EventSettings plane;
    [JsonProperty(PropertyName = "2. Patrol Helicopter settings:")]
    public EventSettings patrol;
    [JsonProperty(PropertyName = "3. Bradley APC settings:")]
    public EventSettings tank;
    [JsonProperty(PropertyName = "4. CH47 settings:")]
    public EventSettings ch47;
    [JsonProperty(PropertyName = "5. Cargo ship settings:")]
    public EventSettings ship;
}

private class EventSettings
{
    [JsonProperty(PropertyName = "1. Disable default spawns")]
    public bool disableDefault;
    [JsonProperty(PropertyName = "2. Minimal respawn time (in seconds)")]
    public int timerMin;
    [JsonProperty(PropertyName = "3. Maximal respawn time (in seconds)")]
    public int timerMax;
    [JsonProperty(PropertyName = "4. Minimal amount that spawned by once")]
    public int spawnMin;
    [JsonProperty(PropertyName = "5. Maximal amount that spawned by once")]
    public int spawnMax;
    [JsonProperty(PropertyName = "6. Minimal players to start event")]
    public int playersMin;
}


```

---

## TimedExecute by misticos - Executes commands every (x) seconds

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Timed Execute", "PaiN & misticos", "0.7.4")]
[Description("Execute commands every (x) seconds.")]
 class TimedExecute : CovalencePlugin
{
    public static TimedExecute Plugin;
     Timer ptimer;
     class Timers
    {
        public static List<Timer> AllTimers;
        public static Timer InGame;
        public static Timer Real;
        public static Timer Repeat;
        public static Timer Once;
        public static void ResetTimer(Types type);
        public static void RunTimer(Types type);
        public static void DestroyAll();
        public static void RunAll();
    }

     void OnServerInitialized();
     void Unload();
     Dictionary<string, object> repeatcmds;
     Dictionary<string, object> chaincmds;
     Dictionary<string, object> realtimecmds;
     Dictionary<string, object> ingamecmds;
    protected override void LoadDefaultConfig();
    [Command("reset.timeronce", "resettimeronce")]
     void cmdReset(IPlayer player, string cmd, string[] args);
}

 class Timers
{
    public static List<Timer> AllTimers;
    public static Timer InGame;
    public static Timer Real;
    public static Timer Repeat;
    public static Timer Once;
    public static void ResetTimer(Types type);
    public static void RunTimer(Types type);
    public static void DestroyAll();
    public static void RunAll();
}


```

---

## TimedPermissions by LaserHydra - Allows you to grant permissions or groups for a specific time

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text.RegularExpressions;
using System;

Oxide.Plugins
[Info("Timed Permissions", "LaserHydra", "1.6.0")]
[Description("Allows you to grant permissions or groups for a specific time")]
 class TimedPermissions : CovalencePlugin
{
    private const string AdminPermission;
    private const string AdvancedAdminPermission;
    private static TimedPermissions _plugin;
    private static List<PlayerInformation> _playerInformationCollection;
    private Regex _timeSpanPattern;
    private Configuration _config;
    private void Loaded();
    private void OnUserConnected(IPlayer player);
    private void OnNewSave(string filename);
    [Command("pinfo")]
    private void CmdPlayerInfo(IPlayer player, string cmd, string[] args);
    [Command("grantperm"), Permission(AdminPermission)]
    private void CmdGrantPerm(IPlayer player, string cmd, string[] args);
    [Command("revokeperm"), Permission(AdminPermission)]
    private void CmdRevokePerm(IPlayer player, string cmd, string[] args);
    [Command("addgroup"), Permission(AdminPermission)]
    private void CmdAddGroup(IPlayer player, string cmd, string[] args);
    [Command("removegroup"), Permission(AdminPermission)]
    private void CmdRemoveGroup(IPlayer player, string cmd, string[] args);
    [Command("timedpermissions_resetaccess"), Permission(AdvancedAdminPermission)]
    private void CmdResetAccess(IPlayer player, string cmd, string[] args);
    private void ResetAllAccess(string backupFileName);
    private bool TryParseTimeSpan(string source, TimeSpan date);
    private IPlayer FindPlayer(string nameOrId, IPlayer player);
    private static bool IsConvertibleTo(object obj);
    private static void LoadData(T data, string filename);
    private static void SaveData(T data, string filename);
    public static string GetMessage(string key, string id);
    protected override void LoadDefaultMessages();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class Configuration
    {
        [JsonProperty("Wipe Data on New Save (Limited to Certain Games)")]
        public bool WipeDataOnNewSave { get; set; }
    }

    private class PlayerInformation
    {
        [JsonProperty("Id")]
        public string Id { get; set; }
        [JsonProperty("Name")]
        public string Name { get; set; }
        [JsonProperty("Permissions")]
        private readonly List<ExpiringAccessValue> _permissions;
        [JsonProperty("Groups")]
        private readonly List<ExpiringAccessValue> _groups;
        [JsonIgnore]
        public ReadOnlyCollection<ExpiringAccessValue> Permissions { get; set; }
        [JsonIgnore]
        public ReadOnlyCollection<ExpiringAccessValue> Groups { get; set; }
        public static PlayerInformation Get(string id);
        public static PlayerInformation GetOrCreate(IPlayer player);
        public void AddPermission(string permission, DateTime expireDate);
        public void RemovePermission(string permission);
        public void AddGroup(string group, DateTime expireDate);
        public void RemoveGroup(string group);
        public void RemoveAllAccess();
        public void EnsureAllAccess();
        public void Update();
        public override int GetHashCode();
        private PlayerInformation(IPlayer player);
        [JsonConstructor]
        private PlayerInformation();
    }

    private class ExpiringAccessValue
    {
        [JsonProperty]
        public string Value { get; set; }
        [JsonProperty]
        public DateTime ExpireDate { get; set; }
        [JsonIgnore]
        public bool IsExpired { get; set; }
        public override int GetHashCode();
        public ExpiringAccessValue(string value, DateTime expireDate);
        public ExpiringAccessValue();
    }

}

private class Configuration
{
    [JsonProperty("Wipe Data on New Save (Limited to Certain Games)")]
    public bool WipeDataOnNewSave { get; set; }
}

private class PlayerInformation
{
    [JsonProperty("Id")]
    public string Id { get; set; }
    [JsonProperty("Name")]
    public string Name { get; set; }
    [JsonProperty("Permissions")]
    private readonly List<ExpiringAccessValue> _permissions;
    [JsonProperty("Groups")]
    private readonly List<ExpiringAccessValue> _groups;
    [JsonIgnore]
    public ReadOnlyCollection<ExpiringAccessValue> Permissions { get; set; }
    [JsonIgnore]
    public ReadOnlyCollection<ExpiringAccessValue> Groups { get; set; }
    public static PlayerInformation Get(string id);
    public static PlayerInformation GetOrCreate(IPlayer player);
    public void AddPermission(string permission, DateTime expireDate);
    public void RemovePermission(string permission);
    public void AddGroup(string group, DateTime expireDate);
    public void RemoveGroup(string group);
    public void RemoveAllAccess();
    public void EnsureAllAccess();
    public void Update();
    public override int GetHashCode();
    private PlayerInformation(IPlayer player);
    [JsonConstructor]
    private PlayerInformation();
}

private class ExpiringAccessValue
{
    [JsonProperty]
    public string Value { get; set; }
    [JsonProperty]
    public DateTime ExpireDate { get; set; }
    [JsonIgnore]
    public bool IsExpired { get; set; }
    public override int GetHashCode();
    public ExpiringAccessValue(string value, DateTime expireDate);
    public ExpiringAccessValue();
}


```

---

## TimedProgression by mothball187 - Restricts configured weapons, armor, and items and unlocks them over configured intervals of time

```csharp
using Rust;
using Facepunch.Extend;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System;
using System.Globalization;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Linq;
using System.ComponentModel;
using ProtoBuf;
using Random = System.Random;
using Oxide.Core.Libraries.Covalence;
using System.Text;

Oxide.Plugins
[Info("Timed Progression", "mothball187", "0.1.2")]
[Description("Restricts crafting and looting of items based on configurable tiers, unlocked over configurable time periods")]
 class TimedProgression : CovalencePlugin
{
    [PluginReference]
    private Plugin DiscordCore;
    private Plugin GUIAnnouncements;
    private DynamicConfigFile timeData;
    private DynamicConfigFile items;
     Random rnd;
    private PluginConfig config;
    private DateTime wipeStart;
    [Command("checkphase")]
    private void CheckPhase(IPlayer player, string command, string[] args);
    [Command("listitems")]
    private void ListItemsCmd(IPlayer player, string command, string[] args);
    [Command("timedprogression.setthreshold")]
    private void SetThreshold(IPlayer player, string command, string[] args);
    [Command("timedprogression.setphase")]
    private void SetPhase(IPlayer player, string command, string[] args);
    [Command("timedprogression.setwipetime")]
    private void SetWipeTime(IPlayer player, string command, string[] args);
     class PluginConfig
    {
        public List<long> thresholds;
        public string botChannel;
    }

    protected void LoadDefaultItemsConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnNewSave(string filename);
    private void OnLootEntity(BasePlayer player, BaseEntity entity);
    private void NotifyPlayer(ItemDefinition itemdef, BasePlayer player);
    private ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos);
    private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount);
    private void NotifyPhaseInfo(IPlayer player);
    private object OnVendingTransaction(VendingMachine machine, BasePlayer buyer, int sellOrderId, int numberOfTransactions);
    private void OnPlayerConnected(BasePlayer player);
    private void OnServerInitialized();
    private void BuildPhaseItemsStrings(Dictionary<string, object> catItems, Dictionary<int, StringBuilder> phaseItems);
    private void ListItems(IPlayer player, string channelId);
    private void SendMessage(string channelId, string message);
    private object HandleListItems(IPlayer player, string channelId, string cmd, string[] args);
    private void OnDiscordCoreReady();
    private string FormatTimeSpan(long minutes);
    private bool ItemIsHeavyAmmo(ItemDefinition itemdef);
    private string GetCategoryString(ItemDefinition itemdef);
    private bool CanHaveItem(ItemDefinition itemdef);
    private void DestroyItem(Item item);
    private Item ReplaceItem(ItemDefinition itemdef, int amount);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private void UpdateContainer(BaseEntity container);
    private void FixHeavyAmmoCategory();
    protected override void LoadConfig();
    private void Init();
    private void UpdateLoop();
    private void Unload();
    private void OnServerSave();
    private void NotifyPhaseChange();
    private void RefreshVendingMachines();
    private void MyInstallFromVendingOrders(NPCVendingMachine machine);
}

 class PluginConfig
{
    public List<long> thresholds;
    public string botChannel;
}


```

---

## TimedWorkbench by DizzasTeR - Allows higher tier workbenches (level 2 and level 3) to be unlocked later in the wipe

```csharp
using Oxide.Core;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using System;
using System.IO;
using System.Diagnostics;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

Oxide.Plugins
[Info("Timed Workbench", "DizzasTeR", "1.0.4")]
[Description("Unlocks Workbenches level 2 and 3 later in the wipe")]
 class TimedWorkbench : CovalencePlugin
{
    private Configuration config;
    private Timer timer_WB2;
    private Timer timer_WB3;
    private long ID_WORKBENCH_LEVEL_2;
    private long ID_WORKBENCH_LEVEL_3;
    private string PERMISSION_ADMIN;
    private string PERMISSION_SKIPLOCK;
    private string PERMISSION_INFO;
    private string PERMISSION_TOGGLE;
    private string PERMISSION_MODIFY;
    private string PERMISSION_RELOAD;
    private string PERMISSION_WIPE;
    private new void LoadDefaultMessages();
    private void SendMessage(IPlayer player, string langCode, string[] args);
    private void Init();
    private void OnNewSave(string filename);
    private bool CanCraft(PlayerBlueprints playerBlueprints, ItemDefinition itemDefinition, int skinItemId);
    [Command("twinfo")]
    private void CMD_PassiveBenchInfo(IPlayer player, string command, string[] args);
    [Command("twtoggle")]
    private void CMD_Toggle(IPlayer player, string command, string[] args);
    [Command("setwbtime")]
    private void CMD_SetWBTime(IPlayer player, string command, string[] args);
    [Command("twreload")]
    private void CMD_Reload(IPlayer player, string command, string[] args);
    [Command("twwipe")]
    private void CMD_Wiped(IPlayer player, string command, string[] args);
    public class Configuration
    {
        [JsonProperty(PropertyName = "Timed Mode")]
        public bool TimedMode { get; set; }
        [JsonProperty(PropertyName = "Last Wipe")]
        public DateTime LastWipe { get; set; }
        [JsonProperty(PropertyName = "How many seconds after wipe to unlock WB2")]
        public long WB2Seconds { get; set; }
        [JsonProperty(PropertyName = "How many seconds after wipe to unlock WB3")]
        public long WB3Seconds { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class Configuration
{
    [JsonProperty(PropertyName = "Timed Mode")]
    public bool TimedMode { get; set; }
    [JsonProperty(PropertyName = "Last Wipe")]
    public DateTime LastWipe { get; set; }
    [JsonProperty(PropertyName = "How many seconds after wipe to unlock WB2")]
    public long WB2Seconds { get; set; }
    [JsonProperty(PropertyName = "How many seconds after wipe to unlock WB3")]
    public long WB3Seconds { get; set; }
}


```

---

## TimedWorkbenchUnlock by HunterZ - Provides timed/manual/disabled unlocking of workbenches

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

Oxide.Plugins
[Info("Timed Workbench Unlock", "HunterZ", "2.3.0")]
[Description("Provides timed/manual/disabled unlocking of workbenches")]
 class TimedWorkbenchUnlock : RustPlugin
{
    private static readonly int[] _WORKBENCH_ID;
    private Timer _broadcastTimer;
    private ConfigData _configData;
    private readonly Dictionary<ulong, Timer> _craftWarned;
    private readonly StringBuilder _statusBuilder;
    private readonly Timer[] _unlockTimers;
    private const string PERMISSION_ADMIN;
    private const string PERMISSION_BROADCAST;
    private const string PERMISSION_INFO;
    private const string PERMISSION_MODIFY;
    private const string PERMISSION_RELOAD;
    private const string PERMISSION_RESET;
    private const string PERMISSION_SKIPLOCK;
    private const string PERMISSION_WIPE;
    private double GetWipeElapsedSeconds(double wipeElapsedSeconds);
    private int GetUnlockStatus(int index, double wipeElapsedSeconds);
    private int[] GetUnlockStatus();
    private Timer GetTimer(int index, double wipeElapsedSeconds);
    private void DestroyBroadcastTimer();
    private void SetBroadcastTimer();
    private void DestroyUnlockTimers();
    private void SetUnlockTimers();
    private void DestroyWarnTimer(ulong userId);
    private string UnlockStatusString(int status, IPlayer player);
    private bool HasPermission(IPlayer player, string perm);
    private string PrefixPermission(string perm);
    private void ReportStatus(IPlayer player);
    private void ReportUnlock(int index);
    private bool AllowCraftAttempt(BasePlayer player, int itemid);
    private void WarnChat(BasePlayer player, string timeString);
    private static void WarnSound(BasePlayer player);
    private void WarnToast(BasePlayer player, string timeString);
    protected override void LoadDefaultMessages();
    private string FormatMessage(IPlayer player, string langCode, string[] args);
    private void SendRawMessage(IPlayer player, string message);
    private void SendMessage(IPlayer player, string langCode, string[] args);
    private void SendToast(IPlayer player, string langCode, string[] args);
    private static string Colorize(string str, string color);
    protected void Init();
    protected void Unload();
    private object CanCraft(PlayerBlueprints playerBlueprints, ItemDefinition itemDefinition);
    private object CanResearchItem(BasePlayer player, Item item);
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void CommandBroadcast(IPlayer player, string command, string[] args);
    private void CommandInfo(IPlayer player);
    private void CommandModify(IPlayer player, string command, string[] args);
    private void CommandReload(IPlayer player);
    private void CommandReset(IPlayer player);
    private void CommandWipe(IPlayer player);
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private sealed class ConfigData
    {
        [JsonIgnore]
        public static readonly int[] _DEFAULT_WB_SECONDS;
        [JsonProperty(PropertyName = "Global status broadcast interval in seconds (0 to disable)")]
        public int BroadcastConfig { get; set; }
        [JsonProperty(PropertyName = "Time that current wipe started (UTC)")]
        public DateTime LastWipeUTC { get; set; }
        [JsonProperty(PropertyName = "Workbench unlock times (seconds from start of wipe, or 0 for unlocked, or -1 for permanently locked)")]
        public int[] WBConfig { get; set; }
        [JsonProperty(PropertyName = "Block crafting of locked workbench(es)")]
        public bool BlockCraft;
        [JsonProperty(PropertyName = "Block researching of locked workbench(es)")]
        public bool BlockResearch;
        [JsonProperty(PropertyName = "Report craft failure as chat message")]
        public bool ReportAsChat;
        [JsonProperty(PropertyName = "Report craft failure as sound effect")]
        public bool ReportAsSound;
        [JsonProperty(PropertyName = "Report craft failure as toast message")]
        public bool ReportAsToast;
    }

}

private sealed class ConfigData
{
    [JsonIgnore]
    public static readonly int[] _DEFAULT_WB_SECONDS;
    [JsonProperty(PropertyName = "Global status broadcast interval in seconds (0 to disable)")]
    public int BroadcastConfig { get; set; }
    [JsonProperty(PropertyName = "Time that current wipe started (UTC)")]
    public DateTime LastWipeUTC { get; set; }
    [JsonProperty(PropertyName = "Workbench unlock times (seconds from start of wipe, or 0 for unlocked, or -1 for permanently locked)")]
    public int[] WBConfig { get; set; }
    [JsonProperty(PropertyName = "Block crafting of locked workbench(es)")]
    public bool BlockCraft;
    [JsonProperty(PropertyName = "Block researching of locked workbench(es)")]
    public bool BlockResearch;
    [JsonProperty(PropertyName = "Report craft failure as chat message")]
    public bool ReportAsChat;
    [JsonProperty(PropertyName = "Report craft failure as sound effect")]
    public bool ReportAsSound;
    [JsonProperty(PropertyName = "Report craft failure as toast message")]
    public bool ReportAsToast;
}


```

---

## TimeOfDay by misticos - Alters the day and night duration

```csharp
using Oxide.Core.Plugins;
using Oxide.Core;
using System;
using System.Text;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

Oxide.Plugins
[Info("TimeOfDay", "FuJiCuRa", "2.3.4")]
[Description("Does alter day and night duration.")]
public class TimeOfDay : RustPlugin
{
     bool Changed;
     bool Initialized;
     int componentSearchAttempts;
     TOD_Time timeComponent;
     bool activatedDay;
     int authLevelCmds;
     int authLevelFreeze;
     int dayLength;
     int nightLength;
     int presetDay;
     int presetMonth;
     int presetYear;
     bool setPresetDate;
     bool freezeDate;
     bool autoSkipNight;
     bool autoSkipDay;
     bool logAutoSkipConsole;
     bool freezeTimeOnload;
     float timeToFreeze;
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
     void Loaded();
     void Unload();
     void OnServerInitialized();
     void SetTimeComponent();
     void StartupFreeze();
     void OnDay();
     void OnHour();
     void OnSunrise();
     void OnSunset();
    [ConsoleCommand("tod.daylength")]
     void ConsoleDayLength(ConsoleSystem.Arg arg);
    [ConsoleCommand("tod.nightlength")]
     void ConsoleNightLength(ConsoleSystem.Arg arg);
    [ConsoleCommand("tod.freezetime")]
     void ConsoleFreezeTime(ConsoleSystem.Arg arg);
    [ConsoleCommand("tod.skipday")]
     void ConsoleSkipDay(ConsoleSystem.Arg arg);
    [ConsoleCommand("tod.skipnight")]
     void ConsoleSkipNight(ConsoleSystem.Arg arg);
    [ChatCommand("tod")]
    private void TodCommand(BasePlayer player, string command, string[] args);
    [HookMethod("SendHelpText")]
    private void SendHelpText(BasePlayer player);
    private void PrintPluginMessageToChat(BasePlayer player, string message);
    private void PrintPluginMessageToChat(string message);
    private string FormNeutralMessage(string message);
}


```

---

## Tip4serv by Tip4Serv - Tip4Serv is a donation web store that sends in-game orders with RCON commands

```csharp
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using Oxide.Core.Libraries;
using System;
using System.Text;
using System.Security.Cryptography;

Oxide.Plugins
[Info("Tip4serv", "Murgator & Duster", "1.4.8")]
[Description("Allows Admin to monetize their 7 Days to die & Rust server from their Tip4serv store")]
public class Tip4serv : CovalencePlugin
{
    private class PluginConfig
    {
        public int request_interval_in_minutes;
        public string configkey;
        public string order_received_text;
    }

    [Serializable]
    public class ResponseData
    {
        public string date;
        public string action;
        public Dictionary<int, int> cmds;
        public int status;
        public string username;
    }

    [Serializable]
    public class Payments
    {
        public string player;
        public string action;
        public string id;
        public string steamid;
        public PaymentCmd[] cmds;
    }

    [Serializable]
    public class PaymentCmd
    {
        public string str;
        public int id;
        public int state;
    }

    private String key_msg;
    private bool Stopped;
    private Timer PaymentTimer;
    private PluginConfig config;
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    private Dictionary<String,IPlayer> GetPlayers();
    private void Loaded();
    private void Unload();
     void OnServerInitialized();
    private void PaymentChecker();
    private string GetUnixTime();
    private void Tip4Print(string content);
    private void check_pending_commands(string[] key_parts, string timestamp, string get_cmd);
    private Dictionary<string, ResponseData> LoadFile(string path);
    private string calculateHMAC(string[] key_parts, string timestamp);
    private IPlayer checkifPlayerIsLoaded(string steam_id, Dictionary<string,IPlayer> players);
    private void exe_command(string cmd, string[] CmdArgs);
}

private class PluginConfig
{
    public int request_interval_in_minutes;
    public string configkey;
    public string order_received_text;
}

[Serializable]
public class ResponseData
{
    public string date;
    public string action;
    public Dictionary<int, int> cmds;
    public int status;
    public string username;
}

[Serializable]
public class Payments
{
    public string player;
    public string action;
    public string id;
    public string steamid;
    public PaymentCmd[] cmds;
}

[Serializable]
public class PaymentCmd
{
    public string str;
    public int id;
    public int state;
}


```

---

## ToggleConVar by birthdates - Toggle ConVars between two values

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Toggle ConVar", "birthdates", "1.0.3")]
[Description("Toggle ConVars between two values")]
public class ToggleConVar : RustPlugin
{
    private const string UsePermission;
    private void Init();
    private readonly IDictionary<ulong, Timer> _timers;
    private void Reply(ConsoleSystem.Arg arg, string msg, bool error);
    [ConsoleCommand("server.toggle")]
    private void ToggleCommand(ConsoleSystem.Arg arg);
    private static ConsoleSystem.Arg RunSilentCommand(string strCommand, object[] args);
    private static void ShowGameTip(BasePlayer player, string msg, bool error);
    private void HideGameTipLater(BasePlayer player, float time);
    private static void HideGameTip(BasePlayer player);
    private ConfigFile _config;
    public class ConfigFile
    {
        [JsonProperty("Reply with Game Tips")]
        public bool ReplyWithGameTips { get; set; }
        [JsonProperty("Game Tip Time")]
        public float GameTipTime { get; set; }
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class ConfigFile
{
    [JsonProperty("Reply with Game Tips")]
    public bool ReplyWithGameTips { get; set; }
    [JsonProperty("Game Tip Time")]
    public float GameTipTime { get; set; }
    public static ConfigFile DefaultConfig();
}


```

---

## ToggleNoggin by CARNY666 - Bindable console command to spawn, equip and ignite a candle hat or miners hat.

```csharp
using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("ToggleNoggin", "carny666", "1.0.4", ResourceId = 2725)]
 class ToggleNoggin : RustPlugin
{
    const string adminPermission;
    const string candlePermission;
    const string minersPermission;
    static string lastHat;
     void Init();
    [ConsoleCommand("togglenoggin")]
     void ccToggleNoggin(ConsoleSystem.Arg arg);
    [ChatCommand("togglenoggin")]
     void chcToggleNoggin(BasePlayer player, string command, string[] args);
     void ToggleHat(BasePlayer player, string hatItemName);
}


```

---

## TollButtons by KajWithAJ - Make players pay toll to press a button using their RP points

```csharp
using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Toll Buttons", "KajWithAJ", "0.3.0")]
[Description("Make players pay toll to press a button using their RP points.")]
 class TollButtons : RustPlugin
{
    [PluginReference]
    private readonly Plugin Economics;
    private readonly Plugin ServerRewards;
    private const string PermissionUse;
    private const string PermissionAdmin;
    private const string PermissionExclude;
    private StoredData storedData;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    [ChatCommand("toll")]
    private void ChatCmdCheckButton(BasePlayer player, string command, string[] args);
    private object OnButtonPress(PressButton button, BasePlayer player);
    private int CheckButtonCost(PressButton button);
    private void Transfer(string beneficiary, string valuta, int amount);
    private bool TryPay(BasePlayer player, string valuta, int price);
    private bool CanPay(BasePlayer player, string valuta, int cost);
    private int CheckBalance(string valuta, int price, ulong playerId);
    private class StoredData
    {
        public readonly Dictionary<ulong, ButtonData> TollButtons;
    }

    private class ButtonData
    {
        public int cost;
        public string ownerID;
    }

    private void LoadData();
    private void SaveData();
    private void OnServerSave();
    private void OnNewSave(string name);
}

private class StoredData
{
    public readonly Dictionary<ulong, ButtonData> TollButtons;
}

private class ButtonData
{
    public int cost;
    public string ownerID;
}


```

---

## ToolBlocker by  - Blocks the use of certain tools on gather of flesh, trees, ore

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("Tool Blocker", "NubbbZ", "1.0.0")]
[Description("Blocks the use of certain tools on gather of flesh, trees, ore")]
 class ToolBlocker : CovalencePlugin
{
     List<object> FleshBlockedTools;
     List<object> TreeBlockedTools;
     List<object> NodeBlockedTools;
    private const string bypass;
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void Init();
     object OnMeleeAttack(BasePlayer player, HitInfo info);
}


```

---

## ToolCupboardTurrets by 0x89A - Turrets only shoot players who are building blocked on the turret's tool cupboard.

```csharp
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Tool Cupboard Turrets", "0x89A", "1.3.1")]
[Description("Turrets only attack building blocked players")]
 class ToolCupboardTurrets : RustPlugin
{
    private const string turretsIgnore;
    private const string turretsNeverIgnore;
     void Init();
     object CanBeTargeted(BasePlayer player, BaseCombatEntity entity);
     object OnSamSiteTarget(SamSite samsite, BaseHelicopter target);
    private bool IsAuthedOnOwnerTc(BaseEntity entity, BasePlayer player);
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Auto-turrets affected")]
        public bool autoturretsAffected;
        [JsonProperty(PropertyName = "shotgun traps affected")]
        public bool shotgunTrapsAffected;
        [JsonProperty(PropertyName = "flame traps affected")]
        public bool flameTrapsAffected;
        [JsonProperty(PropertyName = "Sam sites affected")]
        public bool samSitesAffected;
        [JsonProperty(PropertyName = "Launch site sams affected")]
        public bool staticSamSitesAffected;
        [JsonProperty(PropertyName = "Outpost turrets affected")]
        public bool NPCTurretsAffected;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
}

private class Configuration
{
    [JsonProperty(PropertyName = "Auto-turrets affected")]
    public bool autoturretsAffected;
    [JsonProperty(PropertyName = "shotgun traps affected")]
    public bool shotgunTrapsAffected;
    [JsonProperty(PropertyName = "flame traps affected")]
    public bool flameTrapsAffected;
    [JsonProperty(PropertyName = "Sam sites affected")]
    public bool samSitesAffected;
    [JsonProperty(PropertyName = "Launch site sams affected")]
    public bool staticSamSitesAffected;
    [JsonProperty(PropertyName = "Outpost turrets affected")]
    public bool NPCTurretsAffected;
}


```

---

## ToolsGatherManager by Mevent - Adjusts the gather rate from certain tools

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;

Oxide.Plugins
[Info("Tools Gather Manager", "hoppel", "1.0.5")]
[Description("Adjusts the gather rate from certain tools")]
public class ToolsGatherManager : RustPlugin
{
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
    private const string permName;
    private void RegisterToolPermissions();
    private bool HasPerm(BasePlayer player);
    private bool HasToolPermission(BasePlayer player);
    private void Init();
    private static Configuration config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Permissions for every Tool")]
        public bool usetoolpermissions;
        [JsonProperty(PropertyName = "Night Gatherrate")]
        public float nightrate;
        [JsonProperty(PropertyName = "Day Gatherrate")]
        public float dayrate;
        [JsonProperty(PropertyName = "Tools")]
        public Dictionary<string, float> tools;
        public static Configuration DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class Configuration
{
    [JsonProperty(PropertyName = "Permissions for every Tool")]
    public bool usetoolpermissions;
    [JsonProperty(PropertyName = "Night Gatherrate")]
    public float nightrate;
    [JsonProperty(PropertyName = "Day Gatherrate")]
    public float dayrate;
    [JsonProperty(PropertyName = "Tools")]
    public Dictionary<string, float> tools;
    public static Configuration DefaultConfig();
}


```

---

## TownTeleport by mvrb - Teleport to Outpost and Bandit Camp

```csharp
using System.Collections.Generic;
using UnityEngine;
using System;
using Rust;
using Oxide.Core;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("TownTeleport", "mvrb", "1.10.2")]
[Description("Teleport to Outpost and Bandit Camp")]
 class TownTeleport : RustPlugin
{
    [PluginReference]
     Plugin NoEscape;
    private StoredData storedData;
    private List<Vector3> OutpostSpawns;
    private List<Vector3> BanditSpawns;
    private Dictionary<BasePlayer, Timer> TeleportTimers;
    private string permissionOutpost;
    private string permissionBandit;
    private string permissionNoCooldown;
    private string teleportCommandOutpost;
    private string teleportCommandBandit;
    private string cancelTeleportCommand;
    private bool blockTeleportWhenMounted;
    private bool blockTeleportFromCargo;
    private bool cancelTpAnyDamamage;
    private bool cancelTpPlayerDamage;
    private bool cancelTpFallDamage;
    private bool forceResetHostileTimer;
    private int outpostCooldown;
    private int outpostCountdown;
    private int banditCooldown;
    private int banditCountdown;
    protected override void LoadDefaultConfig();
    private void LoadDefaultMessages();
    private void OnServerInitialized();
    private void Loaded();
    private class StoredData
    {
        public Dictionary<ulong, int> Cooldowns;
    }

    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void CmdOutpost(BasePlayer player);
    private void CmdBandit(BasePlayer player);
    private object CanTownTeleport(BasePlayer player, string town, bool checkTimers);
    private void StartTeleportTimer(BasePlayer player, string town);
    private void CmdCancelTp(BasePlayer player);
    private void FindTowns();
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void CancelTp(BasePlayer player, string reason);
    private void Teleport(BasePlayer player, Vector3 position);
    private void StartSleeping(BasePlayer player);
    private void LoadData();
    private void SaveData();
    private Int32 GetUnix();
    private T GetConfig(string name, T value);
    private string Lang(string key, string id, object[] args);
}

private class StoredData
{
    public Dictionary<ulong, int> Cooldowns;
}


```

---

## ToxicCrossbow by DezLife - Adds a crossbow that has the ability to fire one charge of a radiation arrow

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

Oxide.Plugins
[Info("Toxic Crossbow", "DezLife", "0.0.8")]
[Description("A crossbow that has the ability to fire one charge of a radiation arrow!")]
 class ToxicCrossbow : CovalencePlugin
{
     ItemDefinition itemAmmo;
    private Configuration config;
    private class Configuration
    {
        [JsonProperty("SkinID for the item")]
        public ulong SkinID;
        [JsonProperty("DisplayName for the item")]
        public string DisplayName;
        [JsonProperty("The amount of radiation will be given every 3 seconds")]
        public float Radiations;
        [JsonProperty("Radius of radiation")]
        public float RadiationsRadius;
        [JsonProperty("Exposure time in seconds")]
        public int RadiationsTime;
    }

    private Configuration GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
     void OnPlayerAttack(BasePlayer attacker, HitInfo info);
    private void CreateItem(BasePlayer target);
    [Command("toxiccrossbow.give")]
    private void ConsoleCommandBlade(IPlayer player, string command, string[] args);
}

private class Configuration
{
    [JsonProperty("SkinID for the item")]
    public ulong SkinID;
    [JsonProperty("DisplayName for the item")]
    public string DisplayName;
    [JsonProperty("The amount of radiation will be given every 3 seconds")]
    public float Radiations;
    [JsonProperty("Radius of radiation")]
    public float RadiationsRadius;
    [JsonProperty("Exposure time in seconds")]
    public int RadiationsTime;
}


```

---

## Trade by Calytic - Allows players to trade items safely at a distance

```csharp
using System;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using System.Linq;

Oxide.Plugins
[Info ("Trade", "Calytic", "1.2.45")]
 class Trade : RustPlugin
{
     string box;
     int slots;
     float cooldownMinutes;
     float maxRadius;
     float pendingSeconds;
     float radiationMax;
     bool allowSafeZone;
    [PluginReference]
     Plugin Ignore;
     Plugin Clans;
     Plugin Friends;
     Dictionary<string, DateTime> tradeCooldowns;
     class OnlinePlayer
    {
        public BasePlayer Player;
        public StorageContainer View;
        public OpenTrade Trade;
        public PlayerInventory inventory { get; set; }
        public ItemContainer containerMain { get; set; }
        public OnlinePlayer(BasePlayer player);
        public void Clear();
    }

    [OnlinePlayers]
     Hash<BasePlayer, OnlinePlayer> onlinePlayers;
     class OpenTrade
    {
        public OnlinePlayer source;
        public OnlinePlayer target;
        public BasePlayer sourcePlayer { get; set; }
        public BasePlayer targetPlayer { get; set; }
        public bool complete;
        public bool closing;
        public bool sourceAccept;
        public bool targetAccept;
        public OpenTrade(OnlinePlayer source, OnlinePlayer target);
        public OnlinePlayer GetOther(OnlinePlayer onlinePlayer);
        public BasePlayer GetOther(BasePlayer player);
        public void ResetAcceptance();
        public bool IsInventorySufficient();
        public bool IsValid();
        public bool IsSourceValid();
        public bool IsTargetValid();
    }

     class PendingTrade
    {
        public BasePlayer Target;
        public Timer Timer;
        public PendingTrade(BasePlayer target);
        public void Destroy();
    }

     List<OpenTrade> openTrades;
     Dictionary<BasePlayer, PendingTrade> pendingTrades;
     void Init();
     void UnsubscribeAll();
     void SubscribeAll();
     void Loaded();
     void Unloaded();
    protected new void LoadDefaultConfig();
     void CheckConfig();
    protected void ReloadConfig();
     void LoadMessages();
     void OnPlayerConnected(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void OnPlayerLootEnd(PlayerLoot inventory);
     void OnItemAction(Item item, string cmd);
     void OnItemAddedToContainer(ItemContainer container, Item item);
     object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot);
     void OnItemRemovedFromContainer(ItemContainer container, Item item);
    [ChatCommand ("trade")]
     void cmdTrade(BasePlayer player, string command, string [] args);
    [ConsoleCommand ("trade")]
     void ccTrade(ConsoleSystem.Arg arg);
    [ConsoleCommand ("trade.decline")]
     void ccTradeDecline(ConsoleSystem.Arg arg);
    [ConsoleCommand ("trade.accept")]
     void ccTradeAccept(ConsoleSystem.Arg arg);
     void TradeAccept(BasePlayer player);
     void CompleteTrade(OpenTrade t);
     bool CheckSourceInventory(OpenTrade t);
     bool CheckTargetInventory(OpenTrade t);
    public string jsonTrade;
    private void ShowTrade(BasePlayer player, OpenTrade trade, string status);
    private void HideTrade(BasePlayer player);
     bool CheckCooldown(BasePlayer player);
     void TradeCloseBoxes(OpenTrade trade);
     void TradeReply(OpenTrade trade, string msg, string msg2);
     void ShowTrades(OpenTrade trade, string msg);
     void TradeCooldown(OpenTrade trade);
     void PlayerCooldown(BasePlayer player);
     void FinishTrade(OpenTrade t);
     void AcceptTrade(BasePlayer player);
     void StartTrades(BasePlayer source, BasePlayer target);
     void StartTrade(BasePlayer source, BasePlayer target, OpenTrade trade);
     void OpenBox(BasePlayer player, BaseEntity target);
     void OpenBoxView(BasePlayer player, BaseEntity targArg);
     void CloseBoxView(BasePlayer player, StorageContainer view);
     bool CanPlayerTrade(BasePlayer player, string perm);
    private void SendHelpText(BasePlayer player);
    private bool IsTradeBox(BaseNetworkable entity);
     bool hasAccess(BasePlayer player, string permissionname);
    private BasePlayer FindPlayerByPartialName(string name);
    private T GetConfig(string name, T defaultValue);
    private T GetConfig(string name, string name2, T defaultValue);
     string GetMsg(string key, BasePlayer player);
    private string CleanName(string name);
}

 class OnlinePlayer
{
    public BasePlayer Player;
    public StorageContainer View;
    public OpenTrade Trade;
    public PlayerInventory inventory { get; set; }
    public ItemContainer containerMain { get; set; }
    public OnlinePlayer(BasePlayer player);
    public void Clear();
}

 class OpenTrade
{
    public OnlinePlayer source;
    public OnlinePlayer target;
    public BasePlayer sourcePlayer { get; set; }
    public BasePlayer targetPlayer { get; set; }
    public bool complete;
    public bool closing;
    public bool sourceAccept;
    public bool targetAccept;
    public OpenTrade(OnlinePlayer source, OnlinePlayer target);
    public OnlinePlayer GetOther(OnlinePlayer onlinePlayer);
    public BasePlayer GetOther(BasePlayer player);
    public void ResetAcceptance();
    public bool IsInventorySufficient();
    public bool IsValid();
    public bool IsSourceValid();
    public bool IsTargetValid();
}

 class PendingTrade
{
    public BasePlayer Target;
    public Timer Timer;
    public PendingTrade(BasePlayer target);
    public void Destroy();
}


```

---

## Trapper by shady14u - Adds a few new features to traps

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

Oxide.Plugins
[Info("Trapper", "Shady14u", "1.1.1")]
[Description("Control who sets off traps")]
public partial class Trapper : RustPlugin
{
    [PluginReference]
    private Plugin Friends;
    private Plugin RustIO;
    private Plugin Clans;
    private static BasePlayer FindPlayer(string nameOrId);
    private static Configuration _config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Reset Time")]
        public float ResetTime { get; set; }
        [JsonProperty(PropertyName = "Trigger for Owner")]
        public bool HurtOwner { get; set; }
        [JsonProperty(PropertyName = "Trigger for Friends")]
        public bool HurtFriends { get; set; }
        [JsonProperty(PropertyName = "Trigger for Clan Mates")]
        public bool HurtClanMates { get; set; }
        [JsonProperty(PropertyName = "Trigger for Authorized")]
        public bool HurtAuthed { get; set; }
        [JsonProperty(PropertyName = "Ignore Projectiles")]
        public bool IgnoreProjectiles { get; set; }
        public static Configuration DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    public static class PluginPermissions
    {
        public const string PermissionNameAdmin;
        public const string PermissionName;
        public const string PermissionNameOwner;
        public const string PermissionNameFriends;
        public const string PermissionNameClan;
        public const string PermissionNameAuth;
    }

    private void LoadPermissions();
    private void Init();
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private object OnTrapTrigger(BaseTrap trap, GameObject obj);
}

public class Configuration
{
    [JsonProperty(PropertyName = "Reset Time")]
    public float ResetTime { get; set; }
    [JsonProperty(PropertyName = "Trigger for Owner")]
    public bool HurtOwner { get; set; }
    [JsonProperty(PropertyName = "Trigger for Friends")]
    public bool HurtFriends { get; set; }
    [JsonProperty(PropertyName = "Trigger for Clan Mates")]
    public bool HurtClanMates { get; set; }
    [JsonProperty(PropertyName = "Trigger for Authorized")]
    public bool HurtAuthed { get; set; }
    [JsonProperty(PropertyName = "Ignore Projectiles")]
    public bool IgnoreProjectiles { get; set; }
    public static Configuration DefaultConfig();
}

public static class PluginPermissions
{
    public const string PermissionNameAdmin;
    public const string PermissionName;
    public const string PermissionNameOwner;
    public const string PermissionNameFriends;
    public const string PermissionNameClan;
    public const string PermissionNameAuth;
}


```

---

## Trashcan by smallo - Turn a Large Wood Box into a trashcan to permanently delete items

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Trashcan", "Smallo", "1.0.4")]
[Description("Turn a Large Wood Box into a trashcan")]
public class Trashcan : CovalencePlugin
{
    private ConfigData config;
    private int defaultMin;
    private int defaultMax;
    private int sizeIncrement;
    private string breakEffect;
    private const string trashCommandPermission;
    [PluginReference]
    private Plugin NoEscape;
    private bool CurrentlyRaidBlocked(BasePlayer player);
    private void Loaded();
    private class ConfigData
    {
        [JsonProperty(PropertyName = "SkinID")]
        public ulong TrashSkinID;
        [JsonProperty(PropertyName = "Trashcan Storage Slots")]
        public int TrashStorageSlots;
        [JsonProperty("Enable Effects")]
        public bool EnableEffects;
        [JsonProperty("Lock Box While In Use (This prevents someone else from deleting your items)")]
        public bool LockBox;
        [JsonProperty("Disable During Raid Block (Requires No Escape plugin)")]
        public bool RaidBlock;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnLootEntity(BasePlayer player, StorageContainer storageContainer);
    private void OnPlayerLootEnd(PlayerLoot inventory);
    private CuiPanel TrashPanel(string anchorMin, string anchorMax, string color, string offsetMin, string offsetMax);
    private CuiLabel TrashLabel(string text, int i, float height, TextAnchor align, int fontSize, string xMin, string xMax, string color);
    private void CreateUI(int addAmount, BasePlayer player);
    private int RoundUp(int numToRound, int multiple);
    [Command("trash"), Permission(trashCommandPermission)]
    private void TrashCmd(IPlayer player, string command, string[] args);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "SkinID")]
    public ulong TrashSkinID;
    [JsonProperty(PropertyName = "Trashcan Storage Slots")]
    public int TrashStorageSlots;
    [JsonProperty("Enable Effects")]
    public bool EnableEffects;
    [JsonProperty("Lock Box While In Use (This prevents someone else from deleting your items)")]
    public bool LockBox;
    [JsonProperty("Disable During Raid Block (Requires No Escape plugin)")]
    public bool RaidBlock;
}


```

---

## TreePlanter by Bazz3l - Buy and plant trees in building authed areas using in-game currency

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Libraries.Covalence;
using Oxide.Plugins.TreePlanterEx;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Tree Planter", "Bazz3l", "1.2.2")]
[Description("Buy and plant trees in building authed areas using in-game currency.")]
public class TreePlanter : CovalencePlugin
{
    [PluginReference]
     Plugin ServerRewards;
     Plugin Economics;
     Plugin Clans;
    private const string PERM_USE;
    private PluginConfig _config;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class PluginConfig
    {
        [JsonProperty("UseServerRewards (use server rewards as currency)")]
        public bool UseServerRewards;
        [JsonProperty("UseEconomics (use economics as currency)")]
        public bool UseEconomics;
        [JsonProperty("UseCurrency (use custom items as currency, by specifying the CurrencyItem)")]
        public bool UseCurrency;
        [JsonProperty("CurrencyItem (set an item id to use as currency, default is set to scrap)")]
        public int CurrencyItem;
        [JsonProperty("CurrencySkinID (set an skin id to use as currency, default is set to 0)")]
        public ulong CurrencySkinID;
        [JsonProperty("EnableOwner (enables owners to chop down trees)")]
        public bool EnableOwner;
        [JsonProperty("EnableClan (enables clan members to chop down trees)")]
        public bool EnableClan;
        [JsonProperty("BlockedAgriItems (specify which items should only be placed in a planter box)")]
        public Dictionary<string, bool> AgriBlocked;
        [JsonProperty("TreeConfigs (list of available trees to purchase)")]
        public List<TreeConfig> TreeConfigs;
        [JsonIgnore]
        private Dictionary<string, TreeConfig> _availableConfigs;
        [JsonIgnore]
        public Dictionary<string, TreeConfig> AvailableConfigs { get; set; }
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
        public static PluginConfig DefaultConfig();
        public TreeConfig FindAvailableConfig(string name);
    }

    private class TreeConfig
    {
        [JsonProperty("Name", Order = 0)]
        public string Name;
        [JsonProperty("Cost", Order = 1)]
        public int Cost;
        [JsonProperty("Amount", Order = 2)]
        public int Amount;
        [JsonProperty("Prefab", Order = 3)]
        public string Prefab;
        public TreeConfig(string name, string prefab);
        public void GiveItem(BasePlayer player);
        public static void RefundItem(BasePlayer player, Item item, GrowableGenes growableGenes);
    }

    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private object OnMeleeAttack(BasePlayer player, HitInfo info);
    private void OnEntityBuilt(Planner plan, GameObject gameObject);
    private void TryPlantTree(BasePlayer player, Item item, GrowableEntity entity, TreeConfig treeItem);
    private void TryPlantSeed(BasePlayer player, Item item, GrowableEntity entity);
    private void PlantTree(BasePlayer player, GrowableEntity plant, string prefabName);
    private void ListTrees(BasePlayer player);
    private void KillSeed(GrowableEntity plant);
    private bool TakeCurrency(BasePlayer player, int treeCost);
    private void TreeCommand(IPlayer player, string command, string[] args);
    private bool HasPermission(BasePlayer player, string permName);
    private bool IsValid(BaseEntity entity);
    private bool SameClan(ulong userID, ulong targetID);
    private bool IsBlockedAgri(string shortname);
    private bool IsEntityOwner(ulong userID, ulong ownerID);
    private string Lang(string key, string id, object[] args);
     bool HasAmount(BasePlayer player, int amount);
     void TakeAmount(BasePlayer player, int amount);
     int GetAmount(PlayerInventory inventory, int itemid, ulong skinID);
     int GetAmount(ItemContainer container, int itemid, ulong skinID, bool usable);
     int TakeAmount(PlayerInventory inventory, int itemid, ulong skinID, int amount);
     int TakeAmount(ItemContainer container, int itemid, int amount, ulong skinID);
}

private class PluginConfig
{
    [JsonProperty("UseServerRewards (use server rewards as currency)")]
    public bool UseServerRewards;
    [JsonProperty("UseEconomics (use economics as currency)")]
    public bool UseEconomics;
    [JsonProperty("UseCurrency (use custom items as currency, by specifying the CurrencyItem)")]
    public bool UseCurrency;
    [JsonProperty("CurrencyItem (set an item id to use as currency, default is set to scrap)")]
    public int CurrencyItem;
    [JsonProperty("CurrencySkinID (set an skin id to use as currency, default is set to 0)")]
    public ulong CurrencySkinID;
    [JsonProperty("EnableOwner (enables owners to chop down trees)")]
    public bool EnableOwner;
    [JsonProperty("EnableClan (enables clan members to chop down trees)")]
    public bool EnableClan;
    [JsonProperty("BlockedAgriItems (specify which items should only be placed in a planter box)")]
    public Dictionary<string, bool> AgriBlocked;
    [JsonProperty("TreeConfigs (list of available trees to purchase)")]
    public List<TreeConfig> TreeConfigs;
    [JsonIgnore]
    private Dictionary<string, TreeConfig> _availableConfigs;
    [JsonIgnore]
    public Dictionary<string, TreeConfig> AvailableConfigs { get; set; }
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
    public static PluginConfig DefaultConfig();
    public TreeConfig FindAvailableConfig(string name);
}

private class TreeConfig
{
    [JsonProperty("Name", Order = 0)]
    public string Name;
    [JsonProperty("Cost", Order = 1)]
    public int Cost;
    [JsonProperty("Amount", Order = 2)]
    public int Amount;
    [JsonProperty("Prefab", Order = 3)]
    public string Prefab;
    public TreeConfig(string name, string prefab);
    public void GiveItem(BasePlayer player);
    public static void RefundItem(BasePlayer player, Item item, GrowableGenes growableGenes);
}

public static class PlayerEx
{
    public static BasePlayer ToBasePlayer(IPlayer player);
}

TreePlanterEx
public static class PlayerEx
{
    public static BasePlayer ToBasePlayer(IPlayer player);
}


```

---

## TrollCheaters by Chepzz - Troll cheaters with OP guns and other troll commands

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Troll Cheaters", "x0x58x", "0.2.0")]
[Description("Troll Cheaters with Op Guns and other troll commands")]
 class TrollCheaters : RustPlugin
{
     ConfigData configData;
    private static string rocketGUI;
    private static string blueScreen;
     void Init();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private string Lang(string langKey, BasePlayer player, object[] args);
    protected override void LoadConfig();
    private ConfigData LoadBaseConfig();
     class ConfigData
    {
        [JsonProperty(PropertyName = "Settings")]
        public Settings settings { get; set; }
        public class Settings
        {
            [JsonProperty(PropertyName = "Troll Cheaters Status")]
            public bool status { get; set; }
            [JsonProperty(PropertyName = "Rocket Speed")]
            public int speed { get; set; }
            [JsonProperty(PropertyName = "Player")]
            public object player { get; set; }
        }

        [JsonProperty(PropertyName = "Version: ")]
        public Core.VersionNumber Version { get; set; }
    }

    private Dictionary<ulong, TCInfo> tcInfo;
    private void SavePlayerData();
    private void LoadPlayerData();
    public class TCInfo
    {
        [JsonProperty(PropertyName = "Name: ")]
        public string Name { get; set; }
    }

    protected override void LoadDefaultMessages();
    [ChatCommand("trocket")]
     void trocket(BasePlayer player);
    [ChatCommand("rspeed")]
     void rspeed(BasePlayer player, string command, string[] args);
    [ChatCommand("dropban")]
     void dropban(BasePlayer player);
    [ChatCommand("rdban")]
     void rdban(BasePlayer player);
    [ChatCommand("bscreen")]
     void bscreen(BasePlayer player);
    [ChatCommand("rbscreen")]
     void rbscreen(BasePlayer player);
     void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles);
     object OnItemPickup(BasePlayer player);
     void OnPlayerConnected(BasePlayer player);
     object OnItemCraft(ItemCraftTask task, BasePlayer player, Item item);
     object OnActiveItemChange(BasePlayer player, Item oldItem, uint newItemId);
     void Loaded(BasePlayer player);
     void ripCheater(BasePlayer player);
     void RunEffect(Vector3 position, string prefab, BasePlayer player);
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Settings")]
    public Settings settings { get; set; }
    public class Settings
    {
        [JsonProperty(PropertyName = "Troll Cheaters Status")]
        public bool status { get; set; }
        [JsonProperty(PropertyName = "Rocket Speed")]
        public int speed { get; set; }
        [JsonProperty(PropertyName = "Player")]
        public object player { get; set; }
    }

    [JsonProperty(PropertyName = "Version: ")]
    public Core.VersionNumber Version { get; set; }
}

public class Settings
{
    [JsonProperty(PropertyName = "Troll Cheaters Status")]
    public bool status { get; set; }
    [JsonProperty(PropertyName = "Rocket Speed")]
    public int speed { get; set; }
    [JsonProperty(PropertyName = "Player")]
    public object player { get; set; }
}

public class TCInfo
{
    [JsonProperty(PropertyName = "Name: ")]
    public string Name { get; set; }
}


```

---

## TrollSystem by Grave - Trolls players into thinking they were muted/unmuted or banned/unbanned, but not actually

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;

Oxide.Plugins
[Info("Troll System", "Grave", "0.6.0")]
[Description("A easier way to troll someone in Rust! The commands available are banning and muting, /tmute, /tunmute, /tban, /tunban, and they all annouce in the chat. Example: /tmute Bill - Announces Grave muted Bill, as I sent the command. This works with unmuting and banning/unbanning.")]
 class TrollSystem : CovalencePlugin
{
    private void Init();
    protected override void LoadDefaultMessages();
    [Command("tban"),Permission("trollsystem.ban")]
    private void Cmdtban(IPlayer player, string command, string[] args);
    [Command("tunban"),Permission("trollsystem.unban")]
    private void Cmdtunban(IPlayer player, string command, string[] args);
    [Command("tmute"),Permission("trollsystem.mute")]
    private void Cmdtmute(IPlayer player, string command, string[] args);
    [Command("tunmute"), Permission("trollsystem.unmute")]
    private void Cmdtunmute(IPlayer player, string command, string[] args);
}


```

---

## TrollTax by  - Places a tax on players killed. Once the Taxer dies his/her tax payer list is cleared

```csharp
using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using System.Reflection;

Oxide.Plugins
[Info("Troll Tax", "Absolut", "1.1.1")]
[Description("Places a tax on players killed. Once the Taxer dies his/her tax payer list is cleared")]
public class TrollTax : RustPlugin
{
    [PluginReference]
     Plugin LustyMap;
     string TitleColor;
     string MsgColor;
     TrollTaxData ttData;
    private DynamicConfigFile TTData;
    private Dictionary<string, Timer> timers;
    private Dictionary<ulong, Coords> BoxPrep;
    private List<ulong> VoidSelection;
     void Init();
     void InitializeTaxTimer(ulong taxer, ulong payer);
     void RemoveTax(ulong payer, ulong taxer);
     void Unload();
    private void OnPlayerDisconnected(BasePlayer player);
     void OnServerInitialized();
     void OnEntityBuilt(Planner planner, GameObject gameobject);
    private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo);
     void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player);
     void OnCollectiblePickup(Item item, BasePlayer player);
     void OnDispenserGather(ResourceDispenser Dispenser, BaseEntity entity, Item item);
    public bool isPayor(ulong ID);
    private List<StorageContainer> GetTaxContainer(ulong Payor);
    private void GetSendMSG(BasePlayer player, string message, string arg1, string arg2, string arg3);
    public void DestroyTaxPanel(BasePlayer player);
    private string PanelTax;
    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
        static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
        static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
        static public void LoadImage(CuiElementContainer container, string panel, string png, string aMin, string aMax);
        static public void CreateTextOverlay(CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align, float fadein);
    }

    private Dictionary<string, string> UIColors;
    private void TaxBoxConfirmation(BasePlayer player);
    [ConsoleCommand("UI_SaveTaxBox")]
    private void cmdUI_SaveTaxBox(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_DestroyTaxPanel")]
    private void cmdUI_DestroyTaxPanel(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_DontAsk")]
    private void cmdUI_DontAsk(ConsoleSystem.Arg arg);
    private void SaveLoop();
    private void InfoLoop();
    private void SetBoxFullNotification(string ID);
     class TrollTaxData
    {
        public Dictionary<ulong, List<ulong>> TaxCollector;
        public Dictionary<ulong, Coords> TaxBox;
        public Dictionary<ulong, Dictionary<ulong, Timer>> VictimLimit;
    }

     class Coords
    {
        public float x;
        public float y;
        public float z;
    }

     void SaveData();
     void LoadData();
    private ConfigData configData;
     class ConfigData
    {
        public double TaxRate { get; set; }
        public int TaxTimeLimit { get; set; }
        public int InfoInterval { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
    protected override void LoadDefaultMessages();
}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
    static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
    static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
    static public void LoadImage(CuiElementContainer container, string panel, string png, string aMin, string aMax);
    static public void CreateTextOverlay(CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align, float fadein);
}

 class TrollTaxData
{
    public Dictionary<ulong, List<ulong>> TaxCollector;
    public Dictionary<ulong, Coords> TaxBox;
    public Dictionary<ulong, Dictionary<ulong, Timer>> VictimLimit;
}

 class Coords
{
    public float x;
    public float y;
    public float z;
}

 class ConfigData
{
    public double TaxRate { get; set; }
    public int TaxTimeLimit { get; set; }
    public int InfoInterval { get; set; }
}


```

---

## TruePVE by nivex - Better PVE/PVP implementation

```csharp
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using Rust.Ai.Gen2;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

Oxide.Plugins
[Info("TruePVE", "nivex", "2.2.8")]
[Description("Improvement of the default Rust PVE behavior")]
internal class TruePVE : RustPlugin
{
    private Configuration config;
    [PluginReference]
     Plugin ZoneManager;
     Plugin LiteZones;
     Plugin Clans;
     Plugin Friends;
     Plugin AbandonedBases;
     Plugin RaidableBases;
    public string usageString;
    private Timer scheduleUpdateTimer;
    private bool shareRedirectDudEnabled;
    private RuleSet dudRuleSet;
    private RuleSet currentRuleSet;
    private string currentBroadcastMessage;
    private bool useZones;
    private const string Any;
    private const string AllZones;
    private const string PermCanMap;
    private bool animalsIgnoreSleepers;
    private bool trace;
    private const string traceFile;
    private const float traceTimeout;
    private Timer traceTimer;
    private bool tpveEnabled;
    private List<DamageType> _damageTypes;
    private uint maincannonshell;
    private uint trainbarricade;
    private uint trainbarricadeheavy;
    private uint loot_trash;
    private uint giftbox_loot;
    private uint campfire;
    private uint oilfireballsmall;
    private uint heli_napalm;
    private uint rocket_heli_napalm;
    private uint rocket_heli;
    private bool excludeAllZones;
    private bool twigOutputHandlerEnabled;
    private readonly List<ulong> _waiting;
    private readonly HashSet<string> _deployables;
    private readonly HashSet<string> exclusionLocationsSet;
    private readonly Dictionary<ulong, List<PlayerExclusion>> playerDelayExclusions;
    private readonly Dictionary<string, RuleSet> ruleSetByNameDictionary;
    private readonly TimedCache<bool?> _npcCache;
    public class TimedCache
    {
        private readonly Dictionary<string, Entry> _cache;
        private readonly TimeSpan _cacheDuration;
        private readonly List<string> _remove;
        private readonly int _maxCapacity;
        public TimedCache(TimeSpan cacheDuration, int maxCapacity);
        public bool TryGetValue(string key, object value);
        public T Set(string key, T value);
        private void OnTick();
        private void RemoveOldest();
        public void CancelInvoke();
    }

    private class PlayerExclusion : Pool.IPooled
    {
        public Plugin plugin;
        public float time;
        public bool IsExpired { get; set; }
        public void EnterPool();
        public void LeavePool();
    }

    protected new static void Puts(string format, object[] args);
    private void Unload();
    private void OnPluginLoaded(Plugin plugin);
    private void OnPluginUnloaded(Plugin plugin);
    private void Init();
    private void OnServerInitialized(bool isStartup);
    private IEnumerator OvenCo();
    private void BuildPrefabIds();
    private void OnNewSave();
    private class StoredData
    {
        public Dictionary<ulong, int> LastSeen;
        public DateTime LastRunTime { get; set; }
    }

    private StoredData data;
    private void LoadData();
    private void SaveData();
    public void UpdateLastSeen();
    public bool CanKillOfflinePlayer(BasePlayer player, double timeLeft);
    private void CommandDelegator(IPlayer user, string command, string[] args);
    protected void HandleTrace(IPlayer user);
    private bool IsTraceEnabled(IPlayer user);
    private void HandleSleepers(IPlayer user);
    private void HandleDef(IPlayer user);
    private void HandleProd(IPlayer user);
    private void CommandMap(IPlayer user, string command, string[] args);
    private void HandleScheduleSet(IPlayer user, string[] args);
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private bool canSaveConfig;
    protected override void SaveConfig();
    private void CheckData();
    private bool CheckMappings();
    protected void BuildRuleSetDictionary();
    protected void TryBuildExclusionMappings();
    protected void BuildExclusionMappings();
    protected bool LoadDefaultData();
    protected void BuildDefaultSchedule();
    protected void BuildDefaultMappings();
    protected void BuildDefaultGroups();
    protected void BuildDefaultRuleset();
    private bool ResetRules(string key);
    private StringBuilder _tsb;
    private BaseEntity traceEntity;
    private BasePlayer tracePlayer;
    private float traceDistance;
    private void Trace(string message, int indentation);
    private void LogTrace();
    private void OnPlayerConnected(BasePlayer player);
    private string CurrentRuleSetName();
    private bool IsEnabled();
    private object OnWallpaperRemove(BuildingBlock block, int side);
    private object OnEntityTakeDamage(ResourceEntity entity, HitInfo info);
    private object OnEntityTakeDamage(BaseEntity entity, HitInfo info);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private string ConcatenateListOrDefault(List<string> list, string defaultValue);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private string ConcatenateRuleSetNames(List<RuleSet> sets);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public DamageResult HandleMetabolismDamage(HitInfo info, BasePlayer victim, DamageType damageType, float damageAmount);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool CanPlayerTriggerTurretOrTrap(BasePlayer victim, BaseEntity entity, BaseEntity weapon);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool CanPlayerHurtTurretOrTrap(BasePlayer victim, BaseEntity entity, BasePlayer attacker);
    private bool allowKillingSleepersEnabled;
    private bool AllowKillingSleepers(BaseEntity entity, BaseEntity initiator);
    private static bool AllowAuthorizationDamage(BasePlayer victim, BasePlayer attacker);
    private static bool IsAuthed(DecayEntity entity, BasePlayer attacker);
    private static bool IsAuthed(Tugboat tugboat, BasePlayer attacker);
    private static bool IsAuthed(BaseHelicopter heli, BasePlayer attacker);
    private bool AllowDamage(BaseEntity entity, HitInfo info);
    private BuildingGrade.Enum[] GradeEnums;
    private bool HandleBlockGrade(BuildingBlock block, BasePlayer attacker, DamageType damageType, float damageAmount, bool selfDamageFlag);
    private void TwigOutputHandler(BuildingBlock block, DamageType damageType, float damageAmount, BasePlayer attacker, bool selfDamageFlag);
    private bool IsTutorialNetworkGroup(BaseEntity entity);
    private DamageResult CheckImmortalFlag(BaseEntity entity, RuleSet ruleSet, BaseEntity initiator, BaseEntity weaponPrefab);
    private bool HandleHelicopter(RuleSet ruleSet, BaseEntity entity, BaseEntity weapon, BasePlayer victim, bool isVicId, bool allow);
    private bool HasBuildingPrivilege(DecayEntity decayEntity);
    private bool IsAlly(ulong vic, ulong atk);
    private bool CanAuthorize(BaseEntity entity, BasePlayer attacker, RuleSet ruleSet);
    private bool IsPlayerEntity(BaseEntity entity);
    private void ExcludePlayer(ulong userid, float maxDelayLength, Plugin plugin);
    private bool HasDelayExclusion(ulong userid);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool PlayerHasExclusion(BasePlayer player, PooledList<string> locs);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool PlayerHasExclusion(BasePlayer player);
    [HookMethod("GetPlayerMapping")]
    public string GetPlayerMapping(BasePlayer player);
    private bool EvaluateRules(BaseEntity entity, BaseEntity attacker, RuleSet ruleSet, bool returnDefaultValue);
    private DamageResult CheckLock(RuleSet ruleSet, BaseEntity entity, BaseEntity initiator, BaseEntity weaponPrefab);
    private DamageResult CheckHeliInitiator(RuleSet ruleSet, BaseEntity initiator, BaseEntity weaponPrefab);
    private bool CheckAuthorized(BaseEntity entity, BasePlayer player, RuleSet ruleSet, bool cupboardOwnership);
    private bool IsFunTurret(AutoTurret turret);
    private object OnSamSiteTarget(BaseEntity attacker, BaseEntity entity);
    private object OnMlrsFire(MLRS mlrs, BasePlayer player);
    private object CanWaterBallSplash(ItemDefinition liquidDef, Vector3 position, float radius, int amount);
    private object OnEntityMarkHostile(BasePlayer player, float duration);
    private void OnEntitySpawned(BaseOven oven);
    private void OnEntitySpawned(MLRSRocket rocket);
    private BeeSwarmMaster _lastSwarmMaster;
    private void OnEntitySpawned(BeeSwarmMaster swarm);
    private void OnTimedExplosiveExplode(BeeGrenade grenade, Vector3 fxPos);
    private void OnEntitySpawned(BeeSwarmAI ai);
    private bool CheckIsEventTerritory(Vector3 position);
    private object SamSiteHelper(BaseEntity attacker, BaseEntity entity);
    private object OnEntityEnter(TargetTrigger trigger, BasePlayer target);
    private static void DrawText(BasePlayer player, float duration, Color color, Vector3 from, object text);
    private object OnEntityEnterInternal(BaseEntity entity, BasePlayer target);
    private object OnTurretTarget(AutoTurret turret, BradleyAPC target);
    private object OnTurretTarget(AutoTurret turret, BasePlayer target);
    private object OnTrapTrigger(BaseTrap trap, GameObject go);
    private object OnNpcTarget(BaseNpc npc, BasePlayer target);
    private object OnNpcTarget(BaseNPC2 npc, BasePlayer target);
    private object OnNpcTargetInternal(BaseEntity npc, BasePlayer target);
    private bool CheckExclusion(BaseEntity attacker);
    private bool CheckExclusion(BaseEntity target, BaseEntity attacker);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RuleSet GetRuleSet(PooledList<string> vicLocations, PooledList<string> atkLocations);
    private RuleSet GetRuleSet(BaseEntity e0, BaseEntity e1);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private PooledList<string> GetSharedLocations(PooledList<string> e0Locations, PooledList<string> e1Locations);
    private bool CheckExclusion(PooledList<string> e0Locations, PooledList<string> e1Locations, bool trace);
    private bool AddOrUpdateMapping(string key, string ruleset);
    private bool RemoveMapping(string key);
    private void Message(BasePlayer player, string key, object[] args);
    private void Message(IPlayer user, string key, object[] args);
    private string BuildMessage(BasePlayer player, string key, object[] args);
    private void PrintValue(ConsoleSystem.Arg arg, string text, bool value);
    private string WrapSize(string size, string input);
    private string WrapSize(int size, string input);
    private string WrapColor(string color, string input);
    private void ShowUsage(IPlayer user);
    public string RemoveFormatting(string source);
    private void WarnPve();
    private PooledList<string> GetLocationKeys(BaseEntity entity);
    private bool GetRaycastTarget(BasePlayer player, BaseEntity closestEntity);
    private void TimerLoop(bool firstRun);
    private void ValidateCurrentDamageHook();
    private class TwigDamageOptions
    {
        [JsonProperty(PropertyName = "Apply To Twig (when TwigDamage flag is not set")]
        public bool Twig { get; set; }
        [JsonProperty(PropertyName = "Apply To Wood")]
        public bool Wood { get; set; }
        [JsonProperty(PropertyName = "Apply To Stone")]
        public bool Stone { get; set; }
        [JsonProperty(PropertyName = "Apply To Metal")]
        public bool Metal { get; set; }
        [JsonProperty(PropertyName = "Apply To HQM")]
        public bool HQM { get; set; }
        [JsonProperty(PropertyName = "Require Owner Online")]
        public bool Online { get; set; }
        [JsonProperty(PropertyName = "Log Offenses")]
        public bool Log { get; set; }
        [JsonProperty(PropertyName = "Notify Offenders")]
        public bool Notify { get; set; }
        [JsonProperty(PropertyName = "Reflect Damage Multiplier")]
        public float ReflectDamageMultiplier { get; set; }
        [JsonProperty(PropertyName = "Multiplier Allows Armor Protection")]
        public bool ReflectDamageProtection { get; set; }
        internal bool Any { get; set; }
    }

    private class ConfigurationOptions
    {
        [JsonProperty(PropertyName = "TwigDamage (FLAG)")]
        public TwigDamageOptions BlockHandler { get; set; }
        [JsonProperty(PropertyName = "handleDamage")]
        public bool handleDamage { get; set; }
        [JsonProperty(PropertyName = "useZones")]
        public bool useZones { get; set; }
        [JsonProperty(PropertyName = "Trace To Player Console")]
        public bool PlayerConsole { get; set; }
        [JsonProperty(PropertyName = "Trace To Server Console")]
        public bool ServerConsole { get; set; }
        [JsonProperty(PropertyName = "Log Trace To File")]
        public bool LogToFile { get; set; }
        [JsonProperty(PropertyName = "Maximum Distance From Player To Trace")]
        public float MaxTraceDistance { get; set; }
        [JsonProperty(PropertyName = "Prevent Water From Extinguishing BaseOven")]
        public bool disableBaseOvenSplash { get; set; }
        [JsonProperty(PropertyName = "Prevent Players From Being Marked Hostile")]
        public bool disableHostility { get; set; }
        [JsonProperty(PropertyName = "Allow PVP Below Height")]
        public float Underworld { get; set; }
        [JsonProperty(PropertyName = "Allow PVP Above Height")]
        public float Aboveworld { get; set; }
        [JsonProperty(PropertyName = "Allow Other Damage Below Height")]
        public float UnderworldOther { get; set; }
        [JsonProperty(PropertyName = "Allow Other Damage Above Height")]
        public float AboveworldOther { get; set; }
        [JsonProperty(PropertyName = "Allow Cold Metabolism Damage")]
        public bool Cold { get; set; }
        [JsonProperty(PropertyName = "Allow Heat Metabolism Damage")]
        public bool Heat { get; set; }
    }

    private class Configuration
    {
        [JsonProperty(PropertyName = "Config Version")]
        public string configVersion;
        [JsonProperty(PropertyName = "Default RuleSet")]
        public string defaultRuleSet;
        [JsonProperty(PropertyName = "Configuration Options")]
        public ConfigurationOptions options;
        [JsonProperty(PropertyName = "Mappings")]
        public Dictionary<string, string> mappings;
        [JsonProperty(PropertyName = "Schedule")]
        public Schedule schedule;
        [JsonProperty(PropertyName = "RuleSets")]
        public List<RuleSet> ruleSets;
        [JsonProperty(PropertyName = "Entity Groups")]
        public List<EntityGroup> groups;
        [JsonProperty(PropertyName = "Allow Killing Sleepers")]
        public bool AllowKillingSleepers;
        [JsonProperty(PropertyName = "Allow Killing Sleepers (Ally Only)")]
        public bool AllowKillingSleepersAlly;
        [JsonProperty(PropertyName = "Allow Killing Sleepers (Authorization Only)")]
        public bool AllowKillingSleepersAuthorization;
        [JsonProperty(PropertyName = "Allow Killing Sleepers (After X Hours Offline)")]
        public float AllowKillingSleepersHoursOffline;
        [JsonProperty(PropertyName = "Allow Killing Sleepers (Allowed steam ids)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> AllowKillingSleepersIds;
        [JsonProperty(PropertyName = "Ignore Firework Damage")]
        public bool Firework;
        [JsonProperty(PropertyName = "Ignore Campfire Damage")]
        public bool Campfires;
        [JsonProperty(PropertyName = "Ignore Ladder Damage")]
        public bool Ladders;
        [JsonProperty(PropertyName = "Ignore Sleeping Bag Damage")]
        public bool SleepingBags;
        [JsonProperty(PropertyName = "Players Can Trigger Traps In Monument Topology")]
        public bool PlayersTriggerTraps;
        [JsonProperty(PropertyName = "Players Can Hurt Traps In Monument Topology")]
        public bool PlayersHurtTraps;
        [JsonProperty(PropertyName = "Players Can Trigger Turrets In Monument Topology")]
        public bool PlayersTriggerTurrets;
        [JsonProperty(PropertyName = "Players Can Hurt Turrets In Monument Topology")]
        public bool PlayersHurtTurrets;
        [JsonProperty(PropertyName = "Block Scrap Heli Damage")]
        public bool scrap;
        [JsonProperty(PropertyName = "Block Igniter Damage")]
        public bool igniter;
        [JsonProperty(PropertyName = "Block Wallpaper Damage")]
        public bool wallpaper;
        [JsonProperty(PropertyName = "Block Radioactive Water Damage")]
        public bool BlockRadioactiveWaterDamage;
        [JsonProperty(PropertyName = "Block Decay Damage To Vehicles")]
        public bool BlockDecayDamageToVehicles;
        [JsonProperty(PropertyName = "Prevent ragdolling when struck by another vehicle")]
        public bool PreventRagdolling;
        [JsonProperty(PropertyName = "Experimental ZoneManager support for PVE zones")]
        public bool PVEZones;
        internal Dictionary<ulong, List<string>> groupCache;
        public void Init(TruePVE instance);
        public List<string> ResolveEntityGroups(BaseEntity entity);
        public bool HasMapping(string key);
        public RuleSet GetDefaultRuleSet();
        public RuleSet GetDudRuleSet();
    }

    private class RuleSet
    {
        public string name;
        public bool enabled;
        public bool defaultAllowDamage;
        public string flags;
        internal RuleFlags _flags;
        internal bool Changed;
        public HashSet<string> rules;
        internal HashSet<Rule> parsedRules;
        internal Dictionary<string, Rule> ruleDictionary;
        public RuleSet();
        public RuleSet(string name);
        public bool Evaluate(TruePVE instance, List<string> eg1, List<string> eg2, bool returnDefaultValue);
        public void Build(TruePVE instance);
        public void InitializeRuleDictionary();
        private void ConvertSamSiteFlag();
        private void ConvertTrapsIgnoreScientists();
        private void ConvertTurretsIgnoreScientists(string from, string to, RuleFlags flag);
        public void ValidateRules();
        public void AddRule(TruePVE instance, string ruleText);
        public bool HasAnyFlag(RuleFlags flags);
        public bool HasFlag(RuleFlags flag);
        public bool IsEmpty();
    }

    private class Rule
    {
        public string ruleText;
        internal string key;
        internal bool hurt;
        internal bool valid;
        public Rule();
        public Rule(TruePVE instance, string ruleText);
        public bool Translate(TruePVE instance);
        public override int GetHashCode();
        public override bool Equals(object obj);
    }

    private readonly Regex regex;
    private readonly HashSet<string> synonyms;
    private class EntityGroup
    {
        public string name { get; set; }
        internal readonly HashSet<string> _memberSet;
        internal readonly HashSet<string> _exclusionSet;
        private string _cachedMembersString;
        private string _cachedExclusionsString;
        private bool _isMembersDirty;
        private bool _isExclusionsDirty;
        public EntityGroup();
        public EntityGroup(string name);
        public string members { get; set; }
        public string exclusions { get; set; }
        public bool IsMember(string value);
        public bool IsExclusion(string value);
        public bool Contains(BaseEntity entity);
    }

    private class Schedule
    {
        public bool enabled;
        public bool useRealtime;
        public bool broadcast;
        public List<string> entries;
        internal List<ScheduleEntry> parsedEntries;
        internal bool valid;
        public void Init(TruePVE instance);
        public void ClockUpdate(string ruleSetName, string message);
    }

    private class ScheduleEntry
    {
        public string ruleSet;
        public string message;
        public string scheduleText;
        public bool valid;
        public TimeSpan time { get; set; }
        internal bool isDaily;
        public ScheduleEntry();
        public ScheduleEntry(TruePVE instance, string scheduleText);
        private bool Translate(TruePVE instance);
        public override int GetHashCode();
        public override bool Equals(object obj);
    }

    protected override void LoadDefaultMessages();
    private string GetMessage(string key, string userId);
}

public class TimedCache
{
    private readonly Dictionary<string, Entry> _cache;
    private readonly TimeSpan _cacheDuration;
    private readonly List<string> _remove;
    private readonly int _maxCapacity;
    public TimedCache(TimeSpan cacheDuration, int maxCapacity);
    public bool TryGetValue(string key, object value);
    public T Set(string key, T value);
    private void OnTick();
    private void RemoveOldest();
    public void CancelInvoke();
}

private class PlayerExclusion : Pool.IPooled
{
    public Plugin plugin;
    public float time;
    public bool IsExpired { get; set; }
    public void EnterPool();
    public void LeavePool();
}

private class StoredData
{
    public Dictionary<ulong, int> LastSeen;
    public DateTime LastRunTime { get; set; }
}

private class TwigDamageOptions
{
    [JsonProperty(PropertyName = "Apply To Twig (when TwigDamage flag is not set")]
    public bool Twig { get; set; }
    [JsonProperty(PropertyName = "Apply To Wood")]
    public bool Wood { get; set; }
    [JsonProperty(PropertyName = "Apply To Stone")]
    public bool Stone { get; set; }
    [JsonProperty(PropertyName = "Apply To Metal")]
    public bool Metal { get; set; }
    [JsonProperty(PropertyName = "Apply To HQM")]
    public bool HQM { get; set; }
    [JsonProperty(PropertyName = "Require Owner Online")]
    public bool Online { get; set; }
    [JsonProperty(PropertyName = "Log Offenses")]
    public bool Log { get; set; }
    [JsonProperty(PropertyName = "Notify Offenders")]
    public bool Notify { get; set; }
    [JsonProperty(PropertyName = "Reflect Damage Multiplier")]
    public float ReflectDamageMultiplier { get; set; }
    [JsonProperty(PropertyName = "Multiplier Allows Armor Protection")]
    public bool ReflectDamageProtection { get; set; }
    internal bool Any { get; set; }
}

private class ConfigurationOptions
{
    [JsonProperty(PropertyName = "TwigDamage (FLAG)")]
    public TwigDamageOptions BlockHandler { get; set; }
    [JsonProperty(PropertyName = "handleDamage")]
    public bool handleDamage { get; set; }
    [JsonProperty(PropertyName = "useZones")]
    public bool useZones { get; set; }
    [JsonProperty(PropertyName = "Trace To Player Console")]
    public bool PlayerConsole { get; set; }
    [JsonProperty(PropertyName = "Trace To Server Console")]
    public bool ServerConsole { get; set; }
    [JsonProperty(PropertyName = "Log Trace To File")]
    public bool LogToFile { get; set; }
    [JsonProperty(PropertyName = "Maximum Distance From Player To Trace")]
    public float MaxTraceDistance { get; set; }
    [JsonProperty(PropertyName = "Prevent Water From Extinguishing BaseOven")]
    public bool disableBaseOvenSplash { get; set; }
    [JsonProperty(PropertyName = "Prevent Players From Being Marked Hostile")]
    public bool disableHostility { get; set; }
    [JsonProperty(PropertyName = "Allow PVP Below Height")]
    public float Underworld { get; set; }
    [JsonProperty(PropertyName = "Allow PVP Above Height")]
    public float Aboveworld { get; set; }
    [JsonProperty(PropertyName = "Allow Other Damage Below Height")]
    public float UnderworldOther { get; set; }
    [JsonProperty(PropertyName = "Allow Other Damage Above Height")]
    public float AboveworldOther { get; set; }
    [JsonProperty(PropertyName = "Allow Cold Metabolism Damage")]
    public bool Cold { get; set; }
    [JsonProperty(PropertyName = "Allow Heat Metabolism Damage")]
    public bool Heat { get; set; }
}

private class Configuration
{
    [JsonProperty(PropertyName = "Config Version")]
    public string configVersion;
    [JsonProperty(PropertyName = "Default RuleSet")]
    public string defaultRuleSet;
    [JsonProperty(PropertyName = "Configuration Options")]
    public ConfigurationOptions options;
    [JsonProperty(PropertyName = "Mappings")]
    public Dictionary<string, string> mappings;
    [JsonProperty(PropertyName = "Schedule")]
    public Schedule schedule;
    [JsonProperty(PropertyName = "RuleSets")]
    public List<RuleSet> ruleSets;
    [JsonProperty(PropertyName = "Entity Groups")]
    public List<EntityGroup> groups;
    [JsonProperty(PropertyName = "Allow Killing Sleepers")]
    public bool AllowKillingSleepers;
    [JsonProperty(PropertyName = "Allow Killing Sleepers (Ally Only)")]
    public bool AllowKillingSleepersAlly;
    [JsonProperty(PropertyName = "Allow Killing Sleepers (Authorization Only)")]
    public bool AllowKillingSleepersAuthorization;
    [JsonProperty(PropertyName = "Allow Killing Sleepers (After X Hours Offline)")]
    public float AllowKillingSleepersHoursOffline;
    [JsonProperty(PropertyName = "Allow Killing Sleepers (Allowed steam ids)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> AllowKillingSleepersIds;
    [JsonProperty(PropertyName = "Ignore Firework Damage")]
    public bool Firework;
    [JsonProperty(PropertyName = "Ignore Campfire Damage")]
    public bool Campfires;
    [JsonProperty(PropertyName = "Ignore Ladder Damage")]
    public bool Ladders;
    [JsonProperty(PropertyName = "Ignore Sleeping Bag Damage")]
    public bool SleepingBags;
    [JsonProperty(PropertyName = "Players Can Trigger Traps In Monument Topology")]
    public bool PlayersTriggerTraps;
    [JsonProperty(PropertyName = "Players Can Hurt Traps In Monument Topology")]
    public bool PlayersHurtTraps;
    [JsonProperty(PropertyName = "Players Can Trigger Turrets In Monument Topology")]
    public bool PlayersTriggerTurrets;
    [JsonProperty(PropertyName = "Players Can Hurt Turrets In Monument Topology")]
    public bool PlayersHurtTurrets;
    [JsonProperty(PropertyName = "Block Scrap Heli Damage")]
    public bool scrap;
    [JsonProperty(PropertyName = "Block Igniter Damage")]
    public bool igniter;
    [JsonProperty(PropertyName = "Block Wallpaper Damage")]
    public bool wallpaper;
    [JsonProperty(PropertyName = "Block Radioactive Water Damage")]
    public bool BlockRadioactiveWaterDamage;
    [JsonProperty(PropertyName = "Block Decay Damage To Vehicles")]
    public bool BlockDecayDamageToVehicles;
    [JsonProperty(PropertyName = "Prevent ragdolling when struck by another vehicle")]
    public bool PreventRagdolling;
    [JsonProperty(PropertyName = "Experimental ZoneManager support for PVE zones")]
    public bool PVEZones;
    internal Dictionary<ulong, List<string>> groupCache;
    public void Init(TruePVE instance);
    public List<string> ResolveEntityGroups(BaseEntity entity);
    public bool HasMapping(string key);
    public RuleSet GetDefaultRuleSet();
    public RuleSet GetDudRuleSet();
}

private class RuleSet
{
    public string name;
    public bool enabled;
    public bool defaultAllowDamage;
    public string flags;
    internal RuleFlags _flags;
    internal bool Changed;
    public HashSet<string> rules;
    internal HashSet<Rule> parsedRules;
    internal Dictionary<string, Rule> ruleDictionary;
    public RuleSet();
    public RuleSet(string name);
    public bool Evaluate(TruePVE instance, List<string> eg1, List<string> eg2, bool returnDefaultValue);
    public void Build(TruePVE instance);
    public void InitializeRuleDictionary();
    private void ConvertSamSiteFlag();
    private void ConvertTrapsIgnoreScientists();
    private void ConvertTurretsIgnoreScientists(string from, string to, RuleFlags flag);
    public void ValidateRules();
    public void AddRule(TruePVE instance, string ruleText);
    public bool HasAnyFlag(RuleFlags flags);
    public bool HasFlag(RuleFlags flag);
    public bool IsEmpty();
}

private class Rule
{
    public string ruleText;
    internal string key;
    internal bool hurt;
    internal bool valid;
    public Rule();
    public Rule(TruePVE instance, string ruleText);
    public bool Translate(TruePVE instance);
    public override int GetHashCode();
    public override bool Equals(object obj);
}

private class EntityGroup
{
    public string name { get; set; }
    internal readonly HashSet<string> _memberSet;
    internal readonly HashSet<string> _exclusionSet;
    private string _cachedMembersString;
    private string _cachedExclusionsString;
    private bool _isMembersDirty;
    private bool _isExclusionsDirty;
    public EntityGroup();
    public EntityGroup(string name);
    public string members { get; set; }
    public string exclusions { get; set; }
    public bool IsMember(string value);
    public bool IsExclusion(string value);
    public bool Contains(BaseEntity entity);
}

private class Schedule
{
    public bool enabled;
    public bool useRealtime;
    public bool broadcast;
    public List<string> entries;
    internal List<ScheduleEntry> parsedEntries;
    internal bool valid;
    public void Init(TruePVE instance);
    public void ClockUpdate(string ruleSetName, string message);
}

private class ScheduleEntry
{
    public string ruleSet;
    public string message;
    public string scheduleText;
    public bool valid;
    public TimeSpan time { get; set; }
    internal bool isDaily;
    public ScheduleEntry();
    public ScheduleEntry(TruePVE instance, string scheduleText);
    private bool Translate(TruePVE instance);
    public override int GetHashCode();
    public override bool Equals(object obj);
}


```

---

## TrueSmokeRockets by VisEntities - Fixes non-functional smoke rockets by making them produce a smoke cloud upon explosion

```csharp
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("True Smoke Rockets", "VisEntities", "1.1.0")]
[Description("Functional smoke rockets that produce a smoke cloud upon explosion.")]
public class TrueSmokeRockets : RustPlugin
{
    private static Configuration _config;
    private const string SMOKE_ROCKET_PREFAB;
    private const string SMOKE_GRENADE_PREFAB;
    private class Configuration
    {
        [JsonProperty("Version")]
        public string Version { get; set; }
        [JsonProperty("Smoke Duration Seconds")]
        public float SmokeDurationSeconds { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private Configuration GetDefaultConfig();
    private void Unload();
    private void OnEntityKill(TimedExplosive explosive);
}

private class Configuration
{
    [JsonProperty("Version")]
    public string Version { get; set; }
    [JsonProperty("Smoke Duration Seconds")]
    public float SmokeDurationSeconds { get; set; }
}


```

---

## Tsuri by ColonBlow - Allows players to use weapons to fish ingame

```csharp
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Fishing", "Colon Blow", "1.4.11")]
 class Fishing : RustPlugin
{
    private Dictionary<ulong, string> GuiInfo;
    private void Loaded();
    private static PluginConfig config;
    private class PluginConfig
    {
        public GlobalSettings globalSettings { get; set; }
        public DefaultCatchSettings defaultCatchSettings { get; set; }
        public FishCatchSettings fishCatchSettings { get; set; }
        public LootCatchSettings lootCatchSettings { get; set; }
        public class GlobalSettings
        {
            [JsonProperty(PropertyName = "Global - Show Fish Catch Indicator")]
            public bool ShowFishCatchIcon { get; set; }
            [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ? ")]
            public bool enableRandomLootBox { get; set; }
            [JsonProperty(PropertyName = "Global - Enable Timer when Spear Fishing Pole ? ")]
            public bool enableSpearTimer { get; set; }
            [JsonProperty(PropertyName = "Global - Enable Timer when Casting Fishing Pole ? ")]
            public bool enableCastTimer { get; set; }
            [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ?")]
            public bool enableConditionLoss { get; set; }
            [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Max percent : ")]
            public float conditionLossMax { get; set; }
            [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Min percent : ")]
            public float conditionLossMin { get; set; }
            [JsonProperty(PropertyName = "Global - Allow Bonus from Weapons ? ")]
            public bool enableWeaponModifer { get; set; }
            [JsonProperty(PropertyName = "Global - Allow Bonus from Attire ? ")]
            public bool enableAttireModifer { get; set; }
            [JsonProperty(PropertyName = "Global - Allow Bonus from Items ? ")]
            public bool enableItemModifier { get; set; }
            [JsonProperty(PropertyName = "Global - Allow Bonus from Time of Day ? ")]
            public bool enableTimeModifier { get; set; }
            [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Casting Pole, if enabled (default 6 second) : ")]
            public float timeReCastPole { get; set; }
            [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Spear/Bow, if enabled (default 6 seconds) : ")]
            public float timeReAttack { get; set; }
            [JsonProperty(PropertyName = "Global - Random chests will despawn themselves after this amount of time (default 200 seconds) : ")]
            public float lootBoxDespawnTime { get; set; }
        }

        public class DefaultCatchSettings
        {
            [JsonProperty(PropertyName = "Catch Chance - Starting default chance to catch something (Percentage)")]
            public int chanceDefaultAMT { get; set; }
            [JsonProperty(PropertyName = "Catch Chance - Bonus - From Weapon (Percentage)")]
            public int chanceBonusWeaponAMT { get; set; }
            [JsonProperty(PropertyName = "Catch Chance - Bonus - From Attire (Percentage)")]
            public int chanceBonusAttireAMT { get; set; }
            [JsonProperty(PropertyName = "Catch Chance - Bonus - From Item (Percentage)")]
            public int chacneBonusItemAMT { get; set; }
            [JsonProperty(PropertyName = "Catch Chance - Bonus - From Time of Day (Percentage)")]
            public int chanceBonusTimeAMT { get; set; }
            [JsonProperty(PropertyName = "Attire Bonus - if player is wearing this, gets attire bonus (default Boonie Hat) ")]
            public int attireBonusID { get; set; }
            [JsonProperty(PropertyName = "Item Bonus - if player has in inventory this, get item bonus (default Pookie Bear ")]
            public int itemBonusID { get; set; }
            [JsonProperty(PropertyName = "Time Bonus 1 - if current time is after the hour of : ")]
            public int timeBonus1After { get; set; }
            [JsonProperty(PropertyName = "Time Bonus 1 - and current time is before the hour of : ")]
            public int timeBonus1Before { get; set; }
            [JsonProperty(PropertyName = "Time Bonus 2 - if current time is after the hour of : ")]
            public int timeBonus2After { get; set; }
            [JsonProperty(PropertyName = "Time Bonus 2 - and current time is before the hour of : ")]
            public int timeBonus2Before { get; set; }
        }

        public class FishCatchSettings
        {
            [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 1 ")]
            public int common1catchchance { get; set; }
            [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 2 ")]
            public int common2catchchance { get; set; }
            [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a UnCommon Fish ")]
            public int uncommoncatchchance { get; set; }
            [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Rare Fish ")]
            public int rarecatchchance { get; set; }
            [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Loot Box ")]
            public int randomitemchance { get; set; }
            [JsonProperty(PropertyName = "Amount - Common Fish 1 - When this is caught, Amount of Catch ")]
            public int common1catchamount { get; set; }
            [JsonProperty(PropertyName = "Amount - Common Fish 2 - When this is caught, Amount of Catch ")]
            public int common2catchamount { get; set; }
            [JsonProperty(PropertyName = "Amount - Uncommon Fish - When this is caught, Amount of Catch ")]
            public int uncommoncatchamount { get; set; }
            [JsonProperty(PropertyName = "Amount - Rare Fish - When this is caught, Amount of Catch ")]
            public int rarecatchamount { get; set; }
            [JsonProperty(PropertyName = "ItemID - Common Fish 1 - Item ID of Catch (default is Minnows)")]
            public int common1catchitemid { get; set; }
            [JsonProperty(PropertyName = "ItemID - Common Fish 2 - Item ID of Catch (default is Small Trout)")]
            public int common2catchitemid { get; set; }
            [JsonProperty(PropertyName = "ItemID - Uncommon Fish - Item ID of Catch (default is Small Trout)")]
            public int uncommoncatchitemid { get; set; }
            [JsonProperty(PropertyName = "ItemID - Rare Fish - Item ID of Catch (default is Small Trout)")]
            public int rarecatchitemid { get; set; }
            [JsonProperty(PropertyName = "Icon - Common Fish 1 - Icon URL to show when this fish is caught (if enabled) ")]
            public string common1iconurl { get; set; }
            [JsonProperty(PropertyName = "Icon - Common Fish 2 - Icon URL to show when this fish is caught (if enabled) ")]
            public string common2iconurl { get; set; }
            [JsonProperty(PropertyName = "Icon - Uncommon Fish - Icon URL to show when this fish is caught (if enabled) ")]
            public string uncommoniconurl { get; set; }
            [JsonProperty(PropertyName = "Icon - Rare Fish - Icon URL to show when this fish is caught (if enabled) ")]
            public string rareiconurl { get; set; }
        }

        public class LootCatchSettings
        {
            [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 1 ")]
            public int randomlootprefab1chance { get; set; }
            [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 2 ")]
            public int randomlootprefab2chance { get; set; }
            [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 3 ")]
            public int randomlootprefab3chance { get; set; }
            [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 4 ")]
            public int randomlootprefab4chance { get; set; }
            [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 5 ")]
            public int randomlootprefab5chance { get; set; }
            [JsonProperty(PropertyName = "Chest Type 1 - Prefab string ")]
            public string randomlootprefab1 { get; set; }
            [JsonProperty(PropertyName = "Chest Type 2 - Prefab string ")]
            public string randomlootprefab2 { get; set; }
            [JsonProperty(PropertyName = "Chest Type 3 - Prefab string ")]
            public string randomlootprefab3 { get; set; }
            [JsonProperty(PropertyName = "Chest Type 4 - Prefab string ")]
            public string randomlootprefab4 { get; set; }
            [JsonProperty(PropertyName = "Chest Type 5 - Prefab string ")]
            public string randomlootprefab5 { get; set; }
            [JsonProperty(PropertyName = "Icon - Icon URL to show when this fish is caught (if enabled)")]
            public string randomitemiconurl { get; set; }
        }

        public static PluginConfig DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string msg(string key, string playerId);
     Dictionary<string, string> messages;
    [ChatCommand("castpole")]
    private void cmdChatcastfishingpole(BasePlayer player, string command, string[] args);
    [ConsoleCommand("castpole")]
    private void cmdConsoleCastFishingPole(ConsoleSystem.Arg arg);
    [ChatCommand("fishchance")]
    private void cmdChatfishchance(BasePlayer player, string command, string[] args);
    [ChatCommand("makepole")]
    private void cmdChatMakeFishingPole(BasePlayer player, string command, string[] args);
    [ConsoleCommand("makepole")]
    private void cmdConsoleMakeFishingPole(ConsoleSystem.Arg arg);
    private void MakeFishingPole(BasePlayer player);
    private void OnPlayerInput(BasePlayer player, InputState input);
    private bool ValidateCastFish(BasePlayer player);
    private void ProcessCastFish(BasePlayer player);
    private class FishingControl : MonoBehaviour
    {
        private BasePlayer player;
        public string anchormaxstr;
        private Fishing fishing;
        public float counter;
        private BaseEntity bobber;
        public bool playermoved;
        private Vector3 bobberpos;
        private void Awake();
        public void SpawnBobber(Vector3 pos);
        private void FixedUpdate();
        private void PlayerMoved();
        private void RollForFish(Vector3 pos);
        private string GetGUIString(float counter);
        public void fishingindicator(BasePlayer player, float counter);
        private void DestroyCui(BasePlayer player);
        public void OnDestroy();
    }

    private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo);
    private void ProcessSpearFish(BasePlayer attacker, HitInfo hitInfo);
    private class SpearFishingControl : MonoBehaviour
    {
        private BasePlayer player;
        public string anchormaxstr;
        private Fishing fishing;
        public float counter;
        private void Awake();
        private void FixedUpdate();
        private string GetGUIString(float counter);
        public void fishingindicator(BasePlayer player, float counter);
        private void DestroyCui(BasePlayer player);
        public void OnDestroy();
    }

    private void FishChanceRoll(BasePlayer player, Vector3 hitloc);
    private int CatchFishModifier(BasePlayer player);
    private void FishTypeRoll(BasePlayer player, Vector3 hitloc);
    private void SpawnLootBox(BasePlayer player, Vector3 hitloc);
    private void CheckTreasureDespawn(BaseEntity treasurebox);
    private bool IsFishing(BasePlayer baseplayer);
    private bool HasFishingCooldown(BasePlayer baseplayer);
    private bool UsingCastRod(BasePlayer player);
    private bool UsingSpearRod(HitInfo hitInfo);
    private bool LookingAtWater(BasePlayer player);
    private void SendInfoMessage(BasePlayer player, string message, float time);
    private bool IsAllowed(BasePlayer player, string perm);
    private class IntUtil
    {
        private static System.Random random;
        private static void Init();
        public static int Random(int min, int max);
    }

    private void OnPlayerRespawned(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void Unload();
    private void DestroyAll();
    private void catchFishCui(BasePlayer player, string fishicon);
    private void FishingGui(BasePlayer player, string fishicon);
    private void DestroyCui(BasePlayer player);
}

private class PluginConfig
{
    public GlobalSettings globalSettings { get; set; }
    public DefaultCatchSettings defaultCatchSettings { get; set; }
    public FishCatchSettings fishCatchSettings { get; set; }
    public LootCatchSettings lootCatchSettings { get; set; }
    public class GlobalSettings
    {
        [JsonProperty(PropertyName = "Global - Show Fish Catch Indicator")]
        public bool ShowFishCatchIcon { get; set; }
        [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ? ")]
        public bool enableRandomLootBox { get; set; }
        [JsonProperty(PropertyName = "Global - Enable Timer when Spear Fishing Pole ? ")]
        public bool enableSpearTimer { get; set; }
        [JsonProperty(PropertyName = "Global - Enable Timer when Casting Fishing Pole ? ")]
        public bool enableCastTimer { get; set; }
        [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ?")]
        public bool enableConditionLoss { get; set; }
        [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Max percent : ")]
        public float conditionLossMax { get; set; }
        [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Min percent : ")]
        public float conditionLossMin { get; set; }
        [JsonProperty(PropertyName = "Global - Allow Bonus from Weapons ? ")]
        public bool enableWeaponModifer { get; set; }
        [JsonProperty(PropertyName = "Global - Allow Bonus from Attire ? ")]
        public bool enableAttireModifer { get; set; }
        [JsonProperty(PropertyName = "Global - Allow Bonus from Items ? ")]
        public bool enableItemModifier { get; set; }
        [JsonProperty(PropertyName = "Global - Allow Bonus from Time of Day ? ")]
        public bool enableTimeModifier { get; set; }
        [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Casting Pole, if enabled (default 6 second) : ")]
        public float timeReCastPole { get; set; }
        [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Spear/Bow, if enabled (default 6 seconds) : ")]
        public float timeReAttack { get; set; }
        [JsonProperty(PropertyName = "Global - Random chests will despawn themselves after this amount of time (default 200 seconds) : ")]
        public float lootBoxDespawnTime { get; set; }
    }

    public class DefaultCatchSettings
    {
        [JsonProperty(PropertyName = "Catch Chance - Starting default chance to catch something (Percentage)")]
        public int chanceDefaultAMT { get; set; }
        [JsonProperty(PropertyName = "Catch Chance - Bonus - From Weapon (Percentage)")]
        public int chanceBonusWeaponAMT { get; set; }
        [JsonProperty(PropertyName = "Catch Chance - Bonus - From Attire (Percentage)")]
        public int chanceBonusAttireAMT { get; set; }
        [JsonProperty(PropertyName = "Catch Chance - Bonus - From Item (Percentage)")]
        public int chacneBonusItemAMT { get; set; }
        [JsonProperty(PropertyName = "Catch Chance - Bonus - From Time of Day (Percentage)")]
        public int chanceBonusTimeAMT { get; set; }
        [JsonProperty(PropertyName = "Attire Bonus - if player is wearing this, gets attire bonus (default Boonie Hat) ")]
        public int attireBonusID { get; set; }
        [JsonProperty(PropertyName = "Item Bonus - if player has in inventory this, get item bonus (default Pookie Bear ")]
        public int itemBonusID { get; set; }
        [JsonProperty(PropertyName = "Time Bonus 1 - if current time is after the hour of : ")]
        public int timeBonus1After { get; set; }
        [JsonProperty(PropertyName = "Time Bonus 1 - and current time is before the hour of : ")]
        public int timeBonus1Before { get; set; }
        [JsonProperty(PropertyName = "Time Bonus 2 - if current time is after the hour of : ")]
        public int timeBonus2After { get; set; }
        [JsonProperty(PropertyName = "Time Bonus 2 - and current time is before the hour of : ")]
        public int timeBonus2Before { get; set; }
    }

    public class FishCatchSettings
    {
        [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 1 ")]
        public int common1catchchance { get; set; }
        [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 2 ")]
        public int common2catchchance { get; set; }
        [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a UnCommon Fish ")]
        public int uncommoncatchchance { get; set; }
        [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Rare Fish ")]
        public int rarecatchchance { get; set; }
        [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Loot Box ")]
        public int randomitemchance { get; set; }
        [JsonProperty(PropertyName = "Amount - Common Fish 1 - When this is caught, Amount of Catch ")]
        public int common1catchamount { get; set; }
        [JsonProperty(PropertyName = "Amount - Common Fish 2 - When this is caught, Amount of Catch ")]
        public int common2catchamount { get; set; }
        [JsonProperty(PropertyName = "Amount - Uncommon Fish - When this is caught, Amount of Catch ")]
        public int uncommoncatchamount { get; set; }
        [JsonProperty(PropertyName = "Amount - Rare Fish - When this is caught, Amount of Catch ")]
        public int rarecatchamount { get; set; }
        [JsonProperty(PropertyName = "ItemID - Common Fish 1 - Item ID of Catch (default is Minnows)")]
        public int common1catchitemid { get; set; }
        [JsonProperty(PropertyName = "ItemID - Common Fish 2 - Item ID of Catch (default is Small Trout)")]
        public int common2catchitemid { get; set; }
        [JsonProperty(PropertyName = "ItemID - Uncommon Fish - Item ID of Catch (default is Small Trout)")]
        public int uncommoncatchitemid { get; set; }
        [JsonProperty(PropertyName = "ItemID - Rare Fish - Item ID of Catch (default is Small Trout)")]
        public int rarecatchitemid { get; set; }
        [JsonProperty(PropertyName = "Icon - Common Fish 1 - Icon URL to show when this fish is caught (if enabled) ")]
        public string common1iconurl { get; set; }
        [JsonProperty(PropertyName = "Icon - Common Fish 2 - Icon URL to show when this fish is caught (if enabled) ")]
        public string common2iconurl { get; set; }
        [JsonProperty(PropertyName = "Icon - Uncommon Fish - Icon URL to show when this fish is caught (if enabled) ")]
        public string uncommoniconurl { get; set; }
        [JsonProperty(PropertyName = "Icon - Rare Fish - Icon URL to show when this fish is caught (if enabled) ")]
        public string rareiconurl { get; set; }
    }

    public class LootCatchSettings
    {
        [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 1 ")]
        public int randomlootprefab1chance { get; set; }
        [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 2 ")]
        public int randomlootprefab2chance { get; set; }
        [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 3 ")]
        public int randomlootprefab3chance { get; set; }
        [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 4 ")]
        public int randomlootprefab4chance { get; set; }
        [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 5 ")]
        public int randomlootprefab5chance { get; set; }
        [JsonProperty(PropertyName = "Chest Type 1 - Prefab string ")]
        public string randomlootprefab1 { get; set; }
        [JsonProperty(PropertyName = "Chest Type 2 - Prefab string ")]
        public string randomlootprefab2 { get; set; }
        [JsonProperty(PropertyName = "Chest Type 3 - Prefab string ")]
        public string randomlootprefab3 { get; set; }
        [JsonProperty(PropertyName = "Chest Type 4 - Prefab string ")]
        public string randomlootprefab4 { get; set; }
        [JsonProperty(PropertyName = "Chest Type 5 - Prefab string ")]
        public string randomlootprefab5 { get; set; }
        [JsonProperty(PropertyName = "Icon - Icon URL to show when this fish is caught (if enabled)")]
        public string randomitemiconurl { get; set; }
    }

    public static PluginConfig DefaultConfig();
}

public class GlobalSettings
{
    [JsonProperty(PropertyName = "Global - Show Fish Catch Indicator")]
    public bool ShowFishCatchIcon { get; set; }
    [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ? ")]
    public bool enableRandomLootBox { get; set; }
    [JsonProperty(PropertyName = "Global - Enable Timer when Spear Fishing Pole ? ")]
    public bool enableSpearTimer { get; set; }
    [JsonProperty(PropertyName = "Global - Enable Timer when Casting Fishing Pole ? ")]
    public bool enableCastTimer { get; set; }
    [JsonProperty(PropertyName = "Global - Enable Random Item Condition Loss when Spear/Bow Fishing ?")]
    public bool enableConditionLoss { get; set; }
    [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Max percent : ")]
    public float conditionLossMax { get; set; }
    [JsonProperty(PropertyName = "Global - Random Item Conditon Loss Min percent : ")]
    public float conditionLossMin { get; set; }
    [JsonProperty(PropertyName = "Global - Allow Bonus from Weapons ? ")]
    public bool enableWeaponModifer { get; set; }
    [JsonProperty(PropertyName = "Global - Allow Bonus from Attire ? ")]
    public bool enableAttireModifer { get; set; }
    [JsonProperty(PropertyName = "Global - Allow Bonus from Items ? ")]
    public bool enableItemModifier { get; set; }
    [JsonProperty(PropertyName = "Global - Allow Bonus from Time of Day ? ")]
    public bool enableTimeModifier { get; set; }
    [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Casting Pole, if enabled (default 6 second) : ")]
    public float timeReCastPole { get; set; }
    [JsonProperty(PropertyName = "Global - Seconds to Wait after Fishing Attempt with Spear/Bow, if enabled (default 6 seconds) : ")]
    public float timeReAttack { get; set; }
    [JsonProperty(PropertyName = "Global - Random chests will despawn themselves after this amount of time (default 200 seconds) : ")]
    public float lootBoxDespawnTime { get; set; }
}

public class DefaultCatchSettings
{
    [JsonProperty(PropertyName = "Catch Chance - Starting default chance to catch something (Percentage)")]
    public int chanceDefaultAMT { get; set; }
    [JsonProperty(PropertyName = "Catch Chance - Bonus - From Weapon (Percentage)")]
    public int chanceBonusWeaponAMT { get; set; }
    [JsonProperty(PropertyName = "Catch Chance - Bonus - From Attire (Percentage)")]
    public int chanceBonusAttireAMT { get; set; }
    [JsonProperty(PropertyName = "Catch Chance - Bonus - From Item (Percentage)")]
    public int chacneBonusItemAMT { get; set; }
    [JsonProperty(PropertyName = "Catch Chance - Bonus - From Time of Day (Percentage)")]
    public int chanceBonusTimeAMT { get; set; }
    [JsonProperty(PropertyName = "Attire Bonus - if player is wearing this, gets attire bonus (default Boonie Hat) ")]
    public int attireBonusID { get; set; }
    [JsonProperty(PropertyName = "Item Bonus - if player has in inventory this, get item bonus (default Pookie Bear ")]
    public int itemBonusID { get; set; }
    [JsonProperty(PropertyName = "Time Bonus 1 - if current time is after the hour of : ")]
    public int timeBonus1After { get; set; }
    [JsonProperty(PropertyName = "Time Bonus 1 - and current time is before the hour of : ")]
    public int timeBonus1Before { get; set; }
    [JsonProperty(PropertyName = "Time Bonus 2 - if current time is after the hour of : ")]
    public int timeBonus2After { get; set; }
    [JsonProperty(PropertyName = "Time Bonus 2 - and current time is before the hour of : ")]
    public int timeBonus2Before { get; set; }
}

public class FishCatchSettings
{
    [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 1 ")]
    public int common1catchchance { get; set; }
    [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Common Fish 2 ")]
    public int common2catchchance { get; set; }
    [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a UnCommon Fish ")]
    public int uncommoncatchchance { get; set; }
    [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Rare Fish ")]
    public int rarecatchchance { get; set; }
    [JsonProperty(PropertyName = "Chance - When Something is caught, it will be a Loot Box ")]
    public int randomitemchance { get; set; }
    [JsonProperty(PropertyName = "Amount - Common Fish 1 - When this is caught, Amount of Catch ")]
    public int common1catchamount { get; set; }
    [JsonProperty(PropertyName = "Amount - Common Fish 2 - When this is caught, Amount of Catch ")]
    public int common2catchamount { get; set; }
    [JsonProperty(PropertyName = "Amount - Uncommon Fish - When this is caught, Amount of Catch ")]
    public int uncommoncatchamount { get; set; }
    [JsonProperty(PropertyName = "Amount - Rare Fish - When this is caught, Amount of Catch ")]
    public int rarecatchamount { get; set; }
    [JsonProperty(PropertyName = "ItemID - Common Fish 1 - Item ID of Catch (default is Minnows)")]
    public int common1catchitemid { get; set; }
    [JsonProperty(PropertyName = "ItemID - Common Fish 2 - Item ID of Catch (default is Small Trout)")]
    public int common2catchitemid { get; set; }
    [JsonProperty(PropertyName = "ItemID - Uncommon Fish - Item ID of Catch (default is Small Trout)")]
    public int uncommoncatchitemid { get; set; }
    [JsonProperty(PropertyName = "ItemID - Rare Fish - Item ID of Catch (default is Small Trout)")]
    public int rarecatchitemid { get; set; }
    [JsonProperty(PropertyName = "Icon - Common Fish 1 - Icon URL to show when this fish is caught (if enabled) ")]
    public string common1iconurl { get; set; }
    [JsonProperty(PropertyName = "Icon - Common Fish 2 - Icon URL to show when this fish is caught (if enabled) ")]
    public string common2iconurl { get; set; }
    [JsonProperty(PropertyName = "Icon - Uncommon Fish - Icon URL to show when this fish is caught (if enabled) ")]
    public string uncommoniconurl { get; set; }
    [JsonProperty(PropertyName = "Icon - Rare Fish - Icon URL to show when this fish is caught (if enabled) ")]
    public string rareiconurl { get; set; }
}

public class LootCatchSettings
{
    [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 1 ")]
    public int randomlootprefab1chance { get; set; }
    [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 2 ")]
    public int randomlootprefab2chance { get; set; }
    [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 3 ")]
    public int randomlootprefab3chance { get; set; }
    [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 4 ")]
    public int randomlootprefab4chance { get; set; }
    [JsonProperty(PropertyName = "Chance - If player cathces a loot box, it will be Chest Type 5 ")]
    public int randomlootprefab5chance { get; set; }
    [JsonProperty(PropertyName = "Chest Type 1 - Prefab string ")]
    public string randomlootprefab1 { get; set; }
    [JsonProperty(PropertyName = "Chest Type 2 - Prefab string ")]
    public string randomlootprefab2 { get; set; }
    [JsonProperty(PropertyName = "Chest Type 3 - Prefab string ")]
    public string randomlootprefab3 { get; set; }
    [JsonProperty(PropertyName = "Chest Type 4 - Prefab string ")]
    public string randomlootprefab4 { get; set; }
    [JsonProperty(PropertyName = "Chest Type 5 - Prefab string ")]
    public string randomlootprefab5 { get; set; }
    [JsonProperty(PropertyName = "Icon - Icon URL to show when this fish is caught (if enabled)")]
    public string randomitemiconurl { get; set; }
}

private class FishingControl : MonoBehaviour
{
    private BasePlayer player;
    public string anchormaxstr;
    private Fishing fishing;
    public float counter;
    private BaseEntity bobber;
    public bool playermoved;
    private Vector3 bobberpos;
    private void Awake();
    public void SpawnBobber(Vector3 pos);
    private void FixedUpdate();
    private void PlayerMoved();
    private void RollForFish(Vector3 pos);
    private string GetGUIString(float counter);
    public void fishingindicator(BasePlayer player, float counter);
    private void DestroyCui(BasePlayer player);
    public void OnDestroy();
}

private class SpearFishingControl : MonoBehaviour
{
    private BasePlayer player;
    public string anchormaxstr;
    private Fishing fishing;
    public float counter;
    private void Awake();
    private void FixedUpdate();
    private string GetGUIString(float counter);
    public void fishingindicator(BasePlayer player, float counter);
    private void DestroyCui(BasePlayer player);
    public void OnDestroy();
}

private class IntUtil
{
    private static System.Random random;
    private static void Init();
    public static int Random(int min, int max);
}


```

---

## TurboGather by  - Gives a short gather rate boost with a cooldown afterwards

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using System.Globalization;
using UnityEngine;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("Turbo Gather", "redBDGR", "1.1.12")]
[Description("Lets players activate a resouce gather boost for a certain amount of time")]
 class TurboGather : RustPlugin
{
    private DynamicConfigFile turboGatherData;
     StoredData storedData;
     Dictionary<string, Information> cacheDictionary;
     Dictionary<string, bool> GUIinfo;
    static List<object> Animals();
     List<object> TurboAnimals;
     List<string> turboweapons;
     class StoredData
    {
        public Dictionary<string, Information> turboGatherInformation;
    }

     class Information
    {
        public bool turboEnabled;
        public double activeAgain;
        public double turboEndTime;
        public bool adminTurboGiven;
        public double adminMultiplierGiven;
    }

     void Unload();
     void OnServerSave();
     void SaveData();
     void LoadData();
     bool Changed;
    public float activeTime;
    public double cooldownTime;
    public double boostMultiplier;
    public double endTime;
    public const string permissionName;
    public const string permissionNameVIP;
    public const string permissionNameANIMAL;
    public const string permissionNameADMIN;
    public float activeTimeVIP;
    public double cooldownTimeVIP;
    public double boostMultiplierVIP;
    public bool globalBoostEnabled;
    public float activeTimeGLOBAL;
    public double boostMultiplierGLOBAL;
    public float activeTimeANIMAL;
    public double boostMultiplierANIMAL;
    public bool dispenserEnabled;
    public bool pickupEnabled;
    public bool quarryEnabled;
    public bool activateTurboOnAnimalKill;
    public string PrefixName;
    public bool effectEnabled;
    public const string effect;
    public bool GUIEnabled;
    public string minAnchor;
    public string maxAnchor;
    protected override void LoadDefaultConfig();
     void LoadVariables();
     void Loaded();
     void Init();
     void AddWeapons();
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void OnPlayerDeath(BasePlayer player, HitInfo info);
     void OnPlayerAttack(BasePlayer attacker, HitInfo info);
     void DoGather(BasePlayer player, Item item);
     void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
     void OnCollectiblePickup(Item item, BasePlayer player);
     void OnQuarryGather(MiningQuarry quarry, Item item);
     void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
     void StartAnimalTurbo(BasePlayer player);
     void StartTurbo(BasePlayer player);
    [ChatCommand("turbo")]
     void TurboCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("cancelturbo")]
     void CancelturboCMD(BasePlayer player, string command, string[] args);
    [ChatCommand("giveturbo")]
     void GiveturboCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("globalturbo")]
     void GlobalturboCMD(BasePlayer player, string command, string[] args);
    [ConsoleCommand("globalturbo")]
     void GlobalturboconsoleCMD(ConsoleSystem.Arg arg);
    [ChatCommand("cancelglobalturbo")]
     void CancelglobalturboCMD(BasePlayer player, string command, string[] args);
    [ConsoleCommand("giveturbo")]
     void GiveturboconsoleCMD(ConsoleSystem.Arg arg);
    private string PanelOnScreen;
    private string Panel;
    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateImage(CuiElementContainer element, string panel, string imageURL, string aMin, string aMax);
    }

     void StartGui(BasePlayer player);
     void EndGUI(BasePlayer player);
     object GetConfig(string menu, string datavalue, object defaultValue);
     double GrabCurrentTime();
     string msg(string key, string id);
    private static BasePlayer FindPlayer(string nameOrId);
}

 class StoredData
{
    public Dictionary<string, Information> turboGatherInformation;
}

 class Information
{
    public bool turboEnabled;
    public double activeAgain;
    public double turboEndTime;
    public bool adminTurboGiven;
    public double adminMultiplierGiven;
}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateImage(CuiElementContainer element, string panel, string imageURL, string aMin, string aMax);
}


```

---

## TurretConfig by Calytic - Allows customizing and configuring the way turrets work

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Turret Config", "Calytic", "2.1.0")]
[Description("Allows customizing and configuring the way turrets work")]
 class TurretConfig : RustPlugin
{
    [PluginReference]
    private Plugin Vanish;
    private const string AutoTurretPrefab;
    private const string FlameTurretPrefab;
    private uint _autoTurretPrefabId;
    private uint _flameTurretPrefabId;
    private bool _adminOverride;
    private List<object> _animals;
    private bool _animalOverride;
    private bool _sleepOverride;
    private bool _infiniteAmmo;
    private bool _useGlobalDamageModifier;
    private float _globalDamageModifier;
    private float _defaultBulletModifier;
    private float _defaultBulletSpeed;
    private string _defaultAmmoType;
    private float _defaultSightRange;
    private float _defaultAutoHealth;
    private float _defaultAimCone;
    private Dictionary<string, object> _bulletModifiers;
    private Dictionary<string, object> _bulletSpeeds;
    private Dictionary<string, object> _ammoTypes;
    private Dictionary<string, object> _sightRanges;
    private Dictionary<string, object> _autoHealths;
    private Dictionary<string, object> _aimCones;
    private float _defaultFlameModifier;
    private float _defaultArc;
    private float _defaultTriggerDuration;
    private float _defaultFlameRange;
    private float _defaultFlameRadius;
    private float _defaultFuelPerSec;
    private float _defaultFlameHealth;
    private Dictionary<string, object> _flameModifiers;
    private Dictionary<string, object> _arcs;
    private Dictionary<string, object> _triggerDurations;
    private Dictionary<string, object> _flameRanges;
    private Dictionary<string, object> _flameRadiuses;
    private Dictionary<string, object> _fuelPerSecs;
    private Dictionary<string, object> _flameHealths;
    private void Init();
    private void OnServerInitialized();
    private void LoadPermissions(Dictionary<string, object> type);
    protected void LoadFlameTurrets();
    protected void LoadAutoTurrets();
    protected override void LoadDefaultConfig();
    protected void ReloadConfig();
    protected override void LoadDefaultMessages();
    private List<object> GetPassiveAnimals();
    private Dictionary<string, object> GetDefaultBulletModifiers();
    private Dictionary<string, object> GetDefaultFlameModifiers();
    private Dictionary<string, object> GetDefaultBulletSpeeds();
    private Dictionary<string, object> GetDefaultSightRanges();
    private Dictionary<string, object> GetDefaultAmmoTypes();
    private Dictionary<string, object> GetDefaultAutoHealths();
    private Dictionary<string, object> GetDefaultAimCones();
    private Dictionary<string, object> GetDefaultArcs();
    private Dictionary<string, object> GetDefaultTriggerDurations();
    private Dictionary<string, object> GetDefaultFlameRanges();
    private Dictionary<string, object> GetDefaultFlameRadiuses();
    private Dictionary<string, object> GetDefaultFuelPerSecs();
    private Dictionary<string, object> GetDefaultFlameHealths();
    private void LoadData();
    [ConsoleCommand("turrets.reload")]
    private void CcTurretReload(ConsoleSystem.Arg arg);
    private void OnLootEntity(BasePlayer looter, BaseEntity target);
    private void OnItemUse(Item item, int amount);
     void OnTurretStartup(AutoTurret autoTurret);
     void OnTurretShutdown(AutoTurret autoTurret);
    private void CheckAutoTurretAmmo(AutoTurret autoTurret);
    private void RefillAutoTurretAmmo(AutoTurret autoTurret);
    private void CheckFlameTurretFuel(FlameTurret flameTurret);
    private void RefillFlameTurretFuel(FlameTurret flameTurret);
     void CanPickupEntity(BasePlayer player, BaseEntity entity);
    private object CanBeTargeted(BaseCombatEntity target, MonoBehaviour turret);
    private void OnEntitySpawned(BaseNetworkable entity);
    private T FromPermission(string userID, Dictionary<string, object> options, T defaultValue);
    private void InitializeTurret(BaseCombatEntity turret, float turretHealth, bool justCreated);
    private void UpdateFlameTurret(FlameTurret turret, bool justCreated);
    private void UpdateAutoTurret(AutoTurret turret, bool justCreated);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo);
    private T GetConfig(string name, T defaultValue);
    private T GetConfig(string name, string name2, T defaultValue);
    private string GetMsg(string key, string userID);
}


```

---

## TurretInfo by ninco90 - Check authorized players in an AutoTurret and the victims of it

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("TurretInfo", "ninco90", "1.2.0", ResourceId = 2678)]
 class TurretInfo : RustPlugin
{
    private DynamicConfigFile restorationdata;
    private StoredData storedData;
     void Init();
     class StoredData
    {
        public Dictionary<string, List<string>> Kills;
        public StoredData();
    }

     class SpawnInfo
    {
        public SpawnInfo();
        public string UserId;
    }

     void PlayerKillsAdd(string steamid, string timeleft);
    private BaseEntity FindEntity(BasePlayer player);
    private object Ray(Vector3 Pos, Vector3 Aim);
    private bool IsNPC(BasePlayer player);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private BaseEntity GetViewEntity(BasePlayer player);
    [ChatCommand("turret")]
     void cmdAuth(BasePlayer player, string command, string[] args);
    private void CuiTurretDestroy(BasePlayer player);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "CHAT GLOBAL | Show when someone dies or someone destroys the turret in Global Chat. [true,false]")]
        public bool GS_CHAT_GLOBAL;
        [JsonProperty(PropertyName = "CHAT PRIVATE | Only show the owner when someone dies by the turret or destroys it. [true,false]")]
        public bool GS_CHAT_PRIVATE;
        [JsonProperty(PropertyName = "GUI | Display GUI Turret Destroy [true,false]")]
        public bool GS_GUI;
        [JsonProperty(PropertyName = "EFFECT | Show effect when using [true,false]")]
        public bool GS_EFFECT;
        [JsonProperty(PropertyName = "LOG | Show Show log in console [true,false]")]
        public bool GS_LOG;
        [JsonProperty(PropertyName = "TEAM SUPPORT | Allows teammates to use commands [true,false]")]
        public bool GS_TEAM;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
     string GetMessage(string key, string steamId);
     string msg(string key, string id, object[] args);
     Dictionary<string, string> MessagesEN;
     Dictionary<string, string> MessagesES;
}

 class StoredData
{
    public Dictionary<string, List<string>> Kills;
    public StoredData();
}

 class SpawnInfo
{
    public SpawnInfo();
    public string UserId;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "CHAT GLOBAL | Show when someone dies or someone destroys the turret in Global Chat. [true,false]")]
    public bool GS_CHAT_GLOBAL;
    [JsonProperty(PropertyName = "CHAT PRIVATE | Only show the owner when someone dies by the turret or destroys it. [true,false]")]
    public bool GS_CHAT_PRIVATE;
    [JsonProperty(PropertyName = "GUI | Display GUI Turret Destroy [true,false]")]
    public bool GS_GUI;
    [JsonProperty(PropertyName = "EFFECT | Show effect when using [true,false]")]
    public bool GS_EFFECT;
    [JsonProperty(PropertyName = "LOG | Show Show log in console [true,false]")]
    public bool GS_LOG;
    [JsonProperty(PropertyName = "TEAM SUPPORT | Allows teammates to use commands [true,false]")]
    public bool GS_TEAM;
}


```

---

## TurretLimits by Whispers88 - Limits the number of turrets/traps that can be placed in a particular building or cupboard range

```csharp
using ConVar;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Turret Limits", "Whispers88, gsuberland", "1.2.3")]
[Description("Limits the number of autoturrets, flame turrets, and shotgun traps that can be deployed per building.")]
 class TurretLimits : RustPlugin
{
    private const string AutoTurretPrefabString;
    private const string FlameTurretPrefabString;
    private const string ShotgunTrapPrefabString;
    private const string SamSitePrefabString;
    private bool ConfigChanged;
    private void Init();
    private new void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void GetConfig(T variable, string[] path);
     object CanBuild(Planner planner, Construction prefab, Construction.Target target);
}


```

---

## TurretLoadouts by WhiteThunder - Automatically fills turrets with weapons, attachments and ammo, using configurable loadouts

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Turret Loadouts", "WhiteThunder", "1.2.0")]
[Description("Automatically fills turrets with weapons, attachments and ammo, using configurable loadouts.")]
internal class TurretLoadouts : CovalencePlugin
{
    private const int LoadoutNameMaxLength;
    private const string Permission_AutoToggle;
    private const string Permission_AutoToggleSamSite;
    private const string Permission_Manage;
    private const string Permission_ManageCustom;
    private const string Permission_RulesetPrefix;
    private const string Permission_DefaultLoadoutPrefix;
    private const string Permission_DefaultFlameTurretLoadoutPrefix;
    private const string Permission_DefaultShotgunTrapLoadoutPrefix;
    private const string Permission_DefaultSamSiteLoadoutPrefix;
    private readonly object False;
    private readonly Dictionary<string, PlayerData> _playerDataCache;
    private Configuration _config;
    private void Init();
    private void OnServerInitialized();
    private void OnEntityBuilt(Planner plan, GameObject go);
    private void OnEntityPickedUp(StorageContainer container);
    private void OnTurretToggle(AutoTurret turret);
    private object CanMoveItem(Item item);
    private object OnDropContainerEntity(ContainerIOEntity container);
    private object OnDropContainerEntity(StorageContainer container);
    [HookMethod(nameof(API_FillTurret))]
    public void API_FillTurret(BasePlayer player, BaseEntity turret);
    private static class ExposedHooks
    {
        public static object OnTurretLoadoutFill(BasePlayer player, BaseEntity turret);
    }

    [Command("tl")]
    private void MainCommand(IPlayer player, string cmd, string[] args);
    private void SubCommandDefault(IPlayer player);
    private void SubCommandHelp(IPlayer player);
    private void SubCommandList(IPlayer player);
    private void AddListItem(StringBuilder sb, IPlayer player, TurretLoadout loadout, string activeLoadout);
    private IEnumerable<string> AbbreviateAttachments(IPlayer player, TurretLoadout loadout);
    private void SubCommandSave(IPlayer player, string[] args);
    private void SubCommandUpdate(IPlayer player, string[] args);
    private string PrintDisallowedItems(IPlayer player, Dictionary<string, int> disallowedItems);
    private string PrintLoadoutDetails(IPlayer player, TurretLoadout loadout);
    private void SubCommandRename(IPlayer player, string[] args);
    private void SubCommandDelete(IPlayer player, string[] args);
    private void SubCommandActivate(IPlayer player, string[] args);
    private bool VerifyPermissionAny(IPlayer player, string[] permissionNames);
    private bool VerifyTurretFound(BasePlayer player, AutoTurret turret);
    private bool VerifyTurretLoadoutValid(IPlayer player, AutoTurret turret, TurretLoadout loadout);
    private bool VerifyHasLoadout(IPlayer player, string loadoutName, TurretLoadout loadout, bool matchPartial);
    private bool VerifyLoadoutNameLength(IPlayer player, string loadoutName);
    private static void SetupLockedContainer(ContainerIOEntity container);
    private static void SetupLockedContainer(StorageContainer container);
    private static bool IsLocked(IItemContainerEntity containerEntity);
    private static int GetTotalAmmo(AutoTurret turret);
    private static TurretLoadout CreateLoadout(AutoTurret turret);
    private string GetLoadoutDisplayName(TurretLoadout loadout, string userIdString);
    private Item AddHeldEntity(AutoTurret turret, BasePlayer ownerPlayer, TurretLoadout loadout);
    private void AddReserveAmmo(ItemContainer container, BaseLoadout loadout, BasePlayer ownerPlayer, int firstSlot);
    private void FillAutoTurret(BasePlayer player, AutoTurret turret);
    private void FillSamSite(BasePlayer player, SamSite samSite);
    private void FillFlameTurret(BasePlayer player, FlameTurret flameTurret);
    private void FillGunTrap(BasePlayer player, GunTrap gunTrap);
    private void FillTurretLikeEntity(BasePlayer player, BaseEntity entity);
    public static void LogWarning(string message);
    public static void LogError(string message);
    private bool HasPermissionAny(BasePlayer basePlayer, string[] permissionNames);
    private bool HasPermissionAny(IPlayer player, string[] permissionNames);
    private bool HasPermissionAny(string userId, string[] permissionNames);
    private bool MatchesDefaultLoadoutName(IPlayer player, string loadoutName, bool matchPartial);
    private string GetDefaultLoadoutName(string userIdString);
    private static int SortLoadoutNames(TurretLoadout a, TurretLoadout b);
    private static string GetItemDisplayName(string shortname);
    private static BaseEntity GetLookEntity(BasePlayer basePlayer, int maxDistance);
    private static void AddToDictKey(Dictionary<string, int> dict, string key, int amount);
    private PlayerData GetPlayerData(IPlayer player);
    private PlayerData GetPlayerData(string userIdString);
    private class PlayerData : LoadoutManager
    {
        public static PlayerData Get(string ownerId);
        private static string GetFilepath(string ownerId);
        [JsonProperty("OwnerId")]
        public string OwnerId { get; set; }
        [JsonProperty("ActiveLoadout", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string ActiveLoadout;
        public PlayerData(string ownerId);
        public override void SaveData();
        public void RestrictAndPruneLoadouts(LoadoutRuleset ruleset);
    }

    private abstract class LoadoutManager
    {
        private static bool MatchesLoadout(TurretLoadout loadout, string name, bool matchPartial);
        [JsonProperty("Loadouts")]
        public List<TurretLoadout> Loadouts;
        public TurretLoadout FindByName(string loadoutName, bool matchPartial);
        public bool HasLoadout(string loadoutName);
        public void SaveLoadout(TurretLoadout loadout);
        public bool TryUpdateLoadout(TurretLoadout newLoadout);
        public void RenameLoadout(TurretLoadout loadout, string newName);
        public void DeleteLoadout(TurretLoadout loadout);
        public ValidationResult ValidateAndPossiblyReduceLoadout(TurretLoadout loadout, LoadoutRuleset loadoutRuleset, Dictionary<string, int> disallowedItems);
        public abstract void SaveData();
    }

    private TurretLoadout GetPlayerActiveLoadout(string userIdString);
    private T GetPlayerLastAllowedProfile(T[] profileList, string userIdString, T defaultProfile);
    private LoadoutRuleset GetPlayerLoadoutRuleset(string userIdString);
    private LoadoutRuleset GetPlayerLoadoutRuleset(IPlayer player);
    private class Configuration : BaseConfiguration
    {
        [JsonIgnore]
        public readonly LoadoutRuleset EmptyLoadoutRuleset;
        [JsonProperty("LockAutoFilledTurrets")]
        public bool LockAutoFilledTurrets;
        [JsonProperty("MaxLoadoutsPerPlayer")]
        public int MaxLoadoutsPerPlayer;
        [JsonProperty("DefaultLoadouts")]
        public DefaultTurretLoadout[] DefaultLoadouts;
        [JsonProperty("LoadoutRulesets")]
        public LoadoutRuleset[] LoadoutRulesets;
        [JsonProperty("DefaultSamSiteLoadouts")]
        public DefaultBaseLoadout[] DefaultSamSiteLoadouts;
        [JsonProperty("DefaultFlameTurretLoadouts")]
        public DefaultBaseLoadout[] DefaultFlameTurretLoadouts;
        [JsonProperty("DefaultShotgunTrapLoadouts")]
        public DefaultBaseLoadout[] DefaultShotgunTrapLoadouts;
        public void Init(TurretLoadouts pluginInstance);
    }

    private abstract class BaseProfile
    {
        [JsonProperty("Name")]
        public string Name;
        [JsonIgnore]
        public string Permission;
        public void Init(TurretLoadouts pluginInstance, string permissionPrefix);
    }

    private class LoadoutRuleset : BaseProfile
    {
        [JsonProperty("AllowedWeapons", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string[] AllowedWeapons;
        [JsonProperty("DisallowedWeapons", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string[] DisallowedWeapons;
        [JsonProperty("AllowedAttachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string[] AllowedAttachments;
        [JsonProperty("DisallowedAttachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string[] DisallowedAttachments;
        [JsonProperty("AllowedAmmo", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public Dictionary<string, int> AllowedAmmo;
        public bool IsWeaponAllowed(string weaponName);
        public bool IsAttachmentAllowed(string attachmentName);
    }

    private class BaseLoadout : BaseProfile
    {
        [JsonProperty("ReserveAmmo", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public List<AmmoAmount> ReserveAmmo;
        [JsonIgnore]
        public virtual bool IsDefault { get; set; }
    }

    private class DefaultBaseLoadout : BaseLoadout
    {
        public override bool IsDefault { get; set; }
    }

    private class TurretLoadout : BaseLoadout
    {
        [JsonProperty("Weapon")]
        public string Weapon;
        [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ulong Skin;
        [JsonProperty("Peacekeeper", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool Peacekeeper;
        [JsonProperty("Attachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public List<string> Attachments;
        [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public AmmoAmount Ammo;
    }

    private class DefaultTurretLoadout : TurretLoadout
    {
        public override bool IsDefault { get; set; }
    }

    private class AmmoAmount
    {
        [JsonProperty("Name")]
        public string Name;
        [JsonProperty("Amount")]
        public int Amount;
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(string userIdString, string messageName, object[] args);
    private string GetMessage(BasePlayer basePlayer, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    private void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    private void ChatMessage(BasePlayer basePlayer, string messageName, object[] args);
    protected override void LoadDefaultMessages();
}

private static class ExposedHooks
{
    public static object OnTurretLoadoutFill(BasePlayer player, BaseEntity turret);
}

private class PlayerData : LoadoutManager
{
    public static PlayerData Get(string ownerId);
    private static string GetFilepath(string ownerId);
    [JsonProperty("OwnerId")]
    public string OwnerId { get; set; }
    [JsonProperty("ActiveLoadout", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string ActiveLoadout;
    public PlayerData(string ownerId);
    public override void SaveData();
    public void RestrictAndPruneLoadouts(LoadoutRuleset ruleset);
}

private abstract class LoadoutManager
{
    private static bool MatchesLoadout(TurretLoadout loadout, string name, bool matchPartial);
    [JsonProperty("Loadouts")]
    public List<TurretLoadout> Loadouts;
    public TurretLoadout FindByName(string loadoutName, bool matchPartial);
    public bool HasLoadout(string loadoutName);
    public void SaveLoadout(TurretLoadout loadout);
    public bool TryUpdateLoadout(TurretLoadout newLoadout);
    public void RenameLoadout(TurretLoadout loadout, string newName);
    public void DeleteLoadout(TurretLoadout loadout);
    public ValidationResult ValidateAndPossiblyReduceLoadout(TurretLoadout loadout, LoadoutRuleset loadoutRuleset, Dictionary<string, int> disallowedItems);
    public abstract void SaveData();
}

private class Configuration : BaseConfiguration
{
    [JsonIgnore]
    public readonly LoadoutRuleset EmptyLoadoutRuleset;
    [JsonProperty("LockAutoFilledTurrets")]
    public bool LockAutoFilledTurrets;
    [JsonProperty("MaxLoadoutsPerPlayer")]
    public int MaxLoadoutsPerPlayer;
    [JsonProperty("DefaultLoadouts")]
    public DefaultTurretLoadout[] DefaultLoadouts;
    [JsonProperty("LoadoutRulesets")]
    public LoadoutRuleset[] LoadoutRulesets;
    [JsonProperty("DefaultSamSiteLoadouts")]
    public DefaultBaseLoadout[] DefaultSamSiteLoadouts;
    [JsonProperty("DefaultFlameTurretLoadouts")]
    public DefaultBaseLoadout[] DefaultFlameTurretLoadouts;
    [JsonProperty("DefaultShotgunTrapLoadouts")]
    public DefaultBaseLoadout[] DefaultShotgunTrapLoadouts;
    public void Init(TurretLoadouts pluginInstance);
}

private abstract class BaseProfile
{
    [JsonProperty("Name")]
    public string Name;
    [JsonIgnore]
    public string Permission;
    public void Init(TurretLoadouts pluginInstance, string permissionPrefix);
}

private class LoadoutRuleset : BaseProfile
{
    [JsonProperty("AllowedWeapons", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string[] AllowedWeapons;
    [JsonProperty("DisallowedWeapons", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string[] DisallowedWeapons;
    [JsonProperty("AllowedAttachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string[] AllowedAttachments;
    [JsonProperty("DisallowedAttachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string[] DisallowedAttachments;
    [JsonProperty("AllowedAmmo", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public Dictionary<string, int> AllowedAmmo;
    public bool IsWeaponAllowed(string weaponName);
    public bool IsAttachmentAllowed(string attachmentName);
}

private class BaseLoadout : BaseProfile
{
    [JsonProperty("ReserveAmmo", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public List<AmmoAmount> ReserveAmmo;
    [JsonIgnore]
    public virtual bool IsDefault { get; set; }
}

private class DefaultBaseLoadout : BaseLoadout
{
    public override bool IsDefault { get; set; }
}

private class TurretLoadout : BaseLoadout
{
    [JsonProperty("Weapon")]
    public string Weapon;
    [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public ulong Skin;
    [JsonProperty("Peacekeeper", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool Peacekeeper;
    [JsonProperty("Attachments", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public List<string> Attachments;
    [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public AmmoAmount Ammo;
}

private class DefaultTurretLoadout : TurretLoadout
{
    public override bool IsDefault { get; set; }
}

private class AmmoAmount
{
    [JsonProperty("Name")]
    public string Name;
    [JsonProperty("Amount")]
    public int Amount;
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## TurretLock by redBDGR - Gives players the ability to lock their turrets

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Turret Lock", "redBDGR", "1.0.2")]
[Description("Gives players the ability to lock their turrets")]
 class TurretLock : RustPlugin
{
    private bool Changed;
    private const string codeLockPrefab;
    private const string effectDenied;
    private const string effectDeployed;
    private const string permissionName;
    private bool doEffects;
    private void Init();
    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private object OnTurretAuthorize(AutoTurret turret, BasePlayer player);
    private object OnTurretDeauthorize(AutoTurret turret, BasePlayer player);
    private object OnTurretShutdown(AutoTurret turret);
    private object OnTurretStartup(AutoTurret turret);
    private void OnLootEntity(BasePlayer player, BaseEntity entity);
    private void OnTurretModeToggle(AutoTurret turret);
    private object OnTurretClearList(AutoTurret turret, BasePlayer player);
    [ChatCommand("lockturret")]
    private void LockTurretCMD(BasePlayer player, string command, string[] args);
    private void AddCodelock(AutoTurret turret);
    private static BasePlayer FindBasePlayer(Vector3 pos);
    private object CheckTurretNoSphereCast(AutoTurret turret, BasePlayer player);
    private object CheckTurret(AutoTurret turret);
    private Item InventoryContainsCodelock(BasePlayer player);
    private void RemoveThink(Item item);
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private string msg(string key, string id);
}


```

---

## TurretManager by WhiteThunder - Automatic turret fill up, auth for self/friends, and more

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core.Plugins;
using ProtoBuf;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Turret Manager", "OrangeDoggo", "1.2.0")]
[Description("Allows you to place down a turret fast & easy. (Auto fill up turret,Auto auth self (or/and friends)")]
internal class TurretManager : CovalencePlugin
{
    [PluginReference]
    private Plugin Friends;
    private Configuration PluginConfig;
    private const string autoFillPerm;
    private const string autoAuthPerm;
    private const string autoTogglePerm;
    private ItemDefinition ammoToLoad;
    private ItemDefinition gunToLoad;
    private void Init();
    private void OnServerInitialized();
    private void OnEntityBuilt(Planner plan, GameObject go);
    private void OnEntityDeath(AutoTurret turret);
    private void OnTurretToggle(AutoTurret turret);
    private object CanMoveItem(Item item);
    private bool HasPermission(BasePlayer player, string perm);
    private bool IsTurretLocked(AutoTurret turret);
    private int GetTotalAmmo(AutoTurret turret);
    internal class Configuration : SerializableConfiguration
    {
        [JsonProperty("Gun (Shortname)")]
        public string GunShortName;
        [JsonProperty("Ammo amount")]
        public int AmmoStackSize;
        [JsonProperty("Stack amount")]
        public int AmountOfStacks;
        [JsonProperty("Lock auto filled turrets (true/false)")]
        public bool LockAutoFilledTurrets;
        [JsonProperty("Auto Authorize Friends (Requires Friends API)")]
        public bool AutoAuthFriends;
        [JsonProperty("Admin Bypass")]
        public bool AdminBypass;
    }

    private Configuration GetDefaultConfig();
    internal class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    internal static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(Configuration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

internal class Configuration : SerializableConfiguration
{
    [JsonProperty("Gun (Shortname)")]
    public string GunShortName;
    [JsonProperty("Ammo amount")]
    public int AmmoStackSize;
    [JsonProperty("Stack amount")]
    public int AmountOfStacks;
    [JsonProperty("Lock auto filled turrets (true/false)")]
    public bool LockAutoFilledTurrets;
    [JsonProperty("Auto Authorize Friends (Requires Friends API)")]
    public bool AutoAuthFriends;
    [JsonProperty("Admin Bypass")]
    public bool AdminBypass;
}

internal class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

internal static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## TurretPacifier by TheFriendlyChap - Prevents autoturrets from targeting innocent players

```csharp

Oxide.Plugins
[Info("Turret Pacifier", "The Friendly Chap", "0.0.3")]
[Description("Prevents AutoTurret from targeting innocents")]
 class TurretPacifier : RustPlugin
{
    private object CanBeTargeted(BasePlayer player, AutoTurret turret);
}


```

---

## TurretSwitches by ziptie - Spawns switches on turrets and SAM sites for players with permission

```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Turret Switches", "ziptie", 1.4)]
[Description("Spawns switches on turrets and SAM sites for players with permission.")]
public class TurretSwitches : CovalencePlugin
{
    public static TurretSwitchesConfig config;
    protected override void LoadDefaultConfig();
    private TurretSwitchesConfig GetDefaultConfig();
    private void Init();
    protected override void LoadDefaultMessages();
    public const string TurretPermission;
    public const string SAMPermission;
    private void RegisterPermissions();
     object OnSwitchToggle(IOEntity entity, BasePlayer player);
     void OnEntitySpawned(AutoTurret entity);
     void OnEntitySpawned(SamSite entity);
     void Unload();
    public void PlayEffect(string EffectPath, Vector3 position);
    public IList<ElectricSwitch> switches;
    public void KillAllSwitches();
    public void AddSwitchesToAllTurrets();
}

public class TurretSwitch : MonoBehaviour
{
    public AutoTurret Turret;
    public bool CanToggleTurret(BasePlayer player);
    public void ToggleTurret(bool toggle);
}

public class SAMSwitch : MonoBehaviour
{
    public SamSite SamSite;
    public bool CanToggleSamSite(BasePlayer player);
    public void ToggleTurret(bool toggle);
}

public class TurretSwitchesConfig
{
    public bool NeedsBuildingPrivilegeToUseSwitch;
    public bool RequiresPermission;
    public bool PlaySoundEffects;
}


```

---

## TurretWeapons by misticos - Control weapons placement in turrets

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Turret Weapons", "Iv Misticos", "1.0.1")]
[Description("Control weapons placement in turrets")]
 class TurretWeapons : CovalencePlugin
{
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Weapons Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, bool> Weapons;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private void OnServerInitialized();
    private void OnEntitySpawned(HeldEntity entity);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Weapons Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, bool> Weapons;
}


```

---

## TwitchAuth by MrBlue - Allows players to authorize themselves as a Twitch follower

```csharp
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Twitch Auth", "Wulf", "1.0.0")]
[Description("Allows players to authorize themselves as a Twitch follower")]
 class TwitchAuth : CovalencePlugin
{
    protected override void LoadDefaultMessages();
    [PluginReference]
    private Plugin Twitch;
    private string TwitchChannel;
    private void Init();
    private void OnServerInitialized();
    private void CommandTwitchAuth(IPlayer player, string command, string[] args);
    private void AddLocalizedCommand(string command);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string textOrLang, object[] args);
}


```

---

## TwitchCommands by MrBlue - Runs commands when a player follows/unfollows on Twitch

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Twitch Commands", "Wulf", "1.0.0")]
[Description("Runs commands when a player follows/unfollows on Twitch")]
 class TwitchCommands : CovalencePlugin
{
    private Configuration config;
     class Configuration
    {
        [JsonProperty("Run commands on player follow")]
        public bool RunFollowCommands { get; set; }
        [JsonProperty("Commands to perform on follow", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> FollowCommands;
        [JsonProperty("Run commands on player unfollow")]
        public bool RunUnfollowCommands { get; set; }
        [JsonProperty("Commands to perform on unfollow", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> UnfollowCommands;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Init();
    private void OnTwitchFollow(IPlayer player);
    private void OnTwitchUnfollow(IPlayer player);
    private string ReplacePlaceholders(string command, IPlayer player);
}

 class Configuration
{
    [JsonProperty("Run commands on player follow")]
    public bool RunFollowCommands { get; set; }
    [JsonProperty("Commands to perform on follow", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> FollowCommands;
    [JsonProperty("Run commands on player unfollow")]
    public bool RunUnfollowCommands { get; set; }
    [JsonProperty("Commands to perform on unfollow", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> UnfollowCommands;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## UFilter by MrBlue - Prevents advertising and/or profanity and optionally punishes player

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("UFilter", "Wulf/lukespragg", "5.1.2")]
[Description("Prevents advertising and/or profanity and optionally punishes player")]
public class UFilter : CovalencePlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("Check for advertising (true/false)")]
        public bool CheckForAdvertising;
        [JsonProperty("Check for profanity (true/false)")]
        public bool CheckForProfanity;
        [JsonProperty("Check player chat (true/false)")]
        public bool CheckChat;
        [JsonProperty("Check player names (true/false)")]
        public bool CheckNames;
        [JsonProperty("Log advertising (true/false)")]
        public bool LogAdvertising;
        [JsonProperty("Log profanity (true/false)")]
        public bool LogProfanity;
        [JsonProperty("Log to console (true/false)")]
        public bool LogToConsole;
        [JsonProperty("Log to file (true/false)")]
        public bool LogToFile;
        [JsonProperty("Warn player in chat (true/false)")]
        public bool WarnInChat;
        [JsonProperty("Action for advertising")]
        public string ActionForAdvertising;
        [JsonProperty("Action for profanity")]
        public string ActionForProfanity;
        [JsonProperty("Word or symbol to use for censoring")]
        public string CensorText;
        [JsonProperty("Allowed advertisements")]
        public List<string> AllowedAds;
        [JsonProperty("Allowed profanity")]
        public List<string> AllowedProfanity;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private new void LoadDefaultMessages();
    [PluginReference]
    private readonly Plugin BetterChat;
    private readonly Plugin Slap;
    private const string permAdmin;
    private const string permBypass;
    private static readonly Regex ipRegex;
    private static readonly Regex domainRegex;
    private StoredData storedData;
    private class StoredData
    {
        public readonly HashSet<string> Profanities;
    }

    private void OnServerInitialized();
    private void SaveData();
    private string[] Advertisements(string text);
    private string[] Profanities(string text);
    private string ProcessText(string text, IPlayer player);
    private string TakeAction(IPlayer player, string text, string[] list, string action, string reason);
    private string HandleChat(IPlayer player, string message);
    private object OnBetterChat(Dictionary<string, object> data);
    private object OnUserChat(IPlayer player, string message);
    private void ProcessName(IPlayer player);
    private void OnUserRespawned(IPlayer player);
    private void OnUserSpawned(IPlayer player);
    private string[] GetProfanities();
    private string[] GetAllowedProfanity();
    private bool AddProfanity(string profanity);
    private bool RemoveProfanity(string profanity);
    [Command("ufilter")]
    private void FilterCommand(IPlayer player, string command, string[] args);
    private void AddLocalizedCommand(string key, string command);
    private void Broadcast(IPlayer sender, string text, int channel);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string textOrLang, object[] args);
    private void Log(string text, string filename);
}

public class Configuration
{
    [JsonProperty("Check for advertising (true/false)")]
    public bool CheckForAdvertising;
    [JsonProperty("Check for profanity (true/false)")]
    public bool CheckForProfanity;
    [JsonProperty("Check player chat (true/false)")]
    public bool CheckChat;
    [JsonProperty("Check player names (true/false)")]
    public bool CheckNames;
    [JsonProperty("Log advertising (true/false)")]
    public bool LogAdvertising;
    [JsonProperty("Log profanity (true/false)")]
    public bool LogProfanity;
    [JsonProperty("Log to console (true/false)")]
    public bool LogToConsole;
    [JsonProperty("Log to file (true/false)")]
    public bool LogToFile;
    [JsonProperty("Warn player in chat (true/false)")]
    public bool WarnInChat;
    [JsonProperty("Action for advertising")]
    public string ActionForAdvertising;
    [JsonProperty("Action for profanity")]
    public string ActionForProfanity;
    [JsonProperty("Word or symbol to use for censoring")]
    public string CensorText;
    [JsonProperty("Allowed advertisements")]
    public List<string> AllowedAds;
    [JsonProperty("Allowed profanity")]
    public List<string> AllowedProfanity;
}

private class StoredData
{
    public readonly HashSet<string> Profanities;
}


```

---

## UGather by dFxPhoeniX - Adds zones, permissions, and other options to modify gather rates!

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("UGather", "dFxPhoeniX", "1.1.6")]
[Description("Adds zones, permissions, and other options to modify gather rates!")]
 class UGather : RustPlugin
{
    [PluginReference]
     Plugin ZoneManager;
    public static UGather plugin;
    private DynamicConfigFile ZoneDataFile;
    private ZoneData zoneData;
    private Configuration config;
    private const string SphereEnt;
    public class ZoneData
    {
        public List<GatherZone> Zones;
        public GatherZone GetZoneByID(string id);
    }

    public class GatherZone
    {
        public string enterMessage;
        public string leaveMessage;
        public string permissionToUse;
        public bool requireUserHavePermission;
        public bool overTakePriority;
        public bool restrictPermission;
        public float x;
        public float y;
        public float z;
        public string id;
        public int radius;
        public void OnPlayerEntered(BasePlayer player);
        public void OnPlayerLeave(BasePlayer player);
    }

    private void SaveData();
    private void LoadData();
    private void OnEnterZone(string ZoneID, BasePlayer player);
    private void OnExitZone(string ZoneID, BasePlayer player);
    public class Configuration
    {
        [JsonProperty(PropertyName = "Gather Perms : The list of permissions that grant specified gather rates.")]
        public Dictionary<string, Dictionary<string, Dictionary<string, float>>> GatherPerms;
        [JsonProperty(PropertyName = "Base Permission : The basic permission given to group default.")]
        public string BasePerm;
        [JsonProperty(PropertyName = "Default Group : The group all players should be in, these players get the base perm.")]
        public string DefaultGroup;
        [JsonProperty(PropertyName = "Stackable Permissions : If a user has multiple perms, should they stack gather rate.")]
        public bool Stack;
    }

    protected override void LoadDefaultConfig();
     void SaveConfig(Configuration config);
    public void LoadConfigVars();
     void Loaded();
     void Reply(BasePlayer player, string raw, string[] args);
    [ChatCommand("ugather")]
     void UGather_Command(BasePlayer player, string command, string[] args);
    public float GetZoneRate(string permission, string type, string name);
    public float GetStackedMultiplier(BasePlayer player, string type, string name, bool forced, Vector3 usePosition);
    public float GetSingleMultiplier(BasePlayer player, string type, string name, bool forced, Vector3 usePosition);
    private void Unload();
    private void OnQuarryGather(MiningQuarry quarry, Item item);
    private void OnCollectiblePickup(Item item, BasePlayer player);
     Dictionary<BaseEntity, BasePlayer> SurveyCharges;
     void OnExplosiveThrown(BasePlayer player, BaseEntity entity);
     void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
    private void OnSurveyGather(SurveyCharge survey, Item item);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
}

public class ZoneData
{
    public List<GatherZone> Zones;
    public GatherZone GetZoneByID(string id);
}

public class GatherZone
{
    public string enterMessage;
    public string leaveMessage;
    public string permissionToUse;
    public bool requireUserHavePermission;
    public bool overTakePriority;
    public bool restrictPermission;
    public float x;
    public float y;
    public float z;
    public string id;
    public int radius;
    public void OnPlayerEntered(BasePlayer player);
    public void OnPlayerLeave(BasePlayer player);
}

public class Configuration
{
    [JsonProperty(PropertyName = "Gather Perms : The list of permissions that grant specified gather rates.")]
    public Dictionary<string, Dictionary<string, Dictionary<string, float>>> GatherPerms;
    [JsonProperty(PropertyName = "Base Permission : The basic permission given to group default.")]
    public string BasePerm;
    [JsonProperty(PropertyName = "Default Group : The group all players should be in, these players get the base perm.")]
    public string DefaultGroup;
    [JsonProperty(PropertyName = "Stackable Permissions : If a user has multiple perms, should they stack gather rate.")]
    public bool Stack;
}


```

---

## UiBuilderLibrary by BlueBeka - Allows for easily creating complex UIs.

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using static Oxide.Plugins.UiBuilderLibrary.Element.Instance;

Oxide.Plugins
[Info("UI Builder Library", "BlueBeka", "0.0.1")]
[Description("Allows for easily creating complex UIs.")]
public class UiBuilderLibrary : RustPlugin
{
    private static UiBuilderLibrary SelfRef;
    private PluginConfig config;
    private PluginData data;
    private void Init();
    private void Loaded();
    private void OnServerSave();
    private void Unload();
    private void OnUserDisconnected(IPlayer player);
    protected override void SaveConfig();
    protected override void LoadConfig();
    private class PluginConfig
    {
        private readonly UiBuilderLibrary plugin;
        public Data data;
        public PluginConfig(UiBuilderLibrary plugin);
        public void Save();
        public void Load();
        private void SaveSerializable(T sData);
        private void SaveSerializable(string file, T sData);
        private T LoadSerializable();
        private T LoadSerializable(string file);
        public class Data
        {
            public double DefaultScreenAspectRatio;
            public double DefaultRenderScale;
        }

    }

    private class PluginData
    {
        private readonly string Filename;
        public Dictionary<ulong, Structure> PlayerData { get; set; }
        public PluginData(UiBuilderLibrary plugin, string file);
        public class Structure
        {
            public double ScreenAspectRatio;
            public double RenderScale;
        }

        public void Save();
        public void Load();
    }

    private PluginData.Structure GetPlayerData(BasePlayer player);
    public double GetScreenAspectRatio(BasePlayer player);
    public void SetScreenAspectRatio(BasePlayer player, double value);
    public double GetRenderScale(BasePlayer player);
    public void SetRenderScale(BasePlayer player, double value);
    public class UI
    {
        private static readonly List<WeakReference<UI>> AllUis;
        public static readonly string FontBold;
        public static readonly string FontRegular;
        public static readonly string FontMono;
        public static readonly string FontMarker;
        private RootElement Root { get; set; }
        public UI(string parentId, RootElement.RenderUi rootBuilder);
        internal static IEnumerable<UI> GetAllUis();
        public void Open(BasePlayer player);
        public void Close(BasePlayer player);
        public void CloseAll();
        internal void Clear(BasePlayer player);
        public static double GetScreenAspectRatio(BasePlayer player);
        public static void SetScreenAspectRatio(BasePlayer player, double value);
        public static double GetRenderScale(BasePlayer player);
        public static void SetRenderScale(BasePlayer player, double value);
        private static IEnumerable<string> ToJson(Element.Instance element, HashSet<string> roots);
        private static HashSet<string> GetRootElements(IEnumerable<Element.Instance> elements);
    }

    public abstract class Element
    {
        protected readonly Dictionary<ulong, Instance> InstanceCache;
        private readonly string ParentId;
        private readonly Element Parent;
        internal Element(Element parent);
        internal Element(string parentId);
        public T GetInstance(BasePlayer player);
        public abstract void Build(BasePlayer player, List<Instance> updatedElements, bool parentHasUpdates);
        public void Clear(BasePlayer player);
        public abstract class Instance
        {
            public string Id { get; set; }
            protected readonly Element Element;
            protected readonly Instance Parent;
            public BasePlayer Player { get; set; }
            public BoundingBox Bounds { get; set; }
            public bool Visible { get; set; }
            protected readonly List<Element> Children;
            private int BuildingChildIndex;
            internal bool Initialized;
            public Instance(Element element, BasePlayer player);
            public string GetParentId();
            public bool IsOpen();
            private bool IsOpen(Instance instance);
            public void Build(List<Instance> updatedElements, bool parentHasUpdates);
            public abstract bool Render();
            public void Clear();
            protected T AddChild(T element);
            protected T AddChild();
            public abstract IEnumerable<CuiElement> GetCuiElements();
        }

        public class BoundingBox
        {
            private readonly Instance Parent;
            public double MinX { get; set; }
            public double MinY { get; set; }
            public double MaxX { get; set; }
            public double MaxY { get; set; }
            public BoundingBox(Instance parent);
            public double GetAspectRatio(BasePlayer player);
            public double GetWidth();
            public double GetHeight();
            public double GetRelativeWidth(BasePlayer player);
            public double GetRelativeHeight(BasePlayer player);
            public CuiRectTransformComponent GetCuiComponent();
        }

    }

    public class RootElement : PanelElement
    {
        protected internal RenderUi Renderer;
        internal RootElement(string parentId, RenderUi renderer);
        public Instance GetOrCreateInstance(BasePlayer player);
        public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
        public new class Instance : PanelElement.Instance
        {
            internal bool Open;
            internal Instance(Element element, BasePlayer player);
            public override bool Render();
        }

    }

    public class PanelElement : Element
    {
        internal PanelElement(Element parent);
        internal PanelElement(string parentId);
        public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
        public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
        public new class Instance : Element.Instance
        {
            public readonly CuiImageComponent Image;
            public bool CursorEnabled;
            public bool KeyboardEnabled;
            protected internal RenderUi<Instance> Renderer { get; set; }
            internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
            public override bool Render();
            public override IEnumerable<CuiElement> GetCuiElements();
            public void AddPanel(RenderUi<Instance> renderer);
            public void AddLabel(RenderUi<LabelElement.Instance> renderer);
            public void AddButton(RenderUi<ButtonElement.Instance> renderer);
            public void AddGameImage(RenderUi<GameImageElement.Instance> renderer);
            public void AddRawImage(RenderUi<RawImageElement.Instance> renderer);
            public void AddTabs(RenderUi<TabsElement.Instance> renderer);
            public void AddGrid(RenderUi<GridElement.Instance> renderer);
        }

    }

    public class LabelElement : Element
    {
        internal LabelElement(Element parent);
        public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
        public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
        public new class Instance : Element.Instance
        {
            public readonly CuiTextComponent Text;
            protected internal RenderUi<Instance> Renderer { get; set; }
            internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
            public override bool Render();
            public override IEnumerable<CuiElement> GetCuiElements();
        }

    }

    public class ButtonElement : Element
    {
        internal ButtonElement(Element parent);
        public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
        public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
        public new class Instance : Element.Instance
        {
            public readonly CuiButtonComponent Button;
            public readonly CuiTextComponent Text;
            protected internal RenderUi<Instance> Renderer { get; set; }
            internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
            public override bool Render();
            public override IEnumerable<CuiElement> GetCuiElements();
        }

    }

    public class RawImageElement : Element
    {
        internal RawImageElement(Element parent);
        public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
        public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
        public new class Instance : Element.Instance
        {
            public readonly CuiRawImageComponent Image;
            protected internal RenderUi<Instance> Renderer { get; set; }
            internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
            public override bool Render();
            public override IEnumerable<CuiElement> GetCuiElements();
        }

    }

    public class GameImageElement : Element
    {
        internal GameImageElement(Element parent);
        public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
        public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
        public new class Instance : Element.Instance
        {
            public readonly CuiImageComponent Image;
            protected internal RenderUi<Instance> Renderer { get; set; }
            internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
            public override bool Render();
            public override IEnumerable<CuiElement> GetCuiElements();
        }

    }

    public class TabsElement : PanelElement
    {
        internal TabsElement(Element parent);
        public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
        public new class Instance : PanelElement.Instance
        {
            public bool Vertical;
            public double Gap;
            public double MaxButtonSize;
            private int _BuildingTabIndex;
            private int TabsCount;
            protected internal new RenderUi<Instance> Renderer { get; set; }
            internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
            public override bool Render();
            public void AddTab(RenderUi<ButtonElement.Instance> renderer);
            private void SetTabDefaults(ButtonElement.Instance button);
        }

    }

    public class GridElement : PanelElement
    {
        internal GridElement(Element parent);
        public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
        public new class Instance : PanelElement.Instance
        {
            public double GapX;
            public double GapY;
            public int Rows;
            public int Columns;
            private int _BuildingCellIndex;
            protected internal new RenderUi<Instance> Renderer { get; set; }
            internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
            public override bool Render();
            public void AddCell(RenderUi<PanelElement.Instance> renderer);
            private void SetCellDefaults(PanelElement.Instance cell);
        }

    }

}

private class PluginConfig
{
    private readonly UiBuilderLibrary plugin;
    public Data data;
    public PluginConfig(UiBuilderLibrary plugin);
    public void Save();
    public void Load();
    private void SaveSerializable(T sData);
    private void SaveSerializable(string file, T sData);
    private T LoadSerializable();
    private T LoadSerializable(string file);
    public class Data
    {
        public double DefaultScreenAspectRatio;
        public double DefaultRenderScale;
    }

}

public class Data
{
    public double DefaultScreenAspectRatio;
    public double DefaultRenderScale;
}

private class PluginData
{
    private readonly string Filename;
    public Dictionary<ulong, Structure> PlayerData { get; set; }
    public PluginData(UiBuilderLibrary plugin, string file);
    public class Structure
    {
        public double ScreenAspectRatio;
        public double RenderScale;
    }

    public void Save();
    public void Load();
}

public class Structure
{
    public double ScreenAspectRatio;
    public double RenderScale;
}

public class UI
{
    private static readonly List<WeakReference<UI>> AllUis;
    public static readonly string FontBold;
    public static readonly string FontRegular;
    public static readonly string FontMono;
    public static readonly string FontMarker;
    private RootElement Root { get; set; }
    public UI(string parentId, RootElement.RenderUi rootBuilder);
    internal static IEnumerable<UI> GetAllUis();
    public void Open(BasePlayer player);
    public void Close(BasePlayer player);
    public void CloseAll();
    internal void Clear(BasePlayer player);
    public static double GetScreenAspectRatio(BasePlayer player);
    public static void SetScreenAspectRatio(BasePlayer player, double value);
    public static double GetRenderScale(BasePlayer player);
    public static void SetRenderScale(BasePlayer player, double value);
    private static IEnumerable<string> ToJson(Element.Instance element, HashSet<string> roots);
    private static HashSet<string> GetRootElements(IEnumerable<Element.Instance> elements);
}

public abstract class Element
{
    protected readonly Dictionary<ulong, Instance> InstanceCache;
    private readonly string ParentId;
    private readonly Element Parent;
    internal Element(Element parent);
    internal Element(string parentId);
    public T GetInstance(BasePlayer player);
    public abstract void Build(BasePlayer player, List<Instance> updatedElements, bool parentHasUpdates);
    public void Clear(BasePlayer player);
    public abstract class Instance
    {
        public string Id { get; set; }
        protected readonly Element Element;
        protected readonly Instance Parent;
        public BasePlayer Player { get; set; }
        public BoundingBox Bounds { get; set; }
        public bool Visible { get; set; }
        protected readonly List<Element> Children;
        private int BuildingChildIndex;
        internal bool Initialized;
        public Instance(Element element, BasePlayer player);
        public string GetParentId();
        public bool IsOpen();
        private bool IsOpen(Instance instance);
        public void Build(List<Instance> updatedElements, bool parentHasUpdates);
        public abstract bool Render();
        public void Clear();
        protected T AddChild(T element);
        protected T AddChild();
        public abstract IEnumerable<CuiElement> GetCuiElements();
    }

    public class BoundingBox
    {
        private readonly Instance Parent;
        public double MinX { get; set; }
        public double MinY { get; set; }
        public double MaxX { get; set; }
        public double MaxY { get; set; }
        public BoundingBox(Instance parent);
        public double GetAspectRatio(BasePlayer player);
        public double GetWidth();
        public double GetHeight();
        public double GetRelativeWidth(BasePlayer player);
        public double GetRelativeHeight(BasePlayer player);
        public CuiRectTransformComponent GetCuiComponent();
    }

}

public abstract class Instance
{
    public string Id { get; set; }
    protected readonly Element Element;
    protected readonly Instance Parent;
    public BasePlayer Player { get; set; }
    public BoundingBox Bounds { get; set; }
    public bool Visible { get; set; }
    protected readonly List<Element> Children;
    private int BuildingChildIndex;
    internal bool Initialized;
    public Instance(Element element, BasePlayer player);
    public string GetParentId();
    public bool IsOpen();
    private bool IsOpen(Instance instance);
    public void Build(List<Instance> updatedElements, bool parentHasUpdates);
    public abstract bool Render();
    public void Clear();
    protected T AddChild(T element);
    protected T AddChild();
    public abstract IEnumerable<CuiElement> GetCuiElements();
}

public class BoundingBox
{
    private readonly Instance Parent;
    public double MinX { get; set; }
    public double MinY { get; set; }
    public double MaxX { get; set; }
    public double MaxY { get; set; }
    public BoundingBox(Instance parent);
    public double GetAspectRatio(BasePlayer player);
    public double GetWidth();
    public double GetHeight();
    public double GetRelativeWidth(BasePlayer player);
    public double GetRelativeHeight(BasePlayer player);
    public CuiRectTransformComponent GetCuiComponent();
}

public class RootElement : PanelElement
{
    protected internal RenderUi Renderer;
    internal RootElement(string parentId, RenderUi renderer);
    public Instance GetOrCreateInstance(BasePlayer player);
    public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
    public new class Instance : PanelElement.Instance
    {
        internal bool Open;
        internal Instance(Element element, BasePlayer player);
        public override bool Render();
    }

}

public new class Instance : PanelElement.Instance
{
    internal bool Open;
    internal Instance(Element element, BasePlayer player);
    public override bool Render();
}

public class PanelElement : Element
{
    internal PanelElement(Element parent);
    internal PanelElement(string parentId);
    public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
    public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
    public new class Instance : Element.Instance
    {
        public readonly CuiImageComponent Image;
        public bool CursorEnabled;
        public bool KeyboardEnabled;
        protected internal RenderUi<Instance> Renderer { get; set; }
        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
        public override bool Render();
        public override IEnumerable<CuiElement> GetCuiElements();
        public void AddPanel(RenderUi<Instance> renderer);
        public void AddLabel(RenderUi<LabelElement.Instance> renderer);
        public void AddButton(RenderUi<ButtonElement.Instance> renderer);
        public void AddGameImage(RenderUi<GameImageElement.Instance> renderer);
        public void AddRawImage(RenderUi<RawImageElement.Instance> renderer);
        public void AddTabs(RenderUi<TabsElement.Instance> renderer);
        public void AddGrid(RenderUi<GridElement.Instance> renderer);
    }

}

public new class Instance : Element.Instance
{
    public readonly CuiImageComponent Image;
    public bool CursorEnabled;
    public bool KeyboardEnabled;
    protected internal RenderUi<Instance> Renderer { get; set; }
    internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
    public override bool Render();
    public override IEnumerable<CuiElement> GetCuiElements();
    public void AddPanel(RenderUi<Instance> renderer);
    public void AddLabel(RenderUi<LabelElement.Instance> renderer);
    public void AddButton(RenderUi<ButtonElement.Instance> renderer);
    public void AddGameImage(RenderUi<GameImageElement.Instance> renderer);
    public void AddRawImage(RenderUi<RawImageElement.Instance> renderer);
    public void AddTabs(RenderUi<TabsElement.Instance> renderer);
    public void AddGrid(RenderUi<GridElement.Instance> renderer);
}

public class LabelElement : Element
{
    internal LabelElement(Element parent);
    public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
    public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
    public new class Instance : Element.Instance
    {
        public readonly CuiTextComponent Text;
        protected internal RenderUi<Instance> Renderer { get; set; }
        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
        public override bool Render();
        public override IEnumerable<CuiElement> GetCuiElements();
    }

}

public new class Instance : Element.Instance
{
    public readonly CuiTextComponent Text;
    protected internal RenderUi<Instance> Renderer { get; set; }
    internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
    public override bool Render();
    public override IEnumerable<CuiElement> GetCuiElements();
}

public class ButtonElement : Element
{
    internal ButtonElement(Element parent);
    public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
    public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
    public new class Instance : Element.Instance
    {
        public readonly CuiButtonComponent Button;
        public readonly CuiTextComponent Text;
        protected internal RenderUi<Instance> Renderer { get; set; }
        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
        public override bool Render();
        public override IEnumerable<CuiElement> GetCuiElements();
    }

}

public new class Instance : Element.Instance
{
    public readonly CuiButtonComponent Button;
    public readonly CuiTextComponent Text;
    protected internal RenderUi<Instance> Renderer { get; set; }
    internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
    public override bool Render();
    public override IEnumerable<CuiElement> GetCuiElements();
}

public class RawImageElement : Element
{
    internal RawImageElement(Element parent);
    public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
    public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
    public new class Instance : Element.Instance
    {
        public readonly CuiRawImageComponent Image;
        protected internal RenderUi<Instance> Renderer { get; set; }
        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
        public override bool Render();
        public override IEnumerable<CuiElement> GetCuiElements();
    }

}

public new class Instance : Element.Instance
{
    public readonly CuiRawImageComponent Image;
    protected internal RenderUi<Instance> Renderer { get; set; }
    internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
    public override bool Render();
    public override IEnumerable<CuiElement> GetCuiElements();
}

public class GameImageElement : Element
{
    internal GameImageElement(Element parent);
    public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
    public override void Build(BasePlayer player, List<Element.Instance> updatedElements, bool parentHasUpdates);
    public new class Instance : Element.Instance
    {
        public readonly CuiImageComponent Image;
        protected internal RenderUi<Instance> Renderer { get; set; }
        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
        public override bool Render();
        public override IEnumerable<CuiElement> GetCuiElements();
    }

}

public new class Instance : Element.Instance
{
    public readonly CuiImageComponent Image;
    protected internal RenderUi<Instance> Renderer { get; set; }
    internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
    public override bool Render();
    public override IEnumerable<CuiElement> GetCuiElements();
}

public class TabsElement : PanelElement
{
    internal TabsElement(Element parent);
    public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
    public new class Instance : PanelElement.Instance
    {
        public bool Vertical;
        public double Gap;
        public double MaxButtonSize;
        private int _BuildingTabIndex;
        private int TabsCount;
        protected internal new RenderUi<Instance> Renderer { get; set; }
        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
        public override bool Render();
        public void AddTab(RenderUi<ButtonElement.Instance> renderer);
        private void SetTabDefaults(ButtonElement.Instance button);
    }

}

public new class Instance : PanelElement.Instance
{
    public bool Vertical;
    public double Gap;
    public double MaxButtonSize;
    private int _BuildingTabIndex;
    private int TabsCount;
    protected internal new RenderUi<Instance> Renderer { get; set; }
    internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
    public override bool Render();
    public void AddTab(RenderUi<ButtonElement.Instance> renderer);
    private void SetTabDefaults(ButtonElement.Instance button);
}

public class GridElement : PanelElement
{
    internal GridElement(Element parent);
    public Instance GetOrCreateInstance(BasePlayer player, RenderUi<Instance> renderer);
    public new class Instance : PanelElement.Instance
    {
        public double GapX;
        public double GapY;
        public int Rows;
        public int Columns;
        private int _BuildingCellIndex;
        protected internal new RenderUi<Instance> Renderer { get; set; }
        internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
        public override bool Render();
        public void AddCell(RenderUi<PanelElement.Instance> renderer);
        private void SetCellDefaults(PanelElement.Instance cell);
    }

}

public new class Instance : PanelElement.Instance
{
    public double GapX;
    public double GapY;
    public int Rows;
    public int Columns;
    private int _BuildingCellIndex;
    protected internal new RenderUi<Instance> Renderer { get; set; }
    internal Instance(Element element, BasePlayer player, RenderUi<Instance> renderer);
    public override bool Render();
    public void AddCell(RenderUi<PanelElement.Instance> renderer);
    private void SetCellDefaults(PanelElement.Instance cell);
}


```

---

## UINotify by Mevent - Adds custom notifications for players

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Plugins.UINotifyExtensionMethods;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("UI Notify", "Mevent", "1.0.12")]
[Description("Adds custom notifications for players")]
public class UINotify : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private const string Layer;
    private static UINotify _instance;
    private readonly Dictionary<ulong, NotifyComponent> _notifications;
    private class NotifyData
    {
        public string Message;
        public int Type;
        public readonly string Uid;
        public float StartTime;
    }

    private const string PermSeeNotify;
    private const string PermNotify;
    private const string PermPlayerNotify;
    private const string PermAllPlayersNotify;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Display type (Overlay/Hud)")]
        public string DisplayType;
        [JsonProperty(PropertyName = "Height")]
        public float Height;
        [JsonProperty(PropertyName = "Width")]
        public float Width;
        [JsonProperty(PropertyName = "X Margin")]
        public float XMargin;
        [JsonProperty(PropertyName = "Y Margin")]
        public float YMargin;
        [JsonProperty(PropertyName = "Y Indent")]
        public float ConstYSwitch;
        [JsonProperty(PropertyName = "Display notifications on the top right?")]
        public bool IsUpperRight;
        [JsonProperty(PropertyName = "Notify Cooldown")]
        public float Cooldown;
        [JsonProperty(PropertyName = "Max Notifications On Screen")]
        public int MaxNotificationsOnScreen;
        [JsonProperty(PropertyName = "Send text message to chat if player doesn't have notification permission")]
        public bool SendTextMessageOnDontHavePermission;
        [JsonProperty(PropertyName = "Notifications (type - settings)",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<int, NotifyType> Types;
        public VersionNumber Version;
    }

    protected override void LoadConfig();
    private void UpdateConfigValues();
    private class TextSettings : InterfacePosition
    {
        [JsonProperty(PropertyName = "fontSize")]
        public int FontSize;
        [JsonProperty(PropertyName = "Is Bold?")]
        public bool IsBold;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Color")]
        public IColor Color;
    }

    private class NotifyType
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Background Image")]
        public string BackgroundImage;
        [JsonProperty(PropertyName = "Background Color")]
        public IColor BackgroundColor;
        [JsonProperty(PropertyName = "Enable Gradient?")]
        public bool EnableGradient;
        [JsonProperty(PropertyName = "Gradient Color")]
        public IColor GradientColor;
        [JsonProperty(PropertyName = "Sprite")]
        public string Sprite;
        [JsonProperty(PropertyName = "Material")]
        public string Material;
        [JsonProperty(PropertyName = "Icon Color")]
        public IColor IconColor;
        [JsonProperty(PropertyName = "Icon Text")]
        public string IconText;
        [JsonProperty(PropertyName = "Title Key (lang)")]
        public string TitleKey;
        [JsonProperty(PropertyName = "Fade Out")]
        public float FadeOut;
        [JsonProperty(PropertyName = "Fade In")]
        public float FadeIn;
        [JsonProperty(PropertyName = "Sound Effect (empty - disable)")]
        public string Effect;
        [JsonProperty(PropertyName = "Image Settings")]
        public ImageSettings Image;
        [JsonProperty(PropertyName = "Use custom width")]
        public bool UseCustomWidth;
        [JsonProperty(PropertyName = "Custom width")]
        public float CustomWidth;
        [JsonProperty(PropertyName = "Use custom height")]
        public bool UseCustomHeight;
        [JsonProperty(PropertyName = "Custom height")]
        public float CustomHeight;
        [JsonProperty(PropertyName = "Use command")]
        public bool UseCommand;
        [JsonProperty(PropertyName = "Command")]
        public string Command;
        [JsonProperty(PropertyName = "Close after using the command?")]
        public bool CloseAfterUsingCommand;
        [JsonProperty(PropertyName = "Icon Settings")]
        public TextSettings IconSettings;
        [JsonProperty(PropertyName = "Title Settings")]
        public TextSettings TitleSettings;
        [JsonProperty(PropertyName = "Text Settings")]
        public TextSettings TextSettings;
        [JsonProperty(PropertyName = "Use custom cooldown")]
        public bool UseCustomCooldown;
        [JsonProperty(PropertyName = "Cooldown")]
        public float Cooldown;
        public float Get(BasePlayer player, CuiElementContainer container, NotifyData data, float ySwitch);
        private void ButtonUI(CuiElementContainer container, string parent, string closeLayer);
        private void MessageUI(CuiElementContainer container, string message, string parent);
        private void TitleUI(BasePlayer player, CuiElementContainer container, string parent);
        private void IconUI(CuiElementContainer container, string parent);
        private void GradientUI(CuiElementContainer container, string parent);
        private string BackgroundUI(CuiElementContainer container, string uid, float ySwitch, float width, float height);
    }

    private class InterfacePosition
    {
        public string AnchorMin;
        public string AnchorMax;
        public string OffsetMin;
        public string OffsetMax;
    }

    private class ImageSettings : InterfacePosition
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Image")]
        public string Image;
    }

    private class IColor
    {
        [JsonProperty(PropertyName = "HEX")]
        public string Hex;
        [JsonProperty(PropertyName = "Opacity (0 - 100)")]
        public float Alpha;
        public string Get();
        public IColor(string hex, float alpha);
    }

    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private void OnServerInitialized();
    private void Unload();
    private void CmdShowNotify(IPlayer cov, string command, string[] args);
    private void CmdShowPlayerNotify(IPlayer cov, string command, string[] args);
    private void CmdShowAllPlayerNotify(IPlayer cov, string command, string[] args);
    private class NotifyComponent : FacepunchBehaviour
    {
        private BasePlayer _player;
        private readonly List<NotifyData> _notifies;
        private CuiElementContainer container;
        private void Awake();
        private void OnDestroy();
        public void Kill();
        private void MainUi();
        private float NotifyUi(CuiElementContainer cont, NotifyData data, float ySwitch);
        public void AddNotify(NotifyData data);
        private void RemoveNotify(int index);
        private void NotificationsController();
        private void SendEffect(string effect);
    }

    private void LoadImages();
    private void RegisterCommands();
    private void RegisterPermissions();
    private void SendNotifyAllPlayers(int type, string message);
    private void SendNotify(string userId, int type, string message);
    private void SendNotify(ulong userId, int type, string message);
    private void SendNotify(BasePlayer player, int type, string message);
    private NotifyComponent GetComponent(BasePlayer player);
    private bool TryToggleType(int type, bool newValue);
    private const string NotFound;
    private const string SyntaxAllPlayerNotify;
    private const string SyntaxPlayerNotify;
    private const string SyntaxNotify;
    protected override void LoadDefaultMessages();
    private string Msg(BasePlayer player, string key, object[] obj);
    private string Msg(string player, string key, object[] obj);
}

private class NotifyData
{
    public string Message;
    public int Type;
    public readonly string Uid;
    public float StartTime;
}

private class Configuration
{
    [JsonProperty(PropertyName = "Display type (Overlay/Hud)")]
    public string DisplayType;
    [JsonProperty(PropertyName = "Height")]
    public float Height;
    [JsonProperty(PropertyName = "Width")]
    public float Width;
    [JsonProperty(PropertyName = "X Margin")]
    public float XMargin;
    [JsonProperty(PropertyName = "Y Margin")]
    public float YMargin;
    [JsonProperty(PropertyName = "Y Indent")]
    public float ConstYSwitch;
    [JsonProperty(PropertyName = "Display notifications on the top right?")]
    public bool IsUpperRight;
    [JsonProperty(PropertyName = "Notify Cooldown")]
    public float Cooldown;
    [JsonProperty(PropertyName = "Max Notifications On Screen")]
    public int MaxNotificationsOnScreen;
    [JsonProperty(PropertyName = "Send text message to chat if player doesn't have notification permission")]
    public bool SendTextMessageOnDontHavePermission;
    [JsonProperty(PropertyName = "Notifications (type - settings)",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<int, NotifyType> Types;
    public VersionNumber Version;
}

private class TextSettings : InterfacePosition
{
    [JsonProperty(PropertyName = "fontSize")]
    public int FontSize;
    [JsonProperty(PropertyName = "Is Bold?")]
    public bool IsBold;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Color")]
    public IColor Color;
}

private class NotifyType
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Background Image")]
    public string BackgroundImage;
    [JsonProperty(PropertyName = "Background Color")]
    public IColor BackgroundColor;
    [JsonProperty(PropertyName = "Enable Gradient?")]
    public bool EnableGradient;
    [JsonProperty(PropertyName = "Gradient Color")]
    public IColor GradientColor;
    [JsonProperty(PropertyName = "Sprite")]
    public string Sprite;
    [JsonProperty(PropertyName = "Material")]
    public string Material;
    [JsonProperty(PropertyName = "Icon Color")]
    public IColor IconColor;
    [JsonProperty(PropertyName = "Icon Text")]
    public string IconText;
    [JsonProperty(PropertyName = "Title Key (lang)")]
    public string TitleKey;
    [JsonProperty(PropertyName = "Fade Out")]
    public float FadeOut;
    [JsonProperty(PropertyName = "Fade In")]
    public float FadeIn;
    [JsonProperty(PropertyName = "Sound Effect (empty - disable)")]
    public string Effect;
    [JsonProperty(PropertyName = "Image Settings")]
    public ImageSettings Image;
    [JsonProperty(PropertyName = "Use custom width")]
    public bool UseCustomWidth;
    [JsonProperty(PropertyName = "Custom width")]
    public float CustomWidth;
    [JsonProperty(PropertyName = "Use custom height")]
    public bool UseCustomHeight;
    [JsonProperty(PropertyName = "Custom height")]
    public float CustomHeight;
    [JsonProperty(PropertyName = "Use command")]
    public bool UseCommand;
    [JsonProperty(PropertyName = "Command")]
    public string Command;
    [JsonProperty(PropertyName = "Close after using the command?")]
    public bool CloseAfterUsingCommand;
    [JsonProperty(PropertyName = "Icon Settings")]
    public TextSettings IconSettings;
    [JsonProperty(PropertyName = "Title Settings")]
    public TextSettings TitleSettings;
    [JsonProperty(PropertyName = "Text Settings")]
    public TextSettings TextSettings;
    [JsonProperty(PropertyName = "Use custom cooldown")]
    public bool UseCustomCooldown;
    [JsonProperty(PropertyName = "Cooldown")]
    public float Cooldown;
    public float Get(BasePlayer player, CuiElementContainer container, NotifyData data, float ySwitch);
    private void ButtonUI(CuiElementContainer container, string parent, string closeLayer);
    private void MessageUI(CuiElementContainer container, string message, string parent);
    private void TitleUI(BasePlayer player, CuiElementContainer container, string parent);
    private void IconUI(CuiElementContainer container, string parent);
    private void GradientUI(CuiElementContainer container, string parent);
    private string BackgroundUI(CuiElementContainer container, string uid, float ySwitch, float width, float height);
}

private class InterfacePosition
{
    public string AnchorMin;
    public string AnchorMax;
    public string OffsetMin;
    public string OffsetMax;
}

private class ImageSettings : InterfacePosition
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Image")]
    public string Image;
}

private class IColor
{
    [JsonProperty(PropertyName = "HEX")]
    public string Hex;
    [JsonProperty(PropertyName = "Opacity (0 - 100)")]
    public float Alpha;
    public string Get();
    public IColor(string hex, float alpha);
}

private class NotifyComponent : FacepunchBehaviour
{
    private BasePlayer _player;
    private readonly List<NotifyData> _notifies;
    private CuiElementContainer container;
    private void Awake();
    private void OnDestroy();
    public void Kill();
    private void MainUi();
    private float NotifyUi(CuiElementContainer cont, NotifyData data, float ySwitch);
    public void AddNotify(NotifyData data);
    private void RemoveNotify(int index);
    private void NotificationsController();
    private void SendEffect(string effect);
}

Oxide.Plugins.UINotifyExtensionMethods
public static class ExtensionMethods
{
    public static List<T> Take(List<T> source, int count);
}


```

---

## UiPlus by 2CHEVSKII - Adds various custom elements to the user interface

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

Oxide.Plugins
[Info("UiPlus", "2CHEVSKII", "2.1.0")]
[Description("Adds various custom elements to the user interface")]
 class UiPlus : CovalencePlugin
{
    const string ICON_CLOCK;
    const string ICON_ACTIVE_PLAYERS;
    const string ICON_SLEEPING_PLAYERS;
    const string ICON_SERVER_REWARDS;
    const string ICON_ECONOMICS;
    const string PERMISSION_SEE;
    static UiPlus Instance;
    static ulong ImageId;
    [PluginReference]
     Plugin ImageLibrary;
    [PluginReference]
     Plugin ServerRewards;
    [PluginReference]
     Plugin Economics;
     PluginSettings settings;
     bool iconsReady;
    [Conditional("DEBUG")]
    static void DebugLog(string format, object[] args);
     void Init();
     void OnServerInitialized();
     void OnUserConnected(IPlayer player);
     void OnUserDisconnected(IPlayer player);
     void Unload();
     void CacheIcons();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     class UiPlusComponent : FacepunchBehaviour
    {
        const string PANEL_MATERIAL;
        const string NAME_CLOCK_PANEL;
        const string NAME_CLOCK_TEXT;
        const string NAME_CLOCK_ICON;
        const string NAME_AP_PANEL;
        const string NAME_AP_TEXT;
        const string NAME_AP_ICON;
        const string NAME_SP_PANEL;
        const string NAME_SP_TEXT;
        const string NAME_SP_ICON;
        const string NAME_SR_PANEL;
        const string NAME_SR_TEXT;
        const string NAME_SR_ICON;
        const string NAME_ECO_PANEL;
        const string NAME_ECO_TEXT;
        const string NAME_ECO_ICON;
        const string COLOR_PANEL;
        const string COLOR_ICON;
        const string COLOR_TEXT;
        const string TEXT_PLACEHOLDER;
        static HashSet<UiPlusComponent> AllComponents;
        static string ClockPanel;
        static string ActivePlayersPanel;
        static string SleepingPlayersPanel;
        static string ServerRewardsPanel;
        static string EconomicsPanel;
        static string ClockIcon;
        static string ActivePlayersIcon;
        static string SleepingPlayersIcon;
        static string ServerRewardsIcon;
        static string EconomicsIcon;
        static string ClockText;
        static string ActivePlayersText;
        static string SleepingPlayersText;
        static string ServerRewardsText;
        static string EconomicsText;
        static string RecentClockText;
        static string RecentApText;
        static string RecentSpText;
        static int lastActivePlayers;
        static int lastSleepingPlayers;
        static float lastClockUpdate;
        static StringBuilder Builder;
         int lastSrPts;
         int lastEcoPts;
         bool isSRLoaded;
         bool isEcoLoaded;
         bool isVisible;
         BasePlayer player;
         PluginSettings Settings;
         bool IsVisible { get; set; }
        public static void Initialize(PluginSettings settings);
        public static void Dispose();
        public static void OnPlayerConnected(BasePlayer player);
        public static void OnPlayerDisconnected(BasePlayer player);
        static void BuildUi();
        static CuiRectTransformComponent GetPanelTransform(float x, float y, float scale);
        static CuiRectTransformComponent GetIconTransform();
        static string ReplaceText(string ui, string newText);
        static string FormatTime(TimeSpan time, string format);
        static string FormatTime(TimeSpan time, string format, bool _24);
        static TimeSpan GetServerTime();
        static void UpdateClockText();
        static void UpdateActivePlayersText();
        static void UpdateSleepingPlayersText();
         void Awake();
         void OnDestroy();
         void ResetMyPts();
         int GetMySrPts();
         int GetMyEcoPts();
         void SetVisible(bool wantsVisible);
         void UiTick();
         void UpdateText(bool updateClock, bool updateActivePlayers, bool updateSleepingPlayers, bool updateServerRewards, bool updateEconomics);
    }

     class PluginSettings
    {
        public static PluginSettings Default { get; set; }
        [JsonProperty("Clock")]
        public PanelSettings Clock { get; set; }
        [JsonProperty("Active players")]
        public PanelSettings ActivePlayers { get; set; }
        [JsonProperty("Sleeping players")]
        public PanelSettings SleepingPlayers { get; set; }
        [JsonProperty("Server rewards")]
        public PanelSettings ServerRewards { get; set; }
        [JsonProperty("Economics")]
        public PanelSettings Economics { get; set; }
        [JsonProperty("Ui update interval")]
        public float UiUpdateInterval { get; set; }
        [JsonProperty("Ui time format")]
        public string UiClockFormat { get; set; }
        [JsonProperty("Append AM/PM to 12 hr time format")]
        public bool UiClockFormatAppendAmPm { get; set; }
        public class PanelSettings
        {
            [JsonProperty("Enable")]
            public bool Enable { get; set; }
            [JsonProperty("Position X")]
            public float PosX { get; set; }
            [JsonProperty("Position Y")]
            public float PosY { get; set; }
            [JsonProperty("Scale")]
            public float Scale { get; set; }
            [JsonProperty("Icon URL")]
            public string IconUrl { get; set; }
            [JsonProperty("Font size")]
            public int FontSize { get; set; }
        }

    }

}

 class UiPlusComponent : FacepunchBehaviour
{
    const string PANEL_MATERIAL;
    const string NAME_CLOCK_PANEL;
    const string NAME_CLOCK_TEXT;
    const string NAME_CLOCK_ICON;
    const string NAME_AP_PANEL;
    const string NAME_AP_TEXT;
    const string NAME_AP_ICON;
    const string NAME_SP_PANEL;
    const string NAME_SP_TEXT;
    const string NAME_SP_ICON;
    const string NAME_SR_PANEL;
    const string NAME_SR_TEXT;
    const string NAME_SR_ICON;
    const string NAME_ECO_PANEL;
    const string NAME_ECO_TEXT;
    const string NAME_ECO_ICON;
    const string COLOR_PANEL;
    const string COLOR_ICON;
    const string COLOR_TEXT;
    const string TEXT_PLACEHOLDER;
    static HashSet<UiPlusComponent> AllComponents;
    static string ClockPanel;
    static string ActivePlayersPanel;
    static string SleepingPlayersPanel;
    static string ServerRewardsPanel;
    static string EconomicsPanel;
    static string ClockIcon;
    static string ActivePlayersIcon;
    static string SleepingPlayersIcon;
    static string ServerRewardsIcon;
    static string EconomicsIcon;
    static string ClockText;
    static string ActivePlayersText;
    static string SleepingPlayersText;
    static string ServerRewardsText;
    static string EconomicsText;
    static string RecentClockText;
    static string RecentApText;
    static string RecentSpText;
    static int lastActivePlayers;
    static int lastSleepingPlayers;
    static float lastClockUpdate;
    static StringBuilder Builder;
     int lastSrPts;
     int lastEcoPts;
     bool isSRLoaded;
     bool isEcoLoaded;
     bool isVisible;
     BasePlayer player;
     PluginSettings Settings;
     bool IsVisible { get; set; }
    public static void Initialize(PluginSettings settings);
    public static void Dispose();
    public static void OnPlayerConnected(BasePlayer player);
    public static void OnPlayerDisconnected(BasePlayer player);
    static void BuildUi();
    static CuiRectTransformComponent GetPanelTransform(float x, float y, float scale);
    static CuiRectTransformComponent GetIconTransform();
    static string ReplaceText(string ui, string newText);
    static string FormatTime(TimeSpan time, string format);
    static string FormatTime(TimeSpan time, string format, bool _24);
    static TimeSpan GetServerTime();
    static void UpdateClockText();
    static void UpdateActivePlayersText();
    static void UpdateSleepingPlayersText();
     void Awake();
     void OnDestroy();
     void ResetMyPts();
     int GetMySrPts();
     int GetMyEcoPts();
     void SetVisible(bool wantsVisible);
     void UiTick();
     void UpdateText(bool updateClock, bool updateActivePlayers, bool updateSleepingPlayers, bool updateServerRewards, bool updateEconomics);
}

 class PluginSettings
{
    public static PluginSettings Default { get; set; }
    [JsonProperty("Clock")]
    public PanelSettings Clock { get; set; }
    [JsonProperty("Active players")]
    public PanelSettings ActivePlayers { get; set; }
    [JsonProperty("Sleeping players")]
    public PanelSettings SleepingPlayers { get; set; }
    [JsonProperty("Server rewards")]
    public PanelSettings ServerRewards { get; set; }
    [JsonProperty("Economics")]
    public PanelSettings Economics { get; set; }
    [JsonProperty("Ui update interval")]
    public float UiUpdateInterval { get; set; }
    [JsonProperty("Ui time format")]
    public string UiClockFormat { get; set; }
    [JsonProperty("Append AM/PM to 12 hr time format")]
    public bool UiClockFormatAppendAmPm { get; set; }
    public class PanelSettings
    {
        [JsonProperty("Enable")]
        public bool Enable { get; set; }
        [JsonProperty("Position X")]
        public float PosX { get; set; }
        [JsonProperty("Position Y")]
        public float PosY { get; set; }
        [JsonProperty("Scale")]
        public float Scale { get; set; }
        [JsonProperty("Icon URL")]
        public string IconUrl { get; set; }
        [JsonProperty("Font size")]
        public int FontSize { get; set; }
    }

}

public class PanelSettings
{
    [JsonProperty("Enable")]
    public bool Enable { get; set; }
    [JsonProperty("Position X")]
    public float PosX { get; set; }
    [JsonProperty("Position Y")]
    public float PosY { get; set; }
    [JsonProperty("Scale")]
    public float Scale { get; set; }
    [JsonProperty("Icon URL")]
    public string IconUrl { get; set; }
    [JsonProperty("Font size")]
    public int FontSize { get; set; }
}


```

---

## UIScaleManager by noname - Stores player UI scale preferences for plugins to utilize

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("UI Scale Manager", "noname", "2.2.2")]
[Description("User's UIScale data is stored and provided by API")]
 class UIScaleManager : CovalencePlugin
{
    private static LangDelegate _langGlobal;
    private static VersionNumber _pluginVersion;
    private const float _defaultUIScale;
    private const int _defaultAspectRatioIndicator;
    private static AspectRatioRaw[] _ratioPresets;
    private static int _defaultAspectRatioX;
    private static int _defaultAspectRatioY;
    private DataManager _dataManager;
    private UIController _uiController;
    private UIGenerator.UIScaler _uiScaler;
    private Dictionary<string, float[]> _playerUIInfoCache;
    protected override void LoadDefaultConfig();
    private void Init();
    private void OnServerInitialized();
     void OnServerSave();
     void Unload();
    private void OnPlayerSleepEnded(BasePlayer player);
    private void OnUserDisconnected(IPlayer player);
    private PluginConfig config;
    private void LoadConfig();
    private void VersionUpdate(PluginConfig config);
    private class PluginConfig
    {
        public bool InitPlayer;
        public VersionNumber ConfigVersion;
    }

    private PluginConfig GetDefaultConfig();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    public class DataManager
    {
        public DataFile Data;
        private DynamicConfigFile _dynamicConfigFile;
        public DataManager();
        public LoadResult LoadPlayersData();
        public void SavePlayersData();
        private LoadResult VersionUpdate();
        public class DataFile
        {
            public Dictionary<string, UIStatus> Players;
            public VersionNumber DataVersion;
            public DataFile();
            public void AddPlayerData(IPlayer player);
            public void AddPlayerData(IPlayer player, float uiscale, int RatioIndicator);
            public class UIStatus
            {
                public string Name { get; set; }
                [JsonIgnore]
                public float UIScale { get; set; }
                [JsonProperty("UIScale")]
                public float _uiScale;
                [JsonProperty("AspectRatio")]
                public AspectRatio Ratio { get; set; }
                public UIStatus();
                public UIStatus(IPlayer player);
                public UIStatus(IPlayer player, float uiscale, int AspectRatioIndicator);
                public class AspectRatio
                {
                    [JsonIgnore]
                    public int Indicator { get; set; }
                    [JsonProperty("Indicator")]
                    public int _indicator;
                    public int X;
                    public int Y;
                    public AspectRatio();
                    public AspectRatio(int indicator);
                }

            }

        }

    }

    [Command("UIScaleManager.control")]
     void SetUIScaleCommand(IPlayer player, string command, string[] args);
    [Command("setui")]
     void SetUIScaleOpenCommand(IPlayer player, string command, string[] args);
    private float[] API_CheckPlayerUIInfo(string playerID);
    private float[] API_GetItemBeltAnchor(int ratioX, int ratioY, float uiSize);
    private float[] API_GetItemBeltAnchor(string playerID);
    private float[] API_GetStatusWindowAnchor(int ratioX, int ratioY, float uiSize);
    private float[] API_GetStatusWindowAnchor(string playerID);
    private float[] API_AutoAnchorScaling(float anchorMinX, float anchorMinY, float anchorMaxX, float anchorMaxY, int center, int parent, int ratioX, int ratioY, float uiSize);
    private float[] API_AutoAnchorScaling(float anchorMinX, float anchorMinY, float anchorMaxX, float anchorMaxY, int center, int parent, string playerID);
    public class UIController
    {
        public UIGenerator.UIScaler UIScaler { get; set; }
        private UIGenerator _uiGenerator;
        private List<string> _uiUsers;
        public UIController();
        public void OpenUI(BasePlayer player, int ratioX, int ratioY, float uiSize);
        public void CloseUI(BasePlayer player);
        public void UpdateDisplayAspectRatio(BasePlayer player, int ratioX, int ratioY, float uiSize);
        public void UpdateDisplayUISize(BasePlayer player, int ratioX, int ratioY, float uiSize);
    }

    public class UIGenerator
    {
        public UIScaler Scaler;
        private const string _main;
        private const string _mainInner;
        private const string _innerUp;
        private const string _innerDown;
        private const string _ratioLabel;
        private const string _sizeLabel;
        private const string _rButtonRatioPanel;
        private const string _lButtonRatioPanel;
        private const string _rButtonSizePanel;
        private const string _lButtonSizePanel;
        private const string _itemBeltPanel;
        private const string _statusWindowPanel;
        public const float UnitCorrection;
        private static float _xunit;
        private static float _yunit;
        private readonly UniversalRectAnchor _mainInnerPanelAnchor;
        private readonly UniversalRectAnchor _innerUpPanelAnchor;
        private readonly UniversalRectAnchor _innerDownPanelAnchor;
        private readonly UniversalRectAnchor _cLabelAnchor;
        private readonly UniversalRectAnchor _valueLabelAnchor;
        private readonly UniversalRectAnchor _rButtonPanel;
        private readonly UniversalRectAnchor _lButtonPanel;
        private readonly UniversalRectAnchor _buttonAnchor;
        private static UniversalRectAnchor _itemBeltAnchor;
        private static UniversalRectAnchor _statusWindowAnchor;
        private readonly UniversalRectAnchor _textPadding;
        public UIGenerator();
        public void UIInit(BasePlayer player);
        public void DestroyMainUI(BasePlayer player);
        public void DrawAspectRatioLabel(BasePlayer player, int ratioX, int ratioY);
        public void DestroyAspectRatioLabel(BasePlayer player);
        public void DrawSizeLabel(BasePlayer player, float uiSize);
        public void DestroySizeLabel(BasePlayer player);
        public void DrawUIGuidePanel(BasePlayer player, int ratioX, int ratioY, float uiSize);
        public void DestoryUIGuidePanel(BasePlayer player);
        public CuiElementContainer GetOutline(string parent, float xsize, float ysize);
        public class UniversalRectAnchor
        {
            public float AnchorCenterX { get; set; }
            public float AnchorCenterY { get; set; }
            public float AnchorMinX { get; set; }
            public float AnchorMinY { get; set; }
            public float AnchorMaxX { get; set; }
            public float AnchorMaxY { get; set; }
            public string AnchorMin { get; set; }
            public string AnchorMax { get; set; }
            public UniversalRectAnchor(float maxX, float maxY);
            public UniversalRectAnchor(float minX, float minY, float maxX, float maxY);
            public UniversalRectAnchor(UIScaler.ScalingResult scalingResult);
            public void MoveX(float value);
            public void MoveY(float value);
            public void MoveXStart();
            public void MoveXEnd();
            public void MoveYStart();
            public void MoveYEnd();
            public void AlignCenterX();
            public void AlignCenterY();
            public UniversalRectAnchor Clone();
        }

        public class RootRectAnchor
        {
            public float AnchorMinX { get; set; }
            public float AnchorMinY { get; set; }
            public float AnchorMaxX { get; set; }
            public float AnchorMaxY { get; set; }
            public RectCenter rectCenterPreset { get; set; }
            public float PositionX { get; set; }
            public float PositionY { get; set; }
            public float ScaleX { get; set; }
            public float ScaleY { get; set; }
            public RootRectAnchor(float minX, float minY, float maxX, float maxY, RectCenter rectcenterPreset);
        }

        public class UIScaler
        {
            public IReadOnlyDictionary<DScalingParameter, ScalingResult> ItemBeltResultCache { get; set; }
            public IReadOnlyDictionary<DScalingParameter, ScalingResult> StatusWindowResultCache { get; set; }
            public IReadOnlyDictionary<ScalingParameter, ScalingResult> UniversalResultCache { get; set; }
            private Dictionary<DScalingParameter, ScalingResult> itemBeltResultCache;
            private Dictionary<DScalingParameter, ScalingResult> statusWindowResultCache;
            private Dictionary<ScalingParameter, ScalingResult> universalResultCache;
            public UIScaler();
            public void ItemBeltScaling(UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize);
            public void StatusWindowScaling(UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize);
            public ScalingResult UniversalPanelScaling(StackRectAnchor rectAnchor, RootRectAnchor.RectCenter rectCenter, ScalingParent scalingParent, int ratioX, int ratioY, float uiSize);
            public void ItemBeltScaleCaching(int ratioX, int ratioY, float uiSize);
            public void StatusWindowScaleCaching(int ratioX, int ratioY, float uiSize);
        }

    }

}

private class PluginConfig
{
    public bool InitPlayer;
    public VersionNumber ConfigVersion;
}

public class DataManager
{
    public DataFile Data;
    private DynamicConfigFile _dynamicConfigFile;
    public DataManager();
    public LoadResult LoadPlayersData();
    public void SavePlayersData();
    private LoadResult VersionUpdate();
    public class DataFile
    {
        public Dictionary<string, UIStatus> Players;
        public VersionNumber DataVersion;
        public DataFile();
        public void AddPlayerData(IPlayer player);
        public void AddPlayerData(IPlayer player, float uiscale, int RatioIndicator);
        public class UIStatus
        {
            public string Name { get; set; }
            [JsonIgnore]
            public float UIScale { get; set; }
            [JsonProperty("UIScale")]
            public float _uiScale;
            [JsonProperty("AspectRatio")]
            public AspectRatio Ratio { get; set; }
            public UIStatus();
            public UIStatus(IPlayer player);
            public UIStatus(IPlayer player, float uiscale, int AspectRatioIndicator);
            public class AspectRatio
            {
                [JsonIgnore]
                public int Indicator { get; set; }
                [JsonProperty("Indicator")]
                public int _indicator;
                public int X;
                public int Y;
                public AspectRatio();
                public AspectRatio(int indicator);
            }

        }

    }

}

public class DataFile
{
    public Dictionary<string, UIStatus> Players;
    public VersionNumber DataVersion;
    public DataFile();
    public void AddPlayerData(IPlayer player);
    public void AddPlayerData(IPlayer player, float uiscale, int RatioIndicator);
    public class UIStatus
    {
        public string Name { get; set; }
        [JsonIgnore]
        public float UIScale { get; set; }
        [JsonProperty("UIScale")]
        public float _uiScale;
        [JsonProperty("AspectRatio")]
        public AspectRatio Ratio { get; set; }
        public UIStatus();
        public UIStatus(IPlayer player);
        public UIStatus(IPlayer player, float uiscale, int AspectRatioIndicator);
        public class AspectRatio
        {
            [JsonIgnore]
            public int Indicator { get; set; }
            [JsonProperty("Indicator")]
            public int _indicator;
            public int X;
            public int Y;
            public AspectRatio();
            public AspectRatio(int indicator);
        }

    }

}

public class UIStatus
{
    public string Name { get; set; }
    [JsonIgnore]
    public float UIScale { get; set; }
    [JsonProperty("UIScale")]
    public float _uiScale;
    [JsonProperty("AspectRatio")]
    public AspectRatio Ratio { get; set; }
    public UIStatus();
    public UIStatus(IPlayer player);
    public UIStatus(IPlayer player, float uiscale, int AspectRatioIndicator);
    public class AspectRatio
    {
        [JsonIgnore]
        public int Indicator { get; set; }
        [JsonProperty("Indicator")]
        public int _indicator;
        public int X;
        public int Y;
        public AspectRatio();
        public AspectRatio(int indicator);
    }

}

public class AspectRatio
{
    [JsonIgnore]
    public int Indicator { get; set; }
    [JsonProperty("Indicator")]
    public int _indicator;
    public int X;
    public int Y;
    public AspectRatio();
    public AspectRatio(int indicator);
}

public class UIController
{
    public UIGenerator.UIScaler UIScaler { get; set; }
    private UIGenerator _uiGenerator;
    private List<string> _uiUsers;
    public UIController();
    public void OpenUI(BasePlayer player, int ratioX, int ratioY, float uiSize);
    public void CloseUI(BasePlayer player);
    public void UpdateDisplayAspectRatio(BasePlayer player, int ratioX, int ratioY, float uiSize);
    public void UpdateDisplayUISize(BasePlayer player, int ratioX, int ratioY, float uiSize);
}

public class UIGenerator
{
    public UIScaler Scaler;
    private const string _main;
    private const string _mainInner;
    private const string _innerUp;
    private const string _innerDown;
    private const string _ratioLabel;
    private const string _sizeLabel;
    private const string _rButtonRatioPanel;
    private const string _lButtonRatioPanel;
    private const string _rButtonSizePanel;
    private const string _lButtonSizePanel;
    private const string _itemBeltPanel;
    private const string _statusWindowPanel;
    public const float UnitCorrection;
    private static float _xunit;
    private static float _yunit;
    private readonly UniversalRectAnchor _mainInnerPanelAnchor;
    private readonly UniversalRectAnchor _innerUpPanelAnchor;
    private readonly UniversalRectAnchor _innerDownPanelAnchor;
    private readonly UniversalRectAnchor _cLabelAnchor;
    private readonly UniversalRectAnchor _valueLabelAnchor;
    private readonly UniversalRectAnchor _rButtonPanel;
    private readonly UniversalRectAnchor _lButtonPanel;
    private readonly UniversalRectAnchor _buttonAnchor;
    private static UniversalRectAnchor _itemBeltAnchor;
    private static UniversalRectAnchor _statusWindowAnchor;
    private readonly UniversalRectAnchor _textPadding;
    public UIGenerator();
    public void UIInit(BasePlayer player);
    public void DestroyMainUI(BasePlayer player);
    public void DrawAspectRatioLabel(BasePlayer player, int ratioX, int ratioY);
    public void DestroyAspectRatioLabel(BasePlayer player);
    public void DrawSizeLabel(BasePlayer player, float uiSize);
    public void DestroySizeLabel(BasePlayer player);
    public void DrawUIGuidePanel(BasePlayer player, int ratioX, int ratioY, float uiSize);
    public void DestoryUIGuidePanel(BasePlayer player);
    public CuiElementContainer GetOutline(string parent, float xsize, float ysize);
    public class UniversalRectAnchor
    {
        public float AnchorCenterX { get; set; }
        public float AnchorCenterY { get; set; }
        public float AnchorMinX { get; set; }
        public float AnchorMinY { get; set; }
        public float AnchorMaxX { get; set; }
        public float AnchorMaxY { get; set; }
        public string AnchorMin { get; set; }
        public string AnchorMax { get; set; }
        public UniversalRectAnchor(float maxX, float maxY);
        public UniversalRectAnchor(float minX, float minY, float maxX, float maxY);
        public UniversalRectAnchor(UIScaler.ScalingResult scalingResult);
        public void MoveX(float value);
        public void MoveY(float value);
        public void MoveXStart();
        public void MoveXEnd();
        public void MoveYStart();
        public void MoveYEnd();
        public void AlignCenterX();
        public void AlignCenterY();
        public UniversalRectAnchor Clone();
    }

    public class RootRectAnchor
    {
        public float AnchorMinX { get; set; }
        public float AnchorMinY { get; set; }
        public float AnchorMaxX { get; set; }
        public float AnchorMaxY { get; set; }
        public RectCenter rectCenterPreset { get; set; }
        public float PositionX { get; set; }
        public float PositionY { get; set; }
        public float ScaleX { get; set; }
        public float ScaleY { get; set; }
        public RootRectAnchor(float minX, float minY, float maxX, float maxY, RectCenter rectcenterPreset);
    }

    public class UIScaler
    {
        public IReadOnlyDictionary<DScalingParameter, ScalingResult> ItemBeltResultCache { get; set; }
        public IReadOnlyDictionary<DScalingParameter, ScalingResult> StatusWindowResultCache { get; set; }
        public IReadOnlyDictionary<ScalingParameter, ScalingResult> UniversalResultCache { get; set; }
        private Dictionary<DScalingParameter, ScalingResult> itemBeltResultCache;
        private Dictionary<DScalingParameter, ScalingResult> statusWindowResultCache;
        private Dictionary<ScalingParameter, ScalingResult> universalResultCache;
        public UIScaler();
        public void ItemBeltScaling(UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize);
        public void StatusWindowScaling(UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize);
        public ScalingResult UniversalPanelScaling(StackRectAnchor rectAnchor, RootRectAnchor.RectCenter rectCenter, ScalingParent scalingParent, int ratioX, int ratioY, float uiSize);
        public void ItemBeltScaleCaching(int ratioX, int ratioY, float uiSize);
        public void StatusWindowScaleCaching(int ratioX, int ratioY, float uiSize);
    }

}

public class UniversalRectAnchor
{
    public float AnchorCenterX { get; set; }
    public float AnchorCenterY { get; set; }
    public float AnchorMinX { get; set; }
    public float AnchorMinY { get; set; }
    public float AnchorMaxX { get; set; }
    public float AnchorMaxY { get; set; }
    public string AnchorMin { get; set; }
    public string AnchorMax { get; set; }
    public UniversalRectAnchor(float maxX, float maxY);
    public UniversalRectAnchor(float minX, float minY, float maxX, float maxY);
    public UniversalRectAnchor(UIScaler.ScalingResult scalingResult);
    public void MoveX(float value);
    public void MoveY(float value);
    public void MoveXStart();
    public void MoveXEnd();
    public void MoveYStart();
    public void MoveYEnd();
    public void AlignCenterX();
    public void AlignCenterY();
    public UniversalRectAnchor Clone();
}

public class RootRectAnchor
{
    public float AnchorMinX { get; set; }
    public float AnchorMinY { get; set; }
    public float AnchorMaxX { get; set; }
    public float AnchorMaxY { get; set; }
    public RectCenter rectCenterPreset { get; set; }
    public float PositionX { get; set; }
    public float PositionY { get; set; }
    public float ScaleX { get; set; }
    public float ScaleY { get; set; }
    public RootRectAnchor(float minX, float minY, float maxX, float maxY, RectCenter rectcenterPreset);
}

public class UIScaler
{
    public IReadOnlyDictionary<DScalingParameter, ScalingResult> ItemBeltResultCache { get; set; }
    public IReadOnlyDictionary<DScalingParameter, ScalingResult> StatusWindowResultCache { get; set; }
    public IReadOnlyDictionary<ScalingParameter, ScalingResult> UniversalResultCache { get; set; }
    private Dictionary<DScalingParameter, ScalingResult> itemBeltResultCache;
    private Dictionary<DScalingParameter, ScalingResult> statusWindowResultCache;
    private Dictionary<ScalingParameter, ScalingResult> universalResultCache;
    public UIScaler();
    public void ItemBeltScaling(UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize);
    public void StatusWindowScaling(UniversalRectAnchor rectAnchor, int ratioX, int ratioY, float uiSize);
    public ScalingResult UniversalPanelScaling(StackRectAnchor rectAnchor, RootRectAnchor.RectCenter rectCenter, ScalingParent scalingParent, int ratioX, int ratioY, float uiSize);
    public void ItemBeltScaleCaching(int ratioX, int ratioY, float uiSize);
    public void StatusWindowScaleCaching(int ratioX, int ratioY, float uiSize);
}


```

---

## UltimateGamble by ColdUnwanted - A gambling system that gives the winner a reward

```csharp
using UnityEngine;
using System.Collections.Generic;
using System;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Ultimate Gamble", "ColdUnwanted", "0.2.5")]
[Description("A all-in-one gambling system with in game time timer.")]
public class UltimateGamble : RustPlugin
{
    private bool ConfigChanged;
    private bool raffleActive;
    private float raffleNextStartTime;
    private List<string> raffleStartTime;
    private int raffleJoinAmount;
    private int raffleRewardAmount;
    private int rafflePlayersNeeded;
    private string raffleReward;
    private string raffleJoin;
    private int raffleDaysSkip;
    private bool raffleUseServerTime;
    private string blackjackFee;
    private int blackjackMinimumFee;
    private float blackjackMultiplier;
    private int blackjackCooldown;
    private int blackjackTimeout;
    private int neededAuthLevel;
    private List<DisconnectData> disconnectedPlayers;
    private bool isRaffleTime;
    private List<ulong> joinedPlayersId;
    private string raffleJoinName;
    private string raffleRewardName;
    private bool raffleHasError;
    private bool customStart;
    private List<BlackjackData> blackjackDatas;
    private string blackjackFeeName;
    private bool blackjackHasError;
    private string[] cardName;
    private static List<object> defaultRaffleStartTime();
    protected override void LoadDefaultConfig();
    private void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    protected override void LoadDefaultMessages();
    private class DisconnectData
    {
        public ulong userId;
        public string itemShortName;
        public int amount;
        public DisconnectData(ulong userId, string shortName, int amount);
    }

     void OnUserDisconnected(IPlayer player);
     void OnUserConnected(IPlayer player);
    private void Init();
    private float SecondsTillTime(float time);
    private void NextRaffleTime();
    private void StartRaffleTimer();
    private void EndRaffleTimer();
    private void StartRaffle();
    private void EndRaffle();
    [ChatCommand("raffle")]
    private void RaffleCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("raffle.start")]
    private void RaffleStartCommand(BasePlayer player, string command, string[] args);
    private class BlackjackData
    {
        public BasePlayer thisPlayer;
        public bool isActive;
        public int myCardValue;
        public List<string> mycard;
        public int aiCardValue;
        public List<string> aiCard;
        public float endTime;
        public int amount;
        public string item;
    }

    [ChatCommand("blackjack")]
    private void Blackjack(BasePlayer player, string command, string[] args);
    private void EndBlackjack(BasePlayer player, BlackjackData theData);
    private void BlackjackEndMessage(BasePlayer player, BlackjackData theData, int option);
    private int DetermineCardValue(List<string> theCard, string thisCard);
}

private class DisconnectData
{
    public ulong userId;
    public string itemShortName;
    public int amount;
    public DisconnectData(ulong userId, string shortName, int amount);
}

private class BlackjackData
{
    public BasePlayer thisPlayer;
    public bool isActive;
    public int myCardValue;
    public List<string> mycard;
    public int aiCardValue;
    public List<string> aiCard;
    public float endTime;
    public int amount;
    public string item;
}


```

---

## UltimateQueue by Bobakanoosh - Adds a plethora of additional features to server queue for players with permission

```csharp
using ConVar;
using Network;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Ultimate Queue", "Bobakanoosh", "1.0.4")]
[Description("Adds a plethora of additional features to server queue for players with permission.")]
 class UltimateQueue : RustPlugin
{
    private PluginConfig config;
    private const string FIRST_CONNECT;
    private Dictionary<ulong, int> userDisconnectionTimes;
    private void Init();
    private void Loaded();
    private object CanBypassQueue(Connection connection);
    private object CanClientLogin(Connection connection);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnPlayerConnected(BasePlayer player);
    public void RegisterPermissions();
    private void TryRegister(string perm);
    private bool UserHasAnyPermission(string userid, List<string> perms);
    private void CheckDisconnections();
    private void MessageAllExclude(BasePlayer exclude, string message, object[] args);
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private class PluginConfig
    {
        [JsonProperty("Auth Level required to skip queue no matter what (3 = none, 2 = admin, 1 = moderator)")]
        public int ignoreWithAuthlevel;
        [JsonProperty("Enable first connect skip queue?")]
        public bool enableFirstConnectSkip;
        [JsonProperty("Enable Queue Capacity?")]
        public bool enableQueueCapacity;
        [JsonProperty("If a player has one of the listed permissions, they are affected by queue capacity.")]
        public List<string> permsAffectedByQueueCapacity;
        [JsonProperty("Queue capacity")]
        public int queueCapacity;
        [JsonProperty("Enable Queue Holding?")]
        public bool enableHoldQueue;
        [JsonProperty("If a player has one of the listed permissions, their queue spot is held on disconnect")]
        public List<string> permsGrantingHoldQueue;
        [JsonProperty("Number of minutes to allow a user to reconnect without a queue")]
        public int holdTime;
        [JsonProperty("Enable Queue Skipping?")]
        public bool enableQueueSkip;
        [JsonProperty("If a player has one of the listed permissions, they will skip the queue")]
        public List<string> permsGrantingSkipQueue;
        [JsonProperty("When a user joins for the first time, message the new user. Only works with first connect queue skip enabled")]
        public bool enablePersonalFirstJoinWelcomeMessage;
        [JsonProperty("When a user joins for the first time, announce it to all users. Only works with first connect queue skip enabled")]
        public bool enableGlobalFirstJoinWelcomeMessage;
    }

    protected override void LoadDefaultMessages();
    public static class Epoch
    {
        public static int Current();
        public static int SecondsElapsed(int t1);
        public static int SecondsElapsed(int t1, int t2);
    }

}

private class PluginConfig
{
    [JsonProperty("Auth Level required to skip queue no matter what (3 = none, 2 = admin, 1 = moderator)")]
    public int ignoreWithAuthlevel;
    [JsonProperty("Enable first connect skip queue?")]
    public bool enableFirstConnectSkip;
    [JsonProperty("Enable Queue Capacity?")]
    public bool enableQueueCapacity;
    [JsonProperty("If a player has one of the listed permissions, they are affected by queue capacity.")]
    public List<string> permsAffectedByQueueCapacity;
    [JsonProperty("Queue capacity")]
    public int queueCapacity;
    [JsonProperty("Enable Queue Holding?")]
    public bool enableHoldQueue;
    [JsonProperty("If a player has one of the listed permissions, their queue spot is held on disconnect")]
    public List<string> permsGrantingHoldQueue;
    [JsonProperty("Number of minutes to allow a user to reconnect without a queue")]
    public int holdTime;
    [JsonProperty("Enable Queue Skipping?")]
    public bool enableQueueSkip;
    [JsonProperty("If a player has one of the listed permissions, they will skip the queue")]
    public List<string> permsGrantingSkipQueue;
    [JsonProperty("When a user joins for the first time, message the new user. Only works with first connect queue skip enabled")]
    public bool enablePersonalFirstJoinWelcomeMessage;
    [JsonProperty("When a user joins for the first time, announce it to all users. Only works with first connect queue skip enabled")]
    public bool enableGlobalFirstJoinWelcomeMessage;
}

public static class Epoch
{
    public static int Current();
    public static int SecondsElapsed(int t1);
    public static int SecondsElapsed(int t1, int t2);
}


```

---

## UnburnableMeat by S642667 - Prevents meat from burning

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("Unburnable Meat", "S642667", "1.0.1")]
[Description("Prevent cooked meats from burning")]
 class UnburnableMeat : RustPlugin
{
    public static readonly string[] CookedItems;
    private Dictionary<string, int> lowTemps;
    private Dictionary<string, int> highTemps;
     ItemModCookable GetCookable(string shortname);
     void OnServerInitialized();
     void Unload();
}


```

---

## UnderwaterVehicles by WhiteThunder - Allows vehicles to function underwater

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Underwater Vehicles", "WhiteThunder", "1.6.0")]
[Description("Allows modular cars, snowmobiles, magnet cranes, and helicopters to be used underwater.")]
internal class UnderwaterVehicles : CovalencePlugin
{
    private Configuration _config;
    private VehicleInfoManager _vehicleInfoManager;
    public UnderwaterVehicles();
    private void OnServerInitialized();
    private void Unload();
    private void OnEntityMounted(BaseVehicleSeat seat);
    private void OnEntityDismounted(BaseVehicleSeat seat);
    private static class ExposedHooks
    {
        public static object OnVehicleUnderwaterEnable(BaseEntity vehicle);
    }

    private static string[] FindPrefabsOfType();
    private static BaseVehicle GetParentVehicle(BaseEntity entity);
    private bool VehicleHasPermission(BaseVehicle vehicle, IVehicleInfo vehicleInfo);
    private void RefreshUnderwaterCapability(BaseVehicle vehicle, IVehicleInfo vehicleInfo);
    private void HandleSeatMountedChanged(BaseVehicleSeat seat);
    private class UnderwaterVehicleComponent : FacepunchBehaviour
    {
        public static UnderwaterVehicleComponent AddToVehicle(BaseVehicle vehicle, IVehicleInfo vehicleInfo);
        public static UnderwaterVehicleComponent GetForVehicle(BaseEntity vehicle);
        public static void RemoveFromVehicle(BaseEntity vehicle);
        public bool IsUnderwaterCapable { get; set; }
        private IVehicleInfo _vehicleInfo;
        private BaseVehicle _vehicle;
        private Transform _waterLoggedPoint;
        private Transform _waterLoggedPointParent;
        private Vector3 _waterLoggedPointLocalPosition;
        private Action _customDragCheck;
        public void EnableUnderwater();
        public void DisableUnderwater();
        public void EnableCustomDrag();
        private void DisableCustomDrag();
        private void CustomDragCheck(GroundVehicle groundVehicle, float dragMultiplier);
        private void OnDestroy();
    }

    private class VehicleInfo : IVehicleInfo
    {
        public VehicleConfig Config { get; set; }
        public uint[] PrefabIds { get; set; }
        public string Permission { get; set; }
        public string VehicleName { get; set; }
        public string[] PrefabPaths { get; set; }
        public Func<T, Transform> FindWaterLoggedPoint { get; set; }
        public Action<T, float> ApplyTimeSinceWaterCheck { get; set; }
        public void OnServerInitialized(UnderwaterVehicles plugin);
        public bool IsCorrectType(BaseEntity entity);
        public Transform GetWaterLoggedPoint(BaseEntity entity);
        public void SetTimeSinceWaterCheck(BaseEntity entity, float deltaTime);
    }

    private class VehicleInfoManager
    {
        private static readonly FieldInfo BikeCarPhysicsField;
        private readonly UnderwaterVehicles _plugin;
        private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo;
        private IVehicleInfo[] _allVehicles;
        private Configuration _config { get; set; }
        public VehicleInfoManager(UnderwaterVehicles plugin);
        public void OnServerInitialized();
        public IVehicleInfo GetVehicleInfo(BaseEntity entity);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class VehicleConfig
    {
        [JsonProperty("Enabled", Order = -4)]
        public bool Enabled;
        [JsonProperty("RequireOccupantPermission", Order = -3)]
        public bool RequireOccupantPermission;
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class GroundVehicleConfig : VehicleConfig
    {
        [JsonProperty("DragMultiplier", Order = -2)]
        public float DragMultiplier;
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("ModularCar")]
        public GroundVehicleConfig ModularCar;
        [JsonProperty("Snowmobile")]
        public GroundVehicleConfig Snowmobile;
        [JsonProperty("Tomaha")]
        public GroundVehicleConfig Tomaha;
        [JsonProperty("MotorBikeSidecar")]
        public GroundVehicleConfig MotorBikeSidecar;
        [JsonProperty("MotorBike")]
        public GroundVehicleConfig MotorBike;
        [JsonProperty("PedalBike")]
        public GroundVehicleConfig PedalBike;
        [JsonProperty("PedalTrike")]
        public GroundVehicleConfig PedalTrike;
        [JsonProperty("MagnetCrane")]
        public GroundVehicleConfig MagnetCrane;
        [JsonProperty("Minicopter")]
        public VehicleConfig Minicopter;
        [JsonProperty("ScrapTransportHelicopter")]
        public VehicleConfig ScrapTransportHelicopter;
        [JsonProperty("AttackHelicopter")]
        public VehicleConfig AttackHelicopter;
    }

    private Configuration GetDefaultConfig();
    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

private static class ExposedHooks
{
    public static object OnVehicleUnderwaterEnable(BaseEntity vehicle);
}

private class UnderwaterVehicleComponent : FacepunchBehaviour
{
    public static UnderwaterVehicleComponent AddToVehicle(BaseVehicle vehicle, IVehicleInfo vehicleInfo);
    public static UnderwaterVehicleComponent GetForVehicle(BaseEntity vehicle);
    public static void RemoveFromVehicle(BaseEntity vehicle);
    public bool IsUnderwaterCapable { get; set; }
    private IVehicleInfo _vehicleInfo;
    private BaseVehicle _vehicle;
    private Transform _waterLoggedPoint;
    private Transform _waterLoggedPointParent;
    private Vector3 _waterLoggedPointLocalPosition;
    private Action _customDragCheck;
    public void EnableUnderwater();
    public void DisableUnderwater();
    public void EnableCustomDrag();
    private void DisableCustomDrag();
    private void CustomDragCheck(GroundVehicle groundVehicle, float dragMultiplier);
    private void OnDestroy();
}

private class VehicleInfo : IVehicleInfo
{
    public VehicleConfig Config { get; set; }
    public uint[] PrefabIds { get; set; }
    public string Permission { get; set; }
    public string VehicleName { get; set; }
    public string[] PrefabPaths { get; set; }
    public Func<T, Transform> FindWaterLoggedPoint { get; set; }
    public Action<T, float> ApplyTimeSinceWaterCheck { get; set; }
    public void OnServerInitialized(UnderwaterVehicles plugin);
    public bool IsCorrectType(BaseEntity entity);
    public Transform GetWaterLoggedPoint(BaseEntity entity);
    public void SetTimeSinceWaterCheck(BaseEntity entity, float deltaTime);
}

private class VehicleInfoManager
{
    private static readonly FieldInfo BikeCarPhysicsField;
    private readonly UnderwaterVehicles _plugin;
    private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo;
    private IVehicleInfo[] _allVehicles;
    private Configuration _config { get; set; }
    public VehicleInfoManager(UnderwaterVehicles plugin);
    public void OnServerInitialized();
    public IVehicleInfo GetVehicleInfo(BaseEntity entity);
}

[JsonObject(MemberSerialization.OptIn)]
private class VehicleConfig
{
    [JsonProperty("Enabled", Order = -4)]
    public bool Enabled;
    [JsonProperty("RequireOccupantPermission", Order = -3)]
    public bool RequireOccupantPermission;
}

[JsonObject(MemberSerialization.OptIn)]
private class GroundVehicleConfig : VehicleConfig
{
    [JsonProperty("DragMultiplier", Order = -2)]
    public float DragMultiplier;
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : SerializableConfiguration
{
    [JsonProperty("ModularCar")]
    public GroundVehicleConfig ModularCar;
    [JsonProperty("Snowmobile")]
    public GroundVehicleConfig Snowmobile;
    [JsonProperty("Tomaha")]
    public GroundVehicleConfig Tomaha;
    [JsonProperty("MotorBikeSidecar")]
    public GroundVehicleConfig MotorBikeSidecar;
    [JsonProperty("MotorBike")]
    public GroundVehicleConfig MotorBike;
    [JsonProperty("PedalBike")]
    public GroundVehicleConfig PedalBike;
    [JsonProperty("PedalTrike")]
    public GroundVehicleConfig PedalTrike;
    [JsonProperty("MagnetCrane")]
    public GroundVehicleConfig MagnetCrane;
    [JsonProperty("Minicopter")]
    public VehicleConfig Minicopter;
    [JsonProperty("ScrapTransportHelicopter")]
    public VehicleConfig ScrapTransportHelicopter;
    [JsonProperty("AttackHelicopter")]
    public VehicleConfig AttackHelicopter;
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## Underworld by nivex - Teleports admins/developer under the world when they disconnect

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using CompanionServer.Handlers;
using Facepunch;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Underworld", "nivex", "1.0.8")]
[Description("Teleports youu under the world when disconnected.")]
 class Underworld : RustPlugin
{
    [PluginReference]
     Plugin Vanish;
    private const string permBlocked;
    private const string permName;
    private StoredData storedData;
    private List<ulong> protect;
    public class StoredData
    {
        public Dictionary<string, UserInfo> Users;
    }

    public class UserInfo
    {
        public string Home { get; set; }
        public bool WakeOnLand { get; set; }
        public bool SaveInventory { get; set; }
        public bool AutoNoClip { get; set; }
        public List<UnderworldItem> Items { get; set; }
    }

    public class UnderworldItem
    {
        public List<UnderworldItem> contents { get; set; }
        public string container { get; set; }
        public int ammo { get; set; }
        public int amount { get; set; }
        public string ammoType { get; set; }
        public float condition { get; set; }
        public float fuel { get; set; }
        public int frequency { get; set; }
        public int itemid { get; set; }
        public float maxCondition { get; set; }
        public string name { get; set; }
        public int position { get; set; }
        public ulong skin { get; set; }
        public string text { get; set; }
        public int blueprintAmount { get; set; }
        public int blueprintTarget { get; set; }
        public int dataInt { get; set; }
        public ulong subEntity { get; set; }
        public bool shouldPool { get; set; }
        public UnderworldItem();
        public UnderworldItem(string container, Item item);
        public static Item Create(UnderworldItem uwi);
        public static void Restore(BasePlayer player, UnderworldItem uwi);
    }

    private void OnNewSave();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount);
    private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo);
    private void OnPlayerSleep(BasePlayer player);
    private void OnPlayerConnected(BasePlayer player);
    private void Disappear(BasePlayer player);
    private void OnPlayerSleepEnded(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    [ChatCommand("uw")]
    private void cmdUnderworld(BasePlayer player, string command, string[] args);
    public void StopDrowning(BasePlayer player);
    private UserInfo GetUser(BasePlayer player, bool f);
    public string FormatPosition(Vector3 position);
    private void LoadData();
    private void SaveData();
    private void SaveInventory(BasePlayer player, UserInfo user);
    private bool IsAllowed(BasePlayer player);
    private static bool Blacklisted(Item item);
    private bool Changed;
    private Vector3 defaultPos;
    private bool allowSaveInventory;
    private bool maxHHT;
    private bool autoVanish;
    private static List<string> Blacklist;
    private bool wipeSaves;
    private List<object> DefaultBlacklist { get; set; }
    protected override void LoadDefaultMessages();
    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private void Message(BasePlayer player, string key, object[] args);
    private string GetMessage(string key, string id, object[] args);
}

public class StoredData
{
    public Dictionary<string, UserInfo> Users;
}

public class UserInfo
{
    public string Home { get; set; }
    public bool WakeOnLand { get; set; }
    public bool SaveInventory { get; set; }
    public bool AutoNoClip { get; set; }
    public List<UnderworldItem> Items { get; set; }
}

public class UnderworldItem
{
    public List<UnderworldItem> contents { get; set; }
    public string container { get; set; }
    public int ammo { get; set; }
    public int amount { get; set; }
    public string ammoType { get; set; }
    public float condition { get; set; }
    public float fuel { get; set; }
    public int frequency { get; set; }
    public int itemid { get; set; }
    public float maxCondition { get; set; }
    public string name { get; set; }
    public int position { get; set; }
    public ulong skin { get; set; }
    public string text { get; set; }
    public int blueprintAmount { get; set; }
    public int blueprintTarget { get; set; }
    public int dataInt { get; set; }
    public ulong subEntity { get; set; }
    public bool shouldPool { get; set; }
    public UnderworldItem();
    public UnderworldItem(string container, Item item);
    public static Item Create(UnderworldItem uwi);
    public static void Restore(BasePlayer player, UnderworldItem uwi);
}


```

---

## UniqueNames by MrBlue - Automatically renames and/or kicks players with non-unique/duplicate name

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.IO;
using System.Linq;

Oxide.Plugins
[Info("Unique Names", "Wulf/lukespragg", "1.0.3")]
[Description("Automatic renames and/or kicks players with non-unique/duplicate names")]
 class UniqueNames : CovalencePlugin
{
    private const string permBypass;
    private void Init();
    private Configuration config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Kick player with non-unique name")]
        public bool KickPlayer { get; set; }
        [JsonProperty(PropertyName = "Rename player with non-unqiue name")]
        public bool RenamePlayer { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private string Lang(string langKey, string playerId, object[] args);
    private void OnUserConnected(IPlayer player);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Kick player with non-unique name")]
    public bool KickPlayer { get; set; }
    [JsonProperty(PropertyName = "Rename player with non-unqiue name")]
    public bool RenamePlayer { get; set; }
}


```

---

## UniversalUI by  - A fully customizable UI for info and buttons

```csharp
using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using System;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Core;

Oxide.Plugins
[Info("Universal UI", "Absolut", "2.1.5")]
[Description("A fully customizable UI for info and buttons")]
 class UniversalUI : RustPlugin
{
    [PluginReference]
     Plugin ImageLibrary;
     Plugin Kits;
     string TitleColor;
     string MsgColor;
     bool SkinsReady;
    private Dictionary<ulong, screen> UniversalUIInfo;
     class screen
    {
        public int section;
        public int page;
        public bool open;
        public int showSection;
        public bool admin;
    }

    private bool Debugging;
    private List<ulong> NoInfo;
    private Dictionary<ulong, DelayedCommand> OnDelay;
     class DelayedCommand
    {
        public bool closeui;
        public List<string> args;
    }

    private Dictionary<string, Timer> timers;
     void Loaded();
     void Unload();
     void OnServerInitialized();
    private void OnPlayerInit(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
     object OnServerCommand(ConsoleSystem.Arg arg);
    private void RunCommand(BasePlayer player, string[] command);
    [ConsoleCommand("UI_OpenUniversalUI")]
    private void cmdUI_OpenUniversalUI(ConsoleSystem.Arg arg);
    private void OpenUniversalUI(BasePlayer player);
    [ConsoleCommand("UI_DestroyUniversalUI")]
    private void cmdUI_DestroyUniversalUI(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_OpenInfoUI")]
    private void cmdUI_OpenInfoUI(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_HideInfo")]
    private void cmdUI_HideInfo(ConsoleSystem.Arg arg);
    private object KitMax(string kitname);
    public int GetKitMax(string kitname);
    private object KitItemAmount(string kitname, int ID);
    public int GetKitItemAmount(string kitname, int ID);
    private object KitDescription(string kitname);
    public string GetKitDescription(string kitname);
    private object KitImage(string kitname);
    public string GetKitImage(string kitname);
    private object KitCooldown(string kitname);
    public int GetKitCooldown(string kitname);
    private object GetKits();
    public string[] GetKitNames();
     void AskForPageType(BasePlayer player, int page);
    [ConsoleCommand("UI_SetPageType")]
    private void cmdUI_SetPageType(ConsoleSystem.Arg arg);
    private float[] SelectionButtonLocation(int number, int amount);
    [ConsoleCommand("UI_AddNewSection")]
    private void cmdUI_AddNewSection(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_RemoveSection")]
    private void cmdUI_RemoveSection(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_AddNewPage")]
    private void cmdUI_AddNewPage(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_RemovePage")]
    private void cmdUI_RemovePage(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_RunConsoleCommand")]
    private void cmdUI_RunConsoleCommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_PageTurn")]
    private void cmdUI_PageTurn(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_SwitchSection")]
    private void cmdUI_SwitchSection(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_InfoSectionButtonChange")]
    private void cmdUI_InfoSectionButtonChange(ConsoleSystem.Arg arg);
    private void DestroyUniversalUI(BasePlayer player);
    private void DestroyPlayer(BasePlayer player);
    private string GetLang(string msg, BasePlayer player);
    private void GetSendMSG(BasePlayer player, string message, string arg1, string arg2, string arg3);
    private string GetMSG(string message, BasePlayer player, string arg1, string arg2, string arg3);
     bool isAuth(BasePlayer player);
    private void RegisterPermissions();
     bool isAllowed(BasePlayer player, bool adminonly, string perm);
    private string TryForImage(string shortname, ulong skin);
    private bool Valid(string name, ulong id);
    public string GetImage(string shortname, ulong skin, bool returnUrl);
    public bool HasImage(string shortname, ulong skin);
    public bool AddImage(string url, string shortname, ulong skin);
    public List<ulong> GetImageList(string shortname);
    public bool isReady();
    private string PanelStatic;
    private string PanelUUI;
    private string PanelInfo;
    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
        static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
        static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
        static public void LoadImage(CuiElementContainer container, string panel, string img, string aMin, string aMax);
        static public void CreateTextOverlay(CuiElementContainer element, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align, float fadein);
        static public void CreateTextOutline(CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align);
    }

    private Dictionary<string, string> UIColors;
    private Dictionary<string, string> TextColors;
     void UniversalUIPanel(BasePlayer player);
    private void CreateButtonOnUI(CuiElementContainer container, string panelName, MainButton button, int num);
     void BackgroundPanel(BasePlayer player);
     void UIInfoPanel(BasePlayer player);
    private void CreateKitEntry(CuiElementContainer container, string panelName, BasePlayer player, string kit, int num);
    private void AddKit(BasePlayer player, int page);
    private void CreateKitButton(CuiElementContainer container, string panelName, string color, string name, string cmd, int num);
    [ConsoleCommand("UI_SelectKitToAdd")]
    private void cmdUI_SelectKitToAdd(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_AddKit")]
    private void cmdUI_AddKit(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_RedeemKit")]
    private void cmdUI_RedeemKit(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_RemoveKit")]
    private void cmdUI_RemoveKit(ConsoleSystem.Arg arg);
    private float[] CalcKitButtonPos(int number);
    private float[] KitPos(int number);
    private float[] CalcButtonPos(int number);
    private float[] CalcButtonPagePos(int number);
    private float[] CalcSectionButtonPos(int number);
    private float[] CalcInfoButtonPos(int number);
     class MainButton
    {
        public string name;
        public string command;
        public string ButtonImage;
        public bool adminOnly;
        public string permission;
        public bool CloseUI;
    }

     class PageButton
    {
        public string name;
        public string command;
        public string PageButtonImage;
        public bool adminOnly;
        public int order;
        public string permission;
        public bool CloseUI;
    }

     class Section
    {
        public string name;
        public string SectionButtonimage;
        public bool adminOnly;
        public List<Page> pages;
        public string permission;
    }

     class Page
    {
        public int page;
        public string name;
        public string text;
        public string PageImage;
        public List<PageButton> buttons;
        public PageType type;
        public List<string> Kits;
    }

    [ChatCommand("ui")]
    private void cmdui(BasePlayer player, string command, string[] args);
    [ConsoleCommand("UI_AdminView")]
    private void cmdUI_AdminView(ConsoleSystem.Arg arg);
    [ChatCommand("uuidebug")]
    private void cmduuidebug(BasePlayer player, string command, string[] args);
    [ConsoleCommand("GetAllImages")]
    private void cmdGetAllImages(ConsoleSystem.Arg arg);
    private void GetAllImages();
    private void CheckNewImages();
    private void InfoLoop();
    private ConfigData configData;
     class ConfigData
    {
        public string MenuKeyBinding { get; set; }
        public Page HomePage;
        public Dictionary<int, Section> sections;
        public Dictionary<int, MainButton> buttons;
        public bool UseInfoPanel { get; set; }
        public bool UseButtonPanel { get; set; }
        public int InfoInterval { get; set; }
        public bool ForceOpenOnJoin { get; set; }
    }

    private void LoadVariables();
    private Page DefaultHomePage;
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     Dictionary<string, string> messages;
}

 class screen
{
    public int section;
    public int page;
    public bool open;
    public int showSection;
    public bool admin;
}

 class DelayedCommand
{
    public bool closeui;
    public List<string> args;
}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
    static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
    static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
    static public void LoadImage(CuiElementContainer container, string panel, string img, string aMin, string aMax);
    static public void CreateTextOverlay(CuiElementContainer element, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align, float fadein);
    static public void CreateTextOutline(CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align);
}

 class MainButton
{
    public string name;
    public string command;
    public string ButtonImage;
    public bool adminOnly;
    public string permission;
    public bool CloseUI;
}

 class PageButton
{
    public string name;
    public string command;
    public string PageButtonImage;
    public bool adminOnly;
    public int order;
    public string permission;
    public bool CloseUI;
}

 class Section
{
    public string name;
    public string SectionButtonimage;
    public bool adminOnly;
    public List<Page> pages;
    public string permission;
}

 class Page
{
    public int page;
    public string name;
    public string text;
    public string PageImage;
    public List<PageButton> buttons;
    public PageType type;
    public List<string> Kits;
}

 class ConfigData
{
    public string MenuKeyBinding { get; set; }
    public Page HomePage;
    public Dictionary<int, Section> sections;
    public Dictionary<int, MainButton> buttons;
    public bool UseInfoPanel { get; set; }
    public bool UseButtonPanel { get; set; }
    public int InfoInterval { get; set; }
    public bool ForceOpenOnJoin { get; set; }
}


```

---

## UnlimitedDroneRange by WhiteThunder - (Obsolete) Removes the range limit when remote-controlling drones from a computer station

```csharp
using UnityEngine;

Oxide.Plugins
[Info("Unlimited Drone Range", "WhiteThunder", "1.0.1")]
[Description("Removes the range limit when remote-controlling drones from a computer station.")]
internal class UnlimitedDroneRange : CovalencePlugin
{
    private void OnServerInitialized();
    private void Unload();
    private void OnBookmarkControl(ComputerStation station, BasePlayer player, string bookmarkName, Drone drone);
    private void OnBookmarkControlEnd(ComputerStation station, BasePlayer player, Drone drone);
    private class DroneNetworkGroupUpdater : MonoBehaviour
    {
        private Drone _drone;
        private Network.Visibility.Group _networkGroup;
        public BasePlayer Controller;
        private void Awake();
        private void Update();
    }

}

private class DroneNetworkGroupUpdater : MonoBehaviour
{
    private Drone _drone;
    private Network.Visibility.Group _networkGroup;
    public BasePlayer Controller;
    private void Awake();
    private void Update();
}


```

---

## UnlimitedElevators by k1lly0u - Allows players to extend elevators past the 6 high limit

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Unlimited Elevators", "k1lly0u", "0.1.3")]
[Description("Allow players to extend elevators past the 6 high limit")]
 class UnlimitedElevators : RustPlugin
{
    private int _elevatorItemId;
    private RaycastHit raycastHit;
    private RaycastHit[] _rayBuffer;
    private const string USE_PERM;
    private const string SOCKET_FEMALE;
    private const string SOCKET_MALE;
    private const int RAYCAST_LAYERS;
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private Elevator FindEntity(BasePlayer player);
    private int CountFloorDifference(Elevator topFloor, int targetFloors);
    private bool HasEnoughItems(BasePlayer player, int extensions);
    private void TakeItems(BasePlayer player, int extensions);
    private void RefundItems(BasePlayer player, int subtractions);
    private Elevator FindTopFloor(Elevator root);
    private int CountFloorsToGround(Elevator topFloor);
    private Elevator GetNextFloor(Elevator currentFloor, Elevator.Direction direction);
    private void AddFloors(Elevator topFloor, int extensions);
    private void SubtractFloors(Elevator topFloor, int subtractions);
    [ChatCommand("setfloors")]
    private void cmdSetFloors(BasePlayer player, string command, string[] args);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Maximum number of floors allowed")]
        public int Limit { get; set; }
        [JsonProperty(PropertyName = "Require the user has the correct number of elevator items in their inventory to pay for the extension")]
        public bool RequireItem { get; set; }
        [JsonProperty(PropertyName = "Refund items if setting floors to a number lower than what currently exists")]
        public bool RefundIfSubtracting { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    public string msg(string key, BasePlayer player);
    private Dictionary<string, string> Messages;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Maximum number of floors allowed")]
    public int Limit { get; set; }
    [JsonProperty(PropertyName = "Require the user has the correct number of elevator items in their inventory to pay for the extension")]
    public bool RequireItem { get; set; }
    [JsonProperty(PropertyName = "Refund items if setting floors to a number lower than what currently exists")]
    public bool RefundIfSubtracting { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}


```

---

## Unlootable by DezLife - Prevents players with permission from  opening any boxes or anything with loot

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Unlootable", "Oranger", "1.1.1")]
[Description("Give player/group a permission so they can't open any boxes or anything with loot in")]
public class Unlootable : RustPlugin
{
    private void Init();
    private object CanLootEntity(BasePlayer player, DroppedItemContainer container);
    private object CanLootEntity(BasePlayer player, LootableCorpse corpse);
    private object CanLootEntity(BasePlayer player, StorageContainer container);
    private void OnStart();
    private object CanLoot(string container, BasePlayer player);
    private ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Permission - List of containers (shortname)")]
        public Dictionary<string, List<string>> containers;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Permission - List of containers (shortname)")]
    public Dictionary<string, List<string>> containers;
}


```

---

## UnreliableVehicles by alibali - Vehicles have a chance of exploding when turned on

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;

Oxide.Plugins
[Info("Unreliable Vehicles", "bearr", "1.0.0")]
[Description("Vehicles have a chance of exploding when turned on.")]
 class UnreliableVehicles : RustPlugin
{
    private GameConfig config;
    protected override void LoadConfig();
    protected override void LoadDefaultMessages();
     object OnEngineStart(BaseVehicle vehicle);
    private class GameConfig
    {
        [JsonProperty("Chance Of Exploding")]
        public int chanceofexploding { get; set; }
        [JsonProperty("Broadcast Message To Chat")]
        public bool dobroadcastmessage { get; set; }
        [JsonProperty("Chat Prefix")]
        public string chatprefix { get; set; }
    }

    private GameConfig GetDefaultConfig();
    protected override void LoadDefaultConfig();
}

private class GameConfig
{
    [JsonProperty("Chance Of Exploding")]
    public int chanceofexploding { get; set; }
    [JsonProperty("Broadcast Message To Chat")]
    public bool dobroadcastmessage { get; set; }
    [JsonProperty("Chat Prefix")]
    public string chatprefix { get; set; }
}


```

---

## Unwound by  - The sky presents the newest technology in calling the MEDIC

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Unwound", "mk_sky/Khan", "1.0.20")]
[Description("The sky presents the newest technology in calling the MEDIC!")]
 class Unwound : RustPlugin
{
     ListDictionary<string, string> localization;
     List<ulong> called;
     ListDictionary<uint, uint> ecoSettings;
     List<ulong> inUnwoundZone;
     float startHealth;
     uint waitTillMedic;
     bool popupsEnabled;
     uint chanceTheMedicSavesYou;
     bool canCallMedicOncePerWounded;
     bool enableServerRewards;
     bool enableEconomics;
     bool enableCurrency;
     bool forceCurrency;
    [PluginReference]
     Plugin Economics;
     Plugin ZoneManager;
     Plugin PopupNotifications;
     Plugin ServerRewards;
     void OnServerInitialized();
    protected override void LoadDefaultConfig();
     void ConfigLoader();
     void ConfigUpdater();
    [ConsoleCommand("unwound.recreate")]
     void ConsoleCommandConfigRecreate();
    [ConsoleCommand("unwound.load")]
     void ConsoleCommandConfigLoad();
    [ConsoleCommand("unwound.set")]
     void ConsoleCommandConfigSet(ConsoleSystem.Arg arg);
    [ChatCommand("aid")]
     void ChatCommandAid(BasePlayer player, string command, string[] args);
     void TimedMedic(ulong playerID);
     void OnPlayerWound(BasePlayer player, HitInfo hitInfo);
     bool CheckCanCall(BasePlayer player);
     bool MedicGetsYouUp(BasePlayer player);
    static double ConvertToUnixTimestamp(DateTime date);
    static bool IsUInt(string s);
     double GetCurrency(BasePlayer player);
     bool Withdraw(BasePlayer player, double amount);
}


```

---

## UpdateNotice by Psystec - Notifies when new Rust updates are released

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using static ConsoleSystem;

Oxide.Plugins
[Info("Update Notice", "Psystec", "3.2.2", ResourceId = 2837)]
[Description("Notifies you when new Rust updates are released.")]
internal sealed class UpdateNotice : RustPlugin
{
    private Configuration _configuration;
    private UpdateInfo _updateInfo;
    private const string AdminPermission;
    private const string ApiUrl;
    private bool _initLoad;
    private int _checkingInterval;
    private readonly Dictionary<string, string> _properNames;
    private readonly Dictionary<string, string> _properCommands;
    private sealed class UpdateInfo
    {
        public string carbon { get; set; }
        public string uMod { get; set; }
        public string rustClient { get; set; }
        public string rustClientStaging { get; set; }
        public string rustServer { get; set; }
        public string newsgid { get; set; }
        public string newsurl { get; set; }
        public string newsdate { get; set; }
    }

    private sealed class DiscordMessageEmbeds
    {
        public string username { get; set; }
        public string avatar_url { get; set; }
        public string content { get; set; }
        public Embed[] embeds { get; set; }
    }

    private sealed class Embed
    {
        public Author author { get; set; }
        public string title { get; set; }
        public string url { get; set; }
        public string description { get; set; }
        public int color { get; set; }
        public Field[] fields { get; set; }
        public Thumbnail thumbnail { get; set; }
        public Image image { get; set; }
        public Footer footer { get; set; }
    }

    private sealed class Author
    {
        public string name { get; set; }
        public string url { get; set; }
        public string icon_url { get; set; }
    }

    private sealed class Thumbnail
    {
        public string url { get; set; }
    }

    private sealed class Image
    {
        public string url { get; set; }
    }

    private sealed class Footer
    {
        public string text { get; set; }
        public string icon_url { get; set; }
    }

    private sealed class Field
    {
        public string name { get; set; }
        public string value { get; set; }
        public bool inline { get; set; }
    }

    private sealed class Configuration
    {
        [JsonProperty("Only Notify Admin")]
        public bool OnlyNotifyAdmins { get; set; }
        [JsonProperty("Enable Discord Notifications")]
        public bool EnableDiscordNotify { get; set; }
        [JsonProperty("Discord role id to mention (0 = no mention)")]
        public ulong DiscordRoleId { get; set; }
        [JsonProperty("Discord Webhook URL")]
        public string DiscordWebhookURL { get; set; }
        [JsonProperty("Enable GUI Notifications (Needs GUIAnnouncements)")]
        public bool EnableGuiNotifications { get; set; }
        [JsonProperty("Enable Chat Notifications")]
        public bool EnableChatNotifications { get; set; }
        [JsonProperty("GUI Notifications Tint Color")]
        public string GUINotificationsTintColor { get; set; }
        [JsonProperty("GUI Notifications Text Color")]
        public string GUINotificationsTextColor { get; set; }
        [JsonProperty("Enable Server Version Notifications")]
        public bool EnableServer { get; set; }
        [JsonProperty("Enable DevBlog Notifications")]
        public bool EnableDevBlog { get; set; }
        [JsonProperty("Enable Client Version Notifications")]
        public bool EnableClient { get; set; }
        [JsonProperty("Enable Staging Version Notifications")]
        public bool EnableStaging { get; set; }
        [JsonProperty("Enable UMod Version Notifications")]
        public bool EnableUMod { get; set; }
        [JsonProperty("Enable Carbon Version Notifications")]
        public bool EnableCarbon { get; set; }
    }

    protected override void SaveConfig();
    private void LoadNewConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultMessages();
    private void Init();
    private void Loaded();
    [ConsoleCommand("updatenotice")]
    private void AdvertCommands(Arg arg);
    private void TestNotification(string type, bool condition, string message, Action<string> notificationMethod);
    private void TestUpdate(string type, bool isCmd);
    private void TestAllUpdates();
    private void DisplayCurrentVersions(Arg arg);
    private void SendHelp(Arg arg);
    private void CompareVersions();
    private void UpdateCheck(string type, string newData, string oldData, bool enableFeature, string additionalInfo);
    private string Lang(string key, string id, object[] args);
    private bool HasPermission(BasePlayer player, string perm);
    private void SendtoGui(string message);
    private void SendToChat(string message);
    private void SendToDiscord(string message);
    public string GetServerVersion();
    public string GetDevBlogVersion();
    public string GetClientVersion();
    public string GetStagingVersion();
    public string GetUModVersion();
    public string GetCarbonVersion();
    public string GetDevBlogLink();
    [PluginReference]
     Plugin GUIAnnouncements;
}

private sealed class UpdateInfo
{
    public string carbon { get; set; }
    public string uMod { get; set; }
    public string rustClient { get; set; }
    public string rustClientStaging { get; set; }
    public string rustServer { get; set; }
    public string newsgid { get; set; }
    public string newsurl { get; set; }
    public string newsdate { get; set; }
}

private sealed class DiscordMessageEmbeds
{
    public string username { get; set; }
    public string avatar_url { get; set; }
    public string content { get; set; }
    public Embed[] embeds { get; set; }
}

private sealed class Embed
{
    public Author author { get; set; }
    public string title { get; set; }
    public string url { get; set; }
    public string description { get; set; }
    public int color { get; set; }
    public Field[] fields { get; set; }
    public Thumbnail thumbnail { get; set; }
    public Image image { get; set; }
    public Footer footer { get; set; }
}

private sealed class Author
{
    public string name { get; set; }
    public string url { get; set; }
    public string icon_url { get; set; }
}

private sealed class Thumbnail
{
    public string url { get; set; }
}

private sealed class Image
{
    public string url { get; set; }
}

private sealed class Footer
{
    public string text { get; set; }
    public string icon_url { get; set; }
}

private sealed class Field
{
    public string name { get; set; }
    public string value { get; set; }
    public bool inline { get; set; }
}

private sealed class Configuration
{
    [JsonProperty("Only Notify Admin")]
    public bool OnlyNotifyAdmins { get; set; }
    [JsonProperty("Enable Discord Notifications")]
    public bool EnableDiscordNotify { get; set; }
    [JsonProperty("Discord role id to mention (0 = no mention)")]
    public ulong DiscordRoleId { get; set; }
    [JsonProperty("Discord Webhook URL")]
    public string DiscordWebhookURL { get; set; }
    [JsonProperty("Enable GUI Notifications (Needs GUIAnnouncements)")]
    public bool EnableGuiNotifications { get; set; }
    [JsonProperty("Enable Chat Notifications")]
    public bool EnableChatNotifications { get; set; }
    [JsonProperty("GUI Notifications Tint Color")]
    public string GUINotificationsTintColor { get; set; }
    [JsonProperty("GUI Notifications Text Color")]
    public string GUINotificationsTextColor { get; set; }
    [JsonProperty("Enable Server Version Notifications")]
    public bool EnableServer { get; set; }
    [JsonProperty("Enable DevBlog Notifications")]
    public bool EnableDevBlog { get; set; }
    [JsonProperty("Enable Client Version Notifications")]
    public bool EnableClient { get; set; }
    [JsonProperty("Enable Staging Version Notifications")]
    public bool EnableStaging { get; set; }
    [JsonProperty("Enable UMod Version Notifications")]
    public bool EnableUMod { get; set; }
    [JsonProperty("Enable Carbon Version Notifications")]
    public bool EnableCarbon { get; set; }
}


```

---

## UpgradePermissions by MrBlue - Allows players to upgrade structures based on permissions

```csharp
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Upgrade Permissions", "Wulf", "2.0.0")]
[Description("Allows players to upgrade structures based on permissions")]
 class UpgradePermissions : CovalencePlugin
{
    protected override void LoadDefaultMessages();
    private void Init();
    private object CanChangeGrade(BasePlayer basePlayer, BuildingBlock block, BuildingGrade.Enum grade);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string textOrLang, object[] args);
}


```

---

## UpgradeTimer by  - Online raiding buffed as walls keep their health when upgraded

```csharp
using System.Collections.Generic;
using UnityEngine;
using System;
using System.IO;
using Newtonsoft.Json;
using System.Text;
using System.IO.Compression;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;

Oxide.Plugins
[Info("UpgradeTimer", "Jake_Rich", "2.0.0", ResourceId = 2740)]
[Description("Time limit to upgrade twig after it has been placed")]
public class UpgradeTimer : RustPlugin
{
    public static UpgradeTimer _plugin;
    public static JSONFile<ConfigData> _settingsFile;
    public static ConfigData Settings { get; set; }
    public Dictionary<BaseEntity,EntityData> EntityDictionary;
     void Init();
     void Loaded();
     void Unload();
    public class ConfigData
    {
        public int UpgradeDelay;
        public int WoodUpgradeDelay;
        public int StoneUpgradeDelay;
        public int MetalUpgradeDelay;
        public int ArmouredUpgradeDelay;
        public float ExplosiveDamageDelay;
        public float NormalDamageDelay;
        public Dictionary<string, int> EntityUpgradeTime;
    }

    public class EntityData
    {
        public BaseCombatEntity Entity;
        public Timer timer;
        public int TimerRate;
        public float NextRepairTime;
        public float NextUpgradeTime;
        public EntityData(BaseCombatEntity block);
        public void ResetTimer();
        public void StartTimer();
        private void TimerLoop();
        public void Destroy();
    }

    public EntityData GetEntityData(BaseCombatEntity entity);
     void OnEntityBuilt(Planner plan, GameObject go);
     void OnEntityKill(BaseNetworkable net);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
     object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade);
     object OnStructureRepair(BaseCombatEntity entity, BasePlayer player);
    public class JSONFile
    {
        private DynamicConfigFile _file;
        public string _name { get; set; }
        public Type Instance { get; set; }
        private ConfigLocation _location { get; set; }
        private string _path { get; set; }
        public bool SaveOnUnload;
        public bool Compressed;
        public JSONFile(string name, ConfigLocation location, string path, string extension, bool saveOnUnload);
        public virtual void Init();
        public virtual void Load();
        private void LoadCompressed();
        public virtual void Save();
        private void SaveCompressed();
        public virtual void Reload();
        private void Unload(Plugin sender, PluginManager manager);
    }

}

public class ConfigData
{
    public int UpgradeDelay;
    public int WoodUpgradeDelay;
    public int StoneUpgradeDelay;
    public int MetalUpgradeDelay;
    public int ArmouredUpgradeDelay;
    public float ExplosiveDamageDelay;
    public float NormalDamageDelay;
    public Dictionary<string, int> EntityUpgradeTime;
}

public class EntityData
{
    public BaseCombatEntity Entity;
    public Timer timer;
    public int TimerRate;
    public float NextRepairTime;
    public float NextUpgradeTime;
    public EntityData(BaseCombatEntity block);
    public void ResetTimer();
    public void StartTimer();
    private void TimerLoop();
    public void Destroy();
}

public class JSONFile
{
    private DynamicConfigFile _file;
    public string _name { get; set; }
    public Type Instance { get; set; }
    private ConfigLocation _location { get; set; }
    private string _path { get; set; }
    public bool SaveOnUnload;
    public bool Compressed;
    public JSONFile(string name, ConfigLocation location, string path, string extension, bool saveOnUnload);
    public virtual void Init();
    public virtual void Load();
    private void LoadCompressed();
    public virtual void Save();
    private void SaveCompressed();
    public virtual void Reload();
    private void Unload(Plugin sender, PluginManager manager);
}


```

---

## UpgradeWorkbench by mvrb - Allows players to upgrade workbenches using a command

```csharp
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Upgrade Workbench", "mvrb", "0.1.4")]
[Description("Allows players to upgrade workbenches using a command")]
 class UpgradeWorkbench : RustPlugin
{
    private const string permissionUse;
    private const string permissionNoCost;
    private Dictionary<string, Dictionary<int, int>> WorkbenchIngredients;
    private void LoadDefaultMessages();
    private void OnServerInitialized();
    [ChatCommand("upgradewb")]
    private void cmdUpgradeWorkbench(BasePlayer player);
    private bool ReplaceWorkbench(BaseEntity originalWorkbench);
    private class MissingItem
    {
        public int CurrentAmount;
        public int RequiredAmount;
        public MissingItem(int current, int required);
    }

    private void TryUpgradeWorkbench(BasePlayer player, BaseEntity entity);
    private string Lang(string key, string id, object[] args);
}

private class MissingItem
{
    public int CurrentAmount;
    public int RequiredAmount;
    public MissingItem(int current, int required);
}


```

---

## UpgradeWorkbenches by MJSU - Lets you upgrade / downgrade workbenches.

```csharp
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("UpgradeWorkbenches", "MJSU", "2.1.3")]
[Description("Lets players upgrade workbenches")]
public class UpgradeWorkbenches : RustPlugin
{
    private PluginConfig _pluginConfig;
    private readonly List<int> _workbenchItemIds;
    private const string UpgradePermission;
    private const string DowngradePermission;
    private const string RefundPermission;
    private const string AccentColor;
    private void Init();
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    public PluginConfig AdditionalConfig(PluginConfig config);
    private void OnServerInitialized();
    private void WorkbenchUpgradeChatCommand(BasePlayer player, string cmd, string[] args);
    private object CanMoveItem(Item movedItem, PlayerInventory playerInventory, ItemContainerId targetContainerId);
    private void OnEntityBuilt(Planner planner, GameObject go);
    private T RaycastAll(BasePlayer player, float distance);
    private void Chat(BasePlayer player, string key, object[] args);
    private string Lang(string key, BasePlayer player, object[] args);
    private bool HasPermission(BasePlayer player, string perm);
    public class PluginConfig
    {
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Display Placement Message")]
        public bool DisplayPlacementMessage { get; set; }
    }

    private class LangKeys
    {
        public const string Chat;
        public const string InfoMessage;
        public const string UpgradeNotAllowed;
        public const string DowngradeNotAllow;
        public const string NotAllowed;
        public const string NotLookingAt;
        public const string ChatCommand;
    }

}

public class PluginConfig
{
    [DefaultValue(true)]
    [JsonProperty(PropertyName = "Display Placement Message")]
    public bool DisplayPlacementMessage { get; set; }
}

private class LangKeys
{
    public const string Chat;
    public const string InfoMessage;
    public const string UpgradeNotAllowed;
    public const string DowngradeNotAllow;
    public const string NotAllowed;
    public const string NotLookingAt;
    public const string ChatCommand;
}


```

---

## UpkeepDisplayFix by WhiteThunder - Fixes a display bug where Tool Cupboard upkeep doesn't factor in decay scale

```csharp

Oxide.Plugins
[Info("Upkeep Display Fix", "WhiteThunder", "1.0.1")]
[Description("Fixes display bug where Tool Cupboard upkeep doesn't factor in decay scale.")]
internal class UpkeepDisplayFix : CovalencePlugin
{
    private const int DisplayMinutesWhenNoDecay;
    private void OnEntitySaved(BuildingPrivlidge buildingPrivilege, BaseNetworkable.SaveInfo saveInfo);
}


```

---

## URLCopy by PaiN - Allow players to copy text through a note.

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("URL Copy", "PaiN", "0.1.0")]
[Description("Gives a player a note with a set message.")]
 class URLCopy : RustPlugin
{
    private Configuration config;
    const int NoteID;
    private Dictionary<string, float> cmdCD;
    private class Configuration
    {
        [JsonProperty("Command || Note Text")]
        public Dictionary<string, string> cmds;
        [JsonProperty("Command usage cooldown in seconds (0 = Disabled)")]
        public int cooldown;
        [JsonProperty("Message SteamID icon")]
        public ulong chatId;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
     void Loaded();
    private void HandleNote(BasePlayer player, string cmd, string[] args);
    private bool OnCooldown(BasePlayer player);
    private int GetCooldown(string userid);
    protected override void LoadDefaultMessages();
}

private class Configuration
{
    [JsonProperty("Command || Note Text")]
    public Dictionary<string, string> cmds;
    [JsonProperty("Command usage cooldown in seconds (0 = Disabled)")]
    public int cooldown;
    [JsonProperty("Message SteamID icon")]
    public ulong chatId;
}


```

---

## UsableToBelt by MrBlue - Any usable item will be moved to your belt if there is space

```csharp

Oxide.Plugins
[Info("Usable to Belt", "Wulf", "1.2.2")]
[Description("Any usable item will be moved to your belt if there is space")]
public class UsableToBelt : RustPlugin
{
    private const string permAllow;
    private void Init();
    private void HandleItem(Item item, BasePlayer player);
    private void OnItemAddedToContainer(ItemContainer container, Item item);
}


```

---

## UseableShovels by mr01sam - Allows you to dig into the ground using shovels!

```csharp
using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using System;
using Oxide.Core;

Oxide.Plugins
[Info("Useable Shovels", "mr01sam", "1.0.3")]
[Description("Allows you to dig into the ground using shovels!")]
partial class UseableShovels : CovalencePlugin
{
    private const string PERMISSION_USE;
     void Init();
     void Unload();
     void OnServerInitialized();
}

Oxide.Plugins
partial class UseableShovels : CovalencePlugin
{
    private Configuration config;
    private partial class Configuration
    {
        [JsonProperty(PropertyName = "Gain Stone")]
        public bool GainStone;
        [JsonProperty(PropertyName = "Gain Metal/Sulfur")]
        public bool GainMetalAndSulfur;
        [JsonProperty(PropertyName = "Gain Bait")]
        public bool GainBait;
        [JsonProperty(PropertyName = "Gain Plant Fiber")]
        public bool GainPlantFiber;
        [JsonProperty(PropertyName = "Reveal Player Stashes")]
        public bool RevealStashes;
        [JsonProperty(PropertyName = "Allow Digging in Monuments")]
        public bool AllowDiggingMonuments;
        [JsonProperty(PropertyName = "Allow Digging in Building Privileges")]
        public bool AllowDiggingBuildingPrivilege;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
}

private partial class Configuration
{
    [JsonProperty(PropertyName = "Gain Stone")]
    public bool GainStone;
    [JsonProperty(PropertyName = "Gain Metal/Sulfur")]
    public bool GainMetalAndSulfur;
    [JsonProperty(PropertyName = "Gain Bait")]
    public bool GainBait;
    [JsonProperty(PropertyName = "Gain Plant Fiber")]
    public bool GainPlantFiber;
    [JsonProperty(PropertyName = "Reveal Player Stashes")]
    public bool RevealStashes;
    [JsonProperty(PropertyName = "Allow Digging in Monuments")]
    public bool AllowDiggingMonuments;
    [JsonProperty(PropertyName = "Allow Digging in Building Privileges")]
    public bool AllowDiggingBuildingPrivilege;
}

Oxide.Plugins
partial class UseableShovels : CovalencePlugin
{
    private readonly string STONE_ITEM;
    private readonly string SULPHUR_ITEM;
    private readonly string METAL_ITEM;
    private readonly string GRUB_ITEM;
    private readonly string WORM_ITEM;
    private readonly string PLANT_FIBER_ITEM;
    private static MonumentInfo[] _monumentInfoCache;
    public static MonumentInfo[] MonumentInfoCached { get; set; }
     LocationType GetLocationTypeFromPosition(BasePlayer basePlayer, Vector3 position);
     ItemChance[] GetItemsFromMaterial(HitMaterial material);
     HitMaterial GetHitMaterialFromID(uint material);
     object OnMeleeAttack(BasePlayer basePlayer, HitInfo info);
     void DigHoleAndGetStuff(BasePlayer basePlayer, HitMaterial hitMaterial, Vector3 localPosition, Vector3 worldPosition);
     int RevealPlayerStashes(Vector3 position);
     List<StashContainer> GetNearbyStashes(Vector3 position, float radius);
     int RoundGatherAmount(int amt, float gatherRate);
     void PlayDigEffect(BaseEntity entity, Vector3 position);
     void GiveItemByShortName(BasePlayer basePlayer, string name, int amount);
}

Oxide.Plugins
partial class UseableShovels : CovalencePlugin
{
    public class ItemChance
    {
        public string ItemShortName { get; set; }
        public int Chance { get; set; }
        public bool Enabled { get; set; }
        public ItemChance(string itemShortName, int chance, bool enabled);
    }

}

public class ItemChance
{
    public string ItemShortName { get; set; }
    public int Chance { get; set; }
    public bool Enabled { get; set; }
    public ItemChance(string itemShortName, int chance, bool enabled);
}

Oxide.Plugins
partial class UseableShovels : CovalencePlugin
{
    protected override void LoadDefaultMessages();
    private string Lang(string key, BasePlayer basePlayer, object[] args);
}


```

---

## Vanish by Whispers88 - Allows players with permission to become truly invisible

```csharp
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Facepunch;
using Rust.Ai;
using HarmonyLib;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Vanish", "Whispers88", "1.9.2")]
[Description("Allows players with permission to become invisible")]
public class Vanish : CovalencePlugin
{
    private static Vanish? vanish;
    private readonly List<ulong> _hiddenPlayers;
    private List<ulong> _hiddenOffline;
    private static List<string>? _registeredhooks;
    private static int PlayerLayermask;
    private static DamageTypeList? _EmptyDmgList;
     CuiElementContainer? cachedVanishUI;
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("NoClip on Vanish (runs noclip command)")]
        public bool NoClipOnVanish;
        [JsonProperty("Inventory view cmd", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] InvViewCMD;
        [JsonProperty("Use OnEntityTakeDamage hook (Set to true to enable use of vanish.damage perm. Set to false for better performance)")]
        public bool UseOnEntityTakeDamage;
        [JsonProperty("Use CanUseLockedEntity hook (Allows vanished players with the perm vanish.unlock to bypass locks. Set to false for better performance)")]
        public bool UseCanUseLockedEntity;
        [JsonProperty("Automatically vanish players (with the vanish.use perm) on player connect")]
        public bool EnforceOnConnect;
        [JsonProperty("Automatically vanish players (with the vanish.use perm) on player disconnect")]
        public bool EnforceOnDisconnect;
        [JsonProperty("Keep a vanished player hidden on disconnect")]
        public bool HideOnDisconnect;
        [JsonProperty("Teleport a vanished player under the map on disconnect")]
        public bool UnderWorldOnDisconnect;
        [JsonProperty("Teleport a vanished player above the map on connect")]
        public bool AboveWorldOnConnect;
        [JsonProperty("Bypass violation checks for vanished players")]
        public bool BypassViolation;
        [JsonProperty("Turn off fly hack detection for players in vanish")]
        public bool AntiHack;
        [JsonProperty("Disable metabolism in vanish")]
        public bool Metabolism;
        [JsonProperty("Reset hydration and health on un-vanishing (resets to pre-vanished state)")]
        public bool MetabolismReset;
        [JsonProperty("Enable vanishing and reappearing sound effects")]
        public bool EnableSound;
        [JsonProperty("Make sound effects public")]
        public bool PublicSound;
        [JsonProperty("Enable chat notifications")]
        public bool EnableNotifications;
        [JsonProperty("Sound effect to use when vanishing")]
        public string VanishSoundEffect;
        [JsonProperty("Sound effect to use when reappearing")]
        public string ReappearSoundEffect;
        [JsonProperty("Enable GUI")]
        public bool EnableGUI;
        [JsonProperty("Icon URL (.png or .jpg)")]
        public string ImageUrlIcon;
        [JsonProperty("Image Color")]
        public string ImageColor;
        [JsonProperty("Image AnchorMin")]
        public string ImageAnchorMin;
        [JsonProperty("Image AnchorMax")]
        public string ImageAnchorMax;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Loaded();
    private void InitVanishedPlayers();
    protected override void LoadDefaultMessages();
    private const string PermAllow;
    private const string PermUnlock;
    private const string PermDamage;
    private const string PermVanish;
    private const string PermInvView;
    private void Init();
    private void Unload();
    private DynamicConfigFile _hiddenOfflineData;
    private void LoadData();
    private void SaveData();
    private void InventoryViewerCMD(IPlayer iplayer, string command, string[] args);
    private void StartLootingPlayer(BasePlayer player, BasePlayer foundplayer);
    private void VanishCommand(IPlayer iplayer, string command, string[] args);
    private string drowneffect;
    private string falldamageeffect;
    private void Reappear(BasePlayer player);
    private class MetabolismValues
    {
        public float health;
        public float hydration;
        public float calories;
    }

    private GameObjectRef _emptygameObject;
    private Dictionary<ulong, MetabolismValues> _storedMetabolism;
    private string noclip;
    private void Disappear(BasePlayer player);
    private void OnPlayerConnected(BasePlayer player);
    private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock);
    private object? OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnPlayerSpectate(BasePlayer player, string spectateFilter);
    private void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter);
    private object? OnPlayerColliderEnable(BasePlayer player, CapsuleCollider collider);
    private object? OnPlayerViolation(BasePlayer player, AntiHackType type, float amount);
    private CuiElementContainer CreateVanishUI();
    public class VanishPositionUpdate : FacepunchBehaviour
    {
        private BasePlayer player;
        private static int Layermask;
         LootableCorpse corpse;
         GameObject child;
         SphereCollider col;
         int LayerReserved1;
         BUTTON _reload;
        private void Awake();
        private void FixedUpdate();
        private void UpdatePos();
         void OnTriggerEnter(Collider col);
         void OnTriggerExit(Collider col);
        public void EndSpectate();
        public void RespawnCheck();
        public void CreateChildGO();
        private void OnDestroy();
    }

    private BasePlayer? GetPlayer(ulong steamID);
    private void AddLocalizedCommand(string command);
    private bool HasPerm(string id, string perm);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string langKey, object[] args);
    private bool IsInvisible(BasePlayer player);
    private void UnSubscribeFromHooks();
    private void SubscribeToHooks();
    private static void SendEffect(BasePlayer player, string sound);
    public void _Disappear(BasePlayer basePlayer);
    public void _Reappear(BasePlayer basePlayer);
    public bool _IsInvisible(BasePlayer basePlayer);
    [HarmonyPatch(typeof(BasePlayer), "OcclusionPlayerFound"), AutoPatch]
    private static class BasePlayer_OcclusionPlayerFound_Patch
    {
        [HarmonyPrefix]
        private static bool Prefix(BasePlayer player1, BasePlayer player2, bool cache);
    }

}

public class Configuration
{
    [JsonProperty("NoClip on Vanish (runs noclip command)")]
    public bool NoClipOnVanish;
    [JsonProperty("Inventory view cmd", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] InvViewCMD;
    [JsonProperty("Use OnEntityTakeDamage hook (Set to true to enable use of vanish.damage perm. Set to false for better performance)")]
    public bool UseOnEntityTakeDamage;
    [JsonProperty("Use CanUseLockedEntity hook (Allows vanished players with the perm vanish.unlock to bypass locks. Set to false for better performance)")]
    public bool UseCanUseLockedEntity;
    [JsonProperty("Automatically vanish players (with the vanish.use perm) on player connect")]
    public bool EnforceOnConnect;
    [JsonProperty("Automatically vanish players (with the vanish.use perm) on player disconnect")]
    public bool EnforceOnDisconnect;
    [JsonProperty("Keep a vanished player hidden on disconnect")]
    public bool HideOnDisconnect;
    [JsonProperty("Teleport a vanished player under the map on disconnect")]
    public bool UnderWorldOnDisconnect;
    [JsonProperty("Teleport a vanished player above the map on connect")]
    public bool AboveWorldOnConnect;
    [JsonProperty("Bypass violation checks for vanished players")]
    public bool BypassViolation;
    [JsonProperty("Turn off fly hack detection for players in vanish")]
    public bool AntiHack;
    [JsonProperty("Disable metabolism in vanish")]
    public bool Metabolism;
    [JsonProperty("Reset hydration and health on un-vanishing (resets to pre-vanished state)")]
    public bool MetabolismReset;
    [JsonProperty("Enable vanishing and reappearing sound effects")]
    public bool EnableSound;
    [JsonProperty("Make sound effects public")]
    public bool PublicSound;
    [JsonProperty("Enable chat notifications")]
    public bool EnableNotifications;
    [JsonProperty("Sound effect to use when vanishing")]
    public string VanishSoundEffect;
    [JsonProperty("Sound effect to use when reappearing")]
    public string ReappearSoundEffect;
    [JsonProperty("Enable GUI")]
    public bool EnableGUI;
    [JsonProperty("Icon URL (.png or .jpg)")]
    public string ImageUrlIcon;
    [JsonProperty("Image Color")]
    public string ImageColor;
    [JsonProperty("Image AnchorMin")]
    public string ImageAnchorMin;
    [JsonProperty("Image AnchorMax")]
    public string ImageAnchorMax;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class MetabolismValues
{
    public float health;
    public float hydration;
    public float calories;
}

public class VanishPositionUpdate : FacepunchBehaviour
{
    private BasePlayer player;
    private static int Layermask;
     LootableCorpse corpse;
     GameObject child;
     SphereCollider col;
     int LayerReserved1;
     BUTTON _reload;
    private void Awake();
    private void FixedUpdate();
    private void UpdatePos();
     void OnTriggerEnter(Collider col);
     void OnTriggerExit(Collider col);
    public void EndSpectate();
    public void RespawnCheck();
    public void CreateChildGO();
    private void OnDestroy();
}

[HarmonyPatch(typeof(BasePlayer), "OcclusionPlayerFound"), AutoPatch]
private static class BasePlayer_OcclusionPlayerFound_Patch
{
    [HarmonyPrefix]
    private static bool Prefix(BasePlayer player1, BasePlayer player2, bool cache);
}


```

---

## VehicleBBQ by Judess69er - Puts barbeques on specific vehicles

```csharp
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Vehicle BBQ's", "Judess69er/Shady14u", "1.3.6")]
[Description("Puts Barbeque's on specific Vehicles")]
public class VehicleBBQ : RustPlugin
{
    public const string BBQ_PREFAB;
    public PluginConfig _config;
     void OnServerInitialized(bool initialBoot);
    protected override void LoadDefaultConfig();
    public PluginConfig GetDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    public class PluginConfig
    {
        [JsonProperty(PropertyName = "Add BBQ to Rigid Hull Inflatable Boat ( True/False )")]
        public bool EnableRHIB { get; set; }
        [JsonProperty(PropertyName = "Add BBQ to Workcart ( True/False )")]
        public bool EnableWorkcart { get; set; }
        [JsonProperty(PropertyName = "Add BBQ to Scrap Transport Helicopter ( True/False )")]
        public bool EnableScrapHeli { get; set; }
    }

    private static void RemoveColliderProtection(BaseEntity colliderEntity);
     void OnEntitySpawned(BaseVehicle entity);
     void AddOven(BaseVehicle entity);
    private void SpawnOven(BaseVehicle entity, Vector3 localPosition, Vector3 rotate);
    private void OnEntityKill(BaseVehicle entity);
    [ConsoleCommand("killbbqs")]
    private void cmdKillBBQs(ConsoleSystem.Arg arg);
}

public class PluginConfig
{
    [JsonProperty(PropertyName = "Add BBQ to Rigid Hull Inflatable Boat ( True/False )")]
    public bool EnableRHIB { get; set; }
    [JsonProperty(PropertyName = "Add BBQ to Workcart ( True/False )")]
    public bool EnableWorkcart { get; set; }
    [JsonProperty(PropertyName = "Add BBQ to Scrap Transport Helicopter ( True/False )")]
    public bool EnableScrapHeli { get; set; }
}


```

---

## VehicleDecayProtection by WhiteThunder - Protects vehicles from decay when inside, near TCs, when recently used, or using owner permissions

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Rust;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using UnityEngine;

Oxide.Plugins
[Info("Vehicle Decay Protection", "WhiteThunder", "2.7.1")]
[Description("Protects vehicles from decay based on ownership and other factors.")]
internal class VehicleDecayProtection : CovalencePlugin
{
    private Configuration _pluginConfig;
    private const string Permission_NoDecay_AllVehicles;
    private const float VanillaDecaySeconds;
    private readonly VehicleInfoManager _vehicleInfoManager;
    public VehicleDecayProtection();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnEntitySpawned(BaseVehicle entity);
    private void OnEntitySpawned(HotAirBalloon entity);
    private static class ExposedHooks
    {
        public static object OnVehicleDecayReplace(BaseEntity entity);
    }

    private void ScheduleReplaceDecay(BaseEntity entity, IVehicleInfo vehicleInfo);
    private void HandleEntitySpawned(BaseEntity entity);
    private bool UserHasPermission(UserData userData, string perm);
    private bool UserHasVehiclePermission(ulong ownerId, string vehicleSpecificNoDecayPerm);
    private bool VehiclePrivilegeHasPermission(BaseEntity vehicle, string vehicleSpecificNoDecayPerm);
    private bool LockOwnerHasPermission(BaseEntity vehicle, string vehicleSpecificNoDecayPerm, ulong lockOwnerId);
    public static void LogInfo(string message);
    public static void LogError(string message);
    public static void LogWarning(string message);
    private static T GetChildOfType(BaseEntity entity);
    private static string[] FindPrefabsOfType();
    private static void SetupDecayTick(FacepunchBehaviour component, Action action, float time);
    private static bool WasRecentlyUsed(BaseEntity entity, IVehicleInfo vehicleInfo, float protectionMinutesAfterUse);
    private static bool VehicleHasPermission(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo);
    private static float GetInsideMultiplier(BaseEntity entity, IVehicleInfo vehicleInfo, bool isOutside, bool forceOutsideCheck);
    private static float GetNearTCMultiplier(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo);
    private static float GetLocationMultiplier(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo, bool isOutside, bool forceOutsideCheck);
    private static float GetLocationMultiplier(VehicleDecayProtection pluginInstance, BaseEntity entity, IVehicleInfo vehicleInfo);
    private static void DoDecayDamage(BaseCombatEntity entity, IVehicleInfo vehicleInfo, float fraction, DamageType damageType, bool useProtection);
    private static void DoCarDecayDamage(ModularCar car, IVehicleInfo vehicleInfo, float amount);
    private static void HelicopterDecay(VehicleDecayProtection pluginInstance, PlayerHelicopter heli, IVehicleInfo vehicleInfo);
    private static void SnowmobileDecay(VehicleDecayProtection pluginInstance, Snowmobile snowmobile, IVehicleInfo vehicleInfo);
    private static void WaterVehicleDecay(VehicleDecayProtection pluginInstance, BaseCombatEntity waterVehicle, IVehicleInfo vehicleInfo, float outsideDecayMinutes, float deepWaterDecayMinutes, float protectionMinutesAfterUse);
    private static void SledDecay(VehicleDecayProtection pluginInstance, Sled sled, IVehicleInfo vehicleInfo);
    private static void BikeDecay(VehicleDecayProtection pluginInstance, Bike bike, IVehicleInfo vehicleInfo);
    private static void SiegeWeaponDecay(VehicleDecayProtection pluginInstance, BaseSiegeWeapon siegeWeapon, IVehicleInfo vehicleInfo);
    private class VehicleDecayReplacer : FacepunchBehaviour
    {
        public static void AddToEntity(BaseEntity entity, IVehicleInfo vehicleInfo);
        public static void RemoveFromEntity(BaseEntity entity);
        private BaseEntity _entity;
        private IVehicleInfo _vehicleInfo;
        private void DecayTick();
    }

    private class VehicleInfo : IVehicleInfo
    {
        public uint[] PrefabIds { get; set; }
        public VehicleConfig VehicleConfig { get; set; }
        public string Permission { get; set; }
        public string VehicleType;
        public string[] PrefabPaths;
        public Func<T, float> TimeSinceLastUsed;
        public Func<T, Action> VanillaDecayMethod;
        public Action<T, IVehicleInfo> Decay;
        public void OnServerInitialized(VehicleDecayProtection pluginInstance);
        public bool IsCorrectType(BaseEntity entity);
        public float GetTimeMultiplier();
        public float GetTimeSinceLastUsed(BaseEntity entity);
        public Action GetVanillaDecayMethod(BaseEntity entity);
        public void DecayTick(BaseEntity entity);
    }

    private class VehicleInfoManager
    {
        private static readonly FieldInfo BikeTimeSinceLastUsedField;
        private VehicleDecayProtection _pluginInstance;
        private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo;
        public VehicleInfoManager(VehicleDecayProtection pluginInstance);
        public void OnServerInitialized(Configuration pluginConfig);
        public IVehicleInfo GetVehicleInfo(BaseEntity entity);
    }

    private class VehicleConfig
    {
        [JsonProperty("Allow the plugin to influence decay")]
        public bool Enabled;
        [JsonProperty("Decay multiplier while inside")]
        public float DecayMultiplierInside;
        [JsonProperty("DecayMultiplierInside")]
        private float DeprecatedDecayMultiplierInside { get; set; }
        [JsonProperty("Decay multiplier near tool cupboard")]
        public float DecayMultiplierNearTC;
        [JsonProperty("DecayMultiplierNearTC")]
        private float DeprecatedDecayMultiplierNearTC { get; set; }
        [JsonProperty("Protect from decay after recent use (minutes)", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(-1f)]
        public float ProtectionMinutesAfterUse;
        [JsonProperty("ProtectionMinutesAfterUse")]
        private float DeprecatedProtectionMinutesAfterUse { get; set; }
        [JsonProperty("Decay interval (seconds)")]
        public float DecayIntervalSeconds;
        [JsonProperty("DecayIntervalSeconds")]
        private float DeprecatedDecayIntervalSeconds { get; set; }
    }

    private class VehicleConfigMap
    {
        [JsonProperty("Ridable Horse")]
        public VehicleConfig RidableHorse;
        [JsonProperty("RidableHorse")]
        private VehicleConfig DeprecatedRidableHorse { get; set; }
        [JsonProperty("Ballista")]
        public VehicleConfig Ballista;
        [JsonProperty("Battering Ram")]
        public VehicleConfig BatteringRam;
        [JsonProperty("Catapult")]
        public VehicleConfig Catapult;
        [JsonProperty("Siege Tower")]
        public VehicleConfig SiegeTower;
        [JsonProperty("Modular Car")]
        public VehicleConfig ModularCar;
        [JsonProperty("ModularCar")]
        private VehicleConfig DeprecatedModularCar { get; set; }
        [JsonProperty("Motor Bike")]
        public VehicleConfig MotorBike;
        [JsonProperty("Motor Bike Sidecar")]
        public VehicleConfig MotorBikeSidecar;
        [JsonProperty("Pedal Bike")]
        public VehicleConfig PedalBike;
        [JsonProperty("Pedal Trike")]
        public VehicleConfig PedalTrike;
        [JsonProperty("Snowmobile")]
        public VehicleConfig Snowmobile;
        [JsonProperty("Tomaha")]
        public VehicleConfig Tomaha;
        [JsonProperty("Sled")]
        public VehicleConfig Sled;
        [JsonProperty("Sled Xmas")]
        public VehicleConfig SledXmas;
        [JsonProperty("Sled.Xmas")]
        private VehicleConfig DeprecatedSledXmas { get; set; }
        [JsonProperty("Kayak")]
        public VehicleConfig Kayak;
        [JsonProperty("Rowboat")]
        public VehicleConfig Rowboat;
        [JsonProperty("RHIB")]
        public VehicleConfig RHIB;
        [JsonProperty("Tugboat")]
        public VehicleConfig Tugboat;
        [JsonProperty("Solo Submarine")]
        public VehicleConfig SoloSubmarine;
        [JsonProperty("SoloSubmarine")]
        private VehicleConfig DeprecatedSoloSubmarine { get; set; }
        [JsonProperty("Duo Submarine")]
        public VehicleConfig DuoSubmarine;
        [JsonProperty("DuoSubmarine")]
        private VehicleConfig DeprecatedDuoSubmarine { get; set; }
        [JsonProperty("Hot Air Balloon")]
        public VehicleConfig HotAirBalloon;
        [JsonProperty("HotAirBalloon")]
        private VehicleConfig DeprecatedHotAirBalloon { get; set; }
        [JsonProperty("Minicopter")]
        public VehicleConfig Minicopter;
        [JsonProperty("Scrap Transport Helicopter")]
        public VehicleConfig ScrapTransportHelicopter;
        [JsonProperty("ScrapTransportHelicopter")]
        private VehicleConfig DeprecatedScrapTransportHelicopter { get; set; }
        [JsonProperty("Attack Helicopter")]
        public VehicleConfig AttackHelicopter;
    }

    private class Configuration : BaseConfiguration
    {
        [JsonProperty("Enable permission")]
        public bool EnablePermission;
        [JsonProperty("EnablePermission")]
        private bool DeprecatedEnablePermission { get; set; }
        [JsonProperty("Vehicles")]
        public VehicleConfigMap Vehicles;
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

private static class ExposedHooks
{
    public static object OnVehicleDecayReplace(BaseEntity entity);
}

private class VehicleDecayReplacer : FacepunchBehaviour
{
    public static void AddToEntity(BaseEntity entity, IVehicleInfo vehicleInfo);
    public static void RemoveFromEntity(BaseEntity entity);
    private BaseEntity _entity;
    private IVehicleInfo _vehicleInfo;
    private void DecayTick();
}

private class VehicleInfo : IVehicleInfo
{
    public uint[] PrefabIds { get; set; }
    public VehicleConfig VehicleConfig { get; set; }
    public string Permission { get; set; }
    public string VehicleType;
    public string[] PrefabPaths;
    public Func<T, float> TimeSinceLastUsed;
    public Func<T, Action> VanillaDecayMethod;
    public Action<T, IVehicleInfo> Decay;
    public void OnServerInitialized(VehicleDecayProtection pluginInstance);
    public bool IsCorrectType(BaseEntity entity);
    public float GetTimeMultiplier();
    public float GetTimeSinceLastUsed(BaseEntity entity);
    public Action GetVanillaDecayMethod(BaseEntity entity);
    public void DecayTick(BaseEntity entity);
}

private class VehicleInfoManager
{
    private static readonly FieldInfo BikeTimeSinceLastUsedField;
    private VehicleDecayProtection _pluginInstance;
    private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo;
    public VehicleInfoManager(VehicleDecayProtection pluginInstance);
    public void OnServerInitialized(Configuration pluginConfig);
    public IVehicleInfo GetVehicleInfo(BaseEntity entity);
}

private class VehicleConfig
{
    [JsonProperty("Allow the plugin to influence decay")]
    public bool Enabled;
    [JsonProperty("Decay multiplier while inside")]
    public float DecayMultiplierInside;
    [JsonProperty("DecayMultiplierInside")]
    private float DeprecatedDecayMultiplierInside { get; set; }
    [JsonProperty("Decay multiplier near tool cupboard")]
    public float DecayMultiplierNearTC;
    [JsonProperty("DecayMultiplierNearTC")]
    private float DeprecatedDecayMultiplierNearTC { get; set; }
    [JsonProperty("Protect from decay after recent use (minutes)", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(-1f)]
    public float ProtectionMinutesAfterUse;
    [JsonProperty("ProtectionMinutesAfterUse")]
    private float DeprecatedProtectionMinutesAfterUse { get; set; }
    [JsonProperty("Decay interval (seconds)")]
    public float DecayIntervalSeconds;
    [JsonProperty("DecayIntervalSeconds")]
    private float DeprecatedDecayIntervalSeconds { get; set; }
}

private class VehicleConfigMap
{
    [JsonProperty("Ridable Horse")]
    public VehicleConfig RidableHorse;
    [JsonProperty("RidableHorse")]
    private VehicleConfig DeprecatedRidableHorse { get; set; }
    [JsonProperty("Ballista")]
    public VehicleConfig Ballista;
    [JsonProperty("Battering Ram")]
    public VehicleConfig BatteringRam;
    [JsonProperty("Catapult")]
    public VehicleConfig Catapult;
    [JsonProperty("Siege Tower")]
    public VehicleConfig SiegeTower;
    [JsonProperty("Modular Car")]
    public VehicleConfig ModularCar;
    [JsonProperty("ModularCar")]
    private VehicleConfig DeprecatedModularCar { get; set; }
    [JsonProperty("Motor Bike")]
    public VehicleConfig MotorBike;
    [JsonProperty("Motor Bike Sidecar")]
    public VehicleConfig MotorBikeSidecar;
    [JsonProperty("Pedal Bike")]
    public VehicleConfig PedalBike;
    [JsonProperty("Pedal Trike")]
    public VehicleConfig PedalTrike;
    [JsonProperty("Snowmobile")]
    public VehicleConfig Snowmobile;
    [JsonProperty("Tomaha")]
    public VehicleConfig Tomaha;
    [JsonProperty("Sled")]
    public VehicleConfig Sled;
    [JsonProperty("Sled Xmas")]
    public VehicleConfig SledXmas;
    [JsonProperty("Sled.Xmas")]
    private VehicleConfig DeprecatedSledXmas { get; set; }
    [JsonProperty("Kayak")]
    public VehicleConfig Kayak;
    [JsonProperty("Rowboat")]
    public VehicleConfig Rowboat;
    [JsonProperty("RHIB")]
    public VehicleConfig RHIB;
    [JsonProperty("Tugboat")]
    public VehicleConfig Tugboat;
    [JsonProperty("Solo Submarine")]
    public VehicleConfig SoloSubmarine;
    [JsonProperty("SoloSubmarine")]
    private VehicleConfig DeprecatedSoloSubmarine { get; set; }
    [JsonProperty("Duo Submarine")]
    public VehicleConfig DuoSubmarine;
    [JsonProperty("DuoSubmarine")]
    private VehicleConfig DeprecatedDuoSubmarine { get; set; }
    [JsonProperty("Hot Air Balloon")]
    public VehicleConfig HotAirBalloon;
    [JsonProperty("HotAirBalloon")]
    private VehicleConfig DeprecatedHotAirBalloon { get; set; }
    [JsonProperty("Minicopter")]
    public VehicleConfig Minicopter;
    [JsonProperty("Scrap Transport Helicopter")]
    public VehicleConfig ScrapTransportHelicopter;
    [JsonProperty("ScrapTransportHelicopter")]
    private VehicleConfig DeprecatedScrapTransportHelicopter { get; set; }
    [JsonProperty("Attack Helicopter")]
    public VehicleConfig AttackHelicopter;
}

private class Configuration : BaseConfiguration
{
    [JsonProperty("Enable permission")]
    public bool EnablePermission;
    [JsonProperty("EnablePermission")]
    private bool DeprecatedEnablePermission { get; set; }
    [JsonProperty("Vehicles")]
    public VehicleConfigMap Vehicles;
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## VehicleDeployedLocks by WhiteThunder - Allows players to deploy code locks and key locks onto vehicles

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

Oxide.Plugins
[Info("Vehicle Deployed Locks", "WhiteThunder", "1.13.5")]
[Description("Allows players to deploy code locks and key locks to vehicles.")]
internal class VehicleDeployedLocks : CovalencePlugin
{
    [PluginReference]
    private Plugin Clans;
    private Plugin Friends;
    private const string Permission_CodeLock_Prefix;
    private const string Permission_KeyLock_Prefix;
    private const string Permission_MasterKey;
    private const string Prefab_CodeLock_DeployedEffect;
    private const string Prefab_CodeLock_DeniedEffect;
    private const string Prefab_CodeLock_UnlockEffect;
    private const float MaxDeployDistance;
    private Configuration _config;
    private CooldownManager _craftCodeLockCooldowns;
    private CooldownManager _craftKeyLockCooldowns;
    private readonly VehicleInfoManager _vehicleInfoManager;
    private readonly LockedVehicleTracker _lockedVehicleTracker;
    private readonly AutoUnlockManager _autoUnlockManager;
    private readonly ReskinManager _reskinManager;
    private readonly object False;
    public VehicleDeployedLocks();
    private void Init();
    private void OnServerInitialized();
    private object CanMountEntity(BasePlayer player, BaseMountable entity);
    private object CanLootEntity(BasePlayer player, StorageContainer container);
    private object CanLootEntity(BasePlayer player, ContainerIOEntity container);
    private object CanLootEntity(BasePlayer player, RidableHorse horse);
    private object CanLootEntity(BasePlayer player, RidableHorse2 horse);
    private object CanLootEntity(BasePlayer player, ModularCarGarage carLift);
    private object OnHorseLead(RidableHorse horse, BasePlayer player);
    private object OnHorseLead(RidableHorse2 horse, BasePlayer player);
    private object OnHotAirBalloonToggle(HotAirBalloon hab, BasePlayer player);
    private object OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer player);
    private object OnTurretAuthorize(AutoTurret entity, BasePlayer player);
    private object OnTurretTarget(AutoTurret autoTurret, BasePlayer player);
    private object CanSwapToSeat(BasePlayer player, ModularCarSeat carSeat);
    private object OnVehiclePush(BaseVehicle vehicle, BasePlayer player);
    private void OnEntityKill(BaseLock baseLock);
    private void OnEntityKill(VehicleModuleSeating seatingModule);
    private object CanDeployItem(BasePlayer basePlayer, Deployer deployer, NetworkableId entityId);
    private object OnEntityReskin(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player);
    private void OnEntityReskinned(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player);
    [HookMethod(nameof(API_DeployCodeLock))]
    public CodeLock API_DeployCodeLock(BaseEntity vehicle, BasePlayer player, bool isFree);
    [HookMethod(nameof(API_DeployKeyLock))]
    public KeyLock API_DeployKeyLock(BaseEntity vehicle, BasePlayer player, bool isFree);
    [HookMethod(nameof(API_CanPlayerDeployCodeLock))]
    public bool API_CanPlayerDeployCodeLock(BasePlayer player, BaseEntity vehicle);
    [HookMethod(nameof(API_CanPlayerDeployKeyLock))]
    public bool API_CanPlayerDeployKeyLock(BasePlayer player, BaseEntity vehicle);
    [HookMethod(nameof(API_CanAccessVehicle))]
    public bool API_CanAccessVehicle(BasePlayer player, BaseEntity vehicle, bool provideFeedback);
    [HookMethod(nameof(API_RegisterCustomVehicleType))]
    public void API_RegisterCustomVehicleType(string vehicleType, Vector3 lockPosition, Quaternion lockRotation, string parentBone, Func<BaseEntity, BaseEntity> determineLockParent);
    [Command("vehiclecodelock", "vcodelock", "vlock")]
    private void CodeLockCommand(IPlayer player, string cmd, string[] args);
    [Command("vehiclekeylock", "vkeylock")]
    private void KeyLockCommand(IPlayer player, string cmd, string[] args);
    private void LockCommand(IPlayer player, LockInfo lockInfo);
    private static bool HasPermissionAny(IPlayer player, string[] permissionNames);
    private static BaseLock GetVehicleLock(BaseEntity vehicle);
    private static bool IsLockableEntity(BaseEntity entity);
    private static string[] FindPrefabsOfType();
    private static bool IsTaxiSeat(ModularCarSeat carSeat);
    private bool IsPlayerAuthorizedToCodeLock(ulong userID, CodeLock codeLock);
    private bool IsPlayerAuthorizedToLock(BasePlayer player, BaseLock baseLock);
    private bool PlayerHasMasterKeyForLock(BasePlayer player);
    private bool IsLockSharedWithPlayer(BasePlayer player, BaseLock baseLock);
    private bool CanPlayerBypassLock(BasePlayer player, BaseLock baseLock, bool provideFeedback);
    private object CanPlayerInteractWithVehicle(BasePlayer player, BaseEntity vehicle, bool provideFeedback);
    private BaseEntity GetParentVehicle(BaseEntity entity);
    private object CanPlayerInteractWithParentVehicle(BasePlayer player, BaseEntity entity, bool provideFeedback);
    private static bool DeployWasBlocked(BaseEntity vehicle, BasePlayer player, LockInfo lockInfo);
    private static BaseEntity GetLookEntity(BasePlayer player, float maxDistance);
    private static bool IsDead(BaseEntity entity);
    private static VehicleModuleSeating FindFirstDriverModule(ModularCar car);
    private static bool CanCarHaveLock(ModularCar car);
    private static bool CanVehicleHaveALock(BaseEntity vehicle);
    private static Item GetPlayerLockItem(BasePlayer player, LockInfo lockInfo);
    private static PayType DeterminePayType(IPlayer player, LockInfo lockInfo);
    private static bool CanPlayerAffordLock(BasePlayer player, LockInfo lockInfo, PayType payType);
    private static RidableHorse2 GetClosestHorse(HitchTrough hitchTrough, BasePlayer player);
    private static void ClaimVehicle(BaseEntity vehicle, ulong ownerId);
    private bool IsVehicleConnectedEntity(BasePlayer basePlayer, BaseEntity entity, BaseEntity vehicle);
    private VehicleInfo GetVehicleAndInfo(BaseEntity entity, BasePlayer basePlayer, BaseEntity vehicle, bool fromDeployHook);
    private bool AllowNoOwner(BaseEntity vehicle);
    private bool AllowDifferentOwner(IPlayer player, BaseEntity vehicle);
    private void MaybeChargePlayerForLock(BasePlayer player, LockInfo lockInfo, PayType payType);
    private BaseLock DeployLock(BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo, ulong ownerId);
    private BaseLock DeployLockForPlayer(BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo, BasePlayer player, PayType payType);
    private BaseLock DeployLockForAPI(BaseEntity vehicle, BasePlayer player, LockInfo lockInfo, bool isFree);
    private bool CanPlayerDeployLockForAPI(BasePlayer player, BaseEntity vehicle, LockInfo lockInfo);
    private bool VerifyDeployDistance(IPlayer player, BaseEntity vehicle);
    private bool VerifyPermissionToVehicleAndLockType(IPlayer player, VehicleInfo vehicleInfo, LockInfo lockInfo);
    private bool VerifyVehicleIsNotDead(IPlayer player, BaseEntity vehicle);
    private bool VerifyNotForSale(IPlayer player, BaseEntity vehicle);
    private bool VerifyNoOwnershipRestriction(IPlayer player, BaseEntity vehicle);
    private bool VerifyCanBuild(IPlayer player, BaseEntity vehicle);
    private bool VerifyVehicleHasNoLock(IPlayer player, BaseEntity vehicle);
    private bool VerifyVehicleCanHaveALock(IPlayer player, BaseEntity vehicle);
    private bool VerifyPlayerCanAffordLock(BasePlayer player, LockInfo lockInfo, PayType payType);
    private bool VerifyOffCooldown(IPlayer player, LockInfo lockInfo, PayType payType);
    private bool VerifyPlayerCanDeployLock(IPlayer player, LockInfo lockInfo, PayType payType);
    private bool VerifyNotMounted(IPlayer player, BaseEntity vehicle, VehicleInfo vehicleInfo);
    private bool VerifyCanDeploy(IPlayer player, BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo, PayType payType);
    private class VehicleInfo
    {
        public string VehicleType;
        public string[] PrefabPaths;
        public Vector3 LockPosition;
        public Quaternion LockRotation;
        public string ParentBone;
        public string CodeLockPermission { get; set; }
        public string KeyLockPermission { get; set; }
        public uint[] PrefabIds { get; set; }
        public Func<BaseEntity, BaseEntity> DetermineLockParent;
        public Func<BaseEntity, float> TimeSinceLastUsed;
        public void OnServerInitialized(VehicleDeployedLocks plugin);
        public bool IsMounted(BaseEntity entity);
    }

    private class VehicleInfoManager
    {
        private static readonly FieldInfo BikeTimeSinceLastUsedField;
        private readonly VehicleDeployedLocks _plugin;
        private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo;
        private readonly Dictionary<string, VehicleInfo> _customVehicleTypes;
        public VehicleInfoManager(VehicleDeployedLocks plugin);
        public void OnServerInitialized();
        public void RegisterCustomVehicleType(VehicleDeployedLocks plugin, VehicleInfo vehicleInfo);
        public VehicleInfo GetVehicleInfo(BaseEntity entity);
        public BaseEntity GetCustomVehicleParent(BaseEntity entity);
    }

    private class LockInfo
    {
        public int ItemId;
        public string Prefab;
        public string PermissionAllVehicles;
        public string PermissionFree;
        public string PreHookName;
        public ItemDefinition ItemDefinition { get; set; }
        public ItemBlueprint Blueprint { get; set; }
    }

    private readonly LockInfo LockInfo_CodeLock;
    private readonly LockInfo LockInfo_KeyLock;
    private class LockedVehicleTracker
    {
        public Dictionary<VehicleInfo, HashSet<BaseEntity>> VehiclesWithLocksByType { get; set; }
        private readonly VehicleInfoManager _vehicleInfoManager;
        public LockedVehicleTracker(VehicleInfoManager vehicleInfoManager);
        public void OnServerInitialized();
        public void OnLockAdded(BaseEntity vehicle);
        public void OnLockRemoved(BaseEntity vehicle);
        private HashSet<BaseEntity> EnsureEntityList(VehicleInfo vehicleInfo);
        private HashSet<BaseEntity> GetEntityListForVehicle(BaseEntity entity);
    }

    private class AutoUnlockManager
    {
        private VehicleDeployedLocks _plugin;
        private LockedVehicleTracker _lockedVehicleTracker;
        private AutoUnlockSettings _autoUnlockSettings;
        public AutoUnlockManager(VehicleDeployedLocks plugin, LockedVehicleTracker lockedVehicleTracker);
        public void OnServerInitialized(AutoUnlockSettings settings);
        private void CheckVehicles();
        private void Unlock(BaseLock baseLock);
    }

    private class ReskinEvent
    {
        public BaseEntity Entity;
        public BaseLock BaseLock;
        public Vector3 Position;
        public void Assign(BaseEntity entity, BaseLock baseLock);
        public void Reset();
    }

    private class ReskinManager
    {
        private VehicleInfoManager _vehicleInfoManager;
        private LockedVehicleTracker _lockedVehicleTracker;
        private ReskinEvent _pooledReskinEvent;
        private List<ReskinEvent> _reskinEvents;
        public readonly Action CleanupAction;
        public ReskinManager(VehicleInfoManager vehicleInfoManager, LockedVehicleTracker lockedVehicleTracker);
        public void HandleReskinPre(BaseEntity entity, BaseLock baseLock);
        public void HandleReskinPost(BaseEntity entity);
        private ReskinEvent FindReskinEventForPosition(Vector3 position);
        private void CleanupEvents();
    }

    private class CooldownManager
    {
        private readonly Dictionary<string, float> _cooldownMap;
        private readonly float _cooldownDuration;
        public CooldownManager(float duration);
        public void UpdateLastUsedForPlayer(string userID);
        public float GetSecondsRemaining(string userID);
    }

    private CooldownManager GetCooldownManager(LockInfo lockInfo);
    private class AutoUnlockSettings
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
        [JsonProperty("Unlock after idle time (seconds)")]
        public float IdleSeconds;
        [JsonProperty("IdleSeconds")]
        private float DeprecatedIdleSeconds { get; set; }
        [JsonProperty("Check interval seconds")]
        public float CheckIntervalSeconds;
        [JsonProperty("CheckIntervalSeconds")]
        private float DeprecatedCheckIntervalSeconds { get; set; }
        [JsonProperty("Exempt owned vehicles")]
        public bool ExemptOwnedVehicles;
        [JsonProperty("ExemptOwnedVehicles")]
        private bool DeprecatedExemptOwnedVehicles { get; set; }
        [JsonProperty("Exempt vehicles near cupboards")]
        public bool ExemptNearTC;
        [JsonProperty("ExemptNearTC")]
        private bool DeprecatedExemptNearTC { get; set; }
    }

    private class ModularCarSettings
    {
        [JsonProperty("Allow editing while locked out")]
        public bool AllowEditingWhileLockedOut;
        [JsonProperty("AllowEditingWhileLockedOut")]
        private bool DeprecatedAllowEditingWhileLockedOut { get; set; }
    }

    private class SharingSettings
    {
        [JsonProperty("Clan")]
        public bool Clan;
        [JsonProperty("Clan or ally")]
        public bool ClanOrAlly;
        [JsonProperty("ClanOrAlly")]
        private bool DeprecatedClanOrAlly { get; set; }
        [JsonProperty("Friends")]
        public bool Friends;
        [JsonProperty("Team")]
        public bool Team;
    }

    private class Configuration : BaseConfiguration
    {
        [JsonProperty("Update lock positions", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool UpdateLockPositions;
        [JsonProperty("Allow NPCs to bypass locks")]
        public bool AllowNPCsToBypassLocks;
        [JsonProperty("Allow deploying locks onto vehicles owned by other players")]
        public bool AllowIfDifferentOwner;
        [JsonProperty("AllowIfDifferentOwner")]
        private bool DeprecatedAllowIfDifferentOwner { get; set; }
        [JsonProperty("Allow deploying locks onto unowned vehicles")]
        public bool AllowIfNoOwner;
        [JsonProperty("AllowIfNoOwner")]
        private bool DeprecatedAllowIfNoOwner { get; set; }
        [JsonProperty("Require cupboard auth to deploy locks onto unowned vehicles")]
        public bool RequireTCIfNoOwner;
        [JsonProperty("RequireTCIfNoOwner")]
        private bool DeprecatedRequireTCIfNoOwner { get; set; }
        [JsonProperty("Auto claim unowned vehicles when deploying locks")]
        public bool AutoClaimUnownedVehicles;
        [JsonProperty("Auto replace vehicle ownership when deploying locks")]
        public bool AutoReplaceVehicleOwnership;
        [JsonProperty("Allow pushing vehicles while locked out")]
        public bool AllowPushWhileLockedOut;
        [JsonProperty("AllowPushWhileLockedOut")]
        private bool DeprecatedAllowPushWhileLockedOut { get; set; }
        [JsonProperty("Cooldown to auto craft locks (seconds)")]
        public float CraftCooldownSeconds;
        [JsonProperty("CraftCooldownSeconds")]
        private float DeprecatedCraftCooldownSeconds { get; set; }
        [JsonProperty("Modular car settings")]
        public ModularCarSettings ModularCarSettings;
        [JsonProperty("ModularCarSettings")]
        private ModularCarSettings DeprecatedModularCarSettings { get; set; }
        [JsonProperty("Lock sharing settings")]
        public SharingSettings SharingSettings;
        [JsonProperty("DefaultSharingSettings")]
        private SharingSettings DeprecatedSharingSettings { get; set; }
        [JsonProperty("Auto unlock idle vehicles")]
        public AutoUnlockSettings AutoUnlockSettings;
        [JsonProperty("AutoUnlockIdleVehicles")]
        private AutoUnlockSettings DeprecatedAutoUnlockSettings { get; set; }
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(string playerId, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    private void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    private void ChatMessage(BasePlayer player, string messageName, object[] args);
    private static class Lang
    {
        public const string GenericErrorNoPermission;
        public const string GenericErrorBuildingBlocked;
        public const string GenericErrorCooldown;
        public const string GenericErrorVehicleLocked;
        public const string DeployErrorNoVehicleFound;
        public const string DeployErrorVehicleDead;
        public const string DeployErrorOther;
        public const string DeployErrorDifferentOwner;
        public const string DeployErrorNoOwner;
        public const string DeployErrorNoOwnerRequiresTC;
        public const string DeployErrorHasLock;
        public const string DeployErrorInsufficientResources;
        public const string DeployErrorMounted;
        public const string DeployErrorModularCarNoCockpit;
        public const string DeployErrorDistance;
    }

    protected override void LoadDefaultMessages();
}

private class VehicleInfo
{
    public string VehicleType;
    public string[] PrefabPaths;
    public Vector3 LockPosition;
    public Quaternion LockRotation;
    public string ParentBone;
    public string CodeLockPermission { get; set; }
    public string KeyLockPermission { get; set; }
    public uint[] PrefabIds { get; set; }
    public Func<BaseEntity, BaseEntity> DetermineLockParent;
    public Func<BaseEntity, float> TimeSinceLastUsed;
    public void OnServerInitialized(VehicleDeployedLocks plugin);
    public bool IsMounted(BaseEntity entity);
}

private class VehicleInfoManager
{
    private static readonly FieldInfo BikeTimeSinceLastUsedField;
    private readonly VehicleDeployedLocks _plugin;
    private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo;
    private readonly Dictionary<string, VehicleInfo> _customVehicleTypes;
    public VehicleInfoManager(VehicleDeployedLocks plugin);
    public void OnServerInitialized();
    public void RegisterCustomVehicleType(VehicleDeployedLocks plugin, VehicleInfo vehicleInfo);
    public VehicleInfo GetVehicleInfo(BaseEntity entity);
    public BaseEntity GetCustomVehicleParent(BaseEntity entity);
}

private class LockInfo
{
    public int ItemId;
    public string Prefab;
    public string PermissionAllVehicles;
    public string PermissionFree;
    public string PreHookName;
    public ItemDefinition ItemDefinition { get; set; }
    public ItemBlueprint Blueprint { get; set; }
}

private class LockedVehicleTracker
{
    public Dictionary<VehicleInfo, HashSet<BaseEntity>> VehiclesWithLocksByType { get; set; }
    private readonly VehicleInfoManager _vehicleInfoManager;
    public LockedVehicleTracker(VehicleInfoManager vehicleInfoManager);
    public void OnServerInitialized();
    public void OnLockAdded(BaseEntity vehicle);
    public void OnLockRemoved(BaseEntity vehicle);
    private HashSet<BaseEntity> EnsureEntityList(VehicleInfo vehicleInfo);
    private HashSet<BaseEntity> GetEntityListForVehicle(BaseEntity entity);
}

private class AutoUnlockManager
{
    private VehicleDeployedLocks _plugin;
    private LockedVehicleTracker _lockedVehicleTracker;
    private AutoUnlockSettings _autoUnlockSettings;
    public AutoUnlockManager(VehicleDeployedLocks plugin, LockedVehicleTracker lockedVehicleTracker);
    public void OnServerInitialized(AutoUnlockSettings settings);
    private void CheckVehicles();
    private void Unlock(BaseLock baseLock);
}

private class ReskinEvent
{
    public BaseEntity Entity;
    public BaseLock BaseLock;
    public Vector3 Position;
    public void Assign(BaseEntity entity, BaseLock baseLock);
    public void Reset();
}

private class ReskinManager
{
    private VehicleInfoManager _vehicleInfoManager;
    private LockedVehicleTracker _lockedVehicleTracker;
    private ReskinEvent _pooledReskinEvent;
    private List<ReskinEvent> _reskinEvents;
    public readonly Action CleanupAction;
    public ReskinManager(VehicleInfoManager vehicleInfoManager, LockedVehicleTracker lockedVehicleTracker);
    public void HandleReskinPre(BaseEntity entity, BaseLock baseLock);
    public void HandleReskinPost(BaseEntity entity);
    private ReskinEvent FindReskinEventForPosition(Vector3 position);
    private void CleanupEvents();
}

private class CooldownManager
{
    private readonly Dictionary<string, float> _cooldownMap;
    private readonly float _cooldownDuration;
    public CooldownManager(float duration);
    public void UpdateLastUsedForPlayer(string userID);
    public float GetSecondsRemaining(string userID);
}

private class AutoUnlockSettings
{
    [JsonProperty("Enabled")]
    public bool Enabled;
    [JsonProperty("Unlock after idle time (seconds)")]
    public float IdleSeconds;
    [JsonProperty("IdleSeconds")]
    private float DeprecatedIdleSeconds { get; set; }
    [JsonProperty("Check interval seconds")]
    public float CheckIntervalSeconds;
    [JsonProperty("CheckIntervalSeconds")]
    private float DeprecatedCheckIntervalSeconds { get; set; }
    [JsonProperty("Exempt owned vehicles")]
    public bool ExemptOwnedVehicles;
    [JsonProperty("ExemptOwnedVehicles")]
    private bool DeprecatedExemptOwnedVehicles { get; set; }
    [JsonProperty("Exempt vehicles near cupboards")]
    public bool ExemptNearTC;
    [JsonProperty("ExemptNearTC")]
    private bool DeprecatedExemptNearTC { get; set; }
}

private class ModularCarSettings
{
    [JsonProperty("Allow editing while locked out")]
    public bool AllowEditingWhileLockedOut;
    [JsonProperty("AllowEditingWhileLockedOut")]
    private bool DeprecatedAllowEditingWhileLockedOut { get; set; }
}

private class SharingSettings
{
    [JsonProperty("Clan")]
    public bool Clan;
    [JsonProperty("Clan or ally")]
    public bool ClanOrAlly;
    [JsonProperty("ClanOrAlly")]
    private bool DeprecatedClanOrAlly { get; set; }
    [JsonProperty("Friends")]
    public bool Friends;
    [JsonProperty("Team")]
    public bool Team;
}

private class Configuration : BaseConfiguration
{
    [JsonProperty("Update lock positions", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool UpdateLockPositions;
    [JsonProperty("Allow NPCs to bypass locks")]
    public bool AllowNPCsToBypassLocks;
    [JsonProperty("Allow deploying locks onto vehicles owned by other players")]
    public bool AllowIfDifferentOwner;
    [JsonProperty("AllowIfDifferentOwner")]
    private bool DeprecatedAllowIfDifferentOwner { get; set; }
    [JsonProperty("Allow deploying locks onto unowned vehicles")]
    public bool AllowIfNoOwner;
    [JsonProperty("AllowIfNoOwner")]
    private bool DeprecatedAllowIfNoOwner { get; set; }
    [JsonProperty("Require cupboard auth to deploy locks onto unowned vehicles")]
    public bool RequireTCIfNoOwner;
    [JsonProperty("RequireTCIfNoOwner")]
    private bool DeprecatedRequireTCIfNoOwner { get; set; }
    [JsonProperty("Auto claim unowned vehicles when deploying locks")]
    public bool AutoClaimUnownedVehicles;
    [JsonProperty("Auto replace vehicle ownership when deploying locks")]
    public bool AutoReplaceVehicleOwnership;
    [JsonProperty("Allow pushing vehicles while locked out")]
    public bool AllowPushWhileLockedOut;
    [JsonProperty("AllowPushWhileLockedOut")]
    private bool DeprecatedAllowPushWhileLockedOut { get; set; }
    [JsonProperty("Cooldown to auto craft locks (seconds)")]
    public float CraftCooldownSeconds;
    [JsonProperty("CraftCooldownSeconds")]
    private float DeprecatedCraftCooldownSeconds { get; set; }
    [JsonProperty("Modular car settings")]
    public ModularCarSettings ModularCarSettings;
    [JsonProperty("ModularCarSettings")]
    private ModularCarSettings DeprecatedModularCarSettings { get; set; }
    [JsonProperty("Lock sharing settings")]
    public SharingSettings SharingSettings;
    [JsonProperty("DefaultSharingSettings")]
    private SharingSettings DeprecatedSharingSettings { get; set; }
    [JsonProperty("Auto unlock idle vehicles")]
    public AutoUnlockSettings AutoUnlockSettings;
    [JsonProperty("AutoUnlockIdleVehicles")]
    private AutoUnlockSettings DeprecatedAutoUnlockSettings { get; set; }
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private static class Lang
{
    public const string GenericErrorNoPermission;
    public const string GenericErrorBuildingBlocked;
    public const string GenericErrorCooldown;
    public const string GenericErrorVehicleLocked;
    public const string DeployErrorNoVehicleFound;
    public const string DeployErrorVehicleDead;
    public const string DeployErrorOther;
    public const string DeployErrorDifferentOwner;
    public const string DeployErrorNoOwner;
    public const string DeployErrorNoOwnerRequiresTC;
    public const string DeployErrorHasLock;
    public const string DeployErrorInsufficientResources;
    public const string DeployErrorMounted;
    public const string DeployErrorModularCarNoCockpit;
    public const string DeployErrorDistance;
}


```

---

## VehicleLicence by ViolationHandler - Allows players to buy, spawn and recall: Boat, RHIB, Sedan, HotAirBalloon, MiniCopter, CH47, etc.

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Rust;
using Rust.Modular;
using UnityEngine;
using Debug = UnityEngine.Debug;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Vehicle Licence", "Sorrow/TheDoc/Arainrr", "1.8.7")]
[Description("Allows players to buy vehicles and then spawn or store it")]
public class VehicleLicence : RustPlugin
{
    [PluginReference]
    private readonly Plugin Economics;
    private readonly Plugin ServerRewards;
    private readonly Plugin Friends;
    private readonly Plugin Clans;
    private readonly Plugin NoEscape;
    private readonly Plugin LandOnCargoShip;
    private readonly Plugin RustTranslationAPI;
    private readonly Plugin ZoneManager;
    private readonly string PERMISSION_USE;
    private readonly string PERMISSION_ALL;
    private readonly string PERMISSION_ADMIN;
    private readonly string PERMISSION_BYPASS_COST;
    private readonly string PERMISSION_NO_DAMAGE;
    private readonly string PERMISSION_NO_COLLISION_DAMAGE;
    private const int ITEMID_FUEL;
    private const int ITEMID_HOTAIRBALLOON_ARMOR;
    private const string PREFAB_ITEM_DROP;
    private const string PREFAB_PEDALBIKE;
    private const string PREFAB_PEDALTRIKE;
    private const string PREFAB_MOTORBIKE;
    private const string PREFAB_MOTORBIKE_SIDECAR;
    private const string PREFAB_ATV;
    private const string PREFAB_SOFA;
    private const string PREFAB_WATERBIRD;
    private const string PREFAB_WARBIRD;
    private const string PREFAB_LITTLEBIRD;
    private const string PREFAB_FIGHTER;
    private const string PREFAB_OLDFIGHTER;
    private const string PREFAB_FIGHTERBUS;
    private const string PREFAB_WARBUS;
    private const string PREFAB_AIRBUS;
    private const string PREFAB_PATROLHELI;
    private const string PREFAB_RUSTWING;
    private const string PREFAB_RUSTWINGDETAILED;
    private const string PREFAB_RUSTWINGDETAILEDOLD;
    private const string PREFAB_TINFIGHTER;
    private const string PREFAB_TINFIGHTERDETAILED;
    private const string PREFAB_TINFIGHTERDETAILEDOLD;
    private const string PREFAB_MARSFIGHTER;
    private const string PREFAB_MARSFIGHTERDETAILED;
    private const string PREFAB_SKYPLANE;
    private const string PREFAB_SKYBOAT;
    private const string PREFAB_TWISTEDTRUCK;
    private const string PREFAB_TRIANWRECK;
    private const string PREFAB_TRIANWRECKER;
    private const string PREFAB_SANTA;
    private const string PREFAB_WARSANTA;
    private const string PREFAB_WITCH;
    private const string PREFAB_MAGICCARPET;
    private const string PREFAB_AH69T;
    private const string PREFAB_AH69R;
    private const string PREFAB_AH69A;
    private const string PREFAB_MAVIK;
    private const string PREFAB_HEAVYFIGHTER;
    private const string PREFAB_PORCELAINCOMMANDER;
    private const string PREFAB_DUNEBUGGIE;
    private const string PREFAB_DUNETRUCKARMED;
    private const string PREFAB_DUNETRUCKUNARMED;
    private const string PREFAB_DOOMSDAYDISCOVAN;
    private const string PREFAB_FORKLIFT;
    private const string PREFAB_LAWNMOWER;
    private const string PREFAB_CHARIOT;
    private const string PREFAB_SOULHARVESTER;
    private const string PREFAB_KAYAK;
    private const string PREFAB_TUGBOAT;
    private const string PREFAB_ROWBOAT;
    private const string PREFAB_RHIB;
    private const string PREFAB_SEDAN;
    private const string PREFAB_HOTAIRBALLOON;
    private const string PREFAB_MINICOPTER;
    private const string PREFAB_ATTACKHELICOPTER;
    private const string PREFAB_TRANSPORTCOPTER;
    private const string PREFAB_CHINOOK;
    private const string PREFAB_RIDABLEHORSE;
    private const string PREFAB_WORKCART;
    private const string PREFAB_SEDANRAIL;
    private const string PREFAB_MAGNET_CRANE;
    private const string PREFAB_SUBMARINE_DUO;
    private const string PREFAB_SUBMARINE_SOLO;
    private const string PREFAB_CHASSIS_SMALL;
    private const string PREFAB_CHASSIS_MEDIUM;
    private const string PREFAB_CHASSIS_LARGE;
    private const string PREFAB_SNOWMOBILE;
    private const string PREFAB_SNOWMOBILE_TOMAHA;
    private const string PREFAB_TRAINENGINE;
    private const string PREFAB_TRAINENGINE_COVERED;
    private const string PREFAB_TRAINENGINE_LOCOMOTIVE;
    private const string PREFAB_TRAINWAGON_A;
    private const string PREFAB_TRAINWAGON_B;
    private const string PREFAB_TRAINWAGON_C;
    private const string PREFAB_TRAINWAGON_UNLOADABLE;
    private const string PREFAB_TRAINWAGON_UNLOADABLE_FUEL;
    private const string PREFAB_TRAINWAGON_UNLOADABLE_LOOT;
    private const string PREFAB_CABOOSE;
    private readonly float TUGBOAT_ENGINETHRUST;
    private readonly float HELICOPTER_LIFT;
    private readonly Vector3 SCRAP_HELICOPTER_TORQUE;
    private readonly Vector3 MINICOPTER_TORQUE;
    private readonly Vector3 ATTACK_HELICOPTER_TORQUE;
    private const int LAYER_GROUND;
    private readonly object _false;
    private bool finishedLoading;
    public static VehicleLicence Instance { get; set; }
    public readonly Dictionary<BaseEntity, Vehicle> vehiclesCache;
    public readonly Dictionary<string, BaseVehicleSettings> allVehicleSettings;
    public readonly Dictionary<string, string> commandToVehicleType;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnServerSave();
    private void OnEntityDismounted(BaseMountable entity, BasePlayer player);
    private void OnEngineStarted(BaseMountable entity, BasePlayer player);
    private object OnVehiclePush(BaseVehicle vehicle, BasePlayer player);
    private object CanMountEntity(BasePlayer friend, BaseMountable entity);
    private object CanLootEntity(BasePlayer friend, RidableHorse2 horse);
    private object CanLootEntity(BasePlayer friend, StorageContainer container);
    private object CanLootEntityInternal(BasePlayer friend, BaseEntity parentEntity);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    private void OnEntitySpawned(Tugboat tugboat);
    private void OnEntitySpawned(BaseSubmarine baseSubmarine);
    private void OnEntitySpawned(MotorRowboat motorRowboat);
    private void OnEntitySpawned(Minicopter miniCopter);
    private void OnEntitySpawned(AttackHelicopter attackHelicopter);
    private void OnRidableAnimalClaimed(BaseRidableAnimal ridableAnimal, BasePlayer player);
    private object OnEntityEnter(TriggerHurtNotChild triggerHurtNotChild, BasePlayer player);
    private object OnEntityEnter(TriggerHurt triggerHurt, BasePlayer player);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private void OnEntityKill(BaseCombatEntity entity);
    private object OnEntityReskin(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player);
    private void SendCantUseMessage(BasePlayer friend, Vehicle vehicle);
    private void SendCantPushMessage(BasePlayer friend, Vehicle vehicle);
    private void OnEntityDeathOrKill(BaseCombatEntity entity, bool isCrash);
    private void CheckVehicles();
    private bool VehicleIsActive(BaseEntity entity, Vehicle vehicle, double currentTimestamp);
    private void RefundVehicleItems(Vehicle vehicle, bool isCrash, bool isUnload);
    private static void DropItemContainer(BaseEntity entity, ulong playerId, List<Item> collect);
    private bool TryPay(BasePlayer player, BaseVehicleSettings settings, Dictionary<string, PriceInfo> prices, string resources);
    private bool CanPay(BasePlayer player, Dictionary<string, PriceInfo> prices, string resources);
    private int CheckBalance(string key, int price, ulong playerId);
    private bool AreFriends(ulong playerId, ulong friendId);
    private static bool SameTeam(ulong playerId, ulong friendId);
    private bool HasFriend(ulong playerId, ulong friendId);
    private bool SameClan(ulong playerId, ulong friendId);
    private bool IsPlayerBlocked(BasePlayer player);
    private bool IsRaidBlocked(string playerId);
    private bool IsCombatBlocked(string playerId);
    private bool InZone(BasePlayer player);
    private BaseVehicleSettings GetBaseVehicleSettings(string vehicleType);
    private BaseVehicleSettings GetBaseVehicleSettings(NormalVehicleType normalVehicleType);
    private BaseVehicleSettings GetCustomVehicleSettings(CustomVehicleType normalVehicleType);
    private bool GetBaseVehicleCollisionDamage(string vehicleType);
    private bool GetBaseVehicleCollisionDamage(NormalVehicleType normalVehicleType);
    private bool GetBaseVehicleCollisionDamage(CustomVehicleType normalVehicleType);
    private bool GetBaseVehicleDamage(string vehicleType);
    private bool GetBaseVehicleDamage(NormalVehicleType normalVehicleType);
    private bool GetBaseVehicleDamage(CustomVehicleType normalVehicleType);
    private bool HasAdminPermission(BasePlayer player);
    private bool CanViewVehicleInfo(BasePlayer player, string vehicleType, BaseVehicleSettings settings);
    private bool HasVehiclePermission(BasePlayer player, string vehicleType);
    private void TryClaimVehicle(BaseVehicle baseVehicle);
    private void TryClaimVehicle(BaseVehicle baseVehicle, BasePlayer player);
    private bool TryClaimVehicle(BasePlayer player, BaseEntity entity, string vehicleType);
    private bool TryGetVehicle(BaseEntity entity, Vehicle vehicle);
    private IEnumerator UpdatePlayerData(double currentTimestamp);
    private static NormalVehicleType? GetClaimableVehicleType(BaseVehicle baseVehicle);
    private static bool GetDismountPosition(BaseVehicle baseVehicle, BasePlayer player, Vector3 result);
    private static bool VehicleAnyMounted(BaseEntity entity);
    private static void DismountAllPlayers(BaseEntity entity);
    private static Vector3 GetGroundPositionLookingAt(BasePlayer player, float distance, bool needUp);
    private static Vector3 GetGroundPosition(Vector3 position, bool needUp);
    private static bool IsInWater(Vector3 position);
    private static void MoveToPosition(BasePlayer player, Vector3 position);
    private static void AuthTeamOnTugboat(Tugboat tug, BasePlayer player);
    [HookMethod(nameof(IsLicensedVehicle))]
    public bool IsLicensedVehicle(BaseEntity entity);
    [HookMethod(nameof(GetLicensedVehicle))]
    public BaseEntity GetLicensedVehicle(ulong playerId, string license);
    [HookMethod(nameof(HasVehicleLicense))]
    public bool HasVehicleLicense(ulong playerId, string license);
    [HookMethod(nameof(RemoveVehicleLicense))]
    public bool RemoveVehicleLicense(ulong playerId, string license);
    [HookMethod(nameof(AddVehicleLicense))]
    public bool AddVehicleLicense(ulong playerId, string license);
    [HookMethod(nameof(GetVehicleLicenses))]
    public List<string> GetVehicleLicenses(ulong playerId);
    [HookMethod(nameof(PurchaseAllVehicles))]
    public void PurchaseAllVehicles(ulong playerId);
    private void CmdUniversal(BasePlayer player, string command, string[] args);
    private void HandleUniversalCmd(BasePlayer player, string vehicleType, bool bypassCooldown, string command);
    private void CmdCustomKill(BasePlayer player, string command, string[] args);
    private void CmdLicenseHelp(BasePlayer player, string command, string[] args);
    [ConsoleCommand("vl.remove")]
    private void CCmdRemoveVehicle(ConsoleSystem.Arg arg);
    [ConsoleCommand("vl.cleardata")]
    private void CCmdClearVehicle(ConsoleSystem.Arg arg);
    [ConsoleCommand("vl.buy")]
    private void CCmdBuyVehicle(ConsoleSystem.Arg arg);
    private void CmdBuyVehicle(BasePlayer player, string command, string[] args);
    private bool BuyVehicle(BasePlayer player, string vehicleType, bool response);
    [ConsoleCommand("vl.spawn")]
    private void CCmdSpawnVehicle(ConsoleSystem.Arg arg);
    private void CmdSpawnVehicle(BasePlayer player, string command, string[] args);
    private bool SpawnVehicle(BasePlayer player, string vehicleType, bool bypassCooldown, string command);
    private bool CanSpawn(BasePlayer player, Vehicle vehicle, bool bypassCooldown, string command, string reason, Vector3 position, Quaternion rotation);
    private void SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation, bool response);
    private void CacheVehicleEntity(BaseEntity entity, Vehicle vehicle, BasePlayer player);
    [ConsoleCommand("vl.recall")]
    private void CCmdRecallVehicle(ConsoleSystem.Arg arg);
    private void CmdRecallVehicle(BasePlayer player, string command, string[] args);
    private bool RecallVehicle(BasePlayer player, string vehicleType, bool bypassCooldown, string command);
    private bool CanRecall(BasePlayer player, Vehicle vehicle, bool bypassCooldown, string command, string reason, Vector3 position, Quaternion rotation);
    private void RecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    [ConsoleCommand("vl.kill")]
    private void CCmdKillVehicle(ConsoleSystem.Arg arg);
    private void CmdKillVehicle(BasePlayer player, string command, string[] args);
    private void HandleKillCmd(BasePlayer player, string option);
    private bool KillVehicle(BasePlayer player, string vehicleType, bool response);
    private bool CanKill(BasePlayer player, Vehicle vehicle, BaseVehicleSettings settings);
    private bool IsValidBypassCooldownOption(string option);
    private bool IsValidOption(BasePlayer player, string option, string vehicleType);
    private bool IsValidVehicleType(string option, string vehicleType);
    private string FormatPriceInfo(BasePlayer player, Dictionary<string, PriceInfo> prices);
    private bool CanPlayerAction(BasePlayer player, Vehicle vehicle, BaseVehicleSettings settings, string reason, Vector3 position, Quaternion rotation);
    private bool HasMountedOrParented(BasePlayer player, BaseVehicleSettings settings);
    private bool CheckCooldown(BasePlayer player, Vehicle vehicle, BaseVehicleSettings settings, bool bypassCooldown, bool isSpawnCooldown, string command, string reason);
    private string GetItemTranslationByShortName(string language, string itemShortName);
    private string GetItemDisplayName(string language, string itemShortName, string displayName);
    public ConfigData configData { get; set; }
    public class ConfigData
    {
        [JsonProperty(PropertyName = "Settings")]
        public GlobalSettings global;
        [JsonProperty(PropertyName = "Chat Settings")]
        public ChatSettings chat;
        [JsonProperty("Allow vehicles to be spawned/recalled in zones listed in prevent spawning zones")]
        public bool CanSpawnInZones;
        [JsonProperty(PropertyName = "Zones to prevent users from spawning/recalled vehicles within.", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> AntiSpawnZones;
        [JsonProperty(PropertyName = "Normal Vehicle Settings")]
        public NormalVehicleSettings normalVehicles;
        [JsonProperty(PropertyName = "Modular Vehicle Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, ModularVehicleSettings> modularVehicles;
        [JsonProperty(PropertyName = "Train Vehicle Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, TrainVehicleSettings> trainVehicles;
        [DefaultValue(null)]
        [JsonProperty(PropertyName = "Custom Vehicle Settings", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public CustomVehicleSettings customVehicles;
        [JsonProperty(PropertyName = "Version")]
        public VersionNumber version;
    }

    public class ChatSettings
    {
        [JsonProperty(PropertyName = "Use Universal Chat Command")]
        public bool useUniversalCommand;
        [JsonProperty(PropertyName = "Help Chat Command")]
        public string helpCommand;
        [JsonProperty(PropertyName = "Buy Chat Command")]
        public string buyCommand;
        [JsonProperty(PropertyName = "Spawn Chat Command")]
        public string spawnCommand;
        [JsonProperty(PropertyName = "Recall Chat Command")]
        public string recallCommand;
        [JsonProperty(PropertyName = "Kill Chat Command")]
        public string killCommand;
        [JsonProperty(PropertyName = "Custom Kill Chat Command Prefix")]
        public string customKillCommandPrefix;
        [JsonProperty(PropertyName = "Bypass Cooldown Command")]
        public string bypassCooldownCommand;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong steamIDIcon;
    }

    public class GlobalSettings
    {
        [JsonProperty(PropertyName = "Store Vehicle On Plugin Unloaded / Server Restart")]
        public bool storeVehicle;
        [JsonProperty(PropertyName = "Clear Vehicle Data On Map Wipe")]
        public bool clearVehicleOnWipe;
        [JsonProperty(PropertyName = "Interval to check vehicle for wipe (Seconds)")]
        public float checkVehiclesInterval;
        [JsonProperty(PropertyName = "Spawn vehicle in the direction you are looking at")]
        public bool spawnLookingAt;
        [JsonProperty(PropertyName = "Automatically claim vehicles purchased from vehicle vendors")]
        public bool autoClaimFromVendor;
        [JsonProperty(PropertyName = "Vehicle vendor purchases will unlock the license for the player")]
        public bool autoUnlockFromVendor;
        [JsonProperty(PropertyName = "Limit the number of vehicles at a time")]
        public int limitVehicles;
        [JsonProperty(PropertyName = "Kill a random vehicle when the number of vehicles is limited")]
        public bool killVehicleLimited;
        [JsonProperty(PropertyName = "Prevent vehicles from damaging players")]
        public bool preventDamagePlayer;
        [JsonProperty(PropertyName = "Prevent vehicles from damaging NPCs")]
        public bool preventDamageNPCs;
        [JsonProperty(PropertyName = "Safe dismount players who jump off train")]
        public bool safeTrainDismount;
        [JsonProperty(PropertyName = "Prevent vehicles from shattering")]
        public bool preventShattering;
        [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling in safe zone")]
        public bool preventSafeZone;
        [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling when the player are building blocked")]
        public bool preventBuildingBlocked;
        [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling when the player is mounted or parented")]
        public bool preventMountedOrParented;
        [JsonProperty(PropertyName = "Check if any player mounted when recalling a vehicle")]
        public bool anyMountedRecall;
        [JsonProperty(PropertyName = "Check if any player mounted when killing a vehicle")]
        public bool anyMountedKill;
        [JsonProperty(PropertyName = "Dismount all players when a vehicle is recalled")]
        public bool dismountAllPlayersRecall;
        [JsonProperty(PropertyName = "Prevent other players from mounting vehicle")]
        public bool preventMounting;
        [JsonProperty(PropertyName = "Prevent mounting on driver's seat only")]
        public bool preventDriverSeat;
        [JsonProperty(PropertyName = "Prevent other players from looting fuel container and inventory")]
        public bool preventLooting;
        [JsonProperty(PropertyName = "Prevent other players from pushing vehicles they do not own")]
        public bool preventPushing;
        [JsonProperty(PropertyName = "Use Teams")]
        public bool useTeams;
        [JsonProperty(PropertyName = "Use Clans")]
        public bool useClans;
        [JsonProperty(PropertyName = "Use Friends")]
        public bool useFriends;
        [JsonProperty(PropertyName = "Vehicle No Decay")]
        public bool noDecay;
        [JsonProperty(PropertyName = "Vehicle No Fire Ball")]
        public bool noFireBall;
        [JsonProperty(PropertyName = "Vehicle No Server Gibs")]
        public bool noServerGibs;
        [JsonProperty(PropertyName = "Chinook No Map Marker")]
        public bool noMapMarker;
        [JsonProperty(PropertyName = "Use Raid Blocker (Need NoEscape Plugin)")]
        public bool useRaidBlocker;
        [JsonProperty(PropertyName = "Use Combat Blocker (Need NoEscape Plugin)")]
        public bool useCombatBlocker;
        [JsonProperty(PropertyName = "Populate the config with Custom Vehicles (CANNOT BE UNDONE! Will make config much larger)")]
        public bool useCustomVehicles;
    }

    public class NormalVehicleSettings
    {
        [JsonProperty(PropertyName = "Tugboat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TugboatSettings tugboat;
        [JsonProperty(PropertyName = "Sedan Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SedanSettings sedan;
        [JsonProperty(PropertyName = "Chinook Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public ChinookSettings chinook;
        [JsonProperty(PropertyName = "Rowboat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public RowboatSettings rowboat;
        [JsonProperty(PropertyName = "RHIB Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public RhibSettings rhib;
        [JsonProperty(PropertyName = "Hot Air Balloon Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public HotAirBalloonSettings hotAirBalloon;
        [JsonProperty(PropertyName = "Armored Hot Air Balloon Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public ArmoredHotAirBalloonSettings armoredHotAirBalloon;
        [JsonProperty(PropertyName = "Ridable Horse Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public RidableHorseSettings ridableHorse;
        [JsonProperty(PropertyName = "Mini Copter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MiniCopterSettings miniCopter;
        [JsonProperty(PropertyName = "Attack Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public AttackHelicopterSettings attackHelicopter;
        [JsonProperty(PropertyName = "Transport Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TransportHelicopterSettings transportHelicopter;
        [JsonProperty(PropertyName = "Work Cart Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public WorkCartSettings workCart;
        [JsonProperty(PropertyName = "Sedan Rail Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public WorkCartSettings sedanRail;
        [JsonProperty(PropertyName = "Magnet Crane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MagnetCraneSettings magnetCrane;
        [JsonProperty(PropertyName = "Submarine Solo Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SubmarineSoloSettings submarineSolo;
        [JsonProperty(PropertyName = "Submarine Duo Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SubmarineDuoSettings submarineDuo;
        [JsonProperty(PropertyName = "Snowmobile Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SnowmobileSettings snowmobile;
        [JsonProperty(PropertyName = "Tomaha Snowmobile Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SnowmobileSettings tomahaSnowmobile;
        [JsonProperty(PropertyName = "Pedal Bike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public PedalBikeSettings pedalBike;
        [JsonProperty(PropertyName = "Pedal Trike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public PedalTrikeSettings pedalTrike;
        [JsonProperty(PropertyName = "Motorbike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MotorBikeSettings motorBike;
        [JsonProperty(PropertyName = "Motorbike Sidecar Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MotorBikeSidecarSettings motorBikeSidecar;
        [JsonProperty(PropertyName = "Kayak Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public KayakSettings Kayak;
    }

    public class CustomVehicleSettings
    {
        [JsonProperty(PropertyName = "ATV Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public AtvSettings atv;
        [JsonProperty(PropertyName = "Race Sofa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public RaceSofaSettings raceSofa;
        [JsonProperty(PropertyName = "Water Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public WaterBirdSettings waterBird;
        [JsonProperty(PropertyName = "War Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public WarBirdSettings warBird;
        [JsonProperty(PropertyName = "Little Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public LittleBirdSettings littleBird;
        [JsonProperty(PropertyName = "Fighter Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public FighterSettings fighter;
        [JsonProperty(PropertyName = "Old Fighter Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public OldFighterSettings oldFighter;
        [JsonProperty(PropertyName = "Fighter Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public FighterBusSettings fighterBus;
        [JsonProperty(PropertyName = "War Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public WarBusSettings warBus;
        [JsonProperty(PropertyName = "Air Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public AirBusSettings airBus;
        [JsonProperty(PropertyName = "Patrol Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public PatrolHelicopterSettings patrolHeli;
        [JsonProperty(PropertyName = "Rust Wing Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public RustWingSettings rustWing;
        [JsonProperty(PropertyName = "Rust Wing Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public RustWingDetailedSettings rustWingDetailed;
        [JsonProperty(PropertyName = "Rust Wing Detailed Old Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public RustWingDetailedOldSettings rustWingDetailedOld;
        [JsonProperty(PropertyName = "Tin Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TinFighterSettings tinFighter;
        [JsonProperty(PropertyName = "Tin Fighter Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TinFighterDetailedSettings tinFighterDetailed;
        [JsonProperty(PropertyName = "Tin Fighter Detailed Old Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TinFighterDetailedOldSettings tinFighterDetailedOld;
        [JsonProperty(PropertyName = "Mars Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MarsFighterSettings marsFighter;
        [JsonProperty(PropertyName = "Mars Fighter Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MarsFighterDetailedSettings marsFighterDetailed;
        [JsonProperty(PropertyName = "Sky Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SkyPlaneSettings skyPlane;
        [JsonProperty(PropertyName = "Sky Boat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SkyBoatSettings skyBoat;
        [JsonProperty(PropertyName = "Twisted Truck Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TwistedTruckSettings twistedTruck;
        [JsonProperty(PropertyName = "Train Wreck Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TrainWreckSettings trainWreck;
        [JsonProperty(PropertyName = "Train Wrecker Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public TrainWreckerSettings trainWrecker;
        [JsonProperty(PropertyName = "Santa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SantaSettings santa;
        [JsonProperty(PropertyName = "War Santa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public WarSantaSettings warSanta;
        [JsonProperty(PropertyName = "Witch Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public WitchSettings witch;
        [JsonProperty(PropertyName = "Magic Carpet Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MagicCarpetSettings magicCarpet;
        [JsonProperty(PropertyName = "Ah69t Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Ah69tSettings ah69t;
        [JsonProperty(PropertyName = "Ah69r Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Ah69rSettings ah69r;
        [JsonProperty(PropertyName = "Ah69a Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Ah69aSettings ah69a;
        [JsonProperty(PropertyName = "Mavik Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public MavikSettings mavik;
        [JsonProperty(PropertyName = "Heavy Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public HeavyFighterSettings heavyFighter;
        [JsonProperty(PropertyName = "Porcelain Commander Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public PorcelainCommanderSettings porcelainCommander;
        [JsonProperty(PropertyName = "Dune Buggie Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public DuneBuggieSettings duneBuggie;
        [JsonProperty(PropertyName = "Dune Truck Armed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public DuneTruckArmedSettings duneTruckArmed;
        [JsonProperty(PropertyName = "Dune Truck UnArmed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public DuneTruckUnArmedSettings duneTruckUnArmed;
        [JsonProperty(PropertyName = "Dooms Day Disco Van Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public DoomsDayDiscoVanSettings doomsDayDiscoVan;
        [JsonProperty(PropertyName = "Lawn Mower Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public LawnMowerSettings lawnMower;
        [JsonProperty(PropertyName = "Fork Lift Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public ForkLiftSettings forkLift;
        [JsonProperty(PropertyName = "Chariot Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public ChariotSettings chariot;
        [JsonProperty(PropertyName = "Soul Harvester Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SoulHarvesterSettings soulHarvester;
    }

    [JsonObject(MemberSerialization.OptIn)]
    public abstract class BaseVehicleSettings
    {
        [JsonProperty(PropertyName = "Purchasable")]
        public bool Purchasable { get; set; }
        [JsonProperty(PropertyName = "No Damage")]
        public bool NoDamage { get; set; }
        [JsonProperty(PropertyName = "No Collision Damage")]
        public bool NoCollisionDamage { get; set; }
        [JsonProperty(PropertyName = "Display Name")]
        public string DisplayName { get; set; }
        [JsonProperty(PropertyName = "Use Permission")]
        public bool UsePermission { get; set; }
        [JsonProperty(PropertyName = "Permission")]
        public string Permission { get; set; }
        [JsonProperty(PropertyName = "Bypass Cost Permission")]
        public string BypassCostPermission { get; set; }
        [JsonProperty(PropertyName = "Distance To Spawn")]
        public float Distance { get; set; }
        [JsonProperty(PropertyName = "Time Before Vehicle Wipe (Seconds)")]
        public double WipeTime { get; set; }
        [JsonProperty(PropertyName = "Exclude cupboard zones when wiping")]
        public bool ExcludeCupboard { get; set; }
        [JsonProperty(PropertyName = "Maximum Health")]
        public float MaxHealth { get; set; }
        [JsonProperty(PropertyName = "Can Recall Maximum Distance")]
        public float RecallMaxDistance { get; set; }
        [JsonProperty(PropertyName = "Can Kill Maximum Distance")]
        public float KillMaxDistance { get; set; }
        [JsonProperty(PropertyName = "Minimum distance from player to recall or spawn")]
        public float MinDistanceForPlayers { get; set; }
        [JsonProperty(PropertyName = "Remove License Once Crashed")]
        public bool RemoveLicenseOnceCrash { get; set; }
        [JsonProperty(PropertyName = "Commands")]
        public List<string> Commands { get; set; }
        [JsonProperty(PropertyName = "Purchase Prices")]
        public Dictionary<string, PriceInfo> PurchasePrices { get; set; }
        [JsonProperty(PropertyName = "Spawn Prices")]
        public Dictionary<string, PriceInfo> SpawnPrices { get; set; }
        [JsonProperty(PropertyName = "Recall Prices")]
        public Dictionary<string, PriceInfo> RecallPrices { get; set; }
        [JsonProperty(PropertyName = "Recall Cooldown Bypass Prices")]
        public Dictionary<string, PriceInfo> BypassRecallCooldownPrices { get; set; }
        [JsonProperty(PropertyName = "Spawn Cooldown Bypass Prices")]
        public Dictionary<string, PriceInfo> BypassSpawnCooldownPrices { get; set; }
        [JsonProperty(PropertyName = "Spawn Cooldown (Seconds)")]
        public double SpawnCooldown { get; set; }
        [JsonProperty(PropertyName = "Recall Cooldown (Seconds)")]
        public double RecallCooldown { get; set; }
        [JsonProperty(PropertyName = "Cooldown Permissions")]
        public Dictionary<string, CooldownPermission> CooldownPermissions { get; set; }
        protected ConfigData configData { get; set; }
        public virtual bool IsWaterVehicle { get; set; }
        public virtual bool IsTrainVehicle { get; set; }
        public virtual bool IsNormalVehicle { get; set; }
        public virtual bool IsFightVehicle { get; set; }
        public virtual bool IsModularVehicle { get; set; }
        public virtual bool IsConnectableVehicle { get; set; }
        public virtual bool CustomVehicle { get; set; }
        protected virtual IFuelSystem GetFuelSystem(BaseEntity entity);
        protected virtual IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
        protected virtual string GetVehiclePrefab(string vehicleType);
        protected virtual string GetVehicleCustomPrefab(string vehicleType);
        public virtual BaseEntity SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        public virtual void PreSetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player);
        public virtual void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
        private BaseEntity ModifyVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player);
        public virtual void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        public virtual void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        protected virtual bool CanDropInventory();
        private void TryDropVehicleInventory(BasePlayer player, Vehicle vehicle);
        protected virtual DroppedItemContainer DropVehicleInventory(BasePlayer player, Vehicle vehicle);
        protected bool TryGetTrainCarPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
        protected bool TryMoveToTrainTrackNear(TrainCar trainCar);
        protected bool SpaceIsClearForTrainTrack(Vehicle vehicle, Vector3 position, Quaternion rotation);
        protected virtual bool CanRefundFuel(bool isCrash, bool isUnload);
        protected virtual bool CanRefundInventory(bool isCrash, bool isUnload);
        protected virtual void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload);
        public void RefundVehicleItems(Vehicle vehicle, bool isCrash, bool isUnload);
        protected void TryGiveFuel(BaseEntity entity, IFuelVehicle iFuelVehicle);
        public double GetCooldown(BasePlayer player, bool isSpawn);
        public virtual bool TryGetVehicleParams(BasePlayer player, Vehicle vehicle, string reason, Vector3 spawnPos, Quaternion spawnRot);
        protected virtual float GetSpawnRotationAngle();
        protected virtual Vector3 GetOriginalPosition(BasePlayer player);
        protected virtual bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
        protected virtual void CorrectPositionAndRotation(BasePlayer player, Vehicle vehicle, Vector3 original, Quaternion rotation, Vector3 spawnPos, Quaternion spawnRot);
        private void GetPositionWithNoPlayersNearby(BasePlayer player, Vector3 spawnPos);
        private bool TryGetCenterOfFloorNearby(Vector3 spawnPos);
    }

    public abstract class FuelVehicleSettings : BaseVehicleSettings, IFuelVehicle
    {
        public int SpawnFuelAmount { get; set; }
        public bool RefundFuelOnKill { get; set; }
        public bool RefundFuelOnCrash { get; set; }
        public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
        protected override bool CanRefundFuel(bool isCrash, bool isUnload);
    }

    public abstract class InventoryVehicleSettings : BaseVehicleSettings, IInventoryVehicle
    {
        public bool RefundInventoryOnKill { get; set; }
        public bool RefundInventoryOnCrash { get; set; }
        public bool DropInventoryOnRecall { get; set; }
        protected override bool CanDropInventory();
        protected override bool CanRefundInventory(bool isCrash, bool isUnload);
    }

    public abstract class InvFuelVehicleSettings : BaseVehicleSettings, IFuelVehicle, IInventoryVehicle
    {
        public int SpawnFuelAmount { get; set; }
        public bool RefundFuelOnKill { get; set; }
        public bool RefundFuelOnCrash { get; set; }
        public bool RefundInventoryOnKill { get; set; }
        public bool RefundInventoryOnCrash { get; set; }
        public bool DropInventoryOnRecall { get; set; }
        public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
        protected override bool CanDropInventory();
        protected override bool CanRefundInventory(bool isCrash, bool isUnload);
        protected override bool CanRefundFuel(bool isCrash, bool isUnload);
    }

    public class PedalBikeSettings : BaseVehicleSettings
    {
    }

    public class PedalTrikeSettings : BaseVehicleSettings
    {
    }

    public class MotorBikeSettings : FuelVehicleSettings
    {
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class MotorBikeSidecarSettings : FuelVehicleSettings
    {
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class AtvSettings : FuelVehicleSettings
    {
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class RaceSofaSettings : FuelVehicleSettings
    {
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class KayakSettings : BaseVehicleSettings
    {
        public override bool IsWaterVehicle { get; set; }
    }

    public class SedanSettings : BaseVehicleSettings
    {
    }

    public class ChinookSettings : BaseVehicleSettings
    {
    }

    public class RowboatSettings : InvFuelVehicleSettings
    {
        public override bool IsWaterVehicle { get; set; }
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
    }

    public class RhibSettings : RowboatSettings
    {
    }

    public class TugboatSettings : FuelVehicleSettings
    {
        public override bool IsWaterVehicle { get; set; }
        [JsonProperty(PropertyName = "Speed Multiplier")]
        public float speedMultiplier { get; set; }
        [JsonProperty(PropertyName = "Auto Auth Teammates on spawn/recall")]
        public bool autoAuth { get; set; }
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class HotAirBalloonSettings : InvFuelVehicleSettings
    {
        protected override float GetSpawnRotationAngle();
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
    }

    public class ArmoredHotAirBalloonSettings : HotAirBalloonSettings
    {
    }

    public class MiniCopterSettings : FuelVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        [JsonProperty("Rotation Scale")]
        public float rotationScale;
        [JsonProperty("Lift Fraction")]
        public float liftFraction;
        [JsonProperty("Seconds to pause flyhack when dismount from Mini Copter.")]
        public int flyHackPause;
        [JsonProperty("Instant Engine Start-up (instant take-off)")]
        public bool instantTakeoff;
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class AttackHelicopterSettings : InvFuelVehicleSettings
    {
        private const int HV_AMMO_ITEM_ID;
        private const int INCENDIARY_AMMO_ITEM_ID;
        private const int FLARE_ITEM_ID;
        [JsonProperty("HV Rocket Spawn Amount")]
        public int HVSpawnAmmoAmount { get; set; }
        [JsonProperty("Incendiary Rocket Spawn Amount")]
        public int IncendiarySpawnAmmoAmount { get; set; }
        [JsonProperty("Flare Spawn Amount")]
        public int FlareSpawnAmmoAmount { get; set; }
        public override bool IsFightVehicle { get; set; }
        [JsonProperty("Rotation Scale")]
        public float rotationScale;
        [JsonProperty("Lift Fraction")]
        public float liftFraction;
        [JsonProperty("Seconds to pause flyhack when dismount from Attack Helicopter.")]
        public int flyHackPause;
        [JsonProperty("Instant Engine Start-up (instant take-off)")]
        public bool instantTakeoff;
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
        public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
        private void TryGiveAmmo(BaseEntity entity);
    }

    public class WaterBirdSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool IsWaterVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class WarBirdSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class LittleBirdSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class FighterSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class OldFighterSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class FighterBusSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class WarBusSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class AirBusSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class PatrolHelicopterSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class RustWingSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class RustWingDetailedSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class RustWingDetailedOldSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class TinFighterSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class TinFighterDetailedSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class TinFighterDetailedOldSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class MarsFighterSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class MarsFighterDetailedSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class SkyPlaneSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class SkyBoatSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool IsWaterVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class TwistedTruckSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class TrainWreckSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class TrainWreckerSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class SantaSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class WarSantaSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class WitchSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class MagicCarpetSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class Ah69tSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class Ah69rSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class Ah69aSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class MavikSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class HeavyFighterSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class PorcelainCommanderSettings : BaseVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        public override bool CustomVehicle { get; set; }
    }

    public class DuneBuggieSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class DuneTruckArmedSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class DuneTruckUnArmedSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class DoomsDayDiscoVanSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class ForkLiftSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class LawnMowerSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class ChariotSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class SoulHarvesterSettings : BaseVehicleSettings
    {
        public override bool CustomVehicle { get; set; }
    }

    public class TransportHelicopterSettings : FuelVehicleSettings
    {
        public override bool IsFightVehicle { get; set; }
        [JsonProperty("Lift Fraction")]
        public float liftFraction;
        [JsonProperty("Rotation Scale")]
        public float rotationScale;
        [JsonProperty("Seconds to pause flyhack when dismount from Transport Scrap Helicopter.")]
        public int flyHackPause;
        [JsonProperty("Instant Engine Start-up (instant take-off)")]
        public bool instantTakeoff;
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class RidableHorseSettings : InventoryVehicleSettings
    {
        [JsonProperty("Spawn with Double Saddle")]
        public bool IsDoubleSaddle { get; set; }
        [JsonProperty("Breeds")]
        public List<string> Breeds { get; set; }
        [JsonIgnore]
        public Dictionary<string, int> BreedsRef;
        protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
        public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        protected override void CorrectPositionAndRotation(BasePlayer player, Vehicle vehicle, Vector3 original, Quaternion rotation, Vector3 spawnPos, Quaternion spawnRot);
    }

    public class WorkCartSettings : FuelVehicleSettings
    {
        public override bool IsTrainVehicle { get; set; }
        public bool IsConnectableEngine(TrainEngine trainEngine);
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        protected override bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
    }

    public class MagnetCraneSettings : FuelVehicleSettings
    {
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    }

    public class SubmarineSoloSettings : InvFuelVehicleSettings, IAmmoVehicle
    {
        private const int AMMO_ITEM_ID;
        public int SpawnAmmoAmount { get; set; }
        public override bool IsWaterVehicle { get; set; }
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
        public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
        private void TryGiveAmmo(BaseEntity entity);
    }

    public class SubmarineDuoSettings : SubmarineSoloSettings
    {
    }

    public class SnowmobileSettings : InvFuelVehicleSettings
    {
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
    }

    public class ModularVehicleSettings : InvFuelVehicleSettings, IModularVehicle
    {
        public bool RefundEngineOnKill { get; set; }
        public bool RefundEngineOnCrash { get; set; }
        public bool RefundModuleOnKill { get; set; }
        public bool RefundModuleOnCrash { get; set; }
        [JsonProperty(PropertyName = "Chassis Type (Small, Medium, Large)", Order = 50)]
        public ChassisType ChassisType { get; set; }
        [JsonProperty(PropertyName = "Vehicle Module Items", Order = 51)]
        public List<ModuleItem> ModuleItems { get; set; }
        [JsonProperty(PropertyName = "Vehicle Engine Items", Order = 52)]
        public List<EngineItem> EngineItems { get; set; }
        private List<ModuleItem> _validModuleItems;
        public IEnumerable<ModuleItem> ValidModuleItems { get; set; }
        public IEnumerable<Item> CreateModuleItems();
        private List<EngineItem> _validEngineItems;
        public IEnumerable<EngineItem> ValidEngineItems { get; set; }
        public IEnumerable<Item> CreateEngineItems();
        public override bool IsNormalVehicle { get; set; }
        public override bool IsModularVehicle { get; set; }
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        protected override string GetVehiclePrefab(string vehicleType);
        public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
        public override void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        protected override DroppedItemContainer DropVehicleInventory(BasePlayer player, Vehicle vehicle);
        private void GetRefundStatus(bool isCrash, bool isUnload, bool refundFuel, bool refundInventory, bool refundEngine, bool refundModule);
        protected override void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload);
        private void AttacheVehicleModules(ModularCar modularCar, Vehicle vehicle);
        private void AddItemsToVehicleEngine(ModularCar modularCar, Vehicle vehicle);
    }

    public class TrainVehicleSettings : FuelVehicleSettings, ITrainVehicle
    {
        [JsonProperty(PropertyName = "Train Components", Order = 50)]
        public List<TrainComponent> TrainComponents { get; set; }
        public override bool IsNormalVehicle { get; set; }
        public override bool IsTrainVehicle { get; set; }
        public override bool IsConnectableVehicle { get; set; }
        protected override IFuelSystem GetFuelSystem(BaseEntity entity);
        protected override string GetVehiclePrefab(string vehicleType);
        protected override string GetVehicleCustomPrefab(string vehicleType);
        private static string GetTrainVehiclePrefab(TrainComponentType componentType);
        public override BaseEntity SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        public override void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
        protected override void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload);
        protected override bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private bool GetConfigValue(T value, string[] path);
    private void SetConfigValue(object[] pathAndTrailingValue);
    private void PreprocessOldConfig();
    private JObject GetConfigValue(JObject config, string[] path);
    private bool GetConfigValuePre(JObject config, T value, string[] path);
    private void SetConfigValuePre(JObject config, object value, string[] path);
    private bool GetConfigVersionPre(JObject config, VersionNumber version);
    public StoredData storedData { get; set; }
    public class StoredData
    {
        public readonly Dictionary<ulong, Dictionary<string, Vehicle>> playerData;
        public IEnumerable<BaseEntity> ActiveVehicles(ulong playerId);
        public Dictionary<string, Vehicle> GetPlayerVehicles(ulong playerId, bool readOnly);
        public bool IsVehiclePurchased(ulong playerId, string vehicleType, Vehicle vehicle);
        public Vehicle GetVehicleLicense(ulong playerId, string vehicleType);
        public bool HasVehicleLicense(ulong playerId, string vehicleType);
        public bool AddVehicleLicense(ulong playerId, string vehicleType);
        public bool RemoveVehicleLicense(ulong playerId, string vehicleType);
        public List<string> GetVehicleLicenseNames(ulong playerId);
        public void PurchaseAllVehicles(ulong playerId);
        public void AddLicenseForAllPlayers(string vehicleType);
        public void RemoveLicenseForAllPlayers(string vehicleType);
        public void ResetPlayerData();
    }

    [JsonObject(MemberSerialization.OptIn)]
    public class Vehicle
    {
        [JsonProperty("entityID")]
        public ulong EntityId { get; set; }
        [JsonProperty("lastDeath")]
        public double LastDeath { get; set; }
        public ulong PlayerId { get; set; }
        public BaseEntity Entity { get; set; }
        public string VehicleType { get; set; }
        public double LastRecall { get; set; }
        public double LastDismount { get; set; }
        public void OnDismount();
        public void OnRecall();
        public void OnDeath();
        public void Reset();
        public static Vehicle Create(ulong playerId, string vehicleType);
    }

    private void LoadData();
    private void ClearData();
    private void SaveData();
    private void OnNewSave();
    private void Print(BasePlayer player, string message);
    private void Print(ConsoleSystem.Arg arg, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

public class ConfigData
{
    [JsonProperty(PropertyName = "Settings")]
    public GlobalSettings global;
    [JsonProperty(PropertyName = "Chat Settings")]
    public ChatSettings chat;
    [JsonProperty("Allow vehicles to be spawned/recalled in zones listed in prevent spawning zones")]
    public bool CanSpawnInZones;
    [JsonProperty(PropertyName = "Zones to prevent users from spawning/recalled vehicles within.", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> AntiSpawnZones;
    [JsonProperty(PropertyName = "Normal Vehicle Settings")]
    public NormalVehicleSettings normalVehicles;
    [JsonProperty(PropertyName = "Modular Vehicle Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, ModularVehicleSettings> modularVehicles;
    [JsonProperty(PropertyName = "Train Vehicle Settings", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, TrainVehicleSettings> trainVehicles;
    [DefaultValue(null)]
    [JsonProperty(PropertyName = "Custom Vehicle Settings", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public CustomVehicleSettings customVehicles;
    [JsonProperty(PropertyName = "Version")]
    public VersionNumber version;
}

public class ChatSettings
{
    [JsonProperty(PropertyName = "Use Universal Chat Command")]
    public bool useUniversalCommand;
    [JsonProperty(PropertyName = "Help Chat Command")]
    public string helpCommand;
    [JsonProperty(PropertyName = "Buy Chat Command")]
    public string buyCommand;
    [JsonProperty(PropertyName = "Spawn Chat Command")]
    public string spawnCommand;
    [JsonProperty(PropertyName = "Recall Chat Command")]
    public string recallCommand;
    [JsonProperty(PropertyName = "Kill Chat Command")]
    public string killCommand;
    [JsonProperty(PropertyName = "Custom Kill Chat Command Prefix")]
    public string customKillCommandPrefix;
    [JsonProperty(PropertyName = "Bypass Cooldown Command")]
    public string bypassCooldownCommand;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong steamIDIcon;
}

public class GlobalSettings
{
    [JsonProperty(PropertyName = "Store Vehicle On Plugin Unloaded / Server Restart")]
    public bool storeVehicle;
    [JsonProperty(PropertyName = "Clear Vehicle Data On Map Wipe")]
    public bool clearVehicleOnWipe;
    [JsonProperty(PropertyName = "Interval to check vehicle for wipe (Seconds)")]
    public float checkVehiclesInterval;
    [JsonProperty(PropertyName = "Spawn vehicle in the direction you are looking at")]
    public bool spawnLookingAt;
    [JsonProperty(PropertyName = "Automatically claim vehicles purchased from vehicle vendors")]
    public bool autoClaimFromVendor;
    [JsonProperty(PropertyName = "Vehicle vendor purchases will unlock the license for the player")]
    public bool autoUnlockFromVendor;
    [JsonProperty(PropertyName = "Limit the number of vehicles at a time")]
    public int limitVehicles;
    [JsonProperty(PropertyName = "Kill a random vehicle when the number of vehicles is limited")]
    public bool killVehicleLimited;
    [JsonProperty(PropertyName = "Prevent vehicles from damaging players")]
    public bool preventDamagePlayer;
    [JsonProperty(PropertyName = "Prevent vehicles from damaging NPCs")]
    public bool preventDamageNPCs;
    [JsonProperty(PropertyName = "Safe dismount players who jump off train")]
    public bool safeTrainDismount;
    [JsonProperty(PropertyName = "Prevent vehicles from shattering")]
    public bool preventShattering;
    [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling in safe zone")]
    public bool preventSafeZone;
    [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling when the player are building blocked")]
    public bool preventBuildingBlocked;
    [JsonProperty(PropertyName = "Prevent vehicles from spawning or recalling when the player is mounted or parented")]
    public bool preventMountedOrParented;
    [JsonProperty(PropertyName = "Check if any player mounted when recalling a vehicle")]
    public bool anyMountedRecall;
    [JsonProperty(PropertyName = "Check if any player mounted when killing a vehicle")]
    public bool anyMountedKill;
    [JsonProperty(PropertyName = "Dismount all players when a vehicle is recalled")]
    public bool dismountAllPlayersRecall;
    [JsonProperty(PropertyName = "Prevent other players from mounting vehicle")]
    public bool preventMounting;
    [JsonProperty(PropertyName = "Prevent mounting on driver's seat only")]
    public bool preventDriverSeat;
    [JsonProperty(PropertyName = "Prevent other players from looting fuel container and inventory")]
    public bool preventLooting;
    [JsonProperty(PropertyName = "Prevent other players from pushing vehicles they do not own")]
    public bool preventPushing;
    [JsonProperty(PropertyName = "Use Teams")]
    public bool useTeams;
    [JsonProperty(PropertyName = "Use Clans")]
    public bool useClans;
    [JsonProperty(PropertyName = "Use Friends")]
    public bool useFriends;
    [JsonProperty(PropertyName = "Vehicle No Decay")]
    public bool noDecay;
    [JsonProperty(PropertyName = "Vehicle No Fire Ball")]
    public bool noFireBall;
    [JsonProperty(PropertyName = "Vehicle No Server Gibs")]
    public bool noServerGibs;
    [JsonProperty(PropertyName = "Chinook No Map Marker")]
    public bool noMapMarker;
    [JsonProperty(PropertyName = "Use Raid Blocker (Need NoEscape Plugin)")]
    public bool useRaidBlocker;
    [JsonProperty(PropertyName = "Use Combat Blocker (Need NoEscape Plugin)")]
    public bool useCombatBlocker;
    [JsonProperty(PropertyName = "Populate the config with Custom Vehicles (CANNOT BE UNDONE! Will make config much larger)")]
    public bool useCustomVehicles;
}

public class NormalVehicleSettings
{
    [JsonProperty(PropertyName = "Tugboat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TugboatSettings tugboat;
    [JsonProperty(PropertyName = "Sedan Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SedanSettings sedan;
    [JsonProperty(PropertyName = "Chinook Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public ChinookSettings chinook;
    [JsonProperty(PropertyName = "Rowboat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public RowboatSettings rowboat;
    [JsonProperty(PropertyName = "RHIB Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public RhibSettings rhib;
    [JsonProperty(PropertyName = "Hot Air Balloon Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public HotAirBalloonSettings hotAirBalloon;
    [JsonProperty(PropertyName = "Armored Hot Air Balloon Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public ArmoredHotAirBalloonSettings armoredHotAirBalloon;
    [JsonProperty(PropertyName = "Ridable Horse Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public RidableHorseSettings ridableHorse;
    [JsonProperty(PropertyName = "Mini Copter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MiniCopterSettings miniCopter;
    [JsonProperty(PropertyName = "Attack Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public AttackHelicopterSettings attackHelicopter;
    [JsonProperty(PropertyName = "Transport Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TransportHelicopterSettings transportHelicopter;
    [JsonProperty(PropertyName = "Work Cart Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public WorkCartSettings workCart;
    [JsonProperty(PropertyName = "Sedan Rail Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public WorkCartSettings sedanRail;
    [JsonProperty(PropertyName = "Magnet Crane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MagnetCraneSettings magnetCrane;
    [JsonProperty(PropertyName = "Submarine Solo Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SubmarineSoloSettings submarineSolo;
    [JsonProperty(PropertyName = "Submarine Duo Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SubmarineDuoSettings submarineDuo;
    [JsonProperty(PropertyName = "Snowmobile Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SnowmobileSettings snowmobile;
    [JsonProperty(PropertyName = "Tomaha Snowmobile Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SnowmobileSettings tomahaSnowmobile;
    [JsonProperty(PropertyName = "Pedal Bike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public PedalBikeSettings pedalBike;
    [JsonProperty(PropertyName = "Pedal Trike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public PedalTrikeSettings pedalTrike;
    [JsonProperty(PropertyName = "Motorbike Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MotorBikeSettings motorBike;
    [JsonProperty(PropertyName = "Motorbike Sidecar Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MotorBikeSidecarSettings motorBikeSidecar;
    [JsonProperty(PropertyName = "Kayak Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public KayakSettings Kayak;
}

public class CustomVehicleSettings
{
    [JsonProperty(PropertyName = "ATV Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public AtvSettings atv;
    [JsonProperty(PropertyName = "Race Sofa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public RaceSofaSettings raceSofa;
    [JsonProperty(PropertyName = "Water Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public WaterBirdSettings waterBird;
    [JsonProperty(PropertyName = "War Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public WarBirdSettings warBird;
    [JsonProperty(PropertyName = "Little Bird Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public LittleBirdSettings littleBird;
    [JsonProperty(PropertyName = "Fighter Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public FighterSettings fighter;
    [JsonProperty(PropertyName = "Old Fighter Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public OldFighterSettings oldFighter;
    [JsonProperty(PropertyName = "Fighter Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public FighterBusSettings fighterBus;
    [JsonProperty(PropertyName = "War Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public WarBusSettings warBus;
    [JsonProperty(PropertyName = "Air Bus Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public AirBusSettings airBus;
    [JsonProperty(PropertyName = "Patrol Helicopter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public PatrolHelicopterSettings patrolHeli;
    [JsonProperty(PropertyName = "Rust Wing Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public RustWingSettings rustWing;
    [JsonProperty(PropertyName = "Rust Wing Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public RustWingDetailedSettings rustWingDetailed;
    [JsonProperty(PropertyName = "Rust Wing Detailed Old Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public RustWingDetailedOldSettings rustWingDetailedOld;
    [JsonProperty(PropertyName = "Tin Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TinFighterSettings tinFighter;
    [JsonProperty(PropertyName = "Tin Fighter Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TinFighterDetailedSettings tinFighterDetailed;
    [JsonProperty(PropertyName = "Tin Fighter Detailed Old Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TinFighterDetailedOldSettings tinFighterDetailedOld;
    [JsonProperty(PropertyName = "Mars Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MarsFighterSettings marsFighter;
    [JsonProperty(PropertyName = "Mars Fighter Detailed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MarsFighterDetailedSettings marsFighterDetailed;
    [JsonProperty(PropertyName = "Sky Plane Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SkyPlaneSettings skyPlane;
    [JsonProperty(PropertyName = "Sky Boat Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SkyBoatSettings skyBoat;
    [JsonProperty(PropertyName = "Twisted Truck Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TwistedTruckSettings twistedTruck;
    [JsonProperty(PropertyName = "Train Wreck Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TrainWreckSettings trainWreck;
    [JsonProperty(PropertyName = "Train Wrecker Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public TrainWreckerSettings trainWrecker;
    [JsonProperty(PropertyName = "Santa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SantaSettings santa;
    [JsonProperty(PropertyName = "War Santa Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public WarSantaSettings warSanta;
    [JsonProperty(PropertyName = "Witch Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public WitchSettings witch;
    [JsonProperty(PropertyName = "Magic Carpet Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MagicCarpetSettings magicCarpet;
    [JsonProperty(PropertyName = "Ah69t Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Ah69tSettings ah69t;
    [JsonProperty(PropertyName = "Ah69r Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Ah69rSettings ah69r;
    [JsonProperty(PropertyName = "Ah69a Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Ah69aSettings ah69a;
    [JsonProperty(PropertyName = "Mavik Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public MavikSettings mavik;
    [JsonProperty(PropertyName = "Heavy Fighter Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public HeavyFighterSettings heavyFighter;
    [JsonProperty(PropertyName = "Porcelain Commander Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public PorcelainCommanderSettings porcelainCommander;
    [JsonProperty(PropertyName = "Dune Buggie Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public DuneBuggieSettings duneBuggie;
    [JsonProperty(PropertyName = "Dune Truck Armed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public DuneTruckArmedSettings duneTruckArmed;
    [JsonProperty(PropertyName = "Dune Truck UnArmed Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public DuneTruckUnArmedSettings duneTruckUnArmed;
    [JsonProperty(PropertyName = "Dooms Day Disco Van Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public DoomsDayDiscoVanSettings doomsDayDiscoVan;
    [JsonProperty(PropertyName = "Lawn Mower Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public LawnMowerSettings lawnMower;
    [JsonProperty(PropertyName = "Fork Lift Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public ForkLiftSettings forkLift;
    [JsonProperty(PropertyName = "Chariot Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public ChariotSettings chariot;
    [JsonProperty(PropertyName = "Soul Harvester Vehicle", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SoulHarvesterSettings soulHarvester;
}

[JsonObject(MemberSerialization.OptIn)]
public abstract class BaseVehicleSettings
{
    [JsonProperty(PropertyName = "Purchasable")]
    public bool Purchasable { get; set; }
    [JsonProperty(PropertyName = "No Damage")]
    public bool NoDamage { get; set; }
    [JsonProperty(PropertyName = "No Collision Damage")]
    public bool NoCollisionDamage { get; set; }
    [JsonProperty(PropertyName = "Display Name")]
    public string DisplayName { get; set; }
    [JsonProperty(PropertyName = "Use Permission")]
    public bool UsePermission { get; set; }
    [JsonProperty(PropertyName = "Permission")]
    public string Permission { get; set; }
    [JsonProperty(PropertyName = "Bypass Cost Permission")]
    public string BypassCostPermission { get; set; }
    [JsonProperty(PropertyName = "Distance To Spawn")]
    public float Distance { get; set; }
    [JsonProperty(PropertyName = "Time Before Vehicle Wipe (Seconds)")]
    public double WipeTime { get; set; }
    [JsonProperty(PropertyName = "Exclude cupboard zones when wiping")]
    public bool ExcludeCupboard { get; set; }
    [JsonProperty(PropertyName = "Maximum Health")]
    public float MaxHealth { get; set; }
    [JsonProperty(PropertyName = "Can Recall Maximum Distance")]
    public float RecallMaxDistance { get; set; }
    [JsonProperty(PropertyName = "Can Kill Maximum Distance")]
    public float KillMaxDistance { get; set; }
    [JsonProperty(PropertyName = "Minimum distance from player to recall or spawn")]
    public float MinDistanceForPlayers { get; set; }
    [JsonProperty(PropertyName = "Remove License Once Crashed")]
    public bool RemoveLicenseOnceCrash { get; set; }
    [JsonProperty(PropertyName = "Commands")]
    public List<string> Commands { get; set; }
    [JsonProperty(PropertyName = "Purchase Prices")]
    public Dictionary<string, PriceInfo> PurchasePrices { get; set; }
    [JsonProperty(PropertyName = "Spawn Prices")]
    public Dictionary<string, PriceInfo> SpawnPrices { get; set; }
    [JsonProperty(PropertyName = "Recall Prices")]
    public Dictionary<string, PriceInfo> RecallPrices { get; set; }
    [JsonProperty(PropertyName = "Recall Cooldown Bypass Prices")]
    public Dictionary<string, PriceInfo> BypassRecallCooldownPrices { get; set; }
    [JsonProperty(PropertyName = "Spawn Cooldown Bypass Prices")]
    public Dictionary<string, PriceInfo> BypassSpawnCooldownPrices { get; set; }
    [JsonProperty(PropertyName = "Spawn Cooldown (Seconds)")]
    public double SpawnCooldown { get; set; }
    [JsonProperty(PropertyName = "Recall Cooldown (Seconds)")]
    public double RecallCooldown { get; set; }
    [JsonProperty(PropertyName = "Cooldown Permissions")]
    public Dictionary<string, CooldownPermission> CooldownPermissions { get; set; }
    protected ConfigData configData { get; set; }
    public virtual bool IsWaterVehicle { get; set; }
    public virtual bool IsTrainVehicle { get; set; }
    public virtual bool IsNormalVehicle { get; set; }
    public virtual bool IsFightVehicle { get; set; }
    public virtual bool IsModularVehicle { get; set; }
    public virtual bool IsConnectableVehicle { get; set; }
    public virtual bool CustomVehicle { get; set; }
    protected virtual IFuelSystem GetFuelSystem(BaseEntity entity);
    protected virtual IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
    protected virtual string GetVehiclePrefab(string vehicleType);
    protected virtual string GetVehicleCustomPrefab(string vehicleType);
    public virtual BaseEntity SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    public virtual void PreSetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player);
    public virtual void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
    private BaseEntity ModifyVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player);
    public virtual void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    public virtual void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    protected virtual bool CanDropInventory();
    private void TryDropVehicleInventory(BasePlayer player, Vehicle vehicle);
    protected virtual DroppedItemContainer DropVehicleInventory(BasePlayer player, Vehicle vehicle);
    protected bool TryGetTrainCarPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
    protected bool TryMoveToTrainTrackNear(TrainCar trainCar);
    protected bool SpaceIsClearForTrainTrack(Vehicle vehicle, Vector3 position, Quaternion rotation);
    protected virtual bool CanRefundFuel(bool isCrash, bool isUnload);
    protected virtual bool CanRefundInventory(bool isCrash, bool isUnload);
    protected virtual void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload);
    public void RefundVehicleItems(Vehicle vehicle, bool isCrash, bool isUnload);
    protected void TryGiveFuel(BaseEntity entity, IFuelVehicle iFuelVehicle);
    public double GetCooldown(BasePlayer player, bool isSpawn);
    public virtual bool TryGetVehicleParams(BasePlayer player, Vehicle vehicle, string reason, Vector3 spawnPos, Quaternion spawnRot);
    protected virtual float GetSpawnRotationAngle();
    protected virtual Vector3 GetOriginalPosition(BasePlayer player);
    protected virtual bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
    protected virtual void CorrectPositionAndRotation(BasePlayer player, Vehicle vehicle, Vector3 original, Quaternion rotation, Vector3 spawnPos, Quaternion spawnRot);
    private void GetPositionWithNoPlayersNearby(BasePlayer player, Vector3 spawnPos);
    private bool TryGetCenterOfFloorNearby(Vector3 spawnPos);
}

public abstract class FuelVehicleSettings : BaseVehicleSettings, IFuelVehicle
{
    public int SpawnFuelAmount { get; set; }
    public bool RefundFuelOnKill { get; set; }
    public bool RefundFuelOnCrash { get; set; }
    public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
    protected override bool CanRefundFuel(bool isCrash, bool isUnload);
}

public abstract class InventoryVehicleSettings : BaseVehicleSettings, IInventoryVehicle
{
    public bool RefundInventoryOnKill { get; set; }
    public bool RefundInventoryOnCrash { get; set; }
    public bool DropInventoryOnRecall { get; set; }
    protected override bool CanDropInventory();
    protected override bool CanRefundInventory(bool isCrash, bool isUnload);
}

public abstract class InvFuelVehicleSettings : BaseVehicleSettings, IFuelVehicle, IInventoryVehicle
{
    public int SpawnFuelAmount { get; set; }
    public bool RefundFuelOnKill { get; set; }
    public bool RefundFuelOnCrash { get; set; }
    public bool RefundInventoryOnKill { get; set; }
    public bool RefundInventoryOnCrash { get; set; }
    public bool DropInventoryOnRecall { get; set; }
    public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
    protected override bool CanDropInventory();
    protected override bool CanRefundInventory(bool isCrash, bool isUnload);
    protected override bool CanRefundFuel(bool isCrash, bool isUnload);
}

public class PedalBikeSettings : BaseVehicleSettings
{
}

public class PedalTrikeSettings : BaseVehicleSettings
{
}

public class MotorBikeSettings : FuelVehicleSettings
{
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class MotorBikeSidecarSettings : FuelVehicleSettings
{
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class AtvSettings : FuelVehicleSettings
{
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class RaceSofaSettings : FuelVehicleSettings
{
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class KayakSettings : BaseVehicleSettings
{
    public override bool IsWaterVehicle { get; set; }
}

public class SedanSettings : BaseVehicleSettings
{
}

public class ChinookSettings : BaseVehicleSettings
{
}

public class RowboatSettings : InvFuelVehicleSettings
{
    public override bool IsWaterVehicle { get; set; }
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
}

public class RhibSettings : RowboatSettings
{
}

public class TugboatSettings : FuelVehicleSettings
{
    public override bool IsWaterVehicle { get; set; }
    [JsonProperty(PropertyName = "Speed Multiplier")]
    public float speedMultiplier { get; set; }
    [JsonProperty(PropertyName = "Auto Auth Teammates on spawn/recall")]
    public bool autoAuth { get; set; }
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class HotAirBalloonSettings : InvFuelVehicleSettings
{
    protected override float GetSpawnRotationAngle();
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
}

public class ArmoredHotAirBalloonSettings : HotAirBalloonSettings
{
}

public class MiniCopterSettings : FuelVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    [JsonProperty("Rotation Scale")]
    public float rotationScale;
    [JsonProperty("Lift Fraction")]
    public float liftFraction;
    [JsonProperty("Seconds to pause flyhack when dismount from Mini Copter.")]
    public int flyHackPause;
    [JsonProperty("Instant Engine Start-up (instant take-off)")]
    public bool instantTakeoff;
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class AttackHelicopterSettings : InvFuelVehicleSettings
{
    private const int HV_AMMO_ITEM_ID;
    private const int INCENDIARY_AMMO_ITEM_ID;
    private const int FLARE_ITEM_ID;
    [JsonProperty("HV Rocket Spawn Amount")]
    public int HVSpawnAmmoAmount { get; set; }
    [JsonProperty("Incendiary Rocket Spawn Amount")]
    public int IncendiarySpawnAmmoAmount { get; set; }
    [JsonProperty("Flare Spawn Amount")]
    public int FlareSpawnAmmoAmount { get; set; }
    public override bool IsFightVehicle { get; set; }
    [JsonProperty("Rotation Scale")]
    public float rotationScale;
    [JsonProperty("Lift Fraction")]
    public float liftFraction;
    [JsonProperty("Seconds to pause flyhack when dismount from Attack Helicopter.")]
    public int flyHackPause;
    [JsonProperty("Instant Engine Start-up (instant take-off)")]
    public bool instantTakeoff;
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
    public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
    private void TryGiveAmmo(BaseEntity entity);
}

public class WaterBirdSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool IsWaterVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class WarBirdSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class LittleBirdSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class FighterSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class OldFighterSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class FighterBusSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class WarBusSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class AirBusSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class PatrolHelicopterSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class RustWingSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class RustWingDetailedSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class RustWingDetailedOldSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class TinFighterSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class TinFighterDetailedSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class TinFighterDetailedOldSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class MarsFighterSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class MarsFighterDetailedSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class SkyPlaneSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class SkyBoatSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool IsWaterVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class TwistedTruckSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class TrainWreckSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class TrainWreckerSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class SantaSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class WarSantaSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class WitchSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class MagicCarpetSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class Ah69tSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class Ah69rSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class Ah69aSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class MavikSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class HeavyFighterSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class PorcelainCommanderSettings : BaseVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    public override bool CustomVehicle { get; set; }
}

public class DuneBuggieSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class DuneTruckArmedSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class DuneTruckUnArmedSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class DoomsDayDiscoVanSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class ForkLiftSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class LawnMowerSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class ChariotSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class SoulHarvesterSettings : BaseVehicleSettings
{
    public override bool CustomVehicle { get; set; }
}

public class TransportHelicopterSettings : FuelVehicleSettings
{
    public override bool IsFightVehicle { get; set; }
    [JsonProperty("Lift Fraction")]
    public float liftFraction;
    [JsonProperty("Rotation Scale")]
    public float rotationScale;
    [JsonProperty("Seconds to pause flyhack when dismount from Transport Scrap Helicopter.")]
    public int flyHackPause;
    [JsonProperty("Instant Engine Start-up (instant take-off)")]
    public bool instantTakeoff;
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class RidableHorseSettings : InventoryVehicleSettings
{
    [JsonProperty("Spawn with Double Saddle")]
    public bool IsDoubleSaddle { get; set; }
    [JsonProperty("Breeds")]
    public List<string> Breeds { get; set; }
    [JsonIgnore]
    public Dictionary<string, int> BreedsRef;
    protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
    public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    protected override void CorrectPositionAndRotation(BasePlayer player, Vehicle vehicle, Vector3 original, Quaternion rotation, Vector3 spawnPos, Quaternion spawnRot);
}

public class WorkCartSettings : FuelVehicleSettings
{
    public override bool IsTrainVehicle { get; set; }
    public bool IsConnectableEngine(TrainEngine trainEngine);
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    protected override bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
}

public class MagnetCraneSettings : FuelVehicleSettings
{
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
}

public class SubmarineSoloSettings : InvFuelVehicleSettings, IAmmoVehicle
{
    private const int AMMO_ITEM_ID;
    public int SpawnAmmoAmount { get; set; }
    public override bool IsWaterVehicle { get; set; }
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
    public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
    private void TryGiveAmmo(BaseEntity entity);
}

public class SubmarineDuoSettings : SubmarineSoloSettings
{
}

public class SnowmobileSettings : InvFuelVehicleSettings
{
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    protected override IEnumerable<ItemContainer> GetInventories(BaseEntity entity);
}

public class ModularVehicleSettings : InvFuelVehicleSettings, IModularVehicle
{
    public bool RefundEngineOnKill { get; set; }
    public bool RefundEngineOnCrash { get; set; }
    public bool RefundModuleOnKill { get; set; }
    public bool RefundModuleOnCrash { get; set; }
    [JsonProperty(PropertyName = "Chassis Type (Small, Medium, Large)", Order = 50)]
    public ChassisType ChassisType { get; set; }
    [JsonProperty(PropertyName = "Vehicle Module Items", Order = 51)]
    public List<ModuleItem> ModuleItems { get; set; }
    [JsonProperty(PropertyName = "Vehicle Engine Items", Order = 52)]
    public List<EngineItem> EngineItems { get; set; }
    private List<ModuleItem> _validModuleItems;
    public IEnumerable<ModuleItem> ValidModuleItems { get; set; }
    public IEnumerable<Item> CreateModuleItems();
    private List<EngineItem> _validEngineItems;
    public IEnumerable<EngineItem> ValidEngineItems { get; set; }
    public IEnumerable<Item> CreateEngineItems();
    public override bool IsNormalVehicle { get; set; }
    public override bool IsModularVehicle { get; set; }
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    protected override string GetVehiclePrefab(string vehicleType);
    public override void SetupVehicle(BaseEntity entity, Vehicle vehicle, BasePlayer player, bool justCreated);
    public override void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    protected override DroppedItemContainer DropVehicleInventory(BasePlayer player, Vehicle vehicle);
    private void GetRefundStatus(bool isCrash, bool isUnload, bool refundFuel, bool refundInventory, bool refundEngine, bool refundModule);
    protected override void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload);
    private void AttacheVehicleModules(ModularCar modularCar, Vehicle vehicle);
    private void AddItemsToVehicleEngine(ModularCar modularCar, Vehicle vehicle);
}

public class TrainVehicleSettings : FuelVehicleSettings, ITrainVehicle
{
    [JsonProperty(PropertyName = "Train Components", Order = 50)]
    public List<TrainComponent> TrainComponents { get; set; }
    public override bool IsNormalVehicle { get; set; }
    public override bool IsTrainVehicle { get; set; }
    public override bool IsConnectableVehicle { get; set; }
    protected override IFuelSystem GetFuelSystem(BaseEntity entity);
    protected override string GetVehiclePrefab(string vehicleType);
    protected override string GetVehicleCustomPrefab(string vehicleType);
    private static string GetTrainVehiclePrefab(TrainComponentType componentType);
    public override BaseEntity SpawnVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    public override void PreRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    public override void PostRecallVehicle(BasePlayer player, Vehicle vehicle, Vector3 position, Quaternion rotation);
    protected override void CollectVehicleItems(List<Item> items, Vehicle vehicle, bool isCrash, bool isUnload);
    protected override bool TryGetPositionAndRotation(BasePlayer player, Vehicle vehicle, string reason, Vector3 original, Quaternion rotation);
}

public class StoredData
{
    public readonly Dictionary<ulong, Dictionary<string, Vehicle>> playerData;
    public IEnumerable<BaseEntity> ActiveVehicles(ulong playerId);
    public Dictionary<string, Vehicle> GetPlayerVehicles(ulong playerId, bool readOnly);
    public bool IsVehiclePurchased(ulong playerId, string vehicleType, Vehicle vehicle);
    public Vehicle GetVehicleLicense(ulong playerId, string vehicleType);
    public bool HasVehicleLicense(ulong playerId, string vehicleType);
    public bool AddVehicleLicense(ulong playerId, string vehicleType);
    public bool RemoveVehicleLicense(ulong playerId, string vehicleType);
    public List<string> GetVehicleLicenseNames(ulong playerId);
    public void PurchaseAllVehicles(ulong playerId);
    public void AddLicenseForAllPlayers(string vehicleType);
    public void RemoveLicenseForAllPlayers(string vehicleType);
    public void ResetPlayerData();
}

[JsonObject(MemberSerialization.OptIn)]
public class Vehicle
{
    [JsonProperty("entityID")]
    public ulong EntityId { get; set; }
    [JsonProperty("lastDeath")]
    public double LastDeath { get; set; }
    public ulong PlayerId { get; set; }
    public BaseEntity Entity { get; set; }
    public string VehicleType { get; set; }
    public double LastRecall { get; set; }
    public double LastDismount { get; set; }
    public void OnDismount();
    public void OnRecall();
    public void OnDeath();
    public void Reset();
    public static Vehicle Create(ulong playerId, string vehicleType);
}


```

---

## VehicleLocks by  - Adds locks and ownership to vehicles

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("Vehicle Locks", "MrPoundsign", "1.0.4")]
[Description("Vehicle ownership and locking")]
 class VehicleLocks : RustPlugin
{
    const string chinookPilotSeat;
    const string sedanDriverSeat;
    const string smallBoatDriverSeat;
    const string miniHeliSeat;
    const string rhibDriverSeat;
    const string saddlePrefab;
    const string scrapTransportSeat;
    protected override void LoadDefaultMessages();
     object CanMountEntity(BasePlayer player, BaseMountable entity);
}


```

---

## VehicleStorage by WhiteThunder - Allows adding storage containers to vehicles and increasing built-in storage capacity

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.ComponentModel;
using UnityEngine;

Oxide.Plugins
[Info("Vehicle Storage", "WhiteThunder", "3.5.1")]
[Description("Allows adding storage containers to vehicles and increasing built-in storage capacity.")]
internal class VehicleStorage : CovalencePlugin
{
    [PluginReference]
    private Plugin CargoTrainEvent;
    private Configuration _config;
    private const string BasePermissionPrefix;
    private const string RhibStoragePrefab;
    private const string HabStoragePrefab;
    private const string StashDeployEffectPrefab;
    private const string BoxDeployEffectPrefab;
    private const string ResizableLootPanelName;
    private const int MaxCapacity;
    private readonly VehicleTracker _vehicleTracker;
    private readonly ReskinEventManager _reskinEventManager;
    private readonly ContainerBoundsManager _containerBoundsManager;
    private void Init();
    private void OnServerInitialized();
    private void OnEntitySpawned(BaseEntity entity);
    private void OnEntityKill(BaseEntity entity);
    private void OnUserPermissionGranted(string userId, string perm);
    private void OnGroupPermissionGranted(string group, string perm);
    private void OnUserGroupAdded(string userId, string groupName);
    private void OnRidableAnimalClaimed(RidableHorse horse, BasePlayer player);
    private void OnEntityReskin(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player);
    private void OnEntityReskinned(Snowmobile snowmobile, ItemSkinDirectory.Skin skin, BasePlayer player);
    private void OnVehicleOwnershipChanged(BaseEntity vehicle);
    private bool IsCargoTrain(BaseEntity entity);
    private void API_RefreshVehicleStorage(BaseEntity vehicle);
    private bool AlterStorageWasBlocked(BaseEntity vehicle);
    private bool SpawnStorageWasBlocked(BaseEntity vehicle);
    private void CallHookVehicleStorageSpawned(BaseEntity vehicle, StorageContainer container);
    private void RemoveProblemComponents(BaseEntity entity);
    private void SetupStorage(BaseEntity vehicle, StorageContainer container, ContainerPreset preset);
    private void MoveOverlappingDismountPositions(BaseEntity vehicle, StorageContainer container);
    private StorageContainer SpawnStorage(BaseEntity vehicle, ContainerPreset preset, int capacity);
    private StorageContainer FindStorageContainerForPreset(BaseEntity entity, ContainerPreset preset);
    private void MaybeIncreaseCapacity(StorageContainer container, int capacity);
    private void AddOrUpdateExtraContainers(BaseEntity vehicle, VehicleProfile vehicleProfile);
    private void RefreshVehicleStorage(BaseEntity vehicle, VehicleConfig vehicleConfig);
    private void RefreshVehicleStorage(BaseEntity vehicle);
    private void HandlePermissionChanged(string userIdString);
    private class ContainerBoundsManager
    {
        private readonly Dictionary<string, string> _boundsReplacements;
        private readonly Dictionary<uint, Bounds> _boundsReplacementsByPrefabId;
        public void OnServerInitialized(VehicleStorage plugin);
        public Bounds GetBounds(BaseEntity entity);
    }

    private class VehicleTracker
    {
        public readonly Dictionary<VehicleConfig, HashSet<BaseEntity>> AllSupportedVehicles;
        public HashSet<BaseEntity> GetVehicles(VehicleConfig vehicleConfig);
        public void AddVehicle(VehicleConfig vehicleConfig, BaseEntity vehicle);
        public bool RemoveVehicle(VehicleConfig vehicleConfig, BaseEntity vehicle);
    }

    private class ReskinEvent
    {
        public BaseEntity Parent;
        public VehicleConfig VehicleConfig;
        public List<StorageContainer> Containers;
        public Vector3 Position;
        public ReskinEvent WithParent(BaseEntity parent);
        public ReskinEvent WithVehicleConfig(VehicleConfig vehicleConfig);
        public void AddContainer(StorageContainer container);
        public void Reset();
    }

    private class ReskinEventManager
    {
        private ReskinEvent _pooledReskinEvent;
        private List<ReskinEvent> _reskinEvents;
        public readonly Action CleanupAction;
        public ReskinEventManager();
        public ReskinEvent GetEvent();
        public void RecordEvent(ReskinEvent reskinEvent);
        public void CancelEvent(ReskinEvent reskinEvent);
        public ReskinEvent FindEvent(Vector3 position);
        public void CompleteEvent(ReskinEvent reskinEvent);
        private void CleanupEvents();
    }

    private class ContainerPreset
    {
        [JsonProperty("Prefab")]
        public string Prefab;
        [JsonProperty("Position")]
        public Vector3 Position;
        [JsonProperty("RotationAngles", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public Vector3 RotationAngles;
        [JsonProperty("ParentBone", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string ParentBone;
        [JsonIgnore]
        public Quaternion Rotation { get; set; }
        [JsonIgnore]
        public string Name;
        public void MoveContainerToParent(StorageContainer container, BaseEntity parent);
    }

    private class VehicleProfile
    {
        [JsonProperty("PermissionSuffix", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string PermissionSuffix;
        [JsonProperty("BuiltInStorageCapacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(-1)]
        public int BuiltInStorageCapacity;
        [JsonProperty("AdditionalStorage", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public Dictionary<string, int> AdditionalStorage;
        [JsonIgnore]
        public Dictionary<ContainerPreset, int> ValidAdditionalStorage { get; set; }
        [JsonIgnore]
        public string Permission { get; set; }
        public void Init(VehicleStorage pluginInstance, VehicleConfig vehicleConfig);
    }

    private abstract class VehicleConfig
    {
        [JsonProperty("DefaultProfile")]
        public VehicleProfile DefaultProfile;
        [JsonProperty("ProfilesRequiringPermission")]
        public VehicleProfile[] ProfilesRequiringPermission;
        [JsonProperty("ContainerPresets", DefaultValueHandling = DefaultValueHandling.Ignore, ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, ContainerPreset> ContainerPresets;
        [JsonIgnore]
        public abstract string VehicleType { get; set; }
        [JsonIgnore]
        public abstract string PrefabPath { get; set; }
        public virtual StorageContainer GetDefaultContainer(BaseEntity enitty);
        public virtual ulong GetOwnerId(BaseEntity entity);
        public void Init(VehicleStorage pluginInstance);
        public VehicleProfile GetProfileForVehicle(Permission permissionSystem, BaseEntity vehicle);
        public ContainerPreset FindContainerPreset(string name);
    }

    private class AttackHelicopterConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class ChinookConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class DuoSubmarineConfig : SoloSubmarineConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class HotAirBalloonConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
        public override StorageContainer GetDefaultContainer(BaseEntity entity);
    }

    private class KayakConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class LocomotiveConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class MagnetCraneConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class MinicopterConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class ModularCarStorageModuleConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
        public override StorageContainer GetDefaultContainer(BaseEntity entity);
        public override ulong GetOwnerId(BaseEntity entity);
    }

    private class ModularCarCamperModuleConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
        public override StorageContainer GetDefaultContainer(BaseEntity entity);
        public override ulong GetOwnerId(BaseEntity entity);
    }

    private class MotorBikeConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class MotorBikeSideCarConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class PedalBikeConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class PedalTrikeConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class RHIBConfig : RowboatConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class RidableHorseConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class RowboatConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
        public override StorageContainer GetDefaultContainer(BaseEntity entity);
    }

    private class ScrapTransportHelicopterConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class SedanConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class SedanRailConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class SnowmobileConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
        public override StorageContainer GetDefaultContainer(BaseEntity entity);
    }

    private class SoloSubmarineConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
        public override StorageContainer GetDefaultContainer(BaseEntity entity);
    }

    private class TomahaConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
        public override StorageContainer GetDefaultContainer(BaseEntity entity);
    }

    private class WagonAConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class WagonBConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class WagonCConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class WorkcartConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class WorkcartAbovegroundConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class WorkcartCoveredConfig : VehicleConfig
    {
        public override string VehicleType { get; set; }
        public override string PrefabPath { get; set; }
    }

    private class Configuration : BaseConfiguration
    {
        [JsonProperty("AttackHelicopter")]
        public AttackHelicopterConfig AttackHelicopter;
        [JsonProperty("Chinook")]
        public ChinookConfig Chinook;
        [JsonProperty("DuoSubmarine")]
        public DuoSubmarineConfig DuoSubmarine;
        [JsonProperty("HotAirBalloon")]
        public HotAirBalloonConfig HotAirBalloon;
        [JsonProperty("Kayak")]
        public KayakConfig Kayak;
        [JsonProperty("Locomotive")]
        public LocomotiveConfig Locomotive;
        [JsonProperty("MagnetCrane")]
        public MagnetCraneConfig MagnetCrane;
        [JsonProperty("Minicopter")]
        public MinicopterConfig Minicopter;
        [JsonProperty("ModularCarCamperModule")]
        public ModularCarCamperModuleConfig ModularCarCamperModule;
        [JsonProperty("MotorBike")]
        public MotorBikeConfig MotorBike;
        [JsonProperty("MotorBikeSideCar")]
        public MotorBikeSideCarConfig MotorBikeSideCar;
        [JsonProperty("PedalBike")]
        public PedalBikeConfig PedalBike;
        [JsonProperty("PedalTrike")]
        public PedalTrikeConfig PedalTrike;
        [JsonProperty("ModularCarStorageModule")]
        public ModularCarStorageModuleConfig ModularCarStorageModule;
        [JsonProperty("RHIB")]
        public RHIBConfig RHIB;
        [JsonProperty("RidableHorse")]
        public RidableHorseConfig RidableHorse;
        [JsonProperty("Rowboat")]
        public RowboatConfig Rowboat;
        [JsonProperty("ScrapTransportHelicopter")]
        public ScrapTransportHelicopterConfig ScrapTransportHelicopter;
        [JsonProperty("Sedan")]
        public SedanConfig Sedan;
        [JsonProperty("SedanRail")]
        public SedanRailConfig SedanRail;
        [JsonProperty("Snowmobile")]
        public SnowmobileConfig Snowmobile;
        [JsonProperty("SoloSubmarine")]
        public SoloSubmarineConfig SoloSubmarine;
        [JsonProperty("Tomaha")]
        public TomahaConfig Tomaha;
        [JsonProperty("WagonA")]
        public WagonAConfig WagonA;
        [JsonProperty("WagonB")]
        public WagonBConfig WagonB;
        [JsonProperty("WagonC")]
        public WagonCConfig WagonC;
        [JsonProperty("Workcart")]
        public WorkcartConfig Workcart;
        [JsonProperty("WorkcartAboveground")]
        public WorkcartAbovegroundConfig WorkcartAboveground;
        [JsonProperty("WorkcartCovered")]
        public WorkcartCoveredConfig WorkcartCovered;
        [JsonIgnore]
        private readonly Dictionary<uint, VehicleConfig> _vehicleConfigsByPrefabId;
        public void Init(VehicleStorage pluginInstance);
        public VehicleConfig GetVehicleConfig(BaseEntity entity);
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

private class ContainerBoundsManager
{
    private readonly Dictionary<string, string> _boundsReplacements;
    private readonly Dictionary<uint, Bounds> _boundsReplacementsByPrefabId;
    public void OnServerInitialized(VehicleStorage plugin);
    public Bounds GetBounds(BaseEntity entity);
}

private class VehicleTracker
{
    public readonly Dictionary<VehicleConfig, HashSet<BaseEntity>> AllSupportedVehicles;
    public HashSet<BaseEntity> GetVehicles(VehicleConfig vehicleConfig);
    public void AddVehicle(VehicleConfig vehicleConfig, BaseEntity vehicle);
    public bool RemoveVehicle(VehicleConfig vehicleConfig, BaseEntity vehicle);
}

private class ReskinEvent
{
    public BaseEntity Parent;
    public VehicleConfig VehicleConfig;
    public List<StorageContainer> Containers;
    public Vector3 Position;
    public ReskinEvent WithParent(BaseEntity parent);
    public ReskinEvent WithVehicleConfig(VehicleConfig vehicleConfig);
    public void AddContainer(StorageContainer container);
    public void Reset();
}

private class ReskinEventManager
{
    private ReskinEvent _pooledReskinEvent;
    private List<ReskinEvent> _reskinEvents;
    public readonly Action CleanupAction;
    public ReskinEventManager();
    public ReskinEvent GetEvent();
    public void RecordEvent(ReskinEvent reskinEvent);
    public void CancelEvent(ReskinEvent reskinEvent);
    public ReskinEvent FindEvent(Vector3 position);
    public void CompleteEvent(ReskinEvent reskinEvent);
    private void CleanupEvents();
}

private class ContainerPreset
{
    [JsonProperty("Prefab")]
    public string Prefab;
    [JsonProperty("Position")]
    public Vector3 Position;
    [JsonProperty("RotationAngles", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public Vector3 RotationAngles;
    [JsonProperty("ParentBone", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string ParentBone;
    [JsonIgnore]
    public Quaternion Rotation { get; set; }
    [JsonIgnore]
    public string Name;
    public void MoveContainerToParent(StorageContainer container, BaseEntity parent);
}

private class VehicleProfile
{
    [JsonProperty("PermissionSuffix", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string PermissionSuffix;
    [JsonProperty("BuiltInStorageCapacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(-1)]
    public int BuiltInStorageCapacity;
    [JsonProperty("AdditionalStorage", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public Dictionary<string, int> AdditionalStorage;
    [JsonIgnore]
    public Dictionary<ContainerPreset, int> ValidAdditionalStorage { get; set; }
    [JsonIgnore]
    public string Permission { get; set; }
    public void Init(VehicleStorage pluginInstance, VehicleConfig vehicleConfig);
}

private abstract class VehicleConfig
{
    [JsonProperty("DefaultProfile")]
    public VehicleProfile DefaultProfile;
    [JsonProperty("ProfilesRequiringPermission")]
    public VehicleProfile[] ProfilesRequiringPermission;
    [JsonProperty("ContainerPresets", DefaultValueHandling = DefaultValueHandling.Ignore, ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, ContainerPreset> ContainerPresets;
    [JsonIgnore]
    public abstract string VehicleType { get; set; }
    [JsonIgnore]
    public abstract string PrefabPath { get; set; }
    public virtual StorageContainer GetDefaultContainer(BaseEntity enitty);
    public virtual ulong GetOwnerId(BaseEntity entity);
    public void Init(VehicleStorage pluginInstance);
    public VehicleProfile GetProfileForVehicle(Permission permissionSystem, BaseEntity vehicle);
    public ContainerPreset FindContainerPreset(string name);
}

private class AttackHelicopterConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class ChinookConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class DuoSubmarineConfig : SoloSubmarineConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class HotAirBalloonConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
    public override StorageContainer GetDefaultContainer(BaseEntity entity);
}

private class KayakConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class LocomotiveConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class MagnetCraneConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class MinicopterConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class ModularCarStorageModuleConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
    public override StorageContainer GetDefaultContainer(BaseEntity entity);
    public override ulong GetOwnerId(BaseEntity entity);
}

private class ModularCarCamperModuleConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
    public override StorageContainer GetDefaultContainer(BaseEntity entity);
    public override ulong GetOwnerId(BaseEntity entity);
}

private class MotorBikeConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class MotorBikeSideCarConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class PedalBikeConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class PedalTrikeConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class RHIBConfig : RowboatConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class RidableHorseConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class RowboatConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
    public override StorageContainer GetDefaultContainer(BaseEntity entity);
}

private class ScrapTransportHelicopterConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class SedanConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class SedanRailConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class SnowmobileConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
    public override StorageContainer GetDefaultContainer(BaseEntity entity);
}

private class SoloSubmarineConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
    public override StorageContainer GetDefaultContainer(BaseEntity entity);
}

private class TomahaConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
    public override StorageContainer GetDefaultContainer(BaseEntity entity);
}

private class WagonAConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class WagonBConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class WagonCConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class WorkcartConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class WorkcartAbovegroundConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class WorkcartCoveredConfig : VehicleConfig
{
    public override string VehicleType { get; set; }
    public override string PrefabPath { get; set; }
}

private class Configuration : BaseConfiguration
{
    [JsonProperty("AttackHelicopter")]
    public AttackHelicopterConfig AttackHelicopter;
    [JsonProperty("Chinook")]
    public ChinookConfig Chinook;
    [JsonProperty("DuoSubmarine")]
    public DuoSubmarineConfig DuoSubmarine;
    [JsonProperty("HotAirBalloon")]
    public HotAirBalloonConfig HotAirBalloon;
    [JsonProperty("Kayak")]
    public KayakConfig Kayak;
    [JsonProperty("Locomotive")]
    public LocomotiveConfig Locomotive;
    [JsonProperty("MagnetCrane")]
    public MagnetCraneConfig MagnetCrane;
    [JsonProperty("Minicopter")]
    public MinicopterConfig Minicopter;
    [JsonProperty("ModularCarCamperModule")]
    public ModularCarCamperModuleConfig ModularCarCamperModule;
    [JsonProperty("MotorBike")]
    public MotorBikeConfig MotorBike;
    [JsonProperty("MotorBikeSideCar")]
    public MotorBikeSideCarConfig MotorBikeSideCar;
    [JsonProperty("PedalBike")]
    public PedalBikeConfig PedalBike;
    [JsonProperty("PedalTrike")]
    public PedalTrikeConfig PedalTrike;
    [JsonProperty("ModularCarStorageModule")]
    public ModularCarStorageModuleConfig ModularCarStorageModule;
    [JsonProperty("RHIB")]
    public RHIBConfig RHIB;
    [JsonProperty("RidableHorse")]
    public RidableHorseConfig RidableHorse;
    [JsonProperty("Rowboat")]
    public RowboatConfig Rowboat;
    [JsonProperty("ScrapTransportHelicopter")]
    public ScrapTransportHelicopterConfig ScrapTransportHelicopter;
    [JsonProperty("Sedan")]
    public SedanConfig Sedan;
    [JsonProperty("SedanRail")]
    public SedanRailConfig SedanRail;
    [JsonProperty("Snowmobile")]
    public SnowmobileConfig Snowmobile;
    [JsonProperty("SoloSubmarine")]
    public SoloSubmarineConfig SoloSubmarine;
    [JsonProperty("Tomaha")]
    public TomahaConfig Tomaha;
    [JsonProperty("WagonA")]
    public WagonAConfig WagonA;
    [JsonProperty("WagonB")]
    public WagonBConfig WagonB;
    [JsonProperty("WagonC")]
    public WagonCConfig WagonC;
    [JsonProperty("Workcart")]
    public WorkcartConfig Workcart;
    [JsonProperty("WorkcartAboveground")]
    public WorkcartAbovegroundConfig WorkcartAboveground;
    [JsonProperty("WorkcartCovered")]
    public WorkcartCoveredConfig WorkcartCovered;
    [JsonIgnore]
    private readonly Dictionary<uint, VehicleConfig> _vehicleConfigsByPrefabId;
    public void Init(VehicleStorage pluginInstance);
    public VehicleConfig GetVehicleConfig(BaseEntity entity);
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## VehicleVendorOptions by WhiteThunder - Allows customizing fuel and prices of vehicles purchased at NPC vendors

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using static ConversationData;
using static NPCTalking;

Oxide.Plugins
[Info("Vehicle Vendor Options", "WhiteThunder", "1.7.6")]
[Description("Allows customizing vehicle fuel and prices at NPC vendors.")]
internal class VehicleVendorOptions : CovalencePlugin
{
    [PluginReference]
    private readonly Plugin Economics;
    private readonly Plugin ServerRewards;
    private Configuration _config;
    private const string Permission_Allow_All;
    private const string Permission_Free_All;
    private const string Permission_Ownership_All;
    private const string Permission_Price_Prefix;
    private const int MinHiddenSlot;
    private const int ScrapItemId;
    private const float VanillaDespawnProtectionTime;
    private readonly object False;
    private Item _scrapItem;
    private readonly VehicleInfoManager _vehicleInfoManager;
    public VehicleVendorOptions();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnEntitySpawned(HotAirBalloon vehicle);
    private void OnEntitySpawned(PlayerHelicopter vehicle);
    private void OnEntitySpawned(MotorRowboat vehicle);
    private void OnEntitySpawned(BaseSubmarine vehicle);
    private object OnRidableAnimalClaim(RidableHorse2 horse, BasePlayer player, Item saddleItem);
    private void OnRidableAnimalClaimed(RidableHorse2 horse, BasePlayer player);
    private object OnNpcConversationRespond(VehicleVendor vendor, BasePlayer player, ConversationData conversationData, ResponseNode responseNode);
    private void OnNpcConversationEnded(VehicleVendor vendor, BasePlayer player);
    private static void AdjustFuel(VehicleSpawner.IVehicleSpawnUser vehicle, int desiredFuelAmount);
    private void HandleSpawn(VehicleSpawner.IVehicleSpawnUser vehicle);
    private void MaybeSetOwner(BaseEntity vehicle);
    private void SetOwnerIfPermission(BaseEntity vehicle, BasePlayer basePlayer);
    private bool HasPermission(string userIdString, string perm);
    private object HandlePayPrompt(VehicleVendor vendor, BasePlayer player, SpeechNode resultingSpeechNode, VehicleInfo vehicleInfo);
    private object HandlePayment(VehicleVendor vendor, BasePlayer player, ConversationData conversationData, ResponseNode responseNode, VehicleInfo vehicleInfo);
    private class VehicleInfo
    {
        public string PrefabPath;
        public string PermissionSuffix;
        public VehicleConfig VehicleConfig;
        public string PayPrompt;
        public string PayAction;
        public uint PrefabId { get; set; }
        public string PurchasePermission { get; set; }
        public string OwnershipPermission { get; set; }
        public string FreePermission { get; set; }
        public void Init();
        public void OnServerInitialized();
    }

    private class VehicleInfoManager
    {
        private readonly VehicleVendorOptions _plugin;
        private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo;
        private readonly Dictionary<string, VehicleInfo> _payPromptToVehicleInfo;
        private readonly Dictionary<string, VehicleInfo> _payActionToVehicleInfo;
        private VehicleInfo[] _allVehicles;
        public VehicleInfoManager(VehicleVendorOptions plugin);
        public void Init();
        public void OnServerInitialized();
        public VehicleInfo GetVehicleInfo(BaseEntity entity);
        public VehicleInfo GetForPayPrompt(string promptName);
        public VehicleInfo GetForPayAction(string actionName);
    }

    private static class PlayerInventoryUtils
    {
        public static void Refresh(BasePlayer player);
        public static void UpdateWithFakeScrap(BasePlayer player, Item scrapItem, int amountDiff);
        private static int AddFakeScrapToContainerUpdate(ProtoBuf.ItemContainer containerInfo, Item scrapItem, int scrapAmount);
        private static int GetNextAvailableSlot(ProtoBuf.ItemContainer containerInfo);
    }

    private static class ConversationUtils
    {
        public static class SpeechNodes
        {
            public const string Goodbye;
        }

        public static ConversationCondition GetScrapCondition(ResponseNode responseNode);
        public static ConversationCondition FindPayConditionInResponses(SpeechNode speechNode);
        public static void ForceSpeechNode(NPCTalking npcTalking, BasePlayer player, string speechNodeName);
        public static NPCConversationResultAction FindResultAction(NPCTalking npcTalking, string actionString);
        public static SpeechNode FindSpeechNodeByName(ConversationData conversationData, string speechNodeName);
    }

    private static class CostLabelUI
    {
        private const string Name;
        public static void Destroy(BasePlayer player);
        public static void DestroyAll();
        public static void Create(VehicleVendorOptions plugin, BasePlayer player, PriceConfig priceConfig);
    }

    private class EconomicsPaymentProvider : IPaymentProvider
    {
        private readonly VehicleVendorOptions _plugin;
        private Plugin _ownerPlugin { get; set; }
        public EconomicsPaymentProvider(VehicleVendorOptions plugin);
        public bool IsAvailable { get; set; }
        public int GetBalance(BasePlayer player);
        public void TakeBalance(BasePlayer player, int amount);
    }

    private class ServerRewardsPaymentProvider : IPaymentProvider
    {
        private readonly VehicleVendorOptions _plugin;
        private Plugin _ownerPlugin { get; set; }
        public ServerRewardsPaymentProvider(VehicleVendorOptions plugin);
        public bool IsAvailable { get; set; }
        public int GetBalance(BasePlayer player);
        public void TakeBalance(BasePlayer player, int amount);
    }

    private class ItemsPaymentProvider : IPaymentProvider
    {
        public bool IsAvailable { get; set; }
        private int _itemId;
        public ItemsPaymentProvider(int itemId);
        public int GetBalance(BasePlayer player);
        public void TakeBalance(BasePlayer player, int amount);
    }

    private class VehicleConfigMap
    {
        [JsonProperty("Minicopter")]
        public VehicleConfig Minicopter;
        [JsonProperty("ScrapTransport")]
        public VehicleConfig ScrapTransport;
        [JsonProperty("AttackHelicopter")]
        public VehicleConfig AttackHelicopter;
        [JsonProperty("HotAirBalloon")]
        public VehicleConfig HotAirBalloon;
        [JsonProperty("Rowboat")]
        public VehicleConfig Rowboat;
        [JsonProperty("RHIB")]
        public VehicleConfig RHIB;
        [JsonProperty("SoloSub")]
        public VehicleConfig SoloSub;
        [JsonProperty("DuoSub")]
        public VehicleConfig DuoSub;
    }

    private class VehicleConfig
    {
        private static PriceConfig FreePriceConfig;
        [JsonProperty("RequiresPermission")]
        public bool RequiresPermission;
        [JsonProperty("FuelAmount")]
        public int FuelAmount;
        [JsonProperty("DespawnProtectionSeconds")]
        public float DespawnProtectionSeconds;
        [JsonProperty("PricesRequiringPermission")]
        public PriceConfig[] PricesRequiringPermission;
        public void InitAndValidate(VehicleVendorOptions plugin, string vehicleType);
        public PriceConfig GetPriceForPlayer(VehicleVendorOptions plugin, IPlayer player, string freePermission);
    }

    private class PriceConfig
    {
        [JsonProperty("Amount")]
        public int Amount;
        [JsonProperty("ItemShortName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string ItemShortName;
        [JsonProperty("UseEconomics")]
        public bool UseEconomics;
        [JsonProperty("UseServerRewards")]
        public bool UseServerRewards;
        [JsonIgnore]
        public string Permission;
        [JsonIgnore]
        public IPaymentProvider PaymentProvider;
        [JsonIgnore]
        public bool IsValid { get; set; }
        [JsonIgnore]
        public bool RequiresScrap { get; set; }
        private ItemDefinition _itemDefinition;
        [JsonIgnore]
        public ItemDefinition ItemDef { get; set; }
        public bool MatchesVanillaPrice(int vanillaPrice);
        public void InitAndValidate(VehicleVendorOptions plugin, string vehicleType);
        private IPaymentProvider CreatePaymentProvider(VehicleVendorOptions plugin);
        private string GeneratePermission(string vehicleType);
        public bool CanPlayerAfford(BasePlayer player);
        public bool TryChargePlayer(BasePlayer player);
    }

    private class Configuration : BaseConfiguration
    {
        [JsonProperty("Vehicles")]
        public VehicleConfigMap Vehicles;
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void ChatMessage(BasePlayer player, string messageName, object[] args);
    private string GetMessage(BasePlayer player, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    private string GetMessage(string playerId, string messageName, object[] args);
    private string GetItemNameLocalizationKey(string itemShortName);
    private void AddEnglishItemNamesForPriceConfigs(Dictionary<string, string> messages, PriceConfig[] priceConfigs);
    protected override void LoadDefaultMessages();
}

private class VehicleInfo
{
    public string PrefabPath;
    public string PermissionSuffix;
    public VehicleConfig VehicleConfig;
    public string PayPrompt;
    public string PayAction;
    public uint PrefabId { get; set; }
    public string PurchasePermission { get; set; }
    public string OwnershipPermission { get; set; }
    public string FreePermission { get; set; }
    public void Init();
    public void OnServerInitialized();
}

private class VehicleInfoManager
{
    private readonly VehicleVendorOptions _plugin;
    private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo;
    private readonly Dictionary<string, VehicleInfo> _payPromptToVehicleInfo;
    private readonly Dictionary<string, VehicleInfo> _payActionToVehicleInfo;
    private VehicleInfo[] _allVehicles;
    public VehicleInfoManager(VehicleVendorOptions plugin);
    public void Init();
    public void OnServerInitialized();
    public VehicleInfo GetVehicleInfo(BaseEntity entity);
    public VehicleInfo GetForPayPrompt(string promptName);
    public VehicleInfo GetForPayAction(string actionName);
}

private static class PlayerInventoryUtils
{
    public static void Refresh(BasePlayer player);
    public static void UpdateWithFakeScrap(BasePlayer player, Item scrapItem, int amountDiff);
    private static int AddFakeScrapToContainerUpdate(ProtoBuf.ItemContainer containerInfo, Item scrapItem, int scrapAmount);
    private static int GetNextAvailableSlot(ProtoBuf.ItemContainer containerInfo);
}

private static class ConversationUtils
{
    public static class SpeechNodes
    {
        public const string Goodbye;
    }

    public static ConversationCondition GetScrapCondition(ResponseNode responseNode);
    public static ConversationCondition FindPayConditionInResponses(SpeechNode speechNode);
    public static void ForceSpeechNode(NPCTalking npcTalking, BasePlayer player, string speechNodeName);
    public static NPCConversationResultAction FindResultAction(NPCTalking npcTalking, string actionString);
    public static SpeechNode FindSpeechNodeByName(ConversationData conversationData, string speechNodeName);
}

public static class SpeechNodes
{
    public const string Goodbye;
}

private static class CostLabelUI
{
    private const string Name;
    public static void Destroy(BasePlayer player);
    public static void DestroyAll();
    public static void Create(VehicleVendorOptions plugin, BasePlayer player, PriceConfig priceConfig);
}

private class EconomicsPaymentProvider : IPaymentProvider
{
    private readonly VehicleVendorOptions _plugin;
    private Plugin _ownerPlugin { get; set; }
    public EconomicsPaymentProvider(VehicleVendorOptions plugin);
    public bool IsAvailable { get; set; }
    public int GetBalance(BasePlayer player);
    public void TakeBalance(BasePlayer player, int amount);
}

private class ServerRewardsPaymentProvider : IPaymentProvider
{
    private readonly VehicleVendorOptions _plugin;
    private Plugin _ownerPlugin { get; set; }
    public ServerRewardsPaymentProvider(VehicleVendorOptions plugin);
    public bool IsAvailable { get; set; }
    public int GetBalance(BasePlayer player);
    public void TakeBalance(BasePlayer player, int amount);
}

private class ItemsPaymentProvider : IPaymentProvider
{
    public bool IsAvailable { get; set; }
    private int _itemId;
    public ItemsPaymentProvider(int itemId);
    public int GetBalance(BasePlayer player);
    public void TakeBalance(BasePlayer player, int amount);
}

private class VehicleConfigMap
{
    [JsonProperty("Minicopter")]
    public VehicleConfig Minicopter;
    [JsonProperty("ScrapTransport")]
    public VehicleConfig ScrapTransport;
    [JsonProperty("AttackHelicopter")]
    public VehicleConfig AttackHelicopter;
    [JsonProperty("HotAirBalloon")]
    public VehicleConfig HotAirBalloon;
    [JsonProperty("Rowboat")]
    public VehicleConfig Rowboat;
    [JsonProperty("RHIB")]
    public VehicleConfig RHIB;
    [JsonProperty("SoloSub")]
    public VehicleConfig SoloSub;
    [JsonProperty("DuoSub")]
    public VehicleConfig DuoSub;
}

private class VehicleConfig
{
    private static PriceConfig FreePriceConfig;
    [JsonProperty("RequiresPermission")]
    public bool RequiresPermission;
    [JsonProperty("FuelAmount")]
    public int FuelAmount;
    [JsonProperty("DespawnProtectionSeconds")]
    public float DespawnProtectionSeconds;
    [JsonProperty("PricesRequiringPermission")]
    public PriceConfig[] PricesRequiringPermission;
    public void InitAndValidate(VehicleVendorOptions plugin, string vehicleType);
    public PriceConfig GetPriceForPlayer(VehicleVendorOptions plugin, IPlayer player, string freePermission);
}

private class PriceConfig
{
    [JsonProperty("Amount")]
    public int Amount;
    [JsonProperty("ItemShortName", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string ItemShortName;
    [JsonProperty("UseEconomics")]
    public bool UseEconomics;
    [JsonProperty("UseServerRewards")]
    public bool UseServerRewards;
    [JsonIgnore]
    public string Permission;
    [JsonIgnore]
    public IPaymentProvider PaymentProvider;
    [JsonIgnore]
    public bool IsValid { get; set; }
    [JsonIgnore]
    public bool RequiresScrap { get; set; }
    private ItemDefinition _itemDefinition;
    [JsonIgnore]
    public ItemDefinition ItemDef { get; set; }
    public bool MatchesVanillaPrice(int vanillaPrice);
    public void InitAndValidate(VehicleVendorOptions plugin, string vehicleType);
    private IPaymentProvider CreatePaymentProvider(VehicleVendorOptions plugin);
    private string GeneratePermission(string vehicleType);
    public bool CanPlayerAfford(BasePlayer player);
    public bool TryChargePlayer(BasePlayer player);
}

private class Configuration : BaseConfiguration
{
    [JsonProperty("Vehicles")]
    public VehicleConfigMap Vehicles;
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## VendingInStock by AVOCoder - It just refill items in the NPC vending machines to keep them always in stock.

```csharp
using Oxide.Core;
using System.Linq;
using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Facepunch;

Oxide.Plugins
[Info("Vending In Stock", "AVOcoder / rostov114", "1.1.0")]
[Description("VendingMachines sell-orders always in stock")]
 class VendingInStock : RustPlugin
{
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Disable native refill")]
        public bool disableNativeRefill;
        [JsonProperty(PropertyName = "Do not refill items")]
        public string[] noRefillItems;
        [JsonProperty(PropertyName = "Do not refill vendings")]
        public string[] noRefillVendings;
        public bool NoRefillItem(Item item);
        public bool NoRefillVending(NPCVendingMachine vm);
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void Unload();
    private void CanPurchaseItem(BasePlayer buyer, Item soldItem, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vm);
    [ConsoleCommand("vending_orders_name")]
    private void vending_orders_name(ConsoleSystem.Arg arg);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Disable native refill")]
    public bool disableNativeRefill;
    [JsonProperty(PropertyName = "Do not refill items")]
    public string[] noRefillItems;
    [JsonProperty(PropertyName = "Do not refill vendings")]
    public string[] noRefillVendings;
    public bool NoRefillItem(Item item);
    public bool NoRefillVending(NPCVendingMachine vm);
}


```

---

## VendingLootDrop by Bazz3l - Drops vending machines contents when destroyed.

```csharp
using Newtonsoft.Json;
using System.Linq;

Oxide.Plugins
[Info("Vending Loot Drop", "Bazz3l", "1.0.6")]
[Description("Drops vending machine contents when destroyed.")]
 class VendingLootDrop : RustPlugin
{
    private PluginConfig _config;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     class PluginConfig
    {
        [JsonProperty(PropertyName = "Drop chance (percents, 1f = 100%)")]
        public float DropChance;
        public static PluginConfig DefaultConfig();
    }

     void OnServerInitialized();
     void Init();
     void OnEntitySpawned(VendingMachine machine);
}

 class PluginConfig
{
    [JsonProperty(PropertyName = "Drop chance (percents, 1f = 100%)")]
    public float DropChance;
    public static PluginConfig DefaultConfig();
}


```

---

## VendingMachineLogs by Ryz0r - Logs purchases of all vending machine transactions, or just user-to-user transactions through them.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core.Libraries;

Oxide.Plugins
[Info("Vending Machine Logs", "Ryz0r", "1.0.5"), Description("Logs vending machine transactions to Discord.")]
public class VendingMachineLogs : RustPlugin
{
    private const string BypassPerm;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Discord Webhook URL")]
        public string WebhookURL;
        [JsonProperty(PropertyName = "Ignore Non-Player Vending Machines")]
        public bool IgnoreNonPlayer;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Init();
    private void OnVendingTransaction(VendingMachine machine, BasePlayer player, int sellOrderId, int numberOfTransactions);
    private void SendDiscordMessage(string customerName, string customerID, string soldItem, int soldItemID, string currencyItem, int currencyItemID, string shopName, int soldQuantity, int currencyQuantity, string machineOwner);
    private void GetCallback(int code, string response);
    private class DiscordMessage
    {
        public DiscordMessage(string content, Embed[] embeds);
        [JsonProperty("content")]
        public string Content { get; set; }
        [JsonProperty("embeds")]
        public List<Embed> Embeds { get; set; }
        public string ToJson();
    }

    private class Embed
    {
        [JsonProperty("fields")]
        public List<Field> Fields { get; set; }
        [JsonProperty("color")]
        public int Color { get; set; }
        public Embed AddField(string name, string value, bool inline);
        public Embed SetColor(string color);
    }

    private class Field
    {
        public Field(string name, string value, bool inline);
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("inline")]
        public bool Inline { get; set; }
    }

}

private class Configuration
{
    [JsonProperty(PropertyName = "Discord Webhook URL")]
    public string WebhookURL;
    [JsonProperty(PropertyName = "Ignore Non-Player Vending Machines")]
    public bool IgnoreNonPlayer;
}

private class DiscordMessage
{
    public DiscordMessage(string content, Embed[] embeds);
    [JsonProperty("content")]
    public string Content { get; set; }
    [JsonProperty("embeds")]
    public List<Embed> Embeds { get; set; }
    public string ToJson();
}

private class Embed
{
    [JsonProperty("fields")]
    public List<Field> Fields { get; set; }
    [JsonProperty("color")]
    public int Color { get; set; }
    public Embed AddField(string name, string value, bool inline);
    public Embed SetColor(string color);
}

private class Field
{
    public Field(string name, string value, bool inline);
    [JsonProperty("name")]
    public string Name { get; set; }
    [JsonProperty("value")]
    public string Value { get; set; }
    [JsonProperty("inline")]
    public bool Inline { get; set; }
}


```

---

## VendingMachineTimeout by 0x89A - Prevents players from hogging vending machines at outpost

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Vending Machine Timeout", "0x89A", "1.0.15")]
[Description("Prevents players from hogging vending machines at outpost")]
 class VendingMachineTimeout : RustPlugin
{
    private Dictionary<ulong, Timer> timeoutTimers;
    private const string bypass;
    private void Init();
     void OnOpenVendingShop(NPCVendingMachine machine, BasePlayer player);
     void OnLootEntityEnd(BasePlayer player, NPCVendingMachine entity);
    private Configuration config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Timeout time (seconds)")]
        public float timeoutSeconds;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class Configuration
{
    [JsonProperty(PropertyName = "Timeout time (seconds)")]
    public float timeoutSeconds;
}


```

---

## VendingManager by Whispers88 - Utility for managing vending machines

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Vending Manager", "Whispers88", "0.2.2")]
[Description("Improved vending machine control")]
 class VendingManager : RustPlugin
{
    [PluginReference]
     Plugin CustomVendingSetup;
     Plugin Economics;
     Plugin ServerRewards;
    private const string PermCanUse;
    private const string PermCanEject;
     object[] defaults;
     VendingData data;
     Dictionary<ulong, VendingMachineInfo> vms;
     Dictionary<ulong, LockInfo> locks;
    const float defaultHealth;
     ProtectionProperties defaultProtection;
     ProtectionProperties customProtection;
    const string CodeLockPrefab;
    const string KeyLockPrefab;
     Dictionary<ulong, Timer> transactionTimers;
     Dictionary<ulong, Timer> timeoutTimers;
     bool isShuttingDown;
     bool useEconomics;
     bool useServerRewards;
     string currencyPlugin { get; set; }
     int currencyIndex;
     ItemDefinition currencyItem;
    protected override void LoadDefaultMessages();
     string GetMessage(string key, string userId);
     void Init();
     void Unload();
     void OnServerInitialized();
     void OnPluginLoaded(Plugin plugin);
     void OnPluginUnloaded(Plugin plugin);
     void Check(bool initial);
     void OnServerShutdown();
     void OnServerSave();
     bool LoadDefaultConfig();
     void LoadData();
     void SaveData();
     void SaveVendingMachineData();
     void SaveLocksData();
     T GetConfig(string group, string name, T value);
     bool CheckConfig();
     void OnEntitySpawned(BaseNetworkable entity);
     void OnItemDeployed(Deployer deployer, BaseEntity entity);
     void OnToggleVendingBroadcast(VendingMachine vm, BasePlayer player);
     object OnVendingTransaction(VendingMachine vm, BasePlayer player, int sellOrderId, int numTransactions);
     object CanAdministerVending(VendingMachine vm, BasePlayer player);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo);
     void OnVendingShopOpened(VendingMachine vm, BasePlayer player);
     void OnLootEntityEnd(BasePlayer player, BaseEntity entity);
     void OnRotateVendingMachine(VendingMachine vm, BasePlayer player);
     void CommandDelegator(BasePlayer player, string command, string[] args);
     void HandleReset(string[] args, string message);
     void HandleClear(BasePlayer player, string message);
     void HandleInfo(BasePlayer player, string message, object[] opts);
     void HandleLoad(BasePlayer player, string[] args, bool replaceAll, string message, object[] opts);
     void LoadSellOrders(VendingMachine vm, string templateName, bool replace, string message);
     void HandleSave(BasePlayer player, string[] args, string message, object[] opts);
     void SaveSellOrders(VendingMachine vm, string templateName, string message, bool overwrite);
     void HandleSet(BasePlayer player, string[] args, string message, object[] opts, bool unset);
     void SendMessage(BasePlayer player, string message, object[] options);
     void HandleList(string message, object[] opts);
     void ShowCommands(string message, object[] opts);
     void LogTransaction(LogEntry logEntry, bool force);
     void SetAll(bool lockable, float health);
     void Set(VendingMachine vm, bool lockable, float health, bool restoreProtection);
     bool Eject(VendingMachine m);
     void EjectAll(string message, object[] opts);
     bool GetRaycastTarget(BasePlayer player, object closestEntity);
    private static bool isAdmin(BasePlayer player);
    private bool hasPermission(BasePlayer player, string permname);
     T ConfigValue(Option option);
     void SaveVMsAndLocks();
     void LoadLocks();
     void DestroyLocks();
     double GetBalance(ulong playerId);
     bool Withdraw(ulong playerId, double amount);
     bool Deposit(ulong playerId, double amount);
     bool Transfer(ulong fromId, ulong toId, double amount);
     class VendingData
    {
        public Dictionary<Option, object> config;
        public Dictionary<DamageType, float> resistances;
        public Dictionary<string, SellOrderTemplate> templates;
        public string GetTemplateList();
        public void SetResistances(float[] amounts);
        public float[] GetResistances();
    }

     class SellOrderTemplate
    {
        public List<SellOrderEntry> entries;
        public void PopulateTemplate(List<ProtoBuf.VendingMachine.SellOrder> sellOrders);
        public void AddSellOrder(ProtoBuf.VendingMachine.SellOrder o);
        public bool Empty();
    }

     class VendingMachineInfo
    {
        public ulong id;
        [JsonConverter(typeof(StringEnumConverter))]
        public VMFlags flags;
        public bool HasFlag(VMFlags flag);
    }

     class LockInfo
    {
        static readonly byte[] entropy;
        public ulong vmId;
        public bool isCodeLock;
        public string codeEncrypted;
        [JsonIgnore]
        public string code { get; set; }
        public string guestCodeEncrypted;
        [JsonIgnore]
        public string guestCode { get; set; }
        public List<ulong> whitelist;
        public List<ulong> guests;
        public int keyCode;
        public bool firstKey;
        public bool isLocked;
        public LockInfo();
        public LockInfo(ulong vmId, BaseLock l);
        public void FromLock(BaseLock l);
        public void ToLock(BaseLock l);
        static string Shift(string source, int shift);
    }

}

 class VendingData
{
    public Dictionary<Option, object> config;
    public Dictionary<DamageType, float> resistances;
    public Dictionary<string, SellOrderTemplate> templates;
    public string GetTemplateList();
    public void SetResistances(float[] amounts);
    public float[] GetResistances();
}

 class SellOrderTemplate
{
    public List<SellOrderEntry> entries;
    public void PopulateTemplate(List<ProtoBuf.VendingMachine.SellOrder> sellOrders);
    public void AddSellOrder(ProtoBuf.VendingMachine.SellOrder o);
    public bool Empty();
}

 class VendingMachineInfo
{
    public ulong id;
    [JsonConverter(typeof(StringEnumConverter))]
    public VMFlags flags;
    public bool HasFlag(VMFlags flag);
}

 class LockInfo
{
    static readonly byte[] entropy;
    public ulong vmId;
    public bool isCodeLock;
    public string codeEncrypted;
    [JsonIgnore]
    public string code { get; set; }
    public string guestCodeEncrypted;
    [JsonIgnore]
    public string guestCode { get; set; }
    public List<ulong> whitelist;
    public List<ulong> guests;
    public int keyCode;
    public bool firstKey;
    public bool isLocked;
    public LockInfo();
    public LockInfo(ulong vmId, BaseLock l);
    public void FromLock(BaseLock l);
    public void ToLock(BaseLock l);
    static string Shift(string source, int shift);
}


```

---

## VendorRotateProtection by  - Prevents other player from rotating a vending machine

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Vendor Rotate Protection", "nuchacho/Arainrr", "1.1.3")]
[Description("Prevents anyone except the entity owner from rotating vending machine.")]
public class VendorRotateProtection : RustPlugin
{
    [PluginReference]
    private readonly Plugin Friends;
    private readonly Plugin Clans;
    private object OnRotateVendingMachine(VendingMachine machine, BasePlayer player);
    private bool AreFriends(ulong playerID, ulong friendID);
    private bool HasFriend(ulong playerID, ulong friendID);
    private bool SameTeam(ulong playerID, ulong friendID);
    private bool SameClan(ulong playerID, ulong friendID);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat Prefix Color")]
        public string prefixColor;
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong steamIDIcon;
        [JsonProperty(PropertyName = "Use Team")]
        public bool useTeam;
        [JsonProperty(PropertyName = "Use Friends")]
        public bool useFriends;
        [JsonProperty(PropertyName = "Use Clans")]
        public bool useClans;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void Print(BasePlayer player, string message);
    private string Lang(string key, string id, object[] args);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat Prefix Color")]
    public string prefixColor;
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong steamIDIcon;
    [JsonProperty(PropertyName = "Use Team")]
    public bool useTeam;
    [JsonProperty(PropertyName = "Use Friends")]
    public bool useFriends;
    [JsonProperty(PropertyName = "Use Clans")]
    public bool useClans;
}


```

---

## VerificationGatekeeper by ThibmoRozier - Prevents players from doing anything on the server until they are given the bypass permission

```csharp
using System.ComponentModel;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Verification Gatekeeper", "ThibmoRozier", "1.2.1")]
[Description("Prevents players from doing anything on the server until they are given the bypass permission")]
public class VerificationGatekeeper : RustPlugin
{
    private const string CPermBypass;
    private const string CPermBypassMount;
    private const string CPermBypassBedActions;
    private const string CPermBypassBuild;
    private const string CPermBypassCardSwiping;
    private const string CPermBypassChat;
    private const string CPermBypassCollectiblePickup;
    private const string CPermBypassCommand;
    private const string CPermBypassCounterActions;
    private const string CPermBypassCrafting;
    private const string CPermBypassCrateHack;
    private const string CPermBypassCupboardActions;
    private const string CPermBypassCustomUI;
    private const string CPermBypassDemolish;
    private const string CPermBypassDeployItem;
    private const string CPermBypassDoorActions;
    private const string CPermBypassElevatorActions;
    private const string CPermBypassEntityLooting;
    private const string CPermBypassEntityPickup;
    private const string CPermBypassExplosives;
    private const string CPermBypassFlamers;
    private const string CPermBypassFuelActions;
    private const string CPermBypassGrowableGathering;
    private const string CPermBypassHealingItemUsage;
    private const string CPermBypassHelicopterActions;
    private const string CPermBypassItemActions;
    private const string CPermBypassItemDropping;
    private const string CPermBypassItemMoving;
    private const string CPermBypassItemPickup;
    private const string CPermBypassItemSkinning;
    private const string CPermBypassItemStacking;
    private const string CPermBypassItemWearing;
    private const string CPermBypassLiftActions;
    private const string CPermBypassLockActions;
    private const string CPermBypassMailboxActions;
    private const string CPermBypassMelee;
    private const string CPermBypassOvenActions;
    private const string CPermBypassPhoneActions;
    private const string CPermBypassPlayerAssist;
    private const string CPermBypassPlayerLooting;
    private const string CPermBypassPush;
    private const string CPermBypassRecyclerActions;
    private const string CPermBypassReloading;
    private const string CPermBypassRepair;
    private const string CPermBypassResearch;
    private const string CPermBypassRockets;
    private const string CPermBypassShopActions;
    private const string CPermBypassSignUpdate;
    private const string CPermBypassStashActions;
    private const string CPermBypassStructureRotate;
    private const string CPermBypassSwitchActions;
    private const string CPermBypassTeamCreation;
    private const string CPermBypassTrapActions;
    private const string CPermBypassTurretActions;
    private const string CPermBypassUpgrade;
    private const string CPermBypassVendingAdmin;
    private const string CPermBypassVendingUsage;
    private const string CPermBypassWeaponFiring;
    private const string CPermBypassWiring;
    private const string CPermBypassWoodCutting;
    private const string CPermBypassWorldProjectiles;
    private const string CPermBypassWounded;
    private ConfigData FConfigData;
    private class ConfigData
    {
        [JsonProperty("Admin Is Always Verified", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool AdminAlwaysVerified;
        [JsonProperty("Prevent (Dis-)Mount", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventMount;
        [JsonProperty("Prevent Bed Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventBedActions;
        [JsonProperty("Prevent Build", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventBuild;
        [JsonProperty("Prevent Card Swiping", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventCardSwiping;
        [JsonProperty("Prevent Chat", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventChat;
        [JsonProperty("Prevent Collectible Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventCollectiblePickup;
        [JsonProperty("Prevent Command", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventCommand;
        [JsonProperty("Prevent Counter Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventCounterActions;
        [JsonProperty("Prevent Crafting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventCrafting;
        [JsonProperty("Prevent Crate Hack", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventCrateHack;
        [JsonProperty("Prevent Cupboard Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventCupboardActions;
        [JsonProperty("Prevent Custom UI", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(false)]
        public bool PreventCustomUI;
        [JsonProperty("Prevent Demolish", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventDemolish;
        [JsonProperty("Prevent Deploy Item", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventDeployItem;
        [JsonProperty("Prevent Door Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventDoorActions;
        [JsonProperty("Prevent Elevator Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventElevatorActions;
        [JsonProperty("Prevent Entity Looting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventEntityLooting;
        [JsonProperty("Prevent Entity Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventEntityPickup;
        [JsonProperty("Prevent Explosives", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventExplosives;
        [JsonProperty("Prevent Flamers", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventFlamers;
        [JsonProperty("Prevent Fuel Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventFuelActions;
        [JsonProperty("Prevent Growable Gathering", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventGrowableGathering;
        [JsonProperty("Prevent Healing Item Usage", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventHealingItemUsage;
        [JsonProperty("Prevent Helicopter Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventHelicopterActions;
        [JsonProperty("Prevent Item Action", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventItemAction;
        [JsonProperty("Prevent Item Dropping", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventItemDropping;
        [JsonProperty("Prevent Item Moving", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventItemMoving;
        [JsonProperty("Prevent Item Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventItemPickup;
        [JsonProperty("Prevent Item Skinning", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventItemSkinning;
        [JsonProperty("Prevent Item Stacking", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventItemStacking;
        [JsonProperty("Prevent Item Wearing", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventItemWearing;
        [JsonProperty("Prevent Lift Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventLiftActions;
        [JsonProperty("Prevent Lock Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventLockActions;
        [JsonProperty("Prevent Mailbox Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventMailboxActions;
        [JsonProperty("Prevent Melee", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventMelee;
        [JsonProperty("Prevent Oven & Furnace Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventOvenActions;
        [JsonProperty("Prevent Phone Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventPhoneActions;
        [JsonProperty("Prevent Player Assist", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventPlayerAssist;
        [JsonProperty("Prevent Player Looting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventPlayerLooting;
        [JsonProperty("Prevent Push", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventPush;
        [JsonProperty("Prevent Recycler Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventRecyclerActions;
        [JsonProperty("Prevent Reloading", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventReloading;
        [JsonProperty("Prevent Repair", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventRepair;
        [JsonProperty("Prevent Research", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventResearch;
        [JsonProperty("Prevent Rockets", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventRockets;
        [JsonProperty("Prevent Shop Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventShopActions;
        [JsonProperty("Prevent Sign Update", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventSignUpdate;
        [JsonProperty("Prevent Stash Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventStashActions;
        [JsonProperty("Prevent Structure Rotate", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventStructureRotate;
        [JsonProperty("Prevent Switch Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventSwitchActions;
        [JsonProperty("Prevent Team Creation", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventTeamCreation;
        [JsonProperty("Prevent Trap Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventTrapActions;
        [JsonProperty("Prevent Turret Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventTurretActions;
        [JsonProperty("Prevent Upgrade", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventUpgrade;
        [JsonProperty("Prevent Vending Admin", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventVendingAdmin;
        [JsonProperty("Prevent Vending Usage", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventVendingUsage;
        [JsonProperty("Prevent Weapon Firing", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventWeaponFiring;
        [JsonProperty("Prevent Wiring", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventWiring;
        [JsonProperty("Prevent Wood Cutting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventWoodCutting;
        [JsonProperty("Prevent World Projectiles", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventWorldProjectiles;
        [JsonProperty("Prevent Wounded", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
        public bool PreventWounded;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private bool? CheckAndReturnNullOrFalse(BasePlayer aPlayer, string aBypassPerm);
    private bool? CheckAndReturnNullOrFalse(IPlayer aPlayer, string aBypassPerm);
     void Init();
     bool? CanDismountEntity(BasePlayer aPlayer, BaseMountable aEntity);
     bool? CanMountEntity(BasePlayer aPlayer, BaseMountable aEntity);
     bool? CanSwapToSeat(BasePlayer aPlayer, BaseMountable aMountable);
     bool? OnRidableAnimalClaim(BaseRidableAnimal aAnimal, BasePlayer aPlayer);
     bool? CanAssignBed(BasePlayer aPlayer, SleepingBag aBag, ulong aTargetPlayerId);
     bool? CanRenameBed(BasePlayer aPlayer, SleepingBag aBed, string aBedName);
     bool? CanSetBedPublic(BasePlayer aPlayer, SleepingBag aBed);
     bool? CanAffordToPlace(BasePlayer aPlayer, Planner aPlanner, Construction aConstruction);
     bool? CanBuild(Planner aPlanner, Construction aPrefab, Construction.Target aTarget);
     bool? OnConstructionPlace(BaseEntity aEntity, Construction aComponent, Construction.Target aConstructionTarget, BasePlayer aPlayer);
     bool? OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer aPlayer);
     bool? OnUserChat(IPlayer aPlayer, string aMessage);
     bool? OnCollectiblePickup(CollectibleEntity aEntity, BasePlayer aPlayer);
     bool? OnUserCommand(IPlayer aPlayer, string command, string[] args);
     bool? OnCounterModeToggle(PowerCounter aCounter, BasePlayer aPlayer, bool aMode);
     bool? OnCounterTargetChange(PowerCounter aCounter, BasePlayer aPlayer, int aTargetNumber);
     bool? CanCraft(ItemCrafter aItemCrafter, ItemBlueprint aBp, int aAmount);
     bool? CanCraft(PlayerBlueprints aPlayerBlueprints, ItemDefinition aItemDefinition, int aSkinItemId);
     bool? CanHackCrate(BasePlayer aPlayer, HackableLockedCrate aCrate);
     bool? OnCupboardAuthorize(BuildingPrivlidge aPrivilege, BasePlayer aPlayer);
     bool? OnCupboardClearList(BuildingPrivlidge aPrivilege, BasePlayer aPlayer);
     bool? OnCupboardDeauthorize(BuildingPrivlidge aPrivilege, BasePlayer aPlayer);
     bool? CanUseUI(BasePlayer aPlayer, string aJson);
     bool? CanDemolish(BasePlayer aPlayer, BuildingBlock aBlock, BuildingGrade.Enum aGrade);
     bool? OnStructureDemolish(BaseCombatEntity aEntity, BasePlayer aPlayer, bool aImmediate);
     bool? CanDeployItem(BasePlayer aPlayer, Deployer aDeployer, uint aEntityId);
     void OnDoorClosed(Door aDoor, BasePlayer aPlayer);
     void OnDoorOpened(Door aDoor, BasePlayer aPlayer);
     bool? OnElevatorButtonPress(ElevatorLift aLift, BasePlayer aPlayer, Elevator.Direction aDirection, bool aToTopOrBottom);
     bool? CanLootEntity(BasePlayer aPlayer, BaseRidableAnimal aAnimal);
     bool? CanLootEntity(BasePlayer aPlayer, DroppedItemContainer aContainer);
     bool? CanLootEntity(BasePlayer aPlayer, LootableCorpse aCorpse);
     bool? CanLootEntity(BasePlayer aPlayer, ResourceContainer aContainer);
     bool? CanLootEntity(BasePlayer aPlayer, StorageContainer aContainer);
     bool? CanPickupEntity(BasePlayer aPlayer, BaseEntity aEntity);
     void OnExplosiveDropped(BasePlayer aPlayer, BaseEntity aEntity, ThrownWeapon aItem);
     void OnExplosiveThrown(BasePlayer aPlayer, BaseEntity aEntity, ThrownWeapon aItem);
     void OnFlameThrowerBurn(FlameThrower aThrower, BaseEntity aFlame);
     bool? CanCheckFuel(EntityFuelSystem aFuelSystem, StorageContainer aFuelContainer, BasePlayer aPlayer);
     bool? OnGrowableGather(GrowableEntity plant, BasePlayer aPlayer);
     bool? OnHealingItemUse(MedicalTool aTool, BasePlayer aPlayer);
     bool? CanUseHelicopter(BasePlayer aPlayer, CH47HelicopterAIController aHelicopter);
     bool? OnItemAction(Item aItem, string aAction, BasePlayer aPlayer);
     bool? CanDropActiveItem(BasePlayer aPlayer);
     ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer aContainer, Item aItem, int aTargetPos);
     bool? CanMoveItem(Item aItem, PlayerInventory aPlayerLoot, uint aTargetContainer, int aTargetSlot, int aAmount);
     bool? OnItemPickup(Item aItem, BasePlayer aPlayer);
     bool? OnItemSkinChange(int aSkinItemId, Item aItem, StorageContainer aContainer, BasePlayer aPlayer);
     bool? CanStackItem(Item aItem, Item aTargetItem);
     bool? CanWearItem(PlayerInventory aInventory, Item aItem, int aTargetSlot);
     bool? OnLiftUse(Lift aLift, BasePlayer aPlayer);
     bool? OnLiftUse(ProceduralLift aLift, BasePlayer aPlayer);
     bool? CanChangeCode(BasePlayer aPlayer, CodeLock aCodeLock, string aNewCode, bool aIsGuestCode);
     bool? CanLock(BasePlayer aPlayer, BaseLock aLock);
     bool? CanPickupLock(BasePlayer aPlayer, BaseLock aBaseLock);
     bool? CanUnlock(BasePlayer aPlayer, BaseLock aBaseLock);
     bool? CanUseLockedEntity(BasePlayer aPlayer, BaseLock aBaseLock);
     bool? OnCodeEntered(CodeLock aCodeLock, BasePlayer aPlayer, string aCode);
     bool? OnItemLock(Item aItem);
     bool? OnItemUnlock(Item aItem);
     bool? CanUseMailbox(BasePlayer aPlayer, Mailbox aMailbox);
     bool? OnMeleeAttack(BasePlayer aPlayer, HitInfo aInfo);
     void OnMeleeThrown(BasePlayer aPlayer, Item aItem);
     bool? OnOvenToggle(BaseOven aOven, BasePlayer aPlayer);
     bool? OnPhoneDial(PhoneController aCallerPhone, PhoneController aReceiverPhone, BasePlayer aPlayer);
     bool? OnPhoneCallStart(PhoneController aPhone, PhoneController aOtherPhone, BasePlayer aPlayer);
     bool? OnPhoneNameUpdate(PhoneController aPhoneController, string aName, BasePlayer aPlayer);
     bool? OnPlayerAssist(BasePlayer aTarget, BasePlayer aPlayer);
     bool? OnPlayerRevive(BasePlayer aReviver, BasePlayer aPlayer);
     bool? CanLootPlayer(BasePlayer aTarget, BasePlayer aLooter);
     bool? CanPushBoat(BasePlayer aPlayer, MotorRowboat aBoat);
     bool? OnVehiclePush(BaseVehicle aVehicle, BasePlayer aPlayer);
     bool? OnRecyclerToggle(Recycler aRecycler, BasePlayer aPlayer);
     bool? OnReloadMagazine(BasePlayer aPlayer, BaseProjectile aProjectile, int aDesiredAmount);
     bool? OnReloadWeapon(BasePlayer aPlayer, BaseProjectile aProjectile);
     bool? OnSwitchAmmo(BasePlayer aPlayer, BaseProjectile aProjectile);
     bool? OnHammerHit(BasePlayer aPlayer, HitInfo aInfo);
     bool? OnStructureRepair(BaseCombatEntity aEntity, BasePlayer aPlayer);
     bool? CanResearchItem(BasePlayer aPlayer, Item aTargetItem);
     bool? CanUnlockTechTreeNode(BasePlayer aPlayer, TechTreeData.NodeInstance aNode, TechTreeData aTechTree);
     bool? CanUnlockTechTreeNodePath(BasePlayer aPlayer, TechTreeData.NodeInstance aNode, TechTreeData aTechTree);
     void OnRocketLaunched(BasePlayer aPlayer, BaseEntity aEntity);
     bool? OnShopCompleteTrade(ShopFront aShop, BasePlayer aCustomer);
     bool? CanUpdateSign(BasePlayer aPlayer, PhotoFrame aPhotoFrame);
     bool? CanUpdateSign(BasePlayer aPlayer, Signage aSign);
     bool? CanHideStash(BasePlayer aPlayer, StashContainer aStash);
     bool? CanSeeStash(BasePlayer aPlayer, StashContainer aStash);
     bool? OnStructureRotate(BaseCombatEntity aEntity, BasePlayer aPlayer);
     bool? OnSwitchToggle(IOEntity aEntity, BasePlayer aPlayer);
     bool? OnTeamCreate(BasePlayer aPlayer);
     bool? OnTrapArm(BearTrap aTrap, BasePlayer aPlayer);
     bool? OnTrapDisarm(Landmine aTrap, BasePlayer aPlayer);
     bool? OnTurretAuthorize(AutoTurret aTurret, BasePlayer aPlayer);
     bool? OnTurretClearList(AutoTurret aTurret, BasePlayer aPlayer);
     bool? OnTurretRotate(AutoTurret aTurret, BasePlayer aPlayer);
     bool? CanAffordUpgrade(BasePlayer aPlayer, BuildingBlock aBlock, BuildingGrade.Enum aGrade);
     bool? CanChangeGrade(BasePlayer aPlayer, BuildingBlock aBlock, BuildingGrade.Enum aGrade);
     bool? OnStructureUpgrade(BaseCombatEntity aEntity, BasePlayer aPlayer, BuildingGrade.Enum aGrade);
     bool? CanAdministerVending(BasePlayer aPlayer, VendingMachine aMachine);
     bool? OnRotateVendingMachine(VendingMachine aMachine, BasePlayer aPlayer);
     bool? CanUseVending(VendingMachine aMachine, BasePlayer aPlayer);
     bool? OnBuyVendingItem(VendingMachine aMachine, BasePlayer aPlayer, int aSellOrderId, int aNumberOfTransactions);
     bool? OnVendingTransaction(VendingMachine aMachine, BasePlayer aBuyer, int aSellOrderId, int aNumberOfTransactions);
     void OnWeaponFired(BaseProjectile aProjectile, BasePlayer aPlayer, ItemModProjectile aMod, ProtoBuf.ProjectileShoot aProjectiles);
     bool? CanUseWires(BasePlayer aPlayer);
     bool? CanTakeCutting(BasePlayer aPlayer, GrowableEntity aEntity);
     bool? CanCreateWorldProjectile(HitInfo aInfo, ItemDefinition aItemDef);
     bool? OnCreateWorldProjectile(HitInfo aInfo, Item aItem);
     bool? CanBeWounded(BasePlayer aPlayer, HitInfo aInfo);
}

private class ConfigData
{
    [JsonProperty("Admin Is Always Verified", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool AdminAlwaysVerified;
    [JsonProperty("Prevent (Dis-)Mount", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventMount;
    [JsonProperty("Prevent Bed Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventBedActions;
    [JsonProperty("Prevent Build", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventBuild;
    [JsonProperty("Prevent Card Swiping", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventCardSwiping;
    [JsonProperty("Prevent Chat", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventChat;
    [JsonProperty("Prevent Collectible Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventCollectiblePickup;
    [JsonProperty("Prevent Command", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventCommand;
    [JsonProperty("Prevent Counter Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventCounterActions;
    [JsonProperty("Prevent Crafting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventCrafting;
    [JsonProperty("Prevent Crate Hack", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventCrateHack;
    [JsonProperty("Prevent Cupboard Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventCupboardActions;
    [JsonProperty("Prevent Custom UI", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(false)]
    public bool PreventCustomUI;
    [JsonProperty("Prevent Demolish", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventDemolish;
    [JsonProperty("Prevent Deploy Item", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventDeployItem;
    [JsonProperty("Prevent Door Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventDoorActions;
    [JsonProperty("Prevent Elevator Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventElevatorActions;
    [JsonProperty("Prevent Entity Looting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventEntityLooting;
    [JsonProperty("Prevent Entity Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventEntityPickup;
    [JsonProperty("Prevent Explosives", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventExplosives;
    [JsonProperty("Prevent Flamers", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventFlamers;
    [JsonProperty("Prevent Fuel Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventFuelActions;
    [JsonProperty("Prevent Growable Gathering", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventGrowableGathering;
    [JsonProperty("Prevent Healing Item Usage", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventHealingItemUsage;
    [JsonProperty("Prevent Helicopter Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventHelicopterActions;
    [JsonProperty("Prevent Item Action", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventItemAction;
    [JsonProperty("Prevent Item Dropping", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventItemDropping;
    [JsonProperty("Prevent Item Moving", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventItemMoving;
    [JsonProperty("Prevent Item Pickup", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventItemPickup;
    [JsonProperty("Prevent Item Skinning", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventItemSkinning;
    [JsonProperty("Prevent Item Stacking", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventItemStacking;
    [JsonProperty("Prevent Item Wearing", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventItemWearing;
    [JsonProperty("Prevent Lift Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventLiftActions;
    [JsonProperty("Prevent Lock Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventLockActions;
    [JsonProperty("Prevent Mailbox Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventMailboxActions;
    [JsonProperty("Prevent Melee", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventMelee;
    [JsonProperty("Prevent Oven & Furnace Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventOvenActions;
    [JsonProperty("Prevent Phone Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventPhoneActions;
    [JsonProperty("Prevent Player Assist", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventPlayerAssist;
    [JsonProperty("Prevent Player Looting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventPlayerLooting;
    [JsonProperty("Prevent Push", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventPush;
    [JsonProperty("Prevent Recycler Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventRecyclerActions;
    [JsonProperty("Prevent Reloading", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventReloading;
    [JsonProperty("Prevent Repair", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventRepair;
    [JsonProperty("Prevent Research", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventResearch;
    [JsonProperty("Prevent Rockets", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventRockets;
    [JsonProperty("Prevent Shop Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventShopActions;
    [JsonProperty("Prevent Sign Update", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventSignUpdate;
    [JsonProperty("Prevent Stash Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventStashActions;
    [JsonProperty("Prevent Structure Rotate", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventStructureRotate;
    [JsonProperty("Prevent Switch Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventSwitchActions;
    [JsonProperty("Prevent Team Creation", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventTeamCreation;
    [JsonProperty("Prevent Trap Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventTrapActions;
    [JsonProperty("Prevent Turret Actions", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventTurretActions;
    [JsonProperty("Prevent Upgrade", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventUpgrade;
    [JsonProperty("Prevent Vending Admin", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventVendingAdmin;
    [JsonProperty("Prevent Vending Usage", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventVendingUsage;
    [JsonProperty("Prevent Weapon Firing", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventWeaponFiring;
    [JsonProperty("Prevent Wiring", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventWiring;
    [JsonProperty("Prevent Wood Cutting", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventWoodCutting;
    [JsonProperty("Prevent World Projectiles", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventWorldProjectiles;
    [JsonProperty("Prevent Wounded", DefaultValueHandling = DefaultValueHandling.Populate), DefaultValue(true)]
    public bool PreventWounded;
}


```

---

## VIPNoDecay by ColonBlow - No decay damage for player or group with permissions

```csharp
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("VIPNoDecay", "ColonBlow", "1.0.4")]
[Description("Disables Decay Damage for player or oxide group with VIP permissions")]
 class VIPNoDecay : CovalencePlugin
{
    const string permVIP;
    private void OnServerInitialized();
     bool HasPermission(ulong playerID, string perm);
    private object OnEntityTakeDamage(DecayEntity decayEntity, HitInfo hitInfo);
}


```

---

## VIPTrial by ColdUnwanted - Allows you to set up a VIP trial group with a limited use-time

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("VIP Trial", "Maik8", "1.3.5", ResourceId = 2563)]
[Description("Plugin that lets Users try VIP functions.")]
public class VIPTrial : CovalencePlugin
{
     StoredData storedData;
     string groupName;
     int days;
     string message;
     List<object> permlist;
    [Command("viptrial")]
     void VIPtrialCommand(IPlayer player, string command, string[] args);
     void Init();
     void cleanGroup(IPlayer player);
     void cleanGroup();
     void OnUserConnected(IPlayer player);
     void listActiveTrials(IPlayer player);
     void checkGroup();
     void checkPerm(List<object> perm, string group);
    private int getDaysLeft(IPlayer player);
    private void addUserForTrial(IPlayer player);
    private bool checkPlayerForGroup(IPlayer player);
    private bool checkTrialAllowed(IPlayer player);
    private bool checkTrialAdmin(IPlayer player);
     bool checkAlreadyUsed(IPlayer player);
     bool checkExpired(string Id);
    private string GetLangValue(string key, string userId);
    protected override void LoadDefaultConfig();
     T GetConfig(string name, T value);
    protected override void LoadDefaultMessages();
     class StoredData
    {
        public HashSet<VIPDataSaveFile> VIPDataHash;
        public StoredData();
    }

     class VIPDataSaveFile
    {
        public string userId;
        public string now;
        public VIPDataSaveFile();
        public VIPDataSaveFile(IPlayer player, DateTime now);
    }

}

 class StoredData
{
    public HashSet<VIPDataSaveFile> VIPDataHash;
    public StoredData();
}

 class VIPDataSaveFile
{
    public string userId;
    public string now;
    public VIPDataSaveFile();
    public VIPDataSaveFile(IPlayer player, DateTime now);
}


```

---

## VirtualItems by WhiteThunder - Allows removing resource costs for most player actions, such as crafting and building

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;

Oxide.Plugins
[Info("Virtual Items", "WhiteThunder", "0.5.1")]
[Description("Removes resource costs of specific ingredients for crafting and building.")]
internal class VirtualItems : CovalencePlugin
{
    private const string PermissionRulesetPrefix;
    [PluginReference]
    private readonly Plugin ItemRetriever;
    private Configuration _config;
    private readonly RulesetManager _rulesetManager;
    private readonly object True;
    public VirtualItems();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnPluginLoaded(Plugin plugin);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnGroupPermissionGranted(string groupName, string perm);
    private void OnGroupPermissionRevoked(string groupName, string perm);
    private void OnUserPermissionGranted(string userId, string perm);
    private void OnUserPermissionRevoked(string userId, string perm);
    private object OnPayForPlacement(BasePlayer player, Planner planner);
    public static void LogDebug(string message);
    public static void LogInfo(string message);
    public static void LogWarning(string message);
    public static void LogError(string message);
    private static void SendInventoryUpdate(BasePlayer player);
    private static void UpdatePlayerInventories();
    private void RegisterAsItemSupplier();
    private class ItemPool
    {
        private readonly int _itemId;
        private readonly List<Item> _availableItems;
        private readonly List<Item> _takenItems;
        public ItemPool(int itemId);
        public Item Take();
        public void ReturnUnusedItems();
        public void Unload();
        private bool IsUnused(Item item);
    }

    private class RulesetManager
    {
        private readonly VirtualItems _plugin;
        private readonly Dictionary<ulong, Ruleset> _rulesetByPlayer;
        public RulesetManager(VirtualItems plugin);
        public Ruleset Get(BasePlayer player);
        public void Remove(BasePlayer player);
        public void Clear();
        public void Unload();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Ruleset
    {
        private class ItemInfo
        {
            public int Amount { get; set; }
            private ItemDefinition _itemDefinition;
            private ProtoBuf.Item _itemData;
            public ItemInfo(ItemDefinition itemDefinition, int amount);
            public void SerializeForNetwork(List<ProtoBuf.Item> saveList);
            public Item Create(int amount);
        }

        [JsonProperty("Name")]
        public string Name;
        [JsonProperty("All deployables are free")]
        public bool AllDeployablesFree;
        [JsonProperty("Free deployables")]
        public string[] FreeDeployables;
        [JsonProperty("Items")]
        public Dictionary<string, int> ItemAmounts;
        [JsonIgnore]
        private HashSet<int> _freeDeployableIds;
        [JsonIgnore]
        private Dictionary<int, ItemInfo> _itemCacheById;
        [JsonIgnore]
        private List<ItemInfo> _itemCacheList;
        [JsonIgnore]
        private readonly Dictionary<int, ItemPool> _itemPoolByItemId;
        [JsonIgnore]
        public string Permission { get; set; }
        [JsonIgnore]
        public bool HasAnyFreeDeployables { get; set; }
        public void Init(VirtualItems plugin);
        public bool HasFreeDeployable(Item item);
        public int SumItems(ItemQuery itemQuery);
        public int TakeItems(ItemQuery itemQuery, int amount, List<Item> collect);
        public void FindItems(ItemQuery itemQuery, List<Item> collect);
        public void SerializeForNetwork(List<ProtoBuf.Item> saveList);
        public void Unload();
        private bool VerifyValidItem(string itemShortName, ItemDefinition itemDefinition);
        private ItemInfo GetItemInfo(ItemQuery itemQuery);
        private ItemPool GetItemPool(int itemId);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : BaseConfiguration
    {
        [JsonProperty("Rulesets")]
        private Ruleset[] Rulesets;
        [JsonIgnore]
        public bool AnyRulesetHasFreeDeployables { get; set; }
        public void Init(VirtualItems plugin);
        public Ruleset DetermineBestRuleset(Permission permission, BasePlayer player);
    }

    private Configuration GetDefaultConfig();
    [JsonObject(MemberSerialization.OptIn)]
    private class BaseConfiguration
    {
        private string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

private class ItemPool
{
    private readonly int _itemId;
    private readonly List<Item> _availableItems;
    private readonly List<Item> _takenItems;
    public ItemPool(int itemId);
    public Item Take();
    public void ReturnUnusedItems();
    public void Unload();
    private bool IsUnused(Item item);
}

private class RulesetManager
{
    private readonly VirtualItems _plugin;
    private readonly Dictionary<ulong, Ruleset> _rulesetByPlayer;
    public RulesetManager(VirtualItems plugin);
    public Ruleset Get(BasePlayer player);
    public void Remove(BasePlayer player);
    public void Clear();
    public void Unload();
}

[JsonObject(MemberSerialization.OptIn)]
private class Ruleset
{
    private class ItemInfo
    {
        public int Amount { get; set; }
        private ItemDefinition _itemDefinition;
        private ProtoBuf.Item _itemData;
        public ItemInfo(ItemDefinition itemDefinition, int amount);
        public void SerializeForNetwork(List<ProtoBuf.Item> saveList);
        public Item Create(int amount);
    }

    [JsonProperty("Name")]
    public string Name;
    [JsonProperty("All deployables are free")]
    public bool AllDeployablesFree;
    [JsonProperty("Free deployables")]
    public string[] FreeDeployables;
    [JsonProperty("Items")]
    public Dictionary<string, int> ItemAmounts;
    [JsonIgnore]
    private HashSet<int> _freeDeployableIds;
    [JsonIgnore]
    private Dictionary<int, ItemInfo> _itemCacheById;
    [JsonIgnore]
    private List<ItemInfo> _itemCacheList;
    [JsonIgnore]
    private readonly Dictionary<int, ItemPool> _itemPoolByItemId;
    [JsonIgnore]
    public string Permission { get; set; }
    [JsonIgnore]
    public bool HasAnyFreeDeployables { get; set; }
    public void Init(VirtualItems plugin);
    public bool HasFreeDeployable(Item item);
    public int SumItems(ItemQuery itemQuery);
    public int TakeItems(ItemQuery itemQuery, int amount, List<Item> collect);
    public void FindItems(ItemQuery itemQuery, List<Item> collect);
    public void SerializeForNetwork(List<ProtoBuf.Item> saveList);
    public void Unload();
    private bool VerifyValidItem(string itemShortName, ItemDefinition itemDefinition);
    private ItemInfo GetItemInfo(ItemQuery itemQuery);
    private ItemPool GetItemPool(int itemId);
}

private class ItemInfo
{
    public int Amount { get; set; }
    private ItemDefinition _itemDefinition;
    private ProtoBuf.Item _itemData;
    public ItemInfo(ItemDefinition itemDefinition, int amount);
    public void SerializeForNetwork(List<ProtoBuf.Item> saveList);
    public Item Create(int amount);
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : BaseConfiguration
{
    [JsonProperty("Rulesets")]
    private Ruleset[] Rulesets;
    [JsonIgnore]
    public bool AnyRulesetHasFreeDeployables { get; set; }
    public void Init(VirtualItems plugin);
    public Ruleset DetermineBestRuleset(Permission permission, BasePlayer player);
}

[JsonObject(MemberSerialization.OptIn)]
private class BaseConfiguration
{
    private string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## VisualCupboard by ColonBlow - Allows Authorized Players to Visually See Building Privildge Radius of Owned Tool Cupboards

```csharp
using System;
using Oxide.Core;
using UnityEngine;
using System.Collections.Generic;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("VisualCupboard", "Colon Blow", "1.0.12")]
 class VisualCupboard : RustPlugin
{
    private void OnServerInitialized();
    private void Loaded();
    private void LoadDefaultConfig();
    private Dictionary<string, string> messages;
    private bool Changed;
    private static float UseCupboardRadius;
    private float DurationToShowRadius;
    private float ShowCupboardsWithinRangeOf;
    private int VisualDarkness;
    private static bool serverInitialized;
    private void LoadConfigVariables();
    private void LoadVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private class ToolCupboardSphere : MonoBehaviour
    {
        private BaseEntity sphere;
        private BaseEntity entity;
        public bool showall;
        private Vector3 pos;
        private Quaternion rot;
        private string strPrefab;
        private void Awake();
        private void SpawnSphere();
        private void OnDestroy();
    }

    private object CanNetworkTo(SphereEntity sphereEntity, BasePlayer target);
    [ChatCommand("showsphere")]
    private void cmdChatShowSphere(BasePlayer player, string command);
    [ChatCommand("showsphereall")]
    private void cmdChatShowSphereAll(BasePlayer player, string command);
    [ChatCommand("showsphereadmin")]
    private void cmdChatShowSphereAdmin(BasePlayer player, string command);
    [ChatCommand("killsphere")]
    private void cmdChatDestroySphere(BasePlayer player, string command);
    private void AddSphere(BasePlayer player, bool showall, bool adminshow);
    private string FindPlayerName(ulong userId);
    private void Unload();
    static void DestroyAll();
    private bool isAllowed(BasePlayer player, string perm);
}

private class ToolCupboardSphere : MonoBehaviour
{
    private BaseEntity sphere;
    private BaseEntity entity;
    public bool showall;
    private Vector3 pos;
    private Quaternion rot;
    private string strPrefab;
    private void Awake();
    private void SpawnSphere();
    private void OnDestroy();
}


```

---

## VisualDebug by  - Allows you to view all variables, and call functions inside any running plugin

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Reflection;
using System;
using System.Collections;
using Oxide.Core;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("VisualDebug", "Jake_Rich", "1.0.2")]
[Description("A visual object explorer, to browse rust plugins")]
public class VisualDebug : RustPlugin
{
    public MemoryTableUIManager UI { get; set; }
    public static VisualDebug _plugin { get; set; }
     void Init();
     void Unload();
     void OnPlayerDisconnected(BasePlayer player);
    public Dictionary<string, string> LangAPI;
     void LoadDefaultMessages();
    [ChatCommand("visualdbg")]
     void VisualDebugging(BasePlayer player);
    public static bool IsValueType(object obj);
    public class ObjectMemoryInfo
    {
        public string name { get; set; }
        public int memoryUsed { get; set; }
        public int elements { get; set; }
        public object _target { get; set; }
        private int currentLayer { get; set; }
        public ObjectMemoryInfo _parent { get; set; }
        private bool _autoExpand { get; set; }
        public List<ObjectMemoryInfo> children { get; set; }
        public List<MethodInfo> methods { get; set; }
        public ObjectMemoryInfo(object targetObject, int layers, string variableName, ObjectMemoryInfo parent, bool autoExpand);
        public void Expand();
        public void SetupObject();
        private int GetCount();
        public string GetInfo();
        public string GetVisualText();
        public static string GetMethodText(MethodInfo info);
        private static string GetTypeName(Type type);
        private string GetMemoryUsage();
        public void CalculateSubObjects();
        public bool CheckParents();
        public List<string> GetOutput(int layer, bool justLists);
        public string PrintOutput(bool justLists);
    }

    private Dictionary<string, UIButton> UIButtonCallBacks { get; set; }
     void OnButtonClick(ConsoleSystem.Arg arg);
    public class UIElement
    {
        public CuiElement Element { get; set; }
        public CuiRectTransformComponent transform { get; set; }
        public HashSet<BasePlayer> players { get; set; }
        public Vector2 position { get; set; }
        public Vector2 size { get; set; }
        private VisualDebug _plugin;
        protected UIElement(UIContainer container);
        public void SetParent(UIElement element);
        public void Refresh(BasePlayer player);
        private bool AddPlayer(BasePlayer player);
        private bool RemovePlayer(BasePlayer player);
        public virtual void Show(BasePlayer player);
        public void Show(List<BasePlayer> players);
        public void Show(HashSet<BasePlayer> players);
        public virtual void Hide(BasePlayer player);
        public void HideAll();
        public void RefreshAll();
        private void SafeAddUi(BasePlayer player, CuiElement element);
        private void SafeDestroyUi(BasePlayer player, CuiElement element);
        public void SetSize(float x, float y);
        public void SetPosition(float x, float y);
        public void UpdatePlacement();
        public void SetPositionAndSize(CuiRectTransformComponent trans);
    }

    public class UIButton : UIElement
    {
        public CuiButtonComponent buttonComponent { get; set; }
        public CuiTextComponent textComponent { get; set; }
        private UILabel label { get; set; }
        private int _fontSize;
        public Action<ConsoleSystem.Arg> onClicked;
        public UIButton(UIContainer container, string buttonText, string buttonColor, string textColor, int fontSize);
        public virtual void OnClicked(ConsoleSystem.Arg args);
        public void AddChatCommand(string fullCommand);
        public void AddCallback(Action<BasePlayer> callback);
        public override void Hide(BasePlayer player);
    }

    public class UILabel : UIElement
    {
        public CuiTextComponent text { get; set; }
        public UILabel(UIContainer container, string labelText, int fontSize, string fontColor, TextAnchor alignment, string parent);
    }

    public class UIPanel : UIElement
    {
        private CuiImageComponent panel;
        private CuiNeedsCursorComponent needsCursor { get; set; }
        private bool requiresFocus { get; set; }
        public bool CursorEnabled { get; set; }
        public UIPanel(UIContainer container, Vector2 position, float width, float height, string color, string pngImage);
    }

    public class UIButtonContainer : UIContainer
    {
        private IEnumerable<UIButtonConfiguration> _buttonConfiguration;
        private Vector2 _position;
        private float _width;
        private float _height;
        private string _title;
        private string _panelColor;
        private bool _stackedButtons;
        private float _paddingPercentage;
        private int _titleSize;
        private int _buttonFontSize;
        const float TITLE_PERCENTAGE;
        private float _paddingAmount;
        private bool _hasTitle;
        public UIButtonContainer(IEnumerable<UIButtonConfiguration> buttonConfiguration, string panelBgColor, Vector2 position, float width, float height, float paddingPercentage, string title, int titleSize, int buttonFontSize, bool stackedButtons);
        private void Init();
    }

    public class UIButtonConfiguration
    {
        public string ButtonName { get; set; }
        public string ButtonCommand { get; set; }
        public string ButtonColor { get; set; }
        public Action<BasePlayer> callback { get; set; }
    }

    public class UIImage : UIPanel
    {
        public CuiImageComponent Image { get; set; }
        public UIImage(UIContainer container, Vector2 position, float width, float height);
    }

    public class UIRawImage : UIElement
    {
        public CuiRawImageComponent Image { get; set; }
        public UIRawImage(UIContainer container, Vector2 position, float width, float height, string png);
    }

    public class UIContainer
    {
        public List<UIContainer> ChildContainers { get; set; }
        public List<UIElement> Elements { get; set; }
        private HashSet<BasePlayer> _players { get; set; }
        public UIContainer();
        private void AddPlayer(BasePlayer player);
        public void Show(BasePlayer player);
        public void RemoveElements(IEnumerable<T> elementsToRemove);
        public void Hide(BasePlayer player);
        public void HideAll();
        public void AddElement(UIElement element);
        public void AddChildContainer(UIContainer container);
    }

    public const int objectsPerScreen;
    public class MemoryObjectInfoUI : UIContainer
    {
        public UIButton expand { get; set; }
        private UIPanel background { get; set; }
        private UILabel label { get; set; }
        public ObjectMemoryInfo memoryObject { get; set; }
        public MemoryObjectInfoUI(ObjectMemoryInfo obj, Vector2 pos, MemoryTableUIManager manager, bool parent);
        public MemoryObjectInfoUI(MethodInfo method, Vector2 pos, MemoryTableUIManager manager, ObjectMemoryInfo obj);
    }

    public class MemoryTableUIManager : UIContainer
    {
        public ObjectMemoryInfo rootObject { get; set; }
        public MemoryObjectInfoUI currentObject { get; set; }
        public List<MemoryObjectInfoUI> shownObjects { get; set; }
        private UIButton nextPage { get; set; }
        private UIButton prevPage { get; set; }
        public BasePlayer _player { get; set; }
        private int currentIndex { get; set; }
        public MemoryTableUIManager();
        public void Destroy();
        public void ShowPlayer(BasePlayer player);
        public void HidePlayer(BasePlayer player);
        public void LinqQuery(BasePlayer player, string cmd);
        public void Expand(MemoryObjectInfoUI obj);
        public void Shrink(MemoryObjectInfoUI obj);
        public void NextPage();
        public void PrevPage();
        private void HideCurrent();
        public void ShowObject(ObjectMemoryInfo obj, bool changePage);
    }

}

public class ObjectMemoryInfo
{
    public string name { get; set; }
    public int memoryUsed { get; set; }
    public int elements { get; set; }
    public object _target { get; set; }
    private int currentLayer { get; set; }
    public ObjectMemoryInfo _parent { get; set; }
    private bool _autoExpand { get; set; }
    public List<ObjectMemoryInfo> children { get; set; }
    public List<MethodInfo> methods { get; set; }
    public ObjectMemoryInfo(object targetObject, int layers, string variableName, ObjectMemoryInfo parent, bool autoExpand);
    public void Expand();
    public void SetupObject();
    private int GetCount();
    public string GetInfo();
    public string GetVisualText();
    public static string GetMethodText(MethodInfo info);
    private static string GetTypeName(Type type);
    private string GetMemoryUsage();
    public void CalculateSubObjects();
    public bool CheckParents();
    public List<string> GetOutput(int layer, bool justLists);
    public string PrintOutput(bool justLists);
}

public class UIElement
{
    public CuiElement Element { get; set; }
    public CuiRectTransformComponent transform { get; set; }
    public HashSet<BasePlayer> players { get; set; }
    public Vector2 position { get; set; }
    public Vector2 size { get; set; }
    private VisualDebug _plugin;
    protected UIElement(UIContainer container);
    public void SetParent(UIElement element);
    public void Refresh(BasePlayer player);
    private bool AddPlayer(BasePlayer player);
    private bool RemovePlayer(BasePlayer player);
    public virtual void Show(BasePlayer player);
    public void Show(List<BasePlayer> players);
    public void Show(HashSet<BasePlayer> players);
    public virtual void Hide(BasePlayer player);
    public void HideAll();
    public void RefreshAll();
    private void SafeAddUi(BasePlayer player, CuiElement element);
    private void SafeDestroyUi(BasePlayer player, CuiElement element);
    public void SetSize(float x, float y);
    public void SetPosition(float x, float y);
    public void UpdatePlacement();
    public void SetPositionAndSize(CuiRectTransformComponent trans);
}

public class UIButton : UIElement
{
    public CuiButtonComponent buttonComponent { get; set; }
    public CuiTextComponent textComponent { get; set; }
    private UILabel label { get; set; }
    private int _fontSize;
    public Action<ConsoleSystem.Arg> onClicked;
    public UIButton(UIContainer container, string buttonText, string buttonColor, string textColor, int fontSize);
    public virtual void OnClicked(ConsoleSystem.Arg args);
    public void AddChatCommand(string fullCommand);
    public void AddCallback(Action<BasePlayer> callback);
    public override void Hide(BasePlayer player);
}

public class UILabel : UIElement
{
    public CuiTextComponent text { get; set; }
    public UILabel(UIContainer container, string labelText, int fontSize, string fontColor, TextAnchor alignment, string parent);
}

public class UIPanel : UIElement
{
    private CuiImageComponent panel;
    private CuiNeedsCursorComponent needsCursor { get; set; }
    private bool requiresFocus { get; set; }
    public bool CursorEnabled { get; set; }
    public UIPanel(UIContainer container, Vector2 position, float width, float height, string color, string pngImage);
}

public class UIButtonContainer : UIContainer
{
    private IEnumerable<UIButtonConfiguration> _buttonConfiguration;
    private Vector2 _position;
    private float _width;
    private float _height;
    private string _title;
    private string _panelColor;
    private bool _stackedButtons;
    private float _paddingPercentage;
    private int _titleSize;
    private int _buttonFontSize;
    const float TITLE_PERCENTAGE;
    private float _paddingAmount;
    private bool _hasTitle;
    public UIButtonContainer(IEnumerable<UIButtonConfiguration> buttonConfiguration, string panelBgColor, Vector2 position, float width, float height, float paddingPercentage, string title, int titleSize, int buttonFontSize, bool stackedButtons);
    private void Init();
}

public class UIButtonConfiguration
{
    public string ButtonName { get; set; }
    public string ButtonCommand { get; set; }
    public string ButtonColor { get; set; }
    public Action<BasePlayer> callback { get; set; }
}

public class UIImage : UIPanel
{
    public CuiImageComponent Image { get; set; }
    public UIImage(UIContainer container, Vector2 position, float width, float height);
}

public class UIRawImage : UIElement
{
    public CuiRawImageComponent Image { get; set; }
    public UIRawImage(UIContainer container, Vector2 position, float width, float height, string png);
}

public class UIContainer
{
    public List<UIContainer> ChildContainers { get; set; }
    public List<UIElement> Elements { get; set; }
    private HashSet<BasePlayer> _players { get; set; }
    public UIContainer();
    private void AddPlayer(BasePlayer player);
    public void Show(BasePlayer player);
    public void RemoveElements(IEnumerable<T> elementsToRemove);
    public void Hide(BasePlayer player);
    public void HideAll();
    public void AddElement(UIElement element);
    public void AddChildContainer(UIContainer container);
}

public class MemoryObjectInfoUI : UIContainer
{
    public UIButton expand { get; set; }
    private UIPanel background { get; set; }
    private UILabel label { get; set; }
    public ObjectMemoryInfo memoryObject { get; set; }
    public MemoryObjectInfoUI(ObjectMemoryInfo obj, Vector2 pos, MemoryTableUIManager manager, bool parent);
    public MemoryObjectInfoUI(MethodInfo method, Vector2 pos, MemoryTableUIManager manager, ObjectMemoryInfo obj);
}

public class MemoryTableUIManager : UIContainer
{
    public ObjectMemoryInfo rootObject { get; set; }
    public MemoryObjectInfoUI currentObject { get; set; }
    public List<MemoryObjectInfoUI> shownObjects { get; set; }
    private UIButton nextPage { get; set; }
    private UIButton prevPage { get; set; }
    public BasePlayer _player { get; set; }
    private int currentIndex { get; set; }
    public MemoryTableUIManager();
    public void Destroy();
    public void ShowPlayer(BasePlayer player);
    public void HidePlayer(BasePlayer player);
    public void LinqQuery(BasePlayer player, string cmd);
    public void Expand(MemoryObjectInfoUI obj);
    public void Shrink(MemoryObjectInfoUI obj);
    public void NextPage();
    public void PrevPage();
    private void HideCurrent();
    public void ShowObject(ObjectMemoryInfo obj, bool changePage);
}


```

---

## VoiceMute by Tori1157 - Voice mute via commands with time and optional reason

```csharp
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Voice Mute", "Tori1157", "1.0.3")]
[Description("Voice mute via commands with time and reason")]
 class VoiceMute : CovalencePlugin
{
    private const string permMute;
    private const string permList;
    private const string permInfo;
    private const string permUnmute;
    private const string permCheckInfo;
    private const string mData;
    private bool Changed;
    private bool addReason;
    private bool broadcastMessage;
    private bool hasExpired;
    private DataFileSystem MuteData;
    private void LoadVariables();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void Init();
    private void OnServerInitialized();
    [Command("voice")]
    private void VoiceCommand(IPlayer player, string command, string[] args);
    private bool CanMute(IPlayer player);
    private bool CanList(IPlayer player);
    private bool CanInfo(IPlayer player);
    private bool CanUnmute(IPlayer player);
    private bool CanCheckInfo(IPlayer player);
    private void OnUserConnected(IPlayer player);
    private void OnPlayerVoice(BasePlayer player, Byte[] data);
    private void MutePlayer(IPlayer player, string command, string[] args);
    private void UnmutePlayer(IPlayer player, string command, string[] args);
    private void ListMutes(IPlayer player, string command, string[] args);
    private void InfoMute(IPlayer player, string command, string[] args);
     string FormatTime(TimeSpan time);
    private bool TryParseTimeSpan(string source, TimeSpan timeSpan);
    private void CheckMutes();
     MuteManager Mute;
    private static Dictionary<string, MuteInfo> Mutes;
    public class MuteInfo
    {
        public string PlayerName { get; set; }
        public string PlayerId { get; set; }
        public string Reason { get; set; }
        public string Admin { get; set; }
        public bool Sent { get; set; }
        public DateTime ExpireDate { get; set; }
        public bool Expired { get; set; }
        public MuteInfo();
        public MuteInfo(IPlayer target, string adminName, DateTime expireDate, string reason);
    }

    public class MuteManager
    {
        public MuteInfo AddMute(IPlayer target, string adminName, DateTime expireDate, string reason, bool addReason);
        public void RemoveMute(string steamid);
        public void RemoveMute(IPlayer player);
        private void RemoveMute(MuteInfo info);
         MuteInfo GetMute(IPlayer player);
         MuteInfo GetMute(string steamid);
        public bool MuteExists(string steamid);
        public bool MuteExists(IPlayer player);
        private bool MuteExists(MuteInfo info);
        public bool IsExpired(string steamid);
        public bool IsExpired(IPlayer player);
        private bool IsExpired(MuteInfo info);
        public bool MessageSent(string steamid);
        public bool MessageSent(IPlayer player);
        private bool MessageSent(MuteInfo info);
        public string GetPlayerName(IPlayer player);
        private string GetPlayerName(MuteInfo info);
        public string GetPlayerId(IPlayer player);
        private string GetPlayerId(MuteInfo info);
        public string GetReason(IPlayer player);
        private string GetReason(MuteInfo info);
        public string GetAdmin(IPlayer player);
        private string GetAdmin(MuteInfo info);
        public DateTime? GetExpireDate(IPlayer player);
        private DateTime? GetExpireDate(MuteInfo info);
        public void SetReason(IPlayer player, string reason, bool addReason);
        private void SetReason(MuteInfo info, string reason, bool addReason);
        public void SetAdmin(IPlayer player, IPlayer admin);
        private void SetAdmin(MuteInfo info, IPlayer admin);
        public void SetExpireDate(IPlayer player, DateTime expireDate);
        private void SetExpireDate(MuteInfo info, DateTime expireDate);
        public void SetMessageSent(string steamid, bool sent);
        public void SetMessageSent(IPlayer player, bool sent);
        private void SetMessageSent(MuteInfo info, bool sent);
    }

    private void LoadStoredData();
    private void SaveMutes();
    private void SaveData(T data, string filename);
    private void LoadData(T data, string filename);
    private IPlayer GetPlayer(string nameOrID, IPlayer player);
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private bool BoolConfig(string menu, string dataValue, bool defaultValue);
    private string Lang(string key, string id, object[] args);
    private void SendChatMessage(IPlayer player, string message);
    private void SendBroadcastMessage(string message);
    private void SendInfoMessage(IPlayer player, string prefix, string message);
}

public class MuteInfo
{
    public string PlayerName { get; set; }
    public string PlayerId { get; set; }
    public string Reason { get; set; }
    public string Admin { get; set; }
    public bool Sent { get; set; }
    public DateTime ExpireDate { get; set; }
    public bool Expired { get; set; }
    public MuteInfo();
    public MuteInfo(IPlayer target, string adminName, DateTime expireDate, string reason);
}

public class MuteManager
{
    public MuteInfo AddMute(IPlayer target, string adminName, DateTime expireDate, string reason, bool addReason);
    public void RemoveMute(string steamid);
    public void RemoveMute(IPlayer player);
    private void RemoveMute(MuteInfo info);
     MuteInfo GetMute(IPlayer player);
     MuteInfo GetMute(string steamid);
    public bool MuteExists(string steamid);
    public bool MuteExists(IPlayer player);
    private bool MuteExists(MuteInfo info);
    public bool IsExpired(string steamid);
    public bool IsExpired(IPlayer player);
    private bool IsExpired(MuteInfo info);
    public bool MessageSent(string steamid);
    public bool MessageSent(IPlayer player);
    private bool MessageSent(MuteInfo info);
    public string GetPlayerName(IPlayer player);
    private string GetPlayerName(MuteInfo info);
    public string GetPlayerId(IPlayer player);
    private string GetPlayerId(MuteInfo info);
    public string GetReason(IPlayer player);
    private string GetReason(MuteInfo info);
    public string GetAdmin(IPlayer player);
    private string GetAdmin(MuteInfo info);
    public DateTime? GetExpireDate(IPlayer player);
    private DateTime? GetExpireDate(MuteInfo info);
    public void SetReason(IPlayer player, string reason, bool addReason);
    private void SetReason(MuteInfo info, string reason, bool addReason);
    public void SetAdmin(IPlayer player, IPlayer admin);
    private void SetAdmin(MuteInfo info, IPlayer admin);
    public void SetExpireDate(IPlayer player, DateTime expireDate);
    private void SetExpireDate(MuteInfo info, DateTime expireDate);
    public void SetMessageSent(string steamid, bool sent);
    public void SetMessageSent(IPlayer player, bool sent);
    private void SetMessageSent(MuteInfo info, bool sent);
}


```

---

## VoiceUI by Pinkstink - Displays UI of players names who are actively transmitting voice

```csharp
using Network;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using UnityEngine;

Oxide.Plugins
[Info("Voice UI", "Pinkstink", "1.0.4")]
[Description("Displays UI of players names who are actively transmitting voice")]
public class VoiceUI : RustPlugin
{
    private const string USE_PERMISSION;
    private const string ADMIN_PERMISSION;
    private const string ROOT_UI_NAME;
    private VoiceUIConfiguration config;
    private Dictionary<BasePlayer, List<VoiceRecord>> voiceRecords;
    private float timeSinceLastUpdate;
     void Init();
     void Unload();
     void OnFrame();
     void ProcessVoice();
     void OnPlayerVoice(BasePlayer voiceSender);
    [ChatCommand("showvoice")]
     void ChatCMD_ShowVoice(BasePlayer player, string command, string[] args);
    [ChatCommand("hidevoice")]
     void ChatCMD_HideVoice(BasePlayer player, string command, string[] args);
    [ChatCommand("voice")]
     void ChatCMD_Voice(BasePlayer player, string command, string[] args);
     List<string> GenerateVoiceRecordGrid(IEnumerable<VoiceRecord> records, string identifier, string parentName);
     void SendFormattedMessage(BasePlayer player, string from, string message, string color);
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
     void SaveConfig();
     class VoiceUIConfiguration
    {
        private float updateInterval;
        public float UpdateInterval { get; set; }
        private float uiColorSensitivity;
        public float UIColorSensitivity { get; set; }
        private HashSet<ulong> toggledPlayers;
        public HashSet<ulong> ToggledPlayers { get; set; }
        private bool toggledByDefault;
        public bool ToggledByDefault { get; set; }
    }

     void OnUserPermissionRevoked(string id, string permName);
     void OnRconCommand(IPEndPoint ip, string command, string[] args);
     void OnPlayerConnected(Network.Message packet);
}

 class VoiceUIConfiguration
{
    private float updateInterval;
    public float UpdateInterval { get; set; }
    private float uiColorSensitivity;
    public float UIColorSensitivity { get; set; }
    private HashSet<ulong> toggledPlayers;
    public HashSet<ulong> ToggledPlayers { get; set; }
    private bool toggledByDefault;
    public bool ToggledByDefault { get; set; }
}


```

---

## VoteBan by 2CHEVSKII - Allows players to vote for banning others

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("Vote Ban", "2CHEVSKII", "1.0.1")]
[Description("Allows players to vote for banning others")]
 class VoteBan : CovalencePlugin
{
    const string M_PREFIX;
    const string M_VOTE_STARTED;
    const string M_VOTE_PROGRESS;
    const string M_VOTED;
    const string M_ALREADY_VOTED;
    const string M_NO_PERMISSION;
    const string M_NO_VOTE;
    const string M_VOTE_TIMED_OUT;
    const string M_VOTE_SUCCESS;
    const string M_VOTE_CANCELLED;
    const string M_VOTE_CANCELLED_PLAYERS;
    const string M_BAN_REASON;
    const string M_CANNOT_START_ADMIN;
    const string M_CANNOT_START_PLAYERS;
    const string M_PLAYER_NOT_FOUND;
    const string M_CANNOT_VOTE_SELF;
    const string PERMISSION_MANAGE;
    const string PERMISSION_VOTE;
     PluginSettings settings;
     VoteData voteData;
     void Init();
     void OnVoteStarted(IPlayer initiator, IPlayer target);
     void OnPlayerVoted(IPlayer player);
     void OnVoteTick();
     void OnVoteCancelled(IPlayer canceller);
     void OnVoteTimedOut();
     void OnVoteSuccess();
     bool IsVotebanInProgress();
     bool GetCurrentVotebanData(Dictionary<string, object> record);
     void CommandHandler(IPlayer player, string _, string[] args);
     void HandleVoteCommand(IPlayer player);
     void HandleManageCommand(IPlayer player, string arg);
     int GetPlayerCountWithoutTarget(IPlayer target);
     int GetPlayersRequiredToVoteSuccess(int playerCount);
     bool CheckPermission(IPlayer player, string perm);
     string GetMessage(IPlayer player, string langKey);
     void Message(IPlayer player, string langKey, object[] args);
     void Announce(string langKey, object[] args);
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     class PluginSettings
    {
        public static PluginSettings Default { get; set; }
        [JsonProperty("Vote time")]
        public int VoteTime { get; set; }
        [JsonProperty("Notification frequency")]
        public int NotificationFrequency { get; set; }
        [JsonProperty("Min player count to start vote")]
        public int MinPlayers { get; set; }
        [JsonProperty("Vote success percentage")]
        public int PercentageRequired { get; set; }
        [JsonProperty("Allow banning admins")]
        public bool AllowBanningAdmins { get; set; }
    }

     class VoteData
    {
        public readonly IPlayer voteTarget;
        public readonly IPlayer voteInitiator;
        public List<IPlayer> votedPlayers;
        public float startTime;
        public float endTime;
        readonly VoteBan plugin;
         Timer voteTimer;
        public int VotedPlayerCount { get; set; }
        public float VoteFraction { get; set; }
        public float TimeLeft { get; set; }
        public VoteData(IPlayer initiator, IPlayer target, VoteBan plugin);
        public void OnPlayerVoted(IPlayer player);
        public bool CanPlayerVote(IPlayer player);
        public void CancelVote(IPlayer canceller);
         void StartVote();
         void VoteTick();
         void EndVote();
    }

}

 class PluginSettings
{
    public static PluginSettings Default { get; set; }
    [JsonProperty("Vote time")]
    public int VoteTime { get; set; }
    [JsonProperty("Notification frequency")]
    public int NotificationFrequency { get; set; }
    [JsonProperty("Min player count to start vote")]
    public int MinPlayers { get; set; }
    [JsonProperty("Vote success percentage")]
    public int PercentageRequired { get; set; }
    [JsonProperty("Allow banning admins")]
    public bool AllowBanningAdmins { get; set; }
}

 class VoteData
{
    public readonly IPlayer voteTarget;
    public readonly IPlayer voteInitiator;
    public List<IPlayer> votedPlayers;
    public float startTime;
    public float endTime;
    readonly VoteBan plugin;
     Timer voteTimer;
    public int VotedPlayerCount { get; set; }
    public float VoteFraction { get; set; }
    public float TimeLeft { get; set; }
    public VoteData(IPlayer initiator, IPlayer target, VoteBan plugin);
    public void OnPlayerVoted(IPlayer player);
    public bool CanPlayerVote(IPlayer player);
    public void CancelVote(IPlayer canceller);
     void StartVote();
     void VoteTick();
     void EndVote();
}


```

---

## VoteForMoney by markmozza - Players who vote are rewarded with Economics, Server Rewards, Kits

```csharp
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("VoteForMoney", "Frenk92", "1.0.7")]
 class VoteForMoney : RustPlugin
{
    [PluginReference]
     Plugin Economics;
     Plugin ServerRewards;
     Plugin Kits;
     DateTime wipeTime;
    const string permAdmin;
     class SiteLinks
    {
        public string _vote { get; set; }
        public string _get { get; set; }
        public string _put { get; set; }
    }

     Dictionary<string, SiteLinks> Site;
     ConfigData _config;
     class ConfigData
    {
        public bool InitCheck { get; set; }
        public bool AllGroupsGetDefault { get; set; }
        public string Prefix { get; set; }
        public string BlockVote { get; set; }
        public static ConfigData DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
     Dictionary<ulong, PlayerVote> Users;
     class PlayerVote
    {
        public string Name { get; set; }
        public Dictionary<string, SitesVote> Sites { get; set; }
        public PlayerVote(string Name);
    }

     class SitesVote
    {
        public int Votes { get; set; }
        public string ExpDate { get; set; }
        public List<string> KitsNotClaimed { get; set; }
        public SitesVote();
    }

     RewardsData Rewards;
     class RewardsData
    {
        public Dictionary<string, Dictionary<string, string>> Groups { get; set; }
        public Dictionary<int, Dictionary<string, string>> TopVoters { get; set; }
        public static RewardsData DefaultRewards();
    }

     Dictionary<string, SiteSettings> Settings;
     class SiteSettings
    {
        public string ID { get; set; }
        public string Key { get; set; }
        public string Interval { get; set; }
        public SiteSettings();
    }

     string FileDestination(string name);
    private void LoadData(T data, string filename);
    private void SaveData(T data, string filename);
     void Loaded();
     void OnNewSave(string name);
    private void OnServerInitialized();
     List<ulong> Join;
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
     void OnPlayerSleepEnded(BasePlayer player);
    [ChatCommand("vote")]
     void cmdVote(BasePlayer player, string command, string[] args);
    [ChatCommand("claimkit")]
     void cmdClaimKit(BasePlayer player, string command, string[] args);
     void cmdEditVote(IPlayer player, string command, string[] args);
     string _group;
     void cmdVoteRewards(IPlayer player, string command, string[] args);
     void CheckVote(BasePlayer player);
     void GetCallback(int code, string response, BasePlayer player, KeyValuePair<string, SiteLinks> s);
     void PutCallback(int code, string response, BasePlayer player, KeyValuePair<string, SiteLinks> s);
     void GetReward(BasePlayer player, string s);
     void GetWebRequest(string userID, string reqlink, string key, Action<int, string> callback);
     PlayerVote GetPlayerData(ulong userID, string name);
     bool WipeBlocked(BasePlayer player);
     void WipeCooldown();
     void DataCheck();
     string SteamName(BasePlayer player);
    private new void LoadDefaultMessages();
     string Lang(string key, string id, object[] args);
     void MessageChat(BasePlayer player, string key, object[] args);
}

 class SiteLinks
{
    public string _vote { get; set; }
    public string _get { get; set; }
    public string _put { get; set; }
}

 class ConfigData
{
    public bool InitCheck { get; set; }
    public bool AllGroupsGetDefault { get; set; }
    public string Prefix { get; set; }
    public string BlockVote { get; set; }
    public static ConfigData DefaultConfig();
}

 class PlayerVote
{
    public string Name { get; set; }
    public Dictionary<string, SitesVote> Sites { get; set; }
    public PlayerVote(string Name);
}

 class SitesVote
{
    public int Votes { get; set; }
    public string ExpDate { get; set; }
    public List<string> KitsNotClaimed { get; set; }
    public SitesVote();
}

 class RewardsData
{
    public Dictionary<string, Dictionary<string, string>> Groups { get; set; }
    public Dictionary<int, Dictionary<string, string>> TopVoters { get; set; }
    public static RewardsData DefaultRewards();
}

 class SiteSettings
{
    public string ID { get; set; }
    public string Key { get; set; }
    public string Interval { get; set; }
    public SiteSettings();
}


```

---

## VoteKick by MrBlue - Lets players with permission call votes to kick others

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("VoteKick", "Kappasaurus", "1.0.2")]
 class VoteKick : CovalencePlugin
{
    private List<string> voted;
    private bool activeVote;
    private int votes;
    private IPlayer target;
    private Timer voteTimer;
    private float percentageRequired;
    private int playersRequired;
     void Init();
     void OnUserDisconnected(IPlayer player);
    [Command("votekick")]
     void VoteKickCmd(IPlayer player, string command, string[] args);
    [Command("vote")]
     void VoteCmd(IPlayer player, string command, string[] args);
    private new void LoadConfig();
    protected override void LoadDefaultConfig();
    private void GetConfig(T variable, string[] path);
    protected override void LoadDefaultMessages();
}


```

---

## Voter by k1lly0u - Rewards players who vote for your server on rust-servers.net

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System.Linq;
using System;

Oxide.Plugins
[Info("VoteRewards", "k1lly0u", "2.1.1", ResourceId = 752)]
 class Voter : RustPlugin
{
    [PluginReference]
     Plugin ServerRewards;
    [PluginReference]
     Plugin Economics;
     StoredData storedData;
    private DynamicConfigFile data;
    private Dictionary<string, ItemDefinition> itemDefs;
    private Timer broadcastTimer;
    private TrackerType trackerType;
    const string rsTracker;
    const string trsTracker;
    const string bcTracker;
     string trackerName;
    private string col1;
    private string col2;
     void Loaded();
     void OnServerInitialized();
     void Unload();
    private bool ParseTrackerType();
    private void BroadcastLoop();
    private void CheckForVotes(BasePlayer player);
    private void GetWebRequest(BasePlayer player);
    private bool GiveReward(BasePlayer player, Rewards reward);
    private void GiveRP(BasePlayer player, int amount);
    private void GiveCoins(BasePlayer player, int amount);
    private void cmdVote(BasePlayer player, string command, string[] args);
    private void cmdRewards(BasePlayer player, string command, string[] args);
    private void SendHelpText(BasePlayer player);
     class Tracker
    {
        [JsonProperty(PropertyName = "Tracker type (TopRustServers, RustServers, Beancan)")]
        public string TrackerType { get; set; }
        [JsonProperty(PropertyName = "API Key")]
        public string APIKey { get; set; }
        [JsonProperty(PropertyName = "Points received per vote")]
        public int PointsPerVote { get; set; }
    }

     class Commands
    {
        [JsonProperty(PropertyName = "Chat Command - Reward Menu")]
        public string RewardCommand { get; set; }
        [JsonProperty(PropertyName = "Chat Command - Vote Checking")]
        public string VoteCommand { get; set; }
    }

     class Rewards
    {
        [JsonProperty(PropertyName = "Reward Items")]
        public List<RewardItem> RewardItems { get; set; }
        [JsonProperty(PropertyName = "Reward RP (Server Rewards)")]
        public int RPAmount { get; set; }
        [JsonProperty(PropertyName = "Reward Money (Economics)")]
        public int EcoAmount { get; set; }
        [JsonProperty(PropertyName = "Reward Cost")]
        public int CostToBuy { get; set; }
        public class RewardItem
        {
            [JsonProperty(PropertyName = "Item Shortname")]
            public string Shortname { get; set; }
            [JsonProperty(PropertyName = "Item Skin ID")]
            public ulong SkinID { get; set; }
            [JsonProperty(PropertyName = "Item Amount")]
            public int Amount { get; set; }
        }

    }

     class Messaging
    {
        [JsonProperty(PropertyName = "Message color (Primary)")]
        public string MainColor { get; set; }
        [JsonProperty(PropertyName = "Message color (Secondary)")]
        public string MSGColor { get; set; }
        [JsonProperty(PropertyName = "Activate automated broadcasting")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Automated broadcast timer (minutes)")]
        public int Timer { get; set; }
    }

    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Chat Commands")]
        public Commands Commands { get; set; }
        [JsonProperty(PropertyName = "Messaging Options")]
        public Messaging Messaging { get; set; }
        [JsonProperty(PropertyName = "Reward List")]
        public Dictionary<int, Rewards> Rewards { get; set; }
        [JsonProperty(PropertyName = "Tracker Information")]
        public Tracker Tracker { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     void SaveData();
     void LoadData();
     class StoredData
    {
        public Dictionary<ulong, int> userData;
    }

     string msg(string key, string playerId);
     Dictionary<string, string> Messages;
}

 class Tracker
{
    [JsonProperty(PropertyName = "Tracker type (TopRustServers, RustServers, Beancan)")]
    public string TrackerType { get; set; }
    [JsonProperty(PropertyName = "API Key")]
    public string APIKey { get; set; }
    [JsonProperty(PropertyName = "Points received per vote")]
    public int PointsPerVote { get; set; }
}

 class Commands
{
    [JsonProperty(PropertyName = "Chat Command - Reward Menu")]
    public string RewardCommand { get; set; }
    [JsonProperty(PropertyName = "Chat Command - Vote Checking")]
    public string VoteCommand { get; set; }
}

 class Rewards
{
    [JsonProperty(PropertyName = "Reward Items")]
    public List<RewardItem> RewardItems { get; set; }
    [JsonProperty(PropertyName = "Reward RP (Server Rewards)")]
    public int RPAmount { get; set; }
    [JsonProperty(PropertyName = "Reward Money (Economics)")]
    public int EcoAmount { get; set; }
    [JsonProperty(PropertyName = "Reward Cost")]
    public int CostToBuy { get; set; }
    public class RewardItem
    {
        [JsonProperty(PropertyName = "Item Shortname")]
        public string Shortname { get; set; }
        [JsonProperty(PropertyName = "Item Skin ID")]
        public ulong SkinID { get; set; }
        [JsonProperty(PropertyName = "Item Amount")]
        public int Amount { get; set; }
    }

}

public class RewardItem
{
    [JsonProperty(PropertyName = "Item Shortname")]
    public string Shortname { get; set; }
    [JsonProperty(PropertyName = "Item Skin ID")]
    public ulong SkinID { get; set; }
    [JsonProperty(PropertyName = "Item Amount")]
    public int Amount { get; set; }
}

 class Messaging
{
    [JsonProperty(PropertyName = "Message color (Primary)")]
    public string MainColor { get; set; }
    [JsonProperty(PropertyName = "Message color (Secondary)")]
    public string MSGColor { get; set; }
    [JsonProperty(PropertyName = "Activate automated broadcasting")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Automated broadcast timer (minutes)")]
    public int Timer { get; set; }
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Chat Commands")]
    public Commands Commands { get; set; }
    [JsonProperty(PropertyName = "Messaging Options")]
    public Messaging Messaging { get; set; }
    [JsonProperty(PropertyName = "Reward List")]
    public Dictionary<int, Rewards> Rewards { get; set; }
    [JsonProperty(PropertyName = "Tracker Information")]
    public Tracker Tracker { get; set; }
}

 class StoredData
{
    public Dictionary<ulong, int> userData;
}


```

---

## VPNBlock by Calytic - Automatically kicks players using a VPN

```csharp
using System.Collections.Generic;
using System;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

Oxide.Plugins
[Info ("VPN Block", "Calytic", "1.0.0")]
 class VPNBlock : CovalencePlugin
{
     List<string> allowedISPs;
     string IPHUB_API_KEY;
     string IPSTACK_API_KEY;
     string AA_API_KEY;
     Dictionary<string, string> headers;
     string unauthorizedMessage;
     bool debug;
     void Loaded();
    protected override void LoadDefaultConfig();
     void LoadData();
     void SaveData();
    [Command ("wisp")]
     void WhiteListISP(IPlayer player, string command, string [] args);
     void LoadMessages();
     bool IsAllowed(IPlayer player);
     bool hasAccess(IPlayer player, string permissionname);
     void OnUserConnected(IPlayer player);
     void HandleIPHubResponse(IPlayer player, string url, string ip, int code, string response);
     void FailResponse(string service, int code, string response);
     void HandleIPStackResponse(IPlayer player, string url, string ip, int code, string response);
     void HandleAAResponse(IPlayer player, string url, string ip, int code, string response);
     bool IsWhitelisted(string playerIsp);
     T GetConfig(string name, string name2, T defaultValue);
     T GetConfig(string name, T defaultValue);
     string GetMsg(string key, object userID);
}


```

---

## WakeInfo by Mevent - Gives a note with information about the server after connecting

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Wake Info", "Mevent", "1.2.0")]
[Description("Gives a note with information about the server after connecting")]
public class WakeInfo : RustPlugin
{
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Notes", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<NoteConf> Notes;
        [JsonProperty(PropertyName = "Only Introduce?")]
        public bool Introduce;
        [JsonProperty(PropertyName = "Note Item")]
        public ItemConf Item;
    }

    private class NoteConf
    {
        [JsonProperty(PropertyName = "Title")]
        public string Title;
        [JsonProperty(PropertyName = "Enabled?")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Permission (ex: wakeinfo.vip)")]
        public string Permission;
        [JsonProperty(PropertyName = "Text", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Text;
        public void Get(BasePlayer player);
        private void GiveItem(BasePlayer player, Item item);
        private string ConvertText(BasePlayer player);
    }

    private class ItemConf
    {
        [JsonProperty(PropertyName = "Short Name")]
        public string ShortName;
        [JsonProperty(PropertyName = "Skin")]
        public ulong Skin;
        public Item ToItem(string title);
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private PluginData _data;
    private void SaveData();
    private void LoadData();
    private class PluginData
    {
        [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> Players;
    }

    private void Init();
    private void Unload();
    private void OnNewSave();
    private void OnPlayerConnected(BasePlayer player);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Notes", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<NoteConf> Notes;
    [JsonProperty(PropertyName = "Only Introduce?")]
    public bool Introduce;
    [JsonProperty(PropertyName = "Note Item")]
    public ItemConf Item;
}

private class NoteConf
{
    [JsonProperty(PropertyName = "Title")]
    public string Title;
    [JsonProperty(PropertyName = "Enabled?")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Permission (ex: wakeinfo.vip)")]
    public string Permission;
    [JsonProperty(PropertyName = "Text", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Text;
    public void Get(BasePlayer player);
    private void GiveItem(BasePlayer player, Item item);
    private string ConvertText(BasePlayer player);
}

private class ItemConf
{
    [JsonProperty(PropertyName = "Short Name")]
    public string ShortName;
    [JsonProperty(PropertyName = "Skin")]
    public ulong Skin;
    public Item ToItem(string title);
}

private class PluginData
{
    [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> Players;
}


```

---

## WakeUp by Ryz0r - Automatically wakes players up from sleep

```csharp

Oxide.Plugins
[Info("Wake Up", "Orange", "1.0.2")]
[Description("Automatically wakes players up from sleep")]
public class WakeUp : RustPlugin
{
    private const string permUse;
    private void Init();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerSleep(BasePlayer player);
    private void Wakeup(BasePlayer player);
}


```

---

## WarCopter by Ryz0r - Allows a player to spawn a Minicopter that has a CCTV, or a turret attached

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;
using WebSocketSharp;
using Physics = UnityEngine.Physics;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("War Copter", "Ryz0r", "1.5.1")]
[Description("Allows a user with permission to spawn a Minicopter that has a viewable CCTV, or a turret attached.")]
public class WarCopter : RustPlugin
{
    private const string AutoTurretPrefab;
    private const string CctvPrefab;
    private const string BoxPrefab;
    private const string LightPrefab;
    private const string MinicopterPrefab;
    private const string SearchLightPrefab;
    private const string SwitchPrefab;
    private const string SpherePrefab;
    private static readonly int GlobalLayerMask;
    private const string DronePerm;
    private const string FighterPerm;
    private const string SpawnPerm;
    private const string CooldownPerm;
    private List<ulong> _entityList;
    private Dictionary<string, float> _cooldownList;
    private Dictionary<ulong, string> _camList;
    protected override void SaveConfig();
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Add Back Light")]
        public bool AddBackLight;
        [JsonProperty(PropertyName = "Add Search Light")]
        public bool AddSearchLight;
        [JsonProperty(PropertyName = "Add Storage Box")]
        public bool AddStorageBox;
        [JsonProperty(PropertyName = "Cool Down Time")]
        public float CoolDownTime;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private void Init();
    protected override void LoadDefaultMessages();
    [ChatCommand("warcopter")]
    private void WarcopterCommand(BasePlayer player, string command, string[] args);
    private void StartCooldown(BasePlayer player);
    private void OnEntityKill(BaseNetworkable entity);
    private void SpawnDrone(BasePlayer player, string dName);
    private void SpawnFighter(BasePlayer player);
    private object OnEntityGroundMissing(BaseNetworkable entity);
    private void AddSearchLight(BaseVehicle mini);
    private void AddBackLight(BaseVehicle mini);
    private void AddBackBox(BaseVehicle mini);
    private void AddTurretAndSwitch(BaseVehicle mini, BasePlayer player);
    private object OnSwitchToggle(ElectricSwitch s, BasePlayer player);
    private static void ChangeTurretState(AutoTurret turret, int turretState);
    private static void RemoveColliderProtection(BaseEntity colliderEntity);
    private void IdentifyAndDestroy(BasePlayer player);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Add Back Light")]
    public bool AddBackLight;
    [JsonProperty(PropertyName = "Add Search Light")]
    public bool AddSearchLight;
    [JsonProperty(PropertyName = "Add Storage Box")]
    public bool AddStorageBox;
    [JsonProperty(PropertyName = "Cool Down Time")]
    public float CoolDownTime;
}


```

---

## WarpSystem by  - Creates warp points for players to easily teleport to

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Warp System", "PaiN", "1.9.14", ResourceId = 760)]
[Description("Original Developer: Dathus BR || Create warp points for players.")]
 class WarpSystem : RustPlugin
{
    [PluginReference]
     Plugin Jail;
    private bool Changed;
    private int cooldown;
    private int warpbacktimer;
    private bool enablecooldown;
    private int backcmdauthlevel;
    private bool WarpIfRunning;
    private bool WarpIfWounded;
    private bool WarpIfSwimming;
    private bool WarpIfBuildingBlocked;
    private bool WarpIfDucking;
    private string backtolastloc;
    private string warplist;
    private string therealreadyis;
    private string warpadded;
    private string youhavetowait;
    private string cantwarpwhilerunning;
    private string cantwarpwhilewounded;
    private string cantwarpwhilebuildingblocked;
    private string cantwarpwhileducking;
    private string cantwarpwhileswimming;
    private string youhaveteleportedto;
    private string teleportingto;
    private string youhaveremoved;
     object GetConfig(string menu, string datavalue, object defaultValue);
     double GetTimeStamp();
     void LoadVariables();
    protected override void LoadDefaultConfig();
     class StoredData
    {
        public List<WarpInfo> WarpInfo;
        public Dictionary<ulong, double> cantele;
        public Dictionary<ulong, OldPosInfo> lastposition;
        public Dictionary<ulong, Dictionary<string, int>> maxuses;
    }

     class OldPosInfo
    {
        public float OldX;
        public float OldY;
        public float OldZ;
        public OldPosInfo(float x, float y, float z);
        public OldPosInfo();
    }

     class WarpInfo
    {
        public string WarpName;
        public int WarpId;
        public float WarpX;
        public float WarpY;
        public float WarpZ;
        public string WarpPermissionGroup;
        public int WarpTimer;
        public int WarpMaxUses;
        public string WarpCreatorName;
        public int RandomRange;
        public WarpInfo(string name, BasePlayer player, int timerp, string permissionp, int warpnum, int randomr, int maxusess);
        public WarpInfo();
    }

     StoredData storedData;
     void Loaded();
    [ConsoleCommand("warp.wipemaxuses")]
     void cmdWarpMaxUses(ConsoleSystem.Arg arg);
    [ConsoleCommand("warp.playerto")]
     void cmdWarpPlayerr(ConsoleSystem.Arg arg);
     int GetNewId();
     int GetRandomId(BasePlayer player);
    [ChatCommand("warp")]
     void cmdWarp(BasePlayer player, string cmdd, string[] args);
     void OnServerCommand(ConsoleSystem.Arg arg);
     void ForcePlayerPos(BasePlayer player, Vector3 xyz);
}

 class StoredData
{
    public List<WarpInfo> WarpInfo;
    public Dictionary<ulong, double> cantele;
    public Dictionary<ulong, OldPosInfo> lastposition;
    public Dictionary<ulong, Dictionary<string, int>> maxuses;
}

 class OldPosInfo
{
    public float OldX;
    public float OldY;
    public float OldZ;
    public OldPosInfo(float x, float y, float z);
    public OldPosInfo();
}

 class WarpInfo
{
    public string WarpName;
    public int WarpId;
    public float WarpX;
    public float WarpY;
    public float WarpZ;
    public string WarpPermissionGroup;
    public int WarpTimer;
    public int WarpMaxUses;
    public string WarpCreatorName;
    public int RandomRange;
    public WarpInfo(string name, BasePlayer player, int timerp, string permissionp, int warpnum, int randomr, int maxusess);
    public WarpInfo();
}


```

---

## WaterCatcherBoost by Substrata - Boosts the collection rate of water catchers & pumps

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Water Catcher Boost", "Substrata", "1.0.3")]
[Description("Boosts the collection rate of water catchers & pumps")]
 class WaterCatcherBoost : RustPlugin
{
     System.Random random;
     ItemDefinition freshWater;
     void OnWaterCollect(WaterCatcher waterCatcher);
     void OnWaterCollect(WaterPump waterPump, ItemDefinition water);
     int GetAmount(int min, int max);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Small Water Catchers")]
        public SmallWaterCatchers smallWaterCatchers { get; set; }
        [JsonProperty(PropertyName = "Large Water Catchers")]
        public LargeWaterCatchers largeWaterCatchers { get; set; }
        [JsonProperty(PropertyName = "Water Pumps")]
        public WaterPumps waterPumps { get; set; }
        public class SmallWaterCatchers
        {
            [JsonProperty(PropertyName = "Minimum Boost")]
            public int minBoost { get; set; }
            [JsonProperty(PropertyName = "Maximum Boost")]
            public int maxBoost { get; set; }
        }

        public class LargeWaterCatchers
        {
            [JsonProperty(PropertyName = "Minimum Boost")]
            public int minBoost { get; set; }
            [JsonProperty(PropertyName = "Maximum Boost")]
            public int maxBoost { get; set; }
        }

        public class WaterPumps
        {
            [JsonProperty(PropertyName = "Minimum Boost")]
            public int minBoost { get; set; }
            [JsonProperty(PropertyName = "Maximum Boost")]
            public int maxBoost { get; set; }
        }

        [JsonProperty(PropertyName = "Version (Do not modify)")]
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    private ConfigData GetBaseConfig();
    private void UpdateConfigValues();
    private object GetConfig(string menu, string dataValue, object defaultValue);
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Small Water Catchers")]
    public SmallWaterCatchers smallWaterCatchers { get; set; }
    [JsonProperty(PropertyName = "Large Water Catchers")]
    public LargeWaterCatchers largeWaterCatchers { get; set; }
    [JsonProperty(PropertyName = "Water Pumps")]
    public WaterPumps waterPumps { get; set; }
    public class SmallWaterCatchers
    {
        [JsonProperty(PropertyName = "Minimum Boost")]
        public int minBoost { get; set; }
        [JsonProperty(PropertyName = "Maximum Boost")]
        public int maxBoost { get; set; }
    }

    public class LargeWaterCatchers
    {
        [JsonProperty(PropertyName = "Minimum Boost")]
        public int minBoost { get; set; }
        [JsonProperty(PropertyName = "Maximum Boost")]
        public int maxBoost { get; set; }
    }

    public class WaterPumps
    {
        [JsonProperty(PropertyName = "Minimum Boost")]
        public int minBoost { get; set; }
        [JsonProperty(PropertyName = "Maximum Boost")]
        public int maxBoost { get; set; }
    }

    [JsonProperty(PropertyName = "Version (Do not modify)")]
    public Oxide.Core.VersionNumber Version { get; set; }
}

public class SmallWaterCatchers
{
    [JsonProperty(PropertyName = "Minimum Boost")]
    public int minBoost { get; set; }
    [JsonProperty(PropertyName = "Maximum Boost")]
    public int maxBoost { get; set; }
}

public class LargeWaterCatchers
{
    [JsonProperty(PropertyName = "Minimum Boost")]
    public int minBoost { get; set; }
    [JsonProperty(PropertyName = "Maximum Boost")]
    public int maxBoost { get; set; }
}

public class WaterPumps
{
    [JsonProperty(PropertyName = "Minimum Boost")]
    public int minBoost { get; set; }
    [JsonProperty(PropertyName = "Maximum Boost")]
    public int maxBoost { get; set; }
}


```

---

## WaterlessSprinklers by Lorenzo - Sprinklers will run without water pipe connection.

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Linq;

Oxide.Plugins
[Info("Waterless Sprinklers", "Lorenzo", "1.0.3")]
[Description("Sprinkers dont need water to run")]
 class WaterlessSprinklers : CovalencePlugin
{
    private ItemDefinition water;
    private const int sprinklerID;
    private const ulong sprinklerSkinID;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Use permission")]
        public bool UsePermission;
        [JsonProperty(PropertyName = "Permission")]
        public string PermissionUse;
        [JsonProperty(PropertyName = "PermissionAdmin")]
        public string PermissionAdmin;
        [JsonProperty(PropertyName = "Make sprinkler special command")]
        public string setskincommand;
        [JsonProperty(PropertyName = "Only turn on if there is no IO connected to sprinklers")]
        public bool checkIOconnection;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Unload();
    private void OnServerInitialized();
     void OnEntitySpawned(Sprinkler sprinkler);
    private void SprinklerSetSkin(IPlayer iplayer, string command, string[] args);
    public void SendChatMessage(BasePlayer player, string msg);
     void UpdateAllSprinklers(bool state);
    private bool CanUse(ulong id);
    private bool IsAdmin(ulong id);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Use permission")]
    public bool UsePermission;
    [JsonProperty(PropertyName = "Permission")]
    public string PermissionUse;
    [JsonProperty(PropertyName = "PermissionAdmin")]
    public string PermissionAdmin;
    [JsonProperty(PropertyName = "Make sprinkler special command")]
    public string setskincommand;
    [JsonProperty(PropertyName = "Only turn on if there is no IO connected to sprinklers")]
    public bool checkIOconnection;
}


```

---

## WaterLimits by  - Hurts or kills players that are in water under conditions

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using System.Collections.Generic;
using System.IO;

Oxide.Plugins
[Info("Water Limits", "Wulf/lukespragg", "3.1.0")]
[Description("Hurts or kills players that are in water under conditions")]
public class WaterLimits : CovalencePlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Hurt player on contact (true/false)")]
        public bool HurtOnContact { get; set; }
        [JsonProperty(PropertyName = "Hurt player on disconnect (true/false)")]
        public bool HurtOnDisconnect { get; set; }
        [JsonProperty(PropertyName = "Hurt player over time (true/false)")]
        public bool HurtOverTime { get; set; }
        [JsonProperty(PropertyName = "Kill player on contact (true/false)")]
        public bool KillOnContact { get; set; }
        [JsonProperty(PropertyName = "Kill player on disconnect (true/false)")]
        public bool KillOnDisconnect { get; set; }
        [JsonProperty(PropertyName = "Damage player amount (1 - 500)")]
        public int DamageAmount { get; set; }
        [JsonProperty(PropertyName = "Damage player every (seconds)")]
        public int DamageEvery { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private readonly Dictionary<ulong, Timer> timers;
    private const string permExclude;
    private void Init();
    private bool IsInWater(BasePlayer player);
    private void WaterCheck(BasePlayer player);
    private void OnServerInitialized();
    private void OnPlayerConnected(Network.Message packet);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity entity);
    private void OnPlayerSleepEnded(BasePlayer player);
}

public class Configuration
{
    [JsonProperty(PropertyName = "Hurt player on contact (true/false)")]
    public bool HurtOnContact { get; set; }
    [JsonProperty(PropertyName = "Hurt player on disconnect (true/false)")]
    public bool HurtOnDisconnect { get; set; }
    [JsonProperty(PropertyName = "Hurt player over time (true/false)")]
    public bool HurtOverTime { get; set; }
    [JsonProperty(PropertyName = "Kill player on contact (true/false)")]
    public bool KillOnContact { get; set; }
    [JsonProperty(PropertyName = "Kill player on disconnect (true/false)")]
    public bool KillOnDisconnect { get; set; }
    [JsonProperty(PropertyName = "Damage player amount (1 - 500)")]
    public int DamageAmount { get; set; }
    [JsonProperty(PropertyName = "Damage player every (seconds)")]
    public int DamageEvery { get; set; }
}


```

---

## WaterWellManager by Mevent - Configure how the water wells work

```csharp
using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Facepunch;

Oxide.Plugins
[Info("WaterWellManager", "Krungh Crow", "2.0.0")]
[Description("Configure how the water wells work")]
 class WaterWellManager : CovalencePlugin
{
     void Init();
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Settings")]
        public SettingsWaterWell WellChecks;
    }

     class SettingsWaterWell
    {
        [JsonProperty(PropertyName = "Calories needed Per Pump")]
        public float Calories;
        [JsonProperty(PropertyName = "Pressure per pump")]
        public float Pressure;
        [JsonProperty(PropertyName = "Pressure needed to pump")]
        public float PressureNeeded;
        [JsonProperty(PropertyName = "Water output per pump")]
        public int Output;
    }

    private bool LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConf();
    private void OnServerInitialized();
     void Unload();
    private void UpdateRoutine();
    private void VanillaRoutine();
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Settings")]
    public SettingsWaterWell WellChecks;
}

 class SettingsWaterWell
{
    [JsonProperty(PropertyName = "Calories needed Per Pump")]
    public float Calories;
    [JsonProperty(PropertyName = "Pressure per pump")]
    public float Pressure;
    [JsonProperty(PropertyName = "Pressure needed to pump")]
    public float PressureNeeded;
    [JsonProperty(PropertyName = "Water output per pump")]
    public int Output;
}


```

---

## WaterWorks by nivex - Control the monopoly on your water supplies

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Water Works", "nivex", "1.1.0")]
[Description("Control the monopoly on your water supplies.")]
 class WaterWorks : RustPlugin
{
    private readonly List<string> _itemShortnames;
    private readonly Dictionary<string, ItemConfig> _itemConfigs;
    private readonly Dictionary<string, EntityConfig> _entityConfigs;
    private void Init();
    private void OnServerInitialized();
    private void InitializeEntityConfigs();
    private void Unload();
    private void OnEntitySpawned(LiquidContainer lc);
    private void CommandStats(IPlayer user, string command, string[] args);
    private void SetLiquidContainerStackSize(bool state);
    private void SetLiquidContainerStackSize(LiquidContainer lc, bool state);
    private void SetSlotAmounts(LiquidContainer lc, int num);
    private static void SetMaxStackSize(LiquidContainer lc, int num);
    private void ConfigureWaterDefinitions(bool state);
    private void UpdateWaterBarrel(LiquidContainer lc, bool state, EntityConfig entityConfig);
    private void UpdateWaterCatcher(WaterCatcher wc, bool state, EntityConfig entityConfig);
    private void UpdatePoweredWaterPurifier(LiquidContainer lc, bool state, EntityConfig entityConfig);
    private void UpdateWaterPurifier(WaterPurifier purifier, bool state, EntityConfig entityConfig);
    private void UpdateWaterPump(WaterPump pump, bool state, EntityConfig entityConfig);
    private void UpdateGroundPool(LiquidContainer lc, bool state, EntityConfig entityConfig);
    private void UpdateBigGroundPool(LiquidContainer lc, bool state, EntityConfig entityConfig);
    private Configuration config;
    private int GetConfigValue(string shortname);
    private class SmallWaterCatcherSettings
    {
        [JsonProperty(PropertyName = "Stack Size (vanilla: 10000)")]
        public int StackSize { get; set; }
        [JsonProperty(PropertyName = "Add Amount Of Water (vanilla: 10)")]
        public float MaxItemToCreate { get; set; }
        [JsonProperty(PropertyName = "Add Water Every X Seconds (vanilla: 60)")]
        public float Interval { get; set; }
    }

    private class LargeWaterCatcherSettings
    {
        [JsonProperty(PropertyName = "Stack Size (vanilla: 50000)")]
        public int StackSize { get; set; }
        [JsonProperty(PropertyName = "Add Amount Of Water (vanilla: 30)")]
        public float MaxItemToCreate { get; set; }
        [JsonProperty(PropertyName = "Add Water Every X Seconds (vanilla: 60)")]
        public float Interval { get; set; }
    }

    private class WaterPumpSettings
    {
        [JsonProperty(PropertyName = "ML Capacity (vanilla: 2000)")]
        public int StackSize { get; set; }
        [JsonProperty(PropertyName = "Add Amount Of Water To Water Pumps (Vanilla: 85)")]
        public int Amount { get; set; }
        [JsonProperty(PropertyName = "Add Water To Water Pumps Every X Seconds (Vanilla: 10)")]
        public float Interval { get; set; }
    }

    private class Configuration
    {
        [JsonProperty(PropertyName = "Small Water Catcher")]
        public SmallWaterCatcherSettings SmallWaterCatcher { get; set; }
        [JsonProperty(PropertyName = "Large Water Catcher")]
        public LargeWaterCatcherSettings LargeWaterCatcher { get; set; }
        [JsonProperty(PropertyName = "Water Pump")]
        public WaterPumpSettings WaterPump { get; set; }
        [JsonProperty(PropertyName = "Water Jug ML Capacity (vanilla: 5000)")]
        public int WaterJug { get; set; }
        [JsonProperty(PropertyName = "Water Barrel ML Capacity (vanilla: 20000)")]
        public int WaterBarrel { get; set; }
        [JsonProperty(PropertyName = "Water Bucket ML Capacity (vanilla: 2000)")]
        public int WaterBucket { get; set; }
        [JsonProperty(PropertyName = "Water Ground Pool Capacity (vanilla: 500)")]
        public int GroundPool { get; set; }
        [JsonProperty(PropertyName = "Water Big Ground Pool Capacity (vanilla: 2000)")]
        public int BigGroundPool { get; set; }
        [JsonProperty(PropertyName = "Water Purifier ML Capacity (vanilla: 5000)")]
        public int WaterPurifier { get; set; }
        [JsonProperty(PropertyName = "Water Purifier (Powered) ML Capacity (vanilla: 5000)")]
        public int PoweredWaterPurifier { get; set; }
        [JsonProperty(PropertyName = "Water Pistol ML Capacity (vanilla: 250)")]
        public int WaterPistol { get; set; }
        [JsonProperty(PropertyName = "Water Gun ML Capacity (vanilla: 1000)")]
        public int WaterGun { get; set; }
        [JsonProperty(PropertyName = "Small Water Bottle ML Capacity (vanilla: 250)")]
        public int SmallWaterBottle { get; set; }
        [JsonProperty(PropertyName = "Bota Bag ML Capacity (default: 3000)")]
        public int BotaBag { get; set; }
        [JsonProperty(PropertyName = "Reset To Vanilla Defaults On Unload")]
        public bool Reset { get; set; }
    }

    protected override void LoadConfig();
    private bool canSaveConfig;
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private class ItemConfig
    {
        public string Shortname { get; set; }
        public int ItemId { get; set; }
        public int DefaultMaxStackSize { get; set; }
        public int ConfigMaxStackSize { get; set; }
    }

    private class EntityConfig
    {
        public string ShortPrefabName { get; set; }
        public int DefaultMaxStackSize { get; set; }
        public int ConfigMaxStackSize { get; set; }
        public float DefaultMaxItemToCreate { get; set; }
        public float MaxItemToCreate { get; set; }
        public float Interval { get; set; }
        public float DefaultPumpInterval { get; set; }
        public float PumpInterval { get; set; }
        public int DefaultAmountPerPump { get; set; }
        public int AmountPerPump { get; set; }
    }

}

private class SmallWaterCatcherSettings
{
    [JsonProperty(PropertyName = "Stack Size (vanilla: 10000)")]
    public int StackSize { get; set; }
    [JsonProperty(PropertyName = "Add Amount Of Water (vanilla: 10)")]
    public float MaxItemToCreate { get; set; }
    [JsonProperty(PropertyName = "Add Water Every X Seconds (vanilla: 60)")]
    public float Interval { get; set; }
}

private class LargeWaterCatcherSettings
{
    [JsonProperty(PropertyName = "Stack Size (vanilla: 50000)")]
    public int StackSize { get; set; }
    [JsonProperty(PropertyName = "Add Amount Of Water (vanilla: 30)")]
    public float MaxItemToCreate { get; set; }
    [JsonProperty(PropertyName = "Add Water Every X Seconds (vanilla: 60)")]
    public float Interval { get; set; }
}

private class WaterPumpSettings
{
    [JsonProperty(PropertyName = "ML Capacity (vanilla: 2000)")]
    public int StackSize { get; set; }
    [JsonProperty(PropertyName = "Add Amount Of Water To Water Pumps (Vanilla: 85)")]
    public int Amount { get; set; }
    [JsonProperty(PropertyName = "Add Water To Water Pumps Every X Seconds (Vanilla: 10)")]
    public float Interval { get; set; }
}

private class Configuration
{
    [JsonProperty(PropertyName = "Small Water Catcher")]
    public SmallWaterCatcherSettings SmallWaterCatcher { get; set; }
    [JsonProperty(PropertyName = "Large Water Catcher")]
    public LargeWaterCatcherSettings LargeWaterCatcher { get; set; }
    [JsonProperty(PropertyName = "Water Pump")]
    public WaterPumpSettings WaterPump { get; set; }
    [JsonProperty(PropertyName = "Water Jug ML Capacity (vanilla: 5000)")]
    public int WaterJug { get; set; }
    [JsonProperty(PropertyName = "Water Barrel ML Capacity (vanilla: 20000)")]
    public int WaterBarrel { get; set; }
    [JsonProperty(PropertyName = "Water Bucket ML Capacity (vanilla: 2000)")]
    public int WaterBucket { get; set; }
    [JsonProperty(PropertyName = "Water Ground Pool Capacity (vanilla: 500)")]
    public int GroundPool { get; set; }
    [JsonProperty(PropertyName = "Water Big Ground Pool Capacity (vanilla: 2000)")]
    public int BigGroundPool { get; set; }
    [JsonProperty(PropertyName = "Water Purifier ML Capacity (vanilla: 5000)")]
    public int WaterPurifier { get; set; }
    [JsonProperty(PropertyName = "Water Purifier (Powered) ML Capacity (vanilla: 5000)")]
    public int PoweredWaterPurifier { get; set; }
    [JsonProperty(PropertyName = "Water Pistol ML Capacity (vanilla: 250)")]
    public int WaterPistol { get; set; }
    [JsonProperty(PropertyName = "Water Gun ML Capacity (vanilla: 1000)")]
    public int WaterGun { get; set; }
    [JsonProperty(PropertyName = "Small Water Bottle ML Capacity (vanilla: 250)")]
    public int SmallWaterBottle { get; set; }
    [JsonProperty(PropertyName = "Bota Bag ML Capacity (default: 3000)")]
    public int BotaBag { get; set; }
    [JsonProperty(PropertyName = "Reset To Vanilla Defaults On Unload")]
    public bool Reset { get; set; }
}

private class ItemConfig
{
    public string Shortname { get; set; }
    public int ItemId { get; set; }
    public int DefaultMaxStackSize { get; set; }
    public int ConfigMaxStackSize { get; set; }
}

private class EntityConfig
{
    public string ShortPrefabName { get; set; }
    public int DefaultMaxStackSize { get; set; }
    public int ConfigMaxStackSize { get; set; }
    public float DefaultMaxItemToCreate { get; set; }
    public float MaxItemToCreate { get; set; }
    public float Interval { get; set; }
    public float DefaultPumpInterval { get; set; }
    public float PumpInterval { get; set; }
    public int DefaultAmountPerPump { get; set; }
    public int AmountPerPump { get; set; }
}


```

---

## Waypoints by Razor - Waypoints database to give paths for plugins that require it

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Waypoints", "RFC1920", "1.1.4", ResourceId = 982)]
 class Waypoints : RustPlugin
{
     void Loaded();
    private DynamicConfigFile data;
    private Dictionary<string, Waypoint> waypoints;
     void SaveData();
     void LoadData();
     class WaypointInfo
    {
        [JsonProperty("p")]
        public Vector3 Position;
        [JsonProperty("s")]
        public float Speed;
        public WaypointInfo(Vector3 position, float speed);
    }

    private string _(string msgId, BasePlayer player, object[] args);
    private void PrintMsgL(BasePlayer player, string msgId, object[] args);
    private void PrintMsg(BasePlayer player, string msg);
     void Init();
     class Waypoint
    {
        public string Name;
        public List<WaypointInfo> Waypoints;
        public Waypoint();
        public void AddWaypoint(Vector3 position, float speed);
    }

     class WaypointEditor : MonoBehaviour
    {
        public Waypoint targetWaypoint;
         void Awake();
    }

    [HookMethod("GetWaypointsList")]
     object GetWaypointsList(string name);
     bool hasAccess(BasePlayer player);
     bool isEditingWP(BasePlayer player, int ttype);
    [Command("waypoints_new")]
     void cmdWaypointsNew(IPlayer iplayer, string command, string[] args);
    [Command("waypoints_add")]
     void cmdWaypointsAdd(IPlayer iplayer, string command, string[] args);
    [Command("waypoints_list")]
     void cmdWaypointsList(IPlayer iplayer, string command, string[] args);
    [Command("waypoints_remove")]
     void cmdWaypointsRemove(IPlayer iplayer, string command, string[] args);
    [Command("waypoints_save")]
     void cmdWaypointsSave(IPlayer iplayer, string command, string[] args);
    [Command("waypoints_close")]
     void cmdWaypointsClose(IPlayer iplayer, string command, string[] args);
    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

}

 class WaypointInfo
{
    [JsonProperty("p")]
    public Vector3 Position;
    [JsonProperty("s")]
    public float Speed;
    public WaypointInfo(Vector3 position, float speed);
}

 class Waypoint
{
    public string Name;
    public List<WaypointInfo> Waypoints;
    public Waypoint();
    public void AddWaypoint(Vector3 position, float speed);
}

 class WaypointEditor : MonoBehaviour
{
    public Waypoint targetWaypoint;
     void Awake();
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## WeaponChanger by DezLife - Changes some of weapon stats on the server

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Weapon Changer", "DezLife", "1.0.4")]
[Description("Change weapon stats on your server")]
public class WeaponChanger : RustPlugin
{
    private Dictionary<string, WeaponEntry> weapons;
    private void OnServerInitialized();
    private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter craft);
    private void OnItemAddedToContainer(ItemContainer container, Item item);
    private void OnWeaponReload(BaseProjectile weapon, BasePlayer player);
    private void GetWeapons();
    private void CheckItem(Item item, string playerID);
    private void ChangeClip(BaseProjectile weapon, ClipSettings settings, string playerID);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "List")]
        public List<WeaponEntry> weapons;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class WeaponEntry
    {
        [JsonProperty(PropertyName = "Shortname")]
        public string shortname;
        [JsonProperty(PropertyName = "Enabled")]
        public bool enabled;
        [JsonProperty(PropertyName = "Settings")]
        public WeaponConfig config;
    }

    private class WeaponConfig
    {
        [JsonProperty(PropertyName = "Magazine")]
        public ClipSettings clip;
    }

    private class ClipSettings
    {
        [JsonProperty(PropertyName = "Size")]
        public int size;
        [JsonProperty(PropertyName = "Permission")]
        public string permission;
        [JsonProperty(PropertyName = "Size with permission")]
        public int permSize;
    }

}

private class ConfigData
{
    [JsonProperty(PropertyName = "List")]
    public List<WeaponEntry> weapons;
}

private class WeaponEntry
{
    [JsonProperty(PropertyName = "Shortname")]
    public string shortname;
    [JsonProperty(PropertyName = "Enabled")]
    public bool enabled;
    [JsonProperty(PropertyName = "Settings")]
    public WeaponConfig config;
}

private class WeaponConfig
{
    [JsonProperty(PropertyName = "Magazine")]
    public ClipSettings clip;
}

private class ClipSettings
{
    [JsonProperty(PropertyName = "Size")]
    public int size;
    [JsonProperty(PropertyName = "Permission")]
    public string permission;
    [JsonProperty(PropertyName = "Size with permission")]
    public int permSize;
}


```

---

## WeaponDamageScaler by Shady - Allows scaling of player damage per weapon/ammo/skin/prefab

```csharp
using System.Collections.Generic;
using System.Text;
using Oxide.Core.Configuration;
using Oxide.Core;
using System;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Weapon Damage Scaler", "Shady", "1.1.7", ResourceId = 1594)]
[Description("Scale damage per weapon, ammo types, skins, prefabs, and per body part.")]
internal class WeaponDamageScaler : RustPlugin
{
    private readonly Dictionary<ulong, string> skinIDName;
    private WeaponData weaponData;
    private DynamicConfigFile wData;
    private float GlobalDamageScale;
    private readonly Array buildingGrades;
    private readonly HashSet<string> prefabNames;
    private readonly List<string> _forbiddenTags;
    private readonly Regex _colorRegex;
    private readonly Regex _sizeRegex;
    private class ItemStructure
    {
        public string Name;
        public float GlobalModifier;
        public Dictionary<string, float> IndividualParts;
        public Dictionary<string, float> PrefabModifiers;
    }

    private class WeaponData
    {
        public Dictionary<string, ItemStructure> Weapons;
    }

    private void InitializeWeaponData();
    private Dictionary<string, float> CreateBodypartList();
    private void SaveData();
    private void LoadData();
    protected override void LoadDefaultConfig();
    private T GetConfig(string name, T defaultValue);
    public string[] Bodyparts;
    protected override void LoadDefaultMessages();
    private string GetMessage(string key, string steamId);
    private void OnServerInitialized();
    private void Init();
    private void Unload();
    private void OnExplosiveThrown(BasePlayer player, BaseEntity entity);
    private void OnRocketLaunched(BasePlayer player, BaseEntity entity);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    private void CmdSetScale(IPlayer player, string command, string[] args);
    private void cmdScaleBP(IPlayer player, string command, string[] args);
    private string GetSkinName(ulong skinID);
    private ItemDefinition GetItemDefFromPrefabName(string shortprefabName);
    private void ScaleDealtDamage(HitInfo hitInfo);
    private string RemoveTags(string phrase);
    private void RegisterPerm(string perm);
    private bool HasPermID(string userID, string perm);
    private bool HasPerm(IPlayer player, string perm);
    private void SendReply(IPlayer player, string message);
    private bool PrefabExists(string prefabName);
    private bool GradeExists(string gradeName);
    private string GetEnglishName(string shortName);
    private string FirstUpper(string original);
}

private class ItemStructure
{
    public string Name;
    public float GlobalModifier;
    public Dictionary<string, float> IndividualParts;
    public Dictionary<string, float> PrefabModifiers;
}

private class WeaponData
{
    public Dictionary<string, ItemStructure> Weapons;
}


```

---

## WeaponNames by klauz24 - Allows changing existing weapon name tags

```csharp
using System;
using System.IO;
using Oxide.Core;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Weapon Names", "klauz24", "1.2.2"), Description("Allows to change your active weapon name.")]
internal class WeaponNames : CovalencePlugin
{
    private Configuration _config;
    private const string _perm;
    private readonly Dictionary<string, DateTime> _cooldowns;
    private class Configuration
    {
        [JsonProperty(PropertyName = "New tag digits limit")]
        public int NewTagDigitsLimit { get; set; }
        [JsonProperty(PropertyName = "Cooldown (in minutes)")]
        public double Cooldown { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    [Command("ct")]
    private void ChatCommand(IPlayer player, string command, string[] args);
    private void Init();
}

private class Configuration
{
    [JsonProperty(PropertyName = "New tag digits limit")]
    public int NewTagDigitsLimit { get; set; }
    [JsonProperty(PropertyName = "Cooldown (in minutes)")]
    public double Cooldown { get; set; }
}


```

---

## WeaponTrajectory by VisEntities - Draws the trajectory of rockets and explosives

```csharp
using System.Collections.Generic;
using System;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using UnityEngine;
using System.Linq;
using Facepunch;

Oxide.Plugins
[Info("Weapon Trajectory", "Dana", "1.0.4")]
[Description("Draws the trajectory of rockets and explosives.")]
public class WeaponTrajectory : RustPlugin
{
    public static WeaponTrajectory _plugin;
    public JSONFile<ConfigData> _settingsFile;
    public ConfigData Settings { get; set; }
    public PlayerDataController<GrenadePlayerData> PlayerData;
    public const float UpdateRate;
    public const string Permission_Path;
     void Init();
     void Loaded();
     void Unload();
    public class ConfigData
    {
        public float GrenadeVelocityScale;
        public float RocketVelocityScale;
        public float HVRocketVelocityScale;
        public float FireRocketVelocityScale;
        public bool UsePermissions;
    }

    public class GrenadePlayerData : BasePlayerData
    {
    }

     void DoPlayerUpdate();
     void CheckPlayerInput(BasePlayer player);
     void DrawGrenadePath(BasePlayer player);
     void DrawRocketPath(BasePlayer player, BaseLauncher launcher);
     void OnExplosiveThrown(BasePlayer player, BaseEntity entity);
     void OnRocketLaunched(BasePlayer player, BaseEntity entity);
    private void DoMovement(List<Vector3> output, Vector3 currentPos, Vector3 currentVelocity, float step, int maxSteps, float gravityModifier);
    private class VelocityUpdate
    {
        public Vector3 Position;
        public Vector3 Velocity;
    }

     void OnFrame();
    private static Dictionary<BasePlayer, List<string>> DDrawCommandQueue;
    private static void QueueDDrawCommand(BasePlayer player, string command, object[] args);
    public static void DrawCube(BasePlayer player, float duration, UnityEngine.Color color, Vector3 position, float size);
    public static void DrawBox(BasePlayer player, float duration, UnityEngine.Color color, Vector3 min, Vector3 max);
    public static void DrawText(BasePlayer player, string text, float duration, UnityEngine.Color color, Vector3 position, int size);
    public static void DrawSphere(BasePlayer player, float duration, UnityEngine.Color color, Vector3 position, float size);
    public static void DrawArrow(BasePlayer player, float duration, Color color, Vector3 start, Vector3 end);
    public void SendDDrawCommands();
    public Dictionary<string, string> lang_en;
    public static string GetLangMessage(string key, BasePlayer player);
    public static string GetLangMessage(string key, ulong player);
    public static string GetLangMessage(string key, string player);
    public class BasePlayerData
    {
        [JsonIgnore]
        public BasePlayer Player { get; set; }
        public string userID { get; set; }
        public BasePlayerData();
        public BasePlayerData(BasePlayer player);
    }

    public class PlayerDataController
    {
        [JsonPropertyAttribute(Required = Required.Always)]
        private Dictionary<string, T> playerData { get; set; }
        private JSONFile<Dictionary<string, T>> _file;
        private Timer _timer;
        public IEnumerable<T> All { get; set; }
        public PlayerDataController();
        public PlayerDataController(string filename);
        public void Unload();
        public T Get(string identifer);
        public T Get(ulong userID);
        public T Get(BasePlayer player);
        public bool Has(ulong userID);
        public void Set(string userID, T data);
        public bool Remove(string userID);
        public void Update(T data);
    }

    public class JSONFile
    {
        private DynamicConfigFile _file;
        public string _name { get; set; }
        public Type Instance { get; set; }
        private ConfigLocation _location { get; set; }
        private string _path { get; set; }
        public JSONFile(string name, ConfigLocation location, string path, string extension);
        public virtual void Init();
        public virtual void Load();
        public virtual void Save();
        public virtual void Reload();
        private void Unload(Plugin sender, PluginManager manager);
    }

}

public class ConfigData
{
    public float GrenadeVelocityScale;
    public float RocketVelocityScale;
    public float HVRocketVelocityScale;
    public float FireRocketVelocityScale;
    public bool UsePermissions;
}

public class GrenadePlayerData : BasePlayerData
{
}

private class VelocityUpdate
{
    public Vector3 Position;
    public Vector3 Velocity;
}

public class BasePlayerData
{
    [JsonIgnore]
    public BasePlayer Player { get; set; }
    public string userID { get; set; }
    public BasePlayerData();
    public BasePlayerData(BasePlayer player);
}

public class PlayerDataController
{
    [JsonPropertyAttribute(Required = Required.Always)]
    private Dictionary<string, T> playerData { get; set; }
    private JSONFile<Dictionary<string, T>> _file;
    private Timer _timer;
    public IEnumerable<T> All { get; set; }
    public PlayerDataController();
    public PlayerDataController(string filename);
    public void Unload();
    public T Get(string identifer);
    public T Get(ulong userID);
    public T Get(BasePlayer player);
    public bool Has(ulong userID);
    public void Set(string userID, T data);
    public bool Remove(string userID);
    public void Update(T data);
}

public class JSONFile
{
    private DynamicConfigFile _file;
    public string _name { get; set; }
    public Type Instance { get; set; }
    private ConfigLocation _location { get; set; }
    private string _path { get; set; }
    public JSONFile(string name, ConfigLocation location, string path, string extension);
    public virtual void Init();
    public virtual void Load();
    public virtual void Save();
    public virtual void Reload();
    private void Unload(Plugin sender, PluginManager manager);
}


```

---

## WeatherEvents by Rick6 - Command-based weather that realisticly rolls in and out

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Weather Events", "OuTSMoKE, Rick", "1.4.0")]
[Description("Calls weather events with console commands.")]
 class WeatherEvents : RustPlugin
{
    public Timer StormTimer;
    public int time;
    public List<string> cmds;
     void Unload();
     void OnServerInitialized();
    [ConsoleCommand("we")]
     void cmdSpecial(ConsoleSystem.Arg arg);
     void NewStormTimer(string TypeOfStorm);
     void ProcessStorm(Dictionary<int, List<string>> StormData);
    public Dictionary<string, Dictionary<int, List<string>>> Storms;
}


```

---

## WelcomeMessages by Ankawi - Sends players welcome messages once they connect to the server

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System;

Oxide.Plugins
[Info("WelcomeMessages", "Ankawi", "1.0.7", ResourceId = 2219)]
[Description("Sends players welcome messages")]
 class WelcomeMessages : CovalencePlugin
{
    private float timeInSeconds;
    protected override void LoadDefaultConfig();
     void Init();
     void OnUserConnected(IPlayer player);
}


```

---

## Welcomer by VisEntities - Welcomes players and announces when they join or leave

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

Oxide.Plugins
[Info("Welcomer", "Dana", "2.1.0")]
[Description("Welcomes players and announces when they join or leave.")]
public class Welcomer : RustPlugin
{
    private const string permissionBypass;
    private static Configuration config;
    private Data data;
    private DynamicConfigFile dataFile;
    private const string apiUrl;
    private List<ulong> playersToWelcome { get; set; }
    private class Configuration
    {
        [JsonProperty(PropertyName = "Chat Avatar")]
        public ulong ChatAvatar { get; set; }
        [JsonProperty(PropertyName = "Show Player Avatar")]
        public bool ShowPlayerAvatar { get; set; }
        [JsonProperty(PropertyName = "Enable Chat Welcome Message")]
        public bool EnableChatWelcomeMessage { get; set; }
        [JsonProperty(PropertyName = "Enable Console Welcome Message")]
        public bool EnableConsoleWelcomeMessage { get; set; }
        [JsonProperty(PropertyName = "Enable Join Message")]
        public bool EnableJoinMessage { get; set; }
        [JsonProperty(PropertyName = "Enable Newcomer Join Message")]
        public bool EnableNewcomerJoinMessage { get; set; }
        [JsonProperty(PropertyName = "Enable Leave Message")]
        public bool EnableLeaveMessage { get; set; }
        [JsonProperty(PropertyName = "Enable Rage Quit Message")]
        public bool EnableRageQuitMessage { get; set; }
        [JsonProperty(PropertyName = "Clear Data On Wipe")]
        public bool ClearDataOnWipe { get; set; }
        [JsonProperty(PropertyName = "Log To Console")]
        public bool LogToConsole { get; set; }
    }

    private Configuration GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class Data
    {
        [JsonProperty(PropertyName = "Players Data")]
        public Dictionary<ulong, PlayerData> Players { get; set; }
    }

    private class PlayerData
    {
        [JsonProperty("Country")]
        public string Country { get; set; }
    }

    private void CreatePlayerData(ulong playerId, string country);
    private PlayerData GetPlayerData(ulong playerId);
    private void LoadData();
    private void SaveData();
    private void ClearData();
    private void Init();
    private void Unload();
    private void OnServerSave();
    private void OnNewSave(string fileName);
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerSleepEnded(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void TryExtractCountry(BasePlayer player, string url, string ipAddress, Action<string> requestCallback);
    private string ProcessAddress(BasePlayer player);
    private bool HasPermission(BasePlayer player, string permissionName);
    private void SendConsoleMessage(BasePlayer player, string message);
    private void SendChatMessage(BasePlayer player, string message);
    private void SendMessageToAll(BasePlayer player, string message);
    private string StripRichText(string message);
    private static class Command
    {
        public const string Clear;
        public const string Test;
    }

    [ConsoleCommand(Command.Clear)]
    private void cmdClear(ConsoleSystem.Arg conArgs);
    [ChatCommand(Command.Test)]
    private void cmdTest(BasePlayer player, string cmd, string[] args);
    private class MessageKey
    {
        public const string WelcomeChat;
        public const string WelcomeConsole;
        public const string Join;
        public const string JoinNewcomer;
        public const string Leave;
        public const string LeaveRageQuit;
        public const string Test;
    }

    protected override void LoadDefaultMessages();
    private string GetMessage(string messageKey, string playerId, object[] args);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Chat Avatar")]
    public ulong ChatAvatar { get; set; }
    [JsonProperty(PropertyName = "Show Player Avatar")]
    public bool ShowPlayerAvatar { get; set; }
    [JsonProperty(PropertyName = "Enable Chat Welcome Message")]
    public bool EnableChatWelcomeMessage { get; set; }
    [JsonProperty(PropertyName = "Enable Console Welcome Message")]
    public bool EnableConsoleWelcomeMessage { get; set; }
    [JsonProperty(PropertyName = "Enable Join Message")]
    public bool EnableJoinMessage { get; set; }
    [JsonProperty(PropertyName = "Enable Newcomer Join Message")]
    public bool EnableNewcomerJoinMessage { get; set; }
    [JsonProperty(PropertyName = "Enable Leave Message")]
    public bool EnableLeaveMessage { get; set; }
    [JsonProperty(PropertyName = "Enable Rage Quit Message")]
    public bool EnableRageQuitMessage { get; set; }
    [JsonProperty(PropertyName = "Clear Data On Wipe")]
    public bool ClearDataOnWipe { get; set; }
    [JsonProperty(PropertyName = "Log To Console")]
    public bool LogToConsole { get; set; }
}

private class Data
{
    [JsonProperty(PropertyName = "Players Data")]
    public Dictionary<ulong, PlayerData> Players { get; set; }
}

private class PlayerData
{
    [JsonProperty("Country")]
    public string Country { get; set; }
}

private static class Command
{
    public const string Clear;
    public const string Test;
}

private class MessageKey
{
    public const string WelcomeChat;
    public const string WelcomeConsole;
    public const string Join;
    public const string JoinNewcomer;
    public const string Leave;
    public const string LeaveRageQuit;
    public const string Test;
}


```

---

## WelcomeScreen by Mevent - Shows a welcome image to players that join

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("Welcome Screen", "Mevent", "1.1.0")]
[Description("Showing welcoming image on player joining")]
public class WelcomeScreen : RustPlugin
{
    private static ConfigData _config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Image URL")]
        public string url;
        [JsonProperty(PropertyName = "Fade-in duration")]
        public float fadeIn;
        [JsonProperty(PropertyName = "Fade-out duration")]
        public float fadeOut;
        [JsonProperty(PropertyName = "Delay after joining to create image")]
        public float delay;
        [JsonProperty(PropertyName = "Delay after creating image to start fade out")]
        public float duration;
        [JsonProperty(PropertyName = "Anchor min (left bottom coordinate)")]
        public string anchorMin;
        [JsonProperty(PropertyName = "Anchor min (right top coordinate)")]
        public string anchorMax;
        [JsonProperty(PropertyName = "Image transparency")]
        public float transparency;
        [JsonProperty(PropertyName = "Show multiple times?")]
        public bool MultipleTimes;
    }

    protected override void LoadConfig();
    private static void ValidateConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private PluginData _data;
    private void SaveData();
    private void LoadData();
    private class PluginData
    {
        [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> Players;
    }

    private void Init();
    private void OnPlayerConnected(BasePlayer player);
    private void Unload();
    [ChatCommand("welcomescreen")]
    private void Cmd(BasePlayer player);
    private const string Layer;
    private void CreateGUI(BasePlayer player);
    private string _mainUi;
    private void LoadUi();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Image URL")]
    public string url;
    [JsonProperty(PropertyName = "Fade-in duration")]
    public float fadeIn;
    [JsonProperty(PropertyName = "Fade-out duration")]
    public float fadeOut;
    [JsonProperty(PropertyName = "Delay after joining to create image")]
    public float delay;
    [JsonProperty(PropertyName = "Delay after creating image to start fade out")]
    public float duration;
    [JsonProperty(PropertyName = "Anchor min (left bottom coordinate)")]
    public string anchorMin;
    [JsonProperty(PropertyName = "Anchor min (right top coordinate)")]
    public string anchorMax;
    [JsonProperty(PropertyName = "Image transparency")]
    public float transparency;
    [JsonProperty(PropertyName = "Show multiple times?")]
    public bool MultipleTimes;
}

private class PluginData
{
    [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> Players;
}


```

---

## WelcomeTP by Ryan - Teleports new players to a configured position at random

```csharp
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Welcome TP", "Ryan", "1.1.1")]
[Description("Teleports players to a position if they're new")]
public class WelcomeTP : CovalencePlugin
{
    private string Lang(string key, string id, object[] args);
    private List<GenericPosition> Positions;
    private System.Random random;
    private const string UsedPerm;
    private const string SetPerm;
    private new void LoadDefaultMessages();
    private void Init();
    private void OnServerSave();
    private void OnUserConnected(IPlayer player);
    [Command("tpset")]
    private void SetCommand(IPlayer player, string command, string[] args);
}


```

---

## WhereIsMyHorse by 2CHEVSKII - Allows player to spawn their own horse

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Pool = Facepunch.Pool;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("Where is My Horse", "2CHEVSKII", "1.0.1")]
[Description("Here is your horse, sir!")]
 class WhereIsMyHorse : CovalencePlugin
{
    const string PERMISSION_USE;
    const string PERMISSION_USE_ON;
    const int DEFAULT_COOLDOWN;
    const string HORSE_PREFAB;
    const string M_CHAT_PREFIX;
    const string M_NO_PERMISSION;
    const string M_CANT_SPAWN_INDOORS;
    const string M_SPAWNED;
    const string M_COOLDOWN;
    const string M_NO_ESCAPE;
    const string M_NRE;
    const string M_HORSE_NEARBY;
    const string M_PLAYER_NOT_FOUND;
    const string M_HORSE_SPAWNED;
    const string M_NO_POINT_FOR_SPAWN;
    const float HORSE_NEARBY_RANGE;
    readonly Dictionary<string, float> lastUsed;
     PluginSettings settings;
     void Init();
     object CanLootEntity(BasePlayer player, RidableHorse2 horse);
     bool FindSpawnPoint(BasePlayer targetPlayer, Vector3 spawnPoint, float spawnDistance);
     string ConstructPermission(string perm);
     bool CheckPermission(IPlayer player, string perm, bool allowServer);
     int GetSmallestCooldown(IPlayer player);
     bool CheckCooldown(IPlayer player);
     bool CheckNoEscape(IPlayer player);
     bool CheckOutside(BasePlayer player);
     void CommandHandler(IPlayer player, string _, string[] args);
     bool IsHorseNearby(Vector3 position);
     Quaternion GetHorseRotation(Quaternion playerRotation);
     RidableHorse2 SpawnHorse(Vector3 position, Quaternion rotation, ulong ownerid);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     void Message(IPlayer player, string langKey, object[] args);
    protected override void LoadDefaultMessages();
     class PluginSettings
    {
        public static PluginSettings Default { get; set; }
        [JsonProperty("Cooldowns")]
        public Dictionary<string, int> CooldownGroups { get; set; }
        [JsonProperty("Allow usage inside building")]
        public bool AllowInside { get; set; }
        [JsonProperty("Use NoEscape")]
        public bool UseNoEscape { get; set; }
        [JsonProperty("Prevent looting for non-owner")]
        public bool PreventLooting { get; set; }
    }

}

 class PluginSettings
{
    public static PluginSettings Default { get; set; }
    [JsonProperty("Cooldowns")]
    public Dictionary<string, int> CooldownGroups { get; set; }
    [JsonProperty("Allow usage inside building")]
    public bool AllowInside { get; set; }
    [JsonProperty("Use NoEscape")]
    public bool UseNoEscape { get; set; }
    [JsonProperty("Prevent looting for non-owner")]
    public bool PreventLooting { get; set; }
}


```

---

## WheresMyCorpse by  - Displays direction and distance to corpse after respawn or on command

```csharp
using System;
using System.Text;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Where's My Corpse", "Fuji/LeoCurtss", "0.6.2", ResourceId = 1777)]
[Description("Points a player to their corpse when they type a command.")]
 class WheresMyCorpse : RustPlugin
{
     void Loaded();
    private string GetMessage(string name, string sid);
     Dictionary<string, string> deathInfo;
     void LoadData();
     void SaveData();
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     string GetDirectionAngle(float angle, string UserIDString);
     void OnPlayerRespawned(BasePlayer player);
    [ChatCommand("where")]
     void TestCommand(BasePlayer player, string command, string[] args);
     bool IsSteamId(ulong id);
    public Vector3 getVector3(string rString);
}


```

---

## Whisper by Ryan - Message in-game players from the server console or RCON

```csharp
using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Whisper", "Ryan/mTrX", "1.1.1")]
 class Whisper : CovalencePlugin
{
    private const string UsePerm;
    private const string ReplyPerm;
    private string Command;
    private string ReplyCmd;
    private void LoadDefaultConfig();
    private void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private void Init();
    private void WhisperCommand(IPlayer player, string command, string[] args);
    private void ReplyCommand(IPlayer player, string command, string[] args);
}


```

---

## Whitelist by MrBlue - Restricts server access to whitelisted players with permission

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Whitelist", "Wulf/lukespragg", "3.3.0")]
[Description("Restricts server access to whitelisted players only")]
 class Whitelist : CovalencePlugin
{
    const string permAllow;
     bool adminExcluded;
     bool resetOnRestart;
    protected override void LoadDefaultConfig();
     void OnServerInitialized();
     void LoadDefaultMessages();
     bool IsWhitelisted(string id);
     object CanUserLogin(string name, string id);
     T GetConfig(string name, T value);
     string Lang(string key, string id, object[] args);
}


```

---

## WhoaBoy by Clearshot - Stop horses from running away when you dismount

```csharp

Oxide.Plugins
[Info("Whoa Boy", "Clearshot", "1.1.0")]
[Description("Stop horses from running away when you dismount")]
 class WhoaBoy : CovalencePlugin
{
    private PluginConfig _config;
    private void Init();
     void OnEntityDismounted(BaseVehicleSeat seat, BasePlayer player);
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadConfig();
    private class PluginConfig
    {
        public bool usePermission;
        public string stopType;
    }

}

private class PluginConfig
{
    public bool usePermission;
    public string stopType;
}


```

---

## WhoKnocks by Hockeygel23 - Informs when a player knocks on your door(s) and get owner info

```csharp
using System.Collections.Generic;
using System;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Who Knocks", "Hockeygel23", "0.0.7")]
[Description("Get information messages on door knock")]
 class WhoKnocks : RustPlugin
{
    private const string AdminPermission;
    private const string KnockPermission;
    private const string MessagePermission;
    private ConfigData config;
    private List<BasePlayer> Cooldowns;
    private List<string> Colors;
    const float CellSize;
    private void Init();
    private class ConfigData
    {
        [JsonProperty("Knocking Cooldown in seconds (0 = no cooldown)")]
        public float KnockCooldown;
        [JsonProperty("Display Door coordinates for owner")]
        public bool DoorCoordinates;
        [JsonProperty("Text color when the owner is offline")]
        public string OfflineColor;
        [JsonProperty("Text color when the owner is online")]
        public string OnlineColor;
        [JsonProperty("Display owner online/offline")]
        public bool OwnerDisplay;
    }

    private ConfigData GenerateConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnDoorKnocked(Door door, BasePlayer player);
    private string GetDoorGridPosition(Vector3 position);
    private void Cooldown(BasePlayer player);
    private bool InCooldown(BasePlayer player);
    private void TimerCooldown(BasePlayer player);
    [ChatCommand("whoknocks")]
    private void cmdChat(BasePlayer player, string command, string[] args);
    private void Unload();
}

private class ConfigData
{
    [JsonProperty("Knocking Cooldown in seconds (0 = no cooldown)")]
    public float KnockCooldown;
    [JsonProperty("Display Door coordinates for owner")]
    public bool DoorCoordinates;
    [JsonProperty("Text color when the owner is offline")]
    public string OfflineColor;
    [JsonProperty("Text color when the owner is online")]
    public string OnlineColor;
    [JsonProperty("Display owner online/offline")]
    public bool OwnerDisplay;
}


```

---

## WindyAirdrop by ColonBlow - Makes airdrops move some as if it's windy

```csharp
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Windy Airdrop", "Colon Blow", "1.0.1")]
[Description("Airdrops move some as if its windy")]
public class WindyAirdrop : CovalencePlugin
{
    private bool initComplete;
    private void OnServerInitialized();
    private static PluginConfig config;
    private class PluginConfig
    {
        public WindyAirdropSettings windyAirdropSettings { get; set; }
        public class WindyAirdropSettings
        {
            [JsonProperty(PropertyName = "Wind Speed Max - Maximus wind speed : ")]
            public float windspeedMax { get; set; }
            [JsonProperty(PropertyName = "Wind Speed Min - Minimum wind speed : ")]
            public float windspeedMin { get; set; }
        }

        public static PluginConfig DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void OnEntitySpawned(SupplyDrop supplyDrop);
    private class SupplyDropModifier : MonoBehaviour
    {
         WindyAirdrop.PluginConfig.WindyAirdropSettings airdropSettings;
         SupplyDrop supplyDrop;
         Vector3 windDir;
         Vector3 newDir;
         float windSpeed;
         int counter;
         int nextwind;
         bool dropinit;
        private void Awake();
        private Vector3 GetDirection();
        private int GetRandomInt();
        private void FixedUpdate();
        private void OnDestroy();
    }

}

private class PluginConfig
{
    public WindyAirdropSettings windyAirdropSettings { get; set; }
    public class WindyAirdropSettings
    {
        [JsonProperty(PropertyName = "Wind Speed Max - Maximus wind speed : ")]
        public float windspeedMax { get; set; }
        [JsonProperty(PropertyName = "Wind Speed Min - Minimum wind speed : ")]
        public float windspeedMin { get; set; }
    }

    public static PluginConfig DefaultConfig();
}

public class WindyAirdropSettings
{
    [JsonProperty(PropertyName = "Wind Speed Max - Maximus wind speed : ")]
    public float windspeedMax { get; set; }
    [JsonProperty(PropertyName = "Wind Speed Min - Minimum wind speed : ")]
    public float windspeedMin { get; set; }
}

private class SupplyDropModifier : MonoBehaviour
{
     WindyAirdrop.PluginConfig.WindyAirdropSettings airdropSettings;
     SupplyDrop supplyDrop;
     Vector3 windDir;
     Vector3 newDir;
     float windSpeed;
     int counter;
     int nextwind;
     bool dropinit;
    private void Awake();
    private Vector3 GetDirection();
    private int GetRandomInt();
    private void FixedUpdate();
    private void OnDestroy();
}


```

---

## WipeAssistant by S0N0FBISCUIT - Efficient and customizable wipe system

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;
using Newtonsoft.Json.Linq;

Oxide.Plugins
[Info("WipeAssistant", "S0N_0F_BISCUIT", "1.0.0")]
[Description("Wipes player deployables, players(active and sleeping), and several mod data files.")]
 class WipeAssistant : RustPlugin
{
    const string version;
    [PluginReference("Economics")]
     Plugin Economics;
    [PluginReference("Backpacks")]
     Plugin Backpacks;
    [PluginReference("PlayerChallenges")]
     Plugin PlayerChallenges;
    [PluginReference("ZLevelsRemastered")]
     Plugin ZLevelsRemastered;
    [PluginReference("GUIShop")]
     Plugin GUIShop;
    [PluginReference("HeliControl")]
     Plugin HeliControl;
    [PluginReference("Kits")]
     Plugin Kits;
    [PluginReference("Pets")]
     Plugin Pets;
    [PluginReference("Replenish")]
     Plugin Replenish;
    [PluginReference("SignTracker")]
     Plugin SignTracker;
    [PluginReference("TargetPractice")]
     Plugin TargetPractice;
    [PluginReference("AutoPurge")]
     Plugin AutoPurge;
    [PluginReference("Airstrike")]
     Plugin Airstrike;
    [PluginReference("RotatingBillboards")]
     Plugin RotatingBillboards;
    [PluginReference("NTeleportation")]
     Plugin NTeleportation;
    [PluginReference("Bounty")]
     Plugin Bounty;
    private class EmptyBackpack
    {
        public BackpackInventory Inventory;
        public ulong ownerID;
        private BaseEntity entity;
        private BaseEntity visualEntity;
        private StorageContainer container { get; set; }
        public bool IsOpen { get; set; }
    }

    private class BackpackInventory
    {
        public List<BackpackItem> Items;
        public class BackpackItem
        {
            public int ID;
            public int Amount;
            public ulong Skin;
            public float Fuel;
            public int FlameFuel;
            public float Condition;
            public int Ammo;
            public int AmmoType;
            public List<BackpackItem> Contents;
        }

    }

     class ConfigData
    {
        public bool WipeBackpackOnPlayerJoin { get; set; }
        public ExampleWipe ExampleWipeOptions { get; set; }
        public HardWipe HardWipeOptions { get; set; }
        public SoftWipe SoftWipeOptions { get; set; }
    }

     class ExampleWipe
    {
        public bool WipeAirstrike { get; set; }
        public bool WipeAutoPurge { get; set; }
        public bool WipeBackpacks { get; set; }
        public bool WipeBounty { get; set; }
        public bool WipeEconomics { get; set; }
        public bool WipeGUIShop { get; set; }
        public bool WipeHeliControl { get; set; }
        public bool WipeKits { get; set; }
        public bool WipeNTeleportation { get; set; }
        public bool WipePets { get; set; }
        public bool WipePlayerChallenges { get; set; }
        public bool WipeReplenish { get; set; }
        public bool WipeRotatingBillboards { get; set; }
        public bool WipeSignTracker { get; set; }
        public bool WipeTargetPractice { get; set; }
        public bool WipeZLevelsRemastered { get; set; }
        public List<string> CustomConsoleCommands { get; set; }
    }

     class HardWipe
    {
        public bool WipeAirstrike { get; set; }
        public bool WipeAutoPurge { get; set; }
        public bool WipeBackpacks { get; set; }
        public bool WipeBounty { get; set; }
        public bool WipeEconomics { get; set; }
        public bool WipeGUIShop { get; set; }
        public bool WipeHeliControl { get; set; }
        public bool WipeKits { get; set; }
        public bool WipeNTeleportation { get; set; }
        public bool WipePets { get; set; }
        public bool WipePlayerChallenges { get; set; }
        public bool WipeReplenish { get; set; }
        public bool WipeRotatingBillboards { get; set; }
        public bool WipeSignTracker { get; set; }
        public bool WipeTargetPractice { get; set; }
        public bool WipeZLevelsRemastered { get; set; }
        public List<string> CustomConsoleCommands { get; set; }
    }

     class SoftWipe
    {
        public bool WipeAirstrike { get; set; }
        public bool WipeAutoPurge { get; set; }
        public bool WipeBackpacks { get; set; }
        public bool WipeBounty { get; set; }
        public bool WipeEconomics { get; set; }
        public bool WipeGUIShop { get; set; }
        public bool WipeHeliControl { get; set; }
        public bool WipeKits { get; set; }
        public bool WipeNTeleportation { get; set; }
        public bool WipePets { get; set; }
        public bool WipePlayerChallenges { get; set; }
        public bool WipeReplenish { get; set; }
        public bool WipeRotatingBillboards { get; set; }
        public bool WipeSignTracker { get; set; }
        public bool WipeTargetPractice { get; set; }
        public bool WipeZLevelsRemastered { get; set; }
        public List<string> CustomConsoleCommands { get; set; }
    }

    private Dictionary<ulong, string> PlayerData;
    private ConfigData config;
    protected override void LoadDefaultConfig();
    private void LoadConfig();
    private void LoadData();
    private void Init();
    private void Loaded();
     void OnPlayerConnected(Network.Message packet);
    private void SaveData();
    private void ClearData();
     void CreateBackup();
     void BackupBackpack(string playerName, ulong playerID);
     void killPlayers(string type);
     void removeCorpses();
     void wipePlayers(string type);
     void wipeBackpack(ulong userID, string userName);
     void wipeDeployables();
    [ConsoleCommand("softwipe")]
     void softWipe(ConsoleSystem.Arg arg);
    [ConsoleCommand("hardwipe")]
     void hardWipe(ConsoleSystem.Arg arg);
    [ConsoleCommand("entitycount")]
     void entityCount(ConsoleSystem.Arg args);
}

private class EmptyBackpack
{
    public BackpackInventory Inventory;
    public ulong ownerID;
    private BaseEntity entity;
    private BaseEntity visualEntity;
    private StorageContainer container { get; set; }
    public bool IsOpen { get; set; }
}

private class BackpackInventory
{
    public List<BackpackItem> Items;
    public class BackpackItem
    {
        public int ID;
        public int Amount;
        public ulong Skin;
        public float Fuel;
        public int FlameFuel;
        public float Condition;
        public int Ammo;
        public int AmmoType;
        public List<BackpackItem> Contents;
    }

}

public class BackpackItem
{
    public int ID;
    public int Amount;
    public ulong Skin;
    public float Fuel;
    public int FlameFuel;
    public float Condition;
    public int Ammo;
    public int AmmoType;
    public List<BackpackItem> Contents;
}

 class ConfigData
{
    public bool WipeBackpackOnPlayerJoin { get; set; }
    public ExampleWipe ExampleWipeOptions { get; set; }
    public HardWipe HardWipeOptions { get; set; }
    public SoftWipe SoftWipeOptions { get; set; }
}

 class ExampleWipe
{
    public bool WipeAirstrike { get; set; }
    public bool WipeAutoPurge { get; set; }
    public bool WipeBackpacks { get; set; }
    public bool WipeBounty { get; set; }
    public bool WipeEconomics { get; set; }
    public bool WipeGUIShop { get; set; }
    public bool WipeHeliControl { get; set; }
    public bool WipeKits { get; set; }
    public bool WipeNTeleportation { get; set; }
    public bool WipePets { get; set; }
    public bool WipePlayerChallenges { get; set; }
    public bool WipeReplenish { get; set; }
    public bool WipeRotatingBillboards { get; set; }
    public bool WipeSignTracker { get; set; }
    public bool WipeTargetPractice { get; set; }
    public bool WipeZLevelsRemastered { get; set; }
    public List<string> CustomConsoleCommands { get; set; }
}

 class HardWipe
{
    public bool WipeAirstrike { get; set; }
    public bool WipeAutoPurge { get; set; }
    public bool WipeBackpacks { get; set; }
    public bool WipeBounty { get; set; }
    public bool WipeEconomics { get; set; }
    public bool WipeGUIShop { get; set; }
    public bool WipeHeliControl { get; set; }
    public bool WipeKits { get; set; }
    public bool WipeNTeleportation { get; set; }
    public bool WipePets { get; set; }
    public bool WipePlayerChallenges { get; set; }
    public bool WipeReplenish { get; set; }
    public bool WipeRotatingBillboards { get; set; }
    public bool WipeSignTracker { get; set; }
    public bool WipeTargetPractice { get; set; }
    public bool WipeZLevelsRemastered { get; set; }
    public List<string> CustomConsoleCommands { get; set; }
}

 class SoftWipe
{
    public bool WipeAirstrike { get; set; }
    public bool WipeAutoPurge { get; set; }
    public bool WipeBackpacks { get; set; }
    public bool WipeBounty { get; set; }
    public bool WipeEconomics { get; set; }
    public bool WipeGUIShop { get; set; }
    public bool WipeHeliControl { get; set; }
    public bool WipeKits { get; set; }
    public bool WipeNTeleportation { get; set; }
    public bool WipePets { get; set; }
    public bool WipePlayerChallenges { get; set; }
    public bool WipeReplenish { get; set; }
    public bool WipeRotatingBillboards { get; set; }
    public bool WipeSignTracker { get; set; }
    public bool WipeTargetPractice { get; set; }
    public bool WipeZLevelsRemastered { get; set; }
    public List<string> CustomConsoleCommands { get; set; }
}


```

---

## WipeBlock by  - Blocks items for selected time after wipe

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using Random = Oxide.Core.Random;

Oxide.Plugins
[Info("Wipe Block", "Orange", "1.0.6")]
[Description("Block items for selected time after wipe")]
public class WipeBlock : RustPlugin
{
    private const string elem;
    private void Init();
    private void OnEntitySpawned(AutoTurret turret);
    private void Unload();
    private object CanEquipItem(PlayerInventory inventory, Item item, int targetPos);
    private object OnWeaponReload(BaseProjectile projectile, BasePlayer player);
    private object CanWearItem(PlayerInventory inventory, Item item, int targetPos);
    private object OnMagazineReload(BaseProjectile projectile, int desiredAmount, BasePlayer player);
    private void OnAddedItemInTurret(AutoTurret turret, Item item, bool added);
    private bool CanUseItem(BasePlayer player, string shortName);
    private int GetBlockTime(string shortname);
    private bool IsBlocked(string shortname);
    private void CheckGun(BasePlayer player, BaseProjectile weapon);
    private void ShowUI(BasePlayer player, string time);
    private double Now();
    private int Passed(double since);
    private double SaveTime();
    private int PassedSinceWipe();
    private string GetTimeString(int time);
    protected override void LoadDefaultMessages();
    private void Message(BasePlayer player, string messageKey, object[] args);
    private string GetMessage(string messageKey, string playerID, object[] args);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Shortname -> Block time")]
        public Dictionary<string, int> items;
        [JsonProperty(PropertyName = "Announcement duration")]
        public float showTime;
    }

    protected override void LoadConfig();
    private void ValidateConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private Dictionary<string, int> API_GetTimesLeft();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Shortname -> Block time")]
    public Dictionary<string, int> items;
    [JsonProperty(PropertyName = "Announcement duration")]
    public float showTime;
}


```

---

## WipeDataCleaner by 2CHEVSKII - Clears specified datafiles automatically every wipe

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Wipe Data Cleaner", "2CHEVSKII", "1.4.2")]
[Description("Cleans specified data files on new wipe.")]
 class WipeDataCleaner : CovalencePlugin
{
    const string PERMISSIONUSE;
     OxideMod Oxide;
     PluginSettings settings;
     void Init();
     void OnNewSave(string filename);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     void Wipe(IPlayer executer);
     HashSet<string> DetermineFilesToWipe();
     string SanitizeFileName(string fileName);
     string SearchFile(string name);
     string[] SearchDirectory(string name);
     string WipeFile(string file);
     bool IsNullOrWhiteSpace(string str);
     class PluginSettings
    {
        [JsonProperty("Filenames, without .json")]
        public List<string> FileNames { get; set; }
        [JsonProperty("Command (default: 'wipe')")]
        public string Command { get; set; }
        [JsonProperty("Enable logs", DefaultValueHandling = DefaultValueHandling.Populate)]
        public bool EnableLogs { get; set; }
    }

}

 class PluginSettings
{
    [JsonProperty("Filenames, without .json")]
    public List<string> FileNames { get; set; }
    [JsonProperty("Command (default: 'wipe')")]
    public string Command { get; set; }
    [JsonProperty("Enable logs", DefaultValueHandling = DefaultValueHandling.Populate)]
    public bool EnableLogs { get; set; }
}


```

---

## WipeDates by Freakyy - Shows the last and next wipe dates on command

```csharp
using System;
using System.Linq;
using System.Collections.Generic;

Oxide.Plugins
[Info("Wipe Dates", "Freakyy", "1.0.3")]
[Description("Shows the last and next wipe dates on command.")]
 class WipeDates : RustPlugin
{
    public DateTime Last_Config_Call;
    public string Last_Wipe;
    public string Next_Wipe;
    public List<string> All_Wipe_Dates;
    private Settings _Settings;
    protected override void LoadDefaultMessages();
     void Init();
     void OnPlayerSleepEnded(BasePlayer player);
    [ChatCommand("wipe")]
     void wipe(BasePlayer player);
    private void send_player_wipe_message(BasePlayer player);
    private void calculate_wipe_dates();
    private void save_config_settings();
    private class Settings
    {
        public string Last_Wipe_Message { get; set; }
        public string Next_Wipe_Message { get; set; }
        public string Date_Format { get; set; }
        public List<string> All_Wipe_Dates;
        public bool Send_Message_On_User_Wake_Up { get; set; }
        public string Server_Timezone { get; set; }
    }

    private Settings GetDefaultSettings();
    protected override void LoadDefaultConfig();
}

private class Settings
{
    public string Last_Wipe_Message { get; set; }
    public string Next_Wipe_Message { get; set; }
    public string Date_Format { get; set; }
    public List<string> All_Wipe_Dates;
    public bool Send_Message_On_User_Wake_Up { get; set; }
    public string Server_Timezone { get; set; }
}


```

---

## WipeInfo by dFxPhoeniX - Wipe Info is a plugin who shows in chat time until wipe date.

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using System.Text.RegularExpressions;
using UnityEngine;

Oxide.Plugins
[Info("Wipe Info", "dFxPhoeniX", "1.2.8")]
[Description("Adds the ablity to see wipe cycles")]
public class WipeInfo : RustPlugin
{
    private string LastWipe;
    private string NextWipe;
     Timer announceTimer;
    private void Init();
     void OnServerInitialized();
     void OnPlayerConnected(BasePlayer player);
    private DateTime ParseTime(string time);
    private string NextWipeDays(string WipeDate);
    private void LoadVariables();
    private void BroadcastWipe();
    private string msg(string key, string id, object[] args);
    private string RemoveFormatting(string source);
    [ChatCommand("wipe")]
    private void cmdNextWipe(BasePlayer player, string command, string[] args);
    [ConsoleCommand("wipe")]
    private void cmdGetWipe(ConsoleSystem.Arg arg);
    private bool ConfigChanged;
    private string DateFormat;
    private bool AnnounceOnJoin;
    private bool AnnounceOnTimer;
    private int AnnounceTimer;
    protected override void LoadDefaultConfig();
    private void InitConfig();
    private T GetConfig(T defaultVal, string[] path);
    protected override void LoadDefaultMessages();
}


```

---

## WipeInfoApi by MJSU - API for calculating time between server wipes

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;

Oxide.Plugins
[Info("Wipe Info Api", "MJSU", "1.1.0")]
[Description("Api for when the server is wiping")]
public class WipeInfoApi : RustPlugin
{
    private StoredData _storedData;
    private PluginConfig _pluginConfig;
    private DateTime _currentDate;
    private DateTime _nextWipe;
    private int _daysTillNextWipe;
    private int _currentDaysBetweenWipes;
    private bool _isForcedWipeDay;
    private bool _newSaveVersion;
    private void Init();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private PluginConfig AdditionalConfig(PluginConfig config);
    private void OnServerSave();
    private void OnNewSave(string name);
    private void OnServerInitialized();
    private void CalculateWipe();
    private DateTime GetForcedWipe(DateTime date);
    private int FindWipeDay(int year, int month, DayOfWeek day);
    private int GetDaysTillWipe();
    private DateTime GetNextWipe();
    private int GetDaysBetweenWipe();
    private bool IsForcedWipeDay();
    private bool IsNewSaveVersion();
    private void SaveData();
    private class PluginConfig
    {
        [JsonProperty("4 week schedule (Days since forced wipe)")]
        public List<int> ScheduleWeek4 { get; set; }
        [JsonProperty("5 week schedule (Days since forced wipe)")]
        public List<int> ScheduleWeek5 { get; set; }
    }

    private class StoredData
    {
        public int SaveVersion { get; set; }
        public DateTime PreviousWipe { get; set; }
    }

}

private class PluginConfig
{
    [JsonProperty("4 week schedule (Days since forced wipe)")]
    public List<int> ScheduleWeek4 { get; set; }
    [JsonProperty("5 week schedule (Days since forced wipe)")]
    public List<int> ScheduleWeek5 { get; set; }
}

private class StoredData
{
    public int SaveVersion { get; set; }
    public DateTime PreviousWipe { get; set; }
}


```

---

## WipeKits by Ryan - Puts a configurable cooldown from the wipe on each kit based on kit name

```csharp
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Wipe Kits", "Ryan", "1.2.52")]
[Description("Puts a configurable cooldown on each kit depending on their kitname.")]
public class WipeKits : RustPlugin
{
    private static ConfigFile _cFile;
    private DateTime _cachedWipeTime;
    private const string Perm;
    private class ConfigFile
    {
        [JsonProperty(PropertyName = "Kit Names & Cooldowns - Cooldowns (minutes)")]
        public Dictionary<string, float> Kits;
        [JsonProperty(PropertyName = "Use GUI Kits (true/false)")]
        public bool UseGui { get; set; }
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Regenerate();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private string GetFormattedTime(double time);
    private TimeSpan GetNextKitTime(float cooldown);
    private void OnServerInitialized();
    private object OnServerCommand(ConsoleSystem.Arg arg);
    private object OnPlayerCommand(BasePlayer player, string command, string[] args);
}

private class ConfigFile
{
    [JsonProperty(PropertyName = "Kit Names & Cooldowns - Cooldowns (minutes)")]
    public Dictionary<string, float> Kits;
    [JsonProperty(PropertyName = "Use GUI Kits (true/false)")]
    public bool UseGui { get; set; }
    public static ConfigFile DefaultConfig();
}


```

---

## WipePrize by Mevent - Rewards the first N players after map wipe

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Wipe Prize", "Mevent", "1.0.9")]
[Description("Rewards the first N players after Wipe")]
public class WipePrize : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private const string Layer;
    private static WipePrize _instance;
    private List<ulong> _connectedPlayers;
    private List<ulong> _wasGive;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Auto-wipe Settings")]
        public WipeSettings Wipe;
        [JsonProperty(PropertyName = "Amount of Players")]
        public int MaxCount;
        [JsonProperty(PropertyName = "Command")]
        public string Command;
        [JsonProperty(PropertyName = "Enable logging to the console?")]
        public bool LogToConsole;
        [JsonProperty(PropertyName = "Enable logging to the file?")]
        public bool LogToFile;
        [JsonProperty(PropertyName = "Awards", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ItemCase> Awards;
        [JsonProperty(PropertyName = "Background")]
        public IPanel Background;
        [JsonProperty(PropertyName = "Text")]
        public IText Text;
        [JsonProperty(PropertyName = "Button")]
        public IButton Button;
    }

    private class WipeSettings
    {
        [JsonProperty(PropertyName = "Connected")]
        public bool Players;
        [JsonProperty(PropertyName = "Awards received players")]
        public bool Awards;
    }

    private class ItemCase
    {
        [JsonProperty(PropertyName = "Item type")]
        [JsonConverter(typeof(StringEnumConverter))]
        public ItemType Type;
        [JsonProperty(PropertyName =
                "Display name (for the item) (if empty - standard)")]
        public string DisplayName;
        [JsonProperty(PropertyName = "Shortname")]
        public string Shortname;
        [JsonProperty(PropertyName = "Skin")]
        public ulong Skin;
        [JsonProperty(PropertyName = "Amount (for item)")]
        public int Amount;
        [JsonProperty(PropertyName = "Command")]
        public string Command;
        [JsonProperty(PropertyName = "Plugin")]
        public PluginAward PluginAward;
        private void ToItem(BasePlayer player);
        private void ToCommand(BasePlayer player);
        public void GetItem(BasePlayer player);
    }

    private class PluginAward
    {
        [JsonProperty(PropertyName = "Hook to call")]
        public string Hook;
        [JsonProperty(PropertyName = "Plugin name")]
        public string Plugin;
        [JsonProperty(PropertyName = "Amount")]
        public int Amount;
        [JsonProperty(PropertyName = "(GameStores) Store ID in the service")]
        public string ShopID;
        [JsonProperty(PropertyName = "(GameStores) Server ID in the service")]
        public string ServerID;
        [JsonProperty(PropertyName = "(GameStores) Secret key")]
        public string SecretKey;
        public void ToPluginAward(BasePlayer player);
    }

    private abstract class InterfacePosition
    {
        public string AnchorMin;
        public string AnchorMax;
        public string OffsetMin;
        public string OffsetMax;
    }

    private class IText : InterfacePosition
    {
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Text Color")]
        public string Color;
        public void Get(CuiElementContainer container, string parent, string name, string text);
    }

    private class IButton : InterfacePosition
    {
        [JsonProperty(PropertyName = "Color")]
        public string Color;
        [JsonProperty(PropertyName = "Text Color")]
        public string TextColor;
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        public void Get(CuiElementContainer container, string parent, string name, string close, string cmd, string text);
    }

    private class IPanel : InterfacePosition
    {
        [JsonProperty(PropertyName = "Image")]
        public string Image;
        [JsonProperty(PropertyName = "Color")]
        public string Color;
        [JsonProperty(PropertyName = "Preserving the color of the image?")]
        public bool IsRaw;
        public void Get(CuiElementContainer container, string parent, string name);
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private void SaveData();
    private void LoadData();
    private void Init();
    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnNewSave();
    private void GiveAwardCmd(IPlayer cov, string command, string[] args);
    private void MainUi(BasePlayer player);
    private const string GiveMoney;
    private const string UITitle;
    private const string UiButton;
    private const string GiveAward;
    private const string ReceiveAward;
    protected override void LoadDefaultMessages();
    private string Msg(string key, string userid, object[] obj);
    private void Log(string filename, string key, object[] obj);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Auto-wipe Settings")]
    public WipeSettings Wipe;
    [JsonProperty(PropertyName = "Amount of Players")]
    public int MaxCount;
    [JsonProperty(PropertyName = "Command")]
    public string Command;
    [JsonProperty(PropertyName = "Enable logging to the console?")]
    public bool LogToConsole;
    [JsonProperty(PropertyName = "Enable logging to the file?")]
    public bool LogToFile;
    [JsonProperty(PropertyName = "Awards", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ItemCase> Awards;
    [JsonProperty(PropertyName = "Background")]
    public IPanel Background;
    [JsonProperty(PropertyName = "Text")]
    public IText Text;
    [JsonProperty(PropertyName = "Button")]
    public IButton Button;
}

private class WipeSettings
{
    [JsonProperty(PropertyName = "Connected")]
    public bool Players;
    [JsonProperty(PropertyName = "Awards received players")]
    public bool Awards;
}

private class ItemCase
{
    [JsonProperty(PropertyName = "Item type")]
    [JsonConverter(typeof(StringEnumConverter))]
    public ItemType Type;
    [JsonProperty(PropertyName =
                "Display name (for the item) (if empty - standard)")]
    public string DisplayName;
    [JsonProperty(PropertyName = "Shortname")]
    public string Shortname;
    [JsonProperty(PropertyName = "Skin")]
    public ulong Skin;
    [JsonProperty(PropertyName = "Amount (for item)")]
    public int Amount;
    [JsonProperty(PropertyName = "Command")]
    public string Command;
    [JsonProperty(PropertyName = "Plugin")]
    public PluginAward PluginAward;
    private void ToItem(BasePlayer player);
    private void ToCommand(BasePlayer player);
    public void GetItem(BasePlayer player);
}

private class PluginAward
{
    [JsonProperty(PropertyName = "Hook to call")]
    public string Hook;
    [JsonProperty(PropertyName = "Plugin name")]
    public string Plugin;
    [JsonProperty(PropertyName = "Amount")]
    public int Amount;
    [JsonProperty(PropertyName = "(GameStores) Store ID in the service")]
    public string ShopID;
    [JsonProperty(PropertyName = "(GameStores) Server ID in the service")]
    public string ServerID;
    [JsonProperty(PropertyName = "(GameStores) Secret key")]
    public string SecretKey;
    public void ToPluginAward(BasePlayer player);
}

private abstract class InterfacePosition
{
    public string AnchorMin;
    public string AnchorMax;
    public string OffsetMin;
    public string OffsetMax;
}

private class IText : InterfacePosition
{
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Text Color")]
    public string Color;
    public void Get(CuiElementContainer container, string parent, string name, string text);
}

private class IButton : InterfacePosition
{
    [JsonProperty(PropertyName = "Color")]
    public string Color;
    [JsonProperty(PropertyName = "Text Color")]
    public string TextColor;
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    public void Get(CuiElementContainer container, string parent, string name, string close, string cmd, string text);
}

private class IPanel : InterfacePosition
{
    [JsonProperty(PropertyName = "Image")]
    public string Image;
    [JsonProperty(PropertyName = "Color")]
    public string Color;
    [JsonProperty(PropertyName = "Preserving the color of the image?")]
    public bool IsRaw;
    public void Get(CuiElementContainer container, string parent, string name);
}


```

---

## WipeProtection by FastBurst - Blocks raiding after wipe for so many hours

```csharp
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Text;
using Rust;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("WipeProtection", "FastBurst", "2.1.6")]
[Description("Blocks raiding after wipe for so many hours")]
 class WipeProtection : RustPlugin
{
    [PluginReference]
     Plugin HeliSupport;
    private List<BasePlayer> cooldown;
    private float wipeprotecctime;
    private bool refund;
    private bool broadcastend;
    private bool msgadmin;
    private const string permUse;
    private static WipeProtection Instance { get; set; }
    private StoredData storedData;
    private Dictionary<string, string> raidtools;
    private void Unload();
    private void Init();
    private void CheckTime();
    private void OnNewSave(string filename);
    private void OnPlayerConnected(BasePlayer player);
    private object CanHelicopterTarget(PatrolHelicopterAI heli, BaseEntity entity);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo);
    private void RemoveCD(BasePlayer player);
     bool WipeProtected();
    private void msgPlayer(BasePlayer player, BaseEntity entity);
    private void Refund(BasePlayer player, string name, BaseEntity ent);
    private void SaveFile();
    [ConsoleCommand("wp")]
    private void wipeCmd(ConsoleSystem.Arg arg);
    [ChatCommand("wp")]
    private void wipeCmd2(BasePlayer player, string command, string[] args);
    private static ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Settings")]
        public SettingOptions Settings { get; set; }
        public class SettingOptions
        {
            [JsonProperty(PropertyName = "Broadcast to chat when raid block has ended")]
            public bool broadcastend { get; set; }
            [JsonProperty(PropertyName = "Message admins on connection with info on when the raid block is ending")]
            public bool msgadmin { get; set; }
            [JsonProperty(PropertyName = "Wipe protection time (hours)")]
            public float wipeprotecctime { get; set; }
            [JsonProperty(PropertyName = "Refunding Options")]
            public RefundSettings Refunds { get; set; }
            public class RefundSettings
            {
                [JsonProperty(PropertyName = "Allow Refunding of Explosives & Rockets")]
                public bool RefundAmmo { get; set; }
                [JsonProperty(PropertyName = "Enable notifican on refunding of ammo types")]
                public bool NotifyRefund { get; set; }
                [JsonProperty(PropertyName = "Enable notifican on denial of refunding of ammo types")]
                public bool NotifyRefundNo { get; set; }
            }

        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private T GetConfig(string name, T defaultValue);
    private class StoredData
    {
        public bool wipeprotection;
        public string lastwipe;
        public string RaidStartTime;
        public StoredData();
    }

    private static void SendChatMessage(string key, object[] args);
    private static string msg(string key, string playerId);
    private Dictionary<string, string> Messages;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Settings")]
    public SettingOptions Settings { get; set; }
    public class SettingOptions
    {
        [JsonProperty(PropertyName = "Broadcast to chat when raid block has ended")]
        public bool broadcastend { get; set; }
        [JsonProperty(PropertyName = "Message admins on connection with info on when the raid block is ending")]
        public bool msgadmin { get; set; }
        [JsonProperty(PropertyName = "Wipe protection time (hours)")]
        public float wipeprotecctime { get; set; }
        [JsonProperty(PropertyName = "Refunding Options")]
        public RefundSettings Refunds { get; set; }
        public class RefundSettings
        {
            [JsonProperty(PropertyName = "Allow Refunding of Explosives & Rockets")]
            public bool RefundAmmo { get; set; }
            [JsonProperty(PropertyName = "Enable notifican on refunding of ammo types")]
            public bool NotifyRefund { get; set; }
            [JsonProperty(PropertyName = "Enable notifican on denial of refunding of ammo types")]
            public bool NotifyRefundNo { get; set; }
        }

    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class SettingOptions
{
    [JsonProperty(PropertyName = "Broadcast to chat when raid block has ended")]
    public bool broadcastend { get; set; }
    [JsonProperty(PropertyName = "Message admins on connection with info on when the raid block is ending")]
    public bool msgadmin { get; set; }
    [JsonProperty(PropertyName = "Wipe protection time (hours)")]
    public float wipeprotecctime { get; set; }
    [JsonProperty(PropertyName = "Refunding Options")]
    public RefundSettings Refunds { get; set; }
    public class RefundSettings
    {
        [JsonProperty(PropertyName = "Allow Refunding of Explosives & Rockets")]
        public bool RefundAmmo { get; set; }
        [JsonProperty(PropertyName = "Enable notifican on refunding of ammo types")]
        public bool NotifyRefund { get; set; }
        [JsonProperty(PropertyName = "Enable notifican on denial of refunding of ammo types")]
        public bool NotifyRefundNo { get; set; }
    }

}

public class RefundSettings
{
    [JsonProperty(PropertyName = "Allow Refunding of Explosives & Rockets")]
    public bool RefundAmmo { get; set; }
    [JsonProperty(PropertyName = "Enable notifican on refunding of ammo types")]
    public bool NotifyRefund { get; set; }
    [JsonProperty(PropertyName = "Enable notifican on denial of refunding of ammo types")]
    public bool NotifyRefundNo { get; set; }
}

private class StoredData
{
    public bool wipeprotection;
    public string lastwipe;
    public string RaidStartTime;
    public StoredData();
}


```

---

## WipeSchedule by k1lly0u - Adds the ablity to report regular wipe cycles

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;

Oxide.Plugins
[Info("Wipe Schedule", "k1lly0u", "2.0.5")]
[Description("Adds the ablity to report regular wipe cycles")]
 class WipeSchedule : RustPlugin
{
     DateTime NextWipeDate;
     Timer announceTimer;
     void OnServerInitialized();
     void OnPlayerConnected(BasePlayer player);
     void Unload();
    private DateTime ParseTime(string time);
    private void UpdateWipeDates();
    private void LoadWipeDates();
    private string NextWipeDays(DateTime WipeDate);
    private void BroadcastWipe();
    [ChatCommand("nextwipe")]
    private void cmdNextWipe(BasePlayer player, string command, string[] args);
    [ChatCommand("setwipe")]
    private void cmdSetWipe(BasePlayer player, string command, string[] args);
    [ConsoleCommand("setwipe")]
    private void ccmdSetWipe(ConsoleSystem.Arg arg);
    [ConsoleCommand("getwipe")]
    private void ccmdGetWipe(ConsoleSystem.Arg arg);
    [ChatCommand("setnextwipe")]
    private void cmdSetNextWipe(BasePlayer player, string command, string[] args);
    [ConsoleCommand("setnextwipe")]
    private void ccmdSetNextWipe(ConsoleSystem.Arg arg);
    private ConfigData configData;
     class ConfigData
    {
        public string DateFormat { get; set; }
        public int DaysBetweenWipes { get; set; }
        public string LastWipe { get; set; }
        public string NextWipe { get; set; }
        public bool AnnounceOnJoin { get; set; }
        public bool UseManualNextWipe { get; set; }
        public bool AnnounceOnTimer { get; set; }
        public int AnnounceTimer { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
    private string MSG(string key, string playerid);
    protected override void LoadDefaultMessages();
}

 class ConfigData
{
    public string DateFormat { get; set; }
    public int DaysBetweenWipes { get; set; }
    public string LastWipe { get; set; }
    public string NextWipe { get; set; }
    public bool AnnounceOnJoin { get; set; }
    public bool UseManualNextWipe { get; set; }
    public bool AnnounceOnTimer { get; set; }
    public int AnnounceTimer { get; set; }
}


```

---

## WipeTimer by Rick6 - Allows players to check when the next wipe is

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Wipe Timer", "Rick", "1.1.0")]
[Description("Allows players to check when the next wipe is")]
 class WipeTimer : CovalencePlugin
{
     DefaultConfig config;
     class DefaultConfig
    {
        public int year;
        public int month;
        public int day;
        public int hour;
        public int min;
        public int sec;
        public bool AutoRespond;
        public bool AnnouceOnConnect;
    }

    protected override void LoadDefaultConfig();
    private new void LoadDefaultMessages();
     void Init();
    [Command("wipe")]
     void cmdWipe(IPlayer p, string command, string[] args);
     object OnUserChat(IPlayer p, string message);
     void OnUserConnected(IPlayer p);
     T GetConfig(string name, T value);
     string Lang(string key, string id, object[] args);
}

 class DefaultConfig
{
    public int year;
    public int month;
    public int day;
    public int hour;
    public int min;
    public int sec;
    public bool AutoRespond;
    public bool AnnouceOnConnect;
}


```

---

## WoodSwap by TheFriendlyChap - Swaps wood for charcoal with one command, default command `/char` can be changed in the config file.

```csharp
using System.Collections.Generic;
using Rust;
using System;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("Wood Swap", "The Friendly Chap", "1.0.4")]
[Description("Instanty burns wood into charcoal on command")]
public class WoodSwap : RustPlugin
{
    private const string permUse;
    private void Init();
    private void cmdSwapConsole(ConsoleSystem.Arg arg);
    private void cmdSwapChat(BasePlayer player);
    private void SwapWood(BasePlayer player);
    private void ShowLogo();
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Command")]
        public string command;
        [JsonProperty(PropertyName = "Rate")]
        public float rate;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void Message(BasePlayer player, string messageKey, object[] args);
    private string GetMessage(string messageKey, string playerID, object[] args);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Command")]
    public string command;
    [JsonProperty(PropertyName = "Rate")]
    public float rate;
}


```

---

## WorkcartSafeZones by WhiteThunder - Adds mobile safe zones and optional NPC auto turrets to workcarts

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using VLB;

Oxide.Plugins
[Info("Workcart Safe Zones", "WhiteThunder", "2.0.1")]
[Description("Adds mobile safe zones and optional NPC auto turrets to workcarts.")]
internal class WorkcartSafeZones : CovalencePlugin
{
    [PluginReference]
    private Plugin AutomatedWorkcarts;
    private Plugin CargoTrainEvent;
    private static WorkcartSafeZones _pluginInstance;
    private static Configuration _pluginConfig;
    private const string PermissionUse;
    private const string BanditSentryPrefab;
    private const float SafeZoneWarningCooldown;
    private Dictionary<ulong, float> _playersLastWarnedTime;
    private SavedData _pluginData;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnEntitySpawned(TrainEngine workcart);
    private bool? OnEntityTakeDamage(TrainEngine workcart);
    private void OnEntityEnter(TriggerSafeZone triggerSafeZone, BasePlayer player);
    private void OnEntityEnter(TriggerParent triggerParent, BasePlayer player);
    private void OnWorkcartAutomationStarted(TrainEngine workcart);
    private void OnWorkcartAutomationStopped(TrainEngine workcart);
    private void OnTrainEventStarted(TrainEngine workcart);
    private void CheckDependencies();
    private TrainEngine[] GetAutomatedWorkcarts();
    private bool IsCargoTrain(TrainEngine workcart);
    private bool API_CreateSafeZone(TrainEngine workcart);
    private static bool CreateSafeZoneWasBlocked(TrainEngine workcart);
    private static void CallHookSafeZoneCreated(TrainEngine workcart);
    [Command("safecart.add")]
    private void CommandAddSafeZone(IPlayer player, string cmd, string[] args);
    [Command("safecart.remove")]
    private void CommandRemoveSafeZone(IPlayer player, string cmd, string[] args);
    private static bool TryCreateSafeZone(TrainEngine workcart);
    private static NPCAutoTurret SpawnTurret(BaseEntity entity, Vector3 position, float rotationAngle);
    private static BaseEntity GetLookEntity(BasePlayer player, float maxDistance);
    private class SafeWorkcart : MonoBehaviour
    {
        public static void AddToWorkcart(TrainEngine workcart);
        public static void RemoveFromWorkcart(TrainEngine workcart);
        private TrainEngine _workcart;
        private GameObject _child;
        private ProtectionProperties _originalProtection;
        private List<NPCAutoTurret> _autoTurrets;
        private void Awake();
        private void MaybeAddTurrets();
        private void AddVolumetricSafeZone();
        private void OnDestroy();
    }

    private class SavedData
    {
        [JsonProperty("SafeWorkcartIds")]
        public List<ulong> SafeWorkcarts;
        public static SavedData Load();
        public void Save();
        public void AddWorkcart(TrainEngine workcart);
        public void RemoveWorkcart(TrainEngine workcart);
        public void CleanStaleData();
    }

    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("AddToAllWorkcarts")]
        public bool AddToAllWorkcarts;
        [JsonProperty("AddToAutomatedWorkcarts")]
        public bool AddToAutomatedWorkcarts;
        [JsonProperty("SafeZoneRadius")]
        public float SafeZoneRadius;
        [JsonProperty("DisarmOccupants")]
        public bool DisarmOccupants;
        [JsonProperty("EnableTurrets")]
        public bool EnableTurrets;
        [JsonProperty("TurretPositions")]
        public TurretConfig[] TurretPositions;
    }

    private class TurretConfig
    {
        [JsonProperty("Position")]
        public Vector3 Position;
        [JsonProperty("RotationAngle")]
        public float RotationAngle;
    }

    private Configuration GetDefaultConfig();
    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    private void ChatMessage(BasePlayer player, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    private string GetMessage(string playerId, string messageName, object[] args);
    protected override void LoadDefaultMessages();
}

private class SafeWorkcart : MonoBehaviour
{
    public static void AddToWorkcart(TrainEngine workcart);
    public static void RemoveFromWorkcart(TrainEngine workcart);
    private TrainEngine _workcart;
    private GameObject _child;
    private ProtectionProperties _originalProtection;
    private List<NPCAutoTurret> _autoTurrets;
    private void Awake();
    private void MaybeAddTurrets();
    private void AddVolumetricSafeZone();
    private void OnDestroy();
}

private class SavedData
{
    [JsonProperty("SafeWorkcartIds")]
    public List<ulong> SafeWorkcarts;
    public static SavedData Load();
    public void Save();
    public void AddWorkcart(TrainEngine workcart);
    public void RemoveWorkcart(TrainEngine workcart);
    public void CleanStaleData();
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("AddToAllWorkcarts")]
    public bool AddToAllWorkcarts;
    [JsonProperty("AddToAutomatedWorkcarts")]
    public bool AddToAutomatedWorkcarts;
    [JsonProperty("SafeZoneRadius")]
    public float SafeZoneRadius;
    [JsonProperty("DisarmOccupants")]
    public bool DisarmOccupants;
    [JsonProperty("EnableTurrets")]
    public bool EnableTurrets;
    [JsonProperty("TurretPositions")]
    public TurretConfig[] TurretPositions;
}

private class TurretConfig
{
    [JsonProperty("Position")]
    public Vector3 Position;
    [JsonProperty("RotationAngle")]
    public float RotationAngle;
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## WorkingMan by mothball187 - Limits daily and weekly play times of players

```csharp
using System;
using System.Globalization;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("Working Man", "pilate/mothball187", "0.1")]
[Description("Limit playtime per user")]
 class WorkingMan : CovalencePlugin
{
    [PluginReference]
    private Plugin GUIAnnouncements;
    private Plugin TimeOfDay;
    private DynamicConfigFile timeData;
    private PluginConfig config;
    private int dayWarningThreshold1;
    private int dayWarningThreshold2;
    private int weekWarningThreshold1;
    private int weekWarningThreshold2;
    private int WARNING1_INTERVAL;
    private int WARNING2_INTERVAL;
    private bool countTime;
    protected override void LoadDefaultMessages();
    [Command("workingman.reset")]
    private void ResetTimer(IPlayer player, string command, string[] args);
    [Command("workingman.setdaytimer")]
    private void SetDayTimer(IPlayer player, string command, string[] args);
    [Command("workingman.setweektimer")]
    private void SetWeekTimer(IPlayer player, string command, string[] args);
    [Command("workingman.setdaylimit")]
    private void SetDayLimit(IPlayer player, string command, string[] args);
    [Command("workingman.setweeklimit")]
    private void SetWeekLimit(IPlayer player, string command, string[] args);
    [Command("workingman.setweekstartday")]
    private void SetWeekStartDay(IPlayer player, string command, string[] args);
    [Command("workingman.settimenights")]
    private void SetTimeNights(IPlayer player, string command, string[] args);
    [Command("workingman.resetdefaults")]
    private void ResetDefaults(IPlayer player, string command, string[] args);
    [Command("workingman.setwarn1")]
    private void SetWarningThreshold1(IPlayer player, string command, string[] args);
    [Command("workingman.setwarn2")]
    private void SetWarningThreshold2(IPlayer player, string command, string[] args);
    [Command("workingman.givetimeday")]
    private void GiveTimeDay(IPlayer player, string command, string[] args);
    [Command("workingman.givetimeweek")]
    private void GiveTimeWeek(IPlayer player, string command, string[] args);
    [Command("checktimer")]
    private void CheckTimer(IPlayer player, string command, string[] args);
    private void OnTimeSunset();
    private void OnTimeSunrise();
    private void Unload();
    private void OnServerSave();
    private string WeekOfYear();
    public static DateTime GetNextWeekday(DateTime start, DayOfWeek day);
    private TimeSpan TimeTilNextWeekCycle();
    private TimeSpan TimeTilNextDayCycle();
    private string FormatTimeSpan(long minutes);
    private string FormatTimeSpan2(long minutes);
     class PluginConfig
    {
        public long minutesPerDay { get; set; }
        public long minutesPerWeek { get; set; }
        public long warningThreshold1 { get; set; }
        public long warningThreshold2 { get; set; }
        public int dayOfWeek { get; set; }
        public bool timeNights { get; set; }
    }

    private void Init();
    private void MsgPlayer(BasePlayer player, string msg);
    private void UpdateLoop();
    protected override void LoadDefaultConfig();
    private object CanUserLogin(Network.Connection connection);
    private void SaveConfig();
    private void ResetWarningThresholds();
}

 class PluginConfig
{
    public long minutesPerDay { get; set; }
    public long minutesPerWeek { get; set; }
    public long warningThreshold1 { get; set; }
    public long warningThreshold2 { get; set; }
    public int dayOfWeek { get; set; }
    public bool timeNights { get; set; }
}


```

---

## WorkshopSkinViewer by DezLife - Allows players to check how item skins looks

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

Oxide.Plugins
[Info("Workshop Skin Viewer", "Orange", "1.0.0")]
[Description("Allows you to check item skins from workshop")]
public class WorkshopSkinViewer : RustPlugin
{
    private const string permUse;
    private void Init();
    private void cmdGiveSkinnedItem(BasePlayer player, string command, string[] args);
    private void GiveItem(BasePlayer player, string shortname, string skinIDString);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Command")]
        public string command;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void Message(BasePlayer player, string messageKey, object[] args);
    private string GetMessage(string messageKey, string playerID, object[] args);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Command")]
    public string command;
}


```

---

## WorldShops by  - Create vending machines that automatically restock themselves

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("WorldShops", "4aiur", "1.1.1", ResourceId = 2820)]
[Description("Allows for automated vending machines.")]
public class WorldShops : RustPlugin
{
    private static PluginTimers _timer;
    private Dictionary<BasePlayer, WorldShopsSettings.Shop> queuedShops;
    private List<BasePlayer> queuedWipes;
    private Dictionary<BasePlayer, WorldShopsSettings.Shop> queuedSaves;
    private List<BasePlayer> queuedDisables;
    private List<BasePlayer> queuedSpawns;
    private static Dictionary<VendingMachine, WorldShopsSettings.Shop> _activeShops;
    private void Init();
    private void OnPlayerSleep(BasePlayer player);
    private void OnPlayerSleepEnded(BasePlayer player);
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    [ChatCommand("wshop")]
    private void ShopCommand(BasePlayer player, string command, string[] args);
    private static void PlayerLootContainer(BasePlayer player, StorageContainer container, string panelName);
    protected override void LoadDefaultConfig();
    private void Unload();
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private object CanBuild(Planner planner, Construction prefab, Construction.Target target);
    private void OnPlayerAttack(BasePlayer attacker, HitInfo info);
    private void OnHammerHit(BasePlayer player, HitInfo info);
    private void OnEntityKill(BaseNetworkable entity);
    private void OnVendingTransaction(VendingMachine machine, BasePlayer buyer, int sellOrderId, int numberOfTransactions);
    private void ApplyMachine(VendingMachine machine, WorldShopsSettings.Shop shop);
    private void WipeMachine(VendingMachine machine);
    private void SaveMachine(VendingMachine machine, WorldShopsSettings.Shop shop);
    private Item GetBlueprint(ItemDefinition learnableItem, int amount);
    private object CanAdministerVending(VendingMachine machine, BasePlayer player);
    private object OnRotateVendingMachine(VendingMachine machine, BasePlayer player);
    private string Lang(string key, BasePlayer player, object[] args);
    private class ShopBlock : MonoBehaviour
    {
        private BasePlayer player;
        private bool notificaitonActive;
        private bool notificationShown;
        public void Start();
        public void Update();
        private void ShowGui(bool exiting);
        public void Dispose();
    }

    private class WorldShopsSettings
    {
        public class Item
        {
            [JsonIgnore]
            public ItemDefinition Definition { get; set; }
            public string ShortName { get; set; }
            public int Quantity { get; set; }
            public bool Blueprint { get; set; }
        }

        public class SellOrder
        {
            [JsonIgnore]
            public ProtoBuf.VendingMachine.SellOrder ProtoBuf { get; set; }
            public Item SellItem { get; set; }
            public Item BuyItem { get; set; }
        }

        public class Shop
        {
            public SellOrder[] SellOrders { get; set; }
            public string WorldName { get; set; }
            public string CommandName { get; set; }
            public ulong SkinId { get; set; }
            public float BuildingBlockedDistance { get; set; }
        }

        public class ShopNotification
        {
            public bool Enabled { get; set; }
            public float FadeIn { get; set; }
            public float WaitTime { get; set; }
            public float FadeOut { get; set; }
        }

        public class General
        {
            public List<Shop> Shops { get; set; }
            public ShopNotification Notification { get; set; }
        }

        public static General Loaded;
    }

    private class WorldShopsData
    {
        public class General
        {
            public Dictionary<string, string> Shops { get; set; }
        }

        public static General Loaded;
    }

}

private class ShopBlock : MonoBehaviour
{
    private BasePlayer player;
    private bool notificaitonActive;
    private bool notificationShown;
    public void Start();
    public void Update();
    private void ShowGui(bool exiting);
    public void Dispose();
}

private class WorldShopsSettings
{
    public class Item
    {
        [JsonIgnore]
        public ItemDefinition Definition { get; set; }
        public string ShortName { get; set; }
        public int Quantity { get; set; }
        public bool Blueprint { get; set; }
    }

    public class SellOrder
    {
        [JsonIgnore]
        public ProtoBuf.VendingMachine.SellOrder ProtoBuf { get; set; }
        public Item SellItem { get; set; }
        public Item BuyItem { get; set; }
    }

    public class Shop
    {
        public SellOrder[] SellOrders { get; set; }
        public string WorldName { get; set; }
        public string CommandName { get; set; }
        public ulong SkinId { get; set; }
        public float BuildingBlockedDistance { get; set; }
    }

    public class ShopNotification
    {
        public bool Enabled { get; set; }
        public float FadeIn { get; set; }
        public float WaitTime { get; set; }
        public float FadeOut { get; set; }
    }

    public class General
    {
        public List<Shop> Shops { get; set; }
        public ShopNotification Notification { get; set; }
    }

    public static General Loaded;
}

public class Item
{
    [JsonIgnore]
    public ItemDefinition Definition { get; set; }
    public string ShortName { get; set; }
    public int Quantity { get; set; }
    public bool Blueprint { get; set; }
}

public class SellOrder
{
    [JsonIgnore]
    public ProtoBuf.VendingMachine.SellOrder ProtoBuf { get; set; }
    public Item SellItem { get; set; }
    public Item BuyItem { get; set; }
}

public class Shop
{
    public SellOrder[] SellOrders { get; set; }
    public string WorldName { get; set; }
    public string CommandName { get; set; }
    public ulong SkinId { get; set; }
    public float BuildingBlockedDistance { get; set; }
}

public class ShopNotification
{
    public bool Enabled { get; set; }
    public float FadeIn { get; set; }
    public float WaitTime { get; set; }
    public float FadeOut { get; set; }
}

public class General
{
    public List<Shop> Shops { get; set; }
    public ShopNotification Notification { get; set; }
}

private class WorldShopsData
{
    public class General
    {
        public Dictionary<string, string> Shops { get; set; }
    }

    public static General Loaded;
}

public class General
{
    public Dictionary<string, string> Shops { get; set; }
}


```

---

## WoundedDrop by birthdates - Players who are wounded are no longer able to drop items in their hotbar

```csharp

Oxide.Plugins
[Info("Wounded Drop", "birthdates", "1.0.0")]
[Description("Players who are wounded are no longer able to drop items in their hotbar.")]
public class WoundedDrop : RustPlugin
{
     object OnItemAction(Item item, string action, BasePlayer player);
}


```

---

## WoundedScreams by Death - Restores the screams when a player gets wounded

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("Wounded Screams", "Death", "2.2.3")]
[Description("Restored scream when a player is wounded")]
 class WoundedScreams : RustPlugin
{
     Dictionary<ulong, Timer> Collection;
    const string exclude;
    const string nocooldown;
    const string ondemand;
     bool Sub;
     Timer Get;
     void Init();
     void Unload();
     object OnPlayerWound(BasePlayer p);
     void OnEntityDeath(BaseCombatEntity e);
     void OnPlayerDisconnected(BasePlayer p);
     void PlayFX(BasePlayer p);
     void Destroy(BasePlayer p);
     void Unsub();
    [ConsoleCommand("scream")]
     void ConsoleCommand(ConsoleSystem.Arg arg);
    [ChatCommand("scream")]
     void ChatCommand(BasePlayer p);
    private ConfigData configData;
     class ConfigData
    {
        public Options Options;
    }

     class Options
    {
        public bool Enable_Scream_Ondemand;
        public string FX_Sound;
        public float Interval;
        public float Scream_Cooldown;
    }

    private void LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConfig(ConfigData config);
    protected override void LoadDefaultMessages();
    private string msg(string key, string id);
}

 class ConfigData
{
    public Options Options;
}

 class Options
{
    public bool Enable_Scream_Ondemand;
    public string FX_Sound;
    public float Interval;
    public float Scream_Cooldown;
}


```

---

## WPBridge by Murky - Integrates uMod/Oxide-enabled Rust servers with WordPress

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("WordPress Bridge", "Murky", "1.2.12")]
[Description("WordPress Bridge integrates Rust servers with Wordpress, making it possible to embed player and server statistics on your Wordpress site with shortcodes.")]
internal class WPBridge : RustPlugin
{
     WPBridge GetInstance();
    private bool _isConfiguredAndReady;
    private Configuration _config;
    static WPBridge _instance;
    public static WebRequester webRequester;
     WPBServer WPBServerData;
     List<WPBPlayer> WPBPlayerData;
     string _reservedPlayerGroupName;
     WordPressBridgeRequest wordPressRequest;
     Timer syncTimer;
     string endPointUriSecret;
     string endPointUriSync;
    static List<string> WPBPlayersLeftSteamIds;
     System.Diagnostics.Stopwatch stopWatch;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void InitConfig(Action<bool, string> p);
     void WordPressSiteIsUp(Action<bool,string> returnMethod);
     bool WordPressPluginInstalled(WordPressJson json);
    private void TryValidateWordPressSecret(Action<bool> returnMethod);
    private void WPBRidgeInit();
     void Sync();
     void WPBPlayerOnLoot(Item item, BasePlayer basePlayer);
    private WPBPlayer GetWPBPlayer(BasePlayer basePlayer);
    private WPBPlayer GetWPBPlayer(IPlayer iPlayer);
    private void UpdateWPBPlayers();
    private void ClearWPBPlayerStats();
    private void ClearWPBPlayerLoot();
    private void WPBUpdatePlayer(BasePlayer basePlayer);
    private bool WPBPlayerExists(WPBPlayer wpbPlayer);
    private WPBPlayer CreateWPBPlayer(IPlayer iPlayer);
    private void InsertWPBPlayer(WPBPlayer wpbPlayer);
    private void InsertWPBPlayer(IPlayer iPlayer);
    private void RemoveWPBPlayer(WPBPlayer wpbPlayer);
    private void RemoveWPBPlayer(BasePlayer basePlayer);
    protected override void LoadDefaultMessages();
     void Init();
     void OnServerInitialized(bool initial);
     void OnPlayerConnected(BasePlayer basePlayer);
     void OnUserConnected(IPlayer iPlayer);
     void OnPlayerDisconnected(BasePlayer basePlayer);
     void OnPlayerRespawned(BasePlayer basePlayer);
     object OnUserChat(IPlayer iPlayer);
     void OnPlayerRecovered(BasePlayer basePlayer);
     object OnPlayerWound(BasePlayer basePlayer);
     object OnPlayerDeath(BasePlayer basePlayer, HitInfo hitInfo);
     object OnPlayerVoice(BasePlayer basePlayer, byte[] data);
     void OnMeleeAttack(BasePlayer basePlayer, HitInfo info);
     void OnMapMarkerAdded(BasePlayer basePlayer);
     object OnPlayerViolation(BasePlayer basePlayer, AntiHackType type, float amount);
     void OnNpcConversationEnded(NPCTalking npcTalking, BasePlayer basePlayer);
    private void OnLootEntityEnd(BasePlayer basePlayer, BaseEntity baseEntity);
     object OnEntityTakeDamage(BaseCombatEntity baseCombatEntity, HitInfo hitInfo);
     object OnItemPickup(Item item, BasePlayer basePlayer);
     void OnItemCraftFinished(ItemCraftTask itemCraftTask, Item item);
     object OnItemRepair(BasePlayer basePlayer, Item item);
     void OnItemResearch(ResearchTable researchTable, Item item, BasePlayer basePlayer);
     void OnExplosiveThrown(BasePlayer basePlayer);
     object OnReloadWeapon(BasePlayer basePlayer);
     void OnWeaponFired(BaseProjectile baseProjectile, BasePlayer basePlayer);
     void OnRocketLaunched(BasePlayer basePlayer);
     object OnHammerHit(BasePlayer basePlayer, HitInfo info);
     object OnDispenserGather(ResourceDispenser resourceDispenser, BaseEntity baseEntity, Item item);
     object OnDispenserBonus(ResourceDispenser resourceDispenser, BaseEntity baseEntity, Item item);
     object OnCollectiblePickup(Item item, BasePlayer basePlayer);
     object OnGrowableGather(GrowableEntity growableEntity, Item item, BasePlayer basePlayer);
    private bool TryCreateReservedGroup();
    private bool WPBPlayerIsReserved(BasePlayer basePlayer);
    private bool WPBPlayerIsReserved(IPlayer iPlayer);
    private class Configuration
    {
        [JsonProperty(PropertyName = "External_IP")]
        public string External_IP;
        [JsonProperty(PropertyName = "Wordpress_Site_URL")]
        public string Wordpress_Site_URL;
        [JsonProperty(PropertyName = "Wordpress_Secret")]
        public string Wordpress_Secret;
        [JsonProperty(PropertyName = "Player_Data_Update_Interval")]
        public int UpdateInterval;
        [JsonProperty(PropertyName = "Print_Debug_To_Console")]
        public bool Debug;
    }

    internal class WPBServer
    {
        public WPBServer(string ip, int port, string level, string identity, int seed, int worldsize, int maxPlayers, string hostName, string description);
        public void UpdatePlayerCount();
        public string IP { get; set; }
        public int Port { get; set; }
        public string Level { get; set; }
        public string Identity { get; set; }
        public int Seed { get; set; }
        public int WorldSize { get; set; }
        public int MaxPlayers { get; set; }
        public string HostName { get; set; }
        public string Description { get; set; }
        public int PlayerCount { get; set; }
    }

    internal class LootItem
    {
        public string Name;
        public int Amount;
        public LootItem(string name, int amount);
    }

    internal class WPBPlayer
    {
        private string _steamID;
        private string _displayName;
        private Vector3 _position;
        private WPBPlayerStats _stats;
        private List<LootItem> _lootedItems;
        public string SteamID { get; set; }
        public string DisplayName { get; set; }
        public Vector3 Position { get; set; }
        public WPBPlayerStats Stats { get; set; }
        public List<LootItem> LootedItems { get; set; }
        public WPBPlayer(string steamID, string displayName);
        public WPBPlayer(IPlayer iPlayer);
        public WPBPlayer(BasePlayer p);
        internal void SetPosition(int x, int y, int z);
        internal void SetPosition(Vector3 vector3);
        internal void ClearStats();
        internal void ClearLoot();
    }

    internal class WPBPlayerStats
    {
        public int Joins { get; set; }
        public int Leaves { get; set; }
        public int Deaths { get; set; }
        public int Suicides { get; set; }
        public int Kills { get; set; }
        public int Headshots { get; set; }
        public int Wounded { get; set; }
        public int Recoveries { get; set; }
        public int CraftedItems { get; set; }
        public int RepairedItems { get; set; }
        public int ExplosivesThrown { get; set; }
        public int VoiceBytes { get; set; }
        public int HammerHits { get; set; }
        public int Reloads { get; set; }
        public int Shots { get; set; }
        public int CollectiblesPickedUp { get; set; }
        public int GrowablesGathered { get; set; }
        public int Chats { get; set; }
        public int NPCKills { get; set; }
        public int MeleeAttacks { get; set; }
        public int MapMarkers { get; set; }
        public int Respawns { get; set; }
        public int RocketsLaunched { get; set; }
        public int AntiHackViolations { get; set; }
        public int NPCSpeaks { get; set; }
        public int ResearchedItems { get; set; }
        public int KilledByNPC { get; set; }
        public int LootContainer { get; set; }
        public int LootBradHeli { get; set; }
        public int LootHackable { get; set; }
        public int LootContainerUnderWater { get; set; }
        public void Clear();
    }

    public class WebRequester
    {
        static Dictionary<string, string> _headers;
        public void Post(string url, object data, Action<int,string> response);
        internal void Get(string url, object data, Action<int, string> response);
    }

    public class WordPressBridgeResponse
    {
        public string code;
        public string message;
        public object data;
    }

    public class WordPressBridgeRequest
    {
        public WordPressBridgeRequest(string secret);
        public void SetPlayerData(List<WPBPlayer> playerData);
        public void SetServerData(WPBServer serverData);
         string _secret;
         List<WPBPlayer> _playerData;
         WPBServer _serverData;
        [JsonProperty(PropertyName = "Secret")]
         string Secret { get; set; }
        [JsonProperty(PropertyName = "PlayerData")]
         List<WPBPlayer> PlayerData { get; set; }
        [JsonProperty(PropertyName = "ServerData")]
         WPBServer ServerData { get; set; }
    }

     class WordPressJson
    {
        public string name { get; set; }
        public string description { get; set; }
        public string url { get; set; }
        public string home { get; set; }
        public WordPressJsonRoutes routes { get; set; }
    }

     class WordPressJsonRoutes
    {
        [JsonProperty("/wpbridge")]
        public WordPressJsonRouteWPBridge Wpbridge { get; set; }
    }

     class WordPressJsonRouteWPBridge
    {
        public List<string> methods { get; set; }
    }

    [ChatCommand("wip.help")]
     void HelpCommand(BasePlayer basePlayer, string command, string[] args);
    [ConsoleCommand("wip.debug")]
     void ToggleDebug(ConsoleSystem.Arg arg);
    [ChatCommand("wip.isreserved")]
     void IsReserved(BasePlayer basePlayer, string command, string[] args);
    [ChatCommand("wip.reserve")]
     void ReserveCommand(BasePlayer basePlayer, string command, string[] args);
    private void PrintDebug(string stringToPrint);
    private void PrintDebug(int intToPrint);
    private void PrintDebug(bool boolToPrint);
    private void PrintDebug(Type typeToPrint);
    private string GetMsg(string key);
    public static bool ValidHttpURL(string s);
    public bool ValidIPv4(string ipString);
}

private class Configuration
{
    [JsonProperty(PropertyName = "External_IP")]
    public string External_IP;
    [JsonProperty(PropertyName = "Wordpress_Site_URL")]
    public string Wordpress_Site_URL;
    [JsonProperty(PropertyName = "Wordpress_Secret")]
    public string Wordpress_Secret;
    [JsonProperty(PropertyName = "Player_Data_Update_Interval")]
    public int UpdateInterval;
    [JsonProperty(PropertyName = "Print_Debug_To_Console")]
    public bool Debug;
}

internal class WPBServer
{
    public WPBServer(string ip, int port, string level, string identity, int seed, int worldsize, int maxPlayers, string hostName, string description);
    public void UpdatePlayerCount();
    public string IP { get; set; }
    public int Port { get; set; }
    public string Level { get; set; }
    public string Identity { get; set; }
    public int Seed { get; set; }
    public int WorldSize { get; set; }
    public int MaxPlayers { get; set; }
    public string HostName { get; set; }
    public string Description { get; set; }
    public int PlayerCount { get; set; }
}

internal class LootItem
{
    public string Name;
    public int Amount;
    public LootItem(string name, int amount);
}

internal class WPBPlayer
{
    private string _steamID;
    private string _displayName;
    private Vector3 _position;
    private WPBPlayerStats _stats;
    private List<LootItem> _lootedItems;
    public string SteamID { get; set; }
    public string DisplayName { get; set; }
    public Vector3 Position { get; set; }
    public WPBPlayerStats Stats { get; set; }
    public List<LootItem> LootedItems { get; set; }
    public WPBPlayer(string steamID, string displayName);
    public WPBPlayer(IPlayer iPlayer);
    public WPBPlayer(BasePlayer p);
    internal void SetPosition(int x, int y, int z);
    internal void SetPosition(Vector3 vector3);
    internal void ClearStats();
    internal void ClearLoot();
}

internal class WPBPlayerStats
{
    public int Joins { get; set; }
    public int Leaves { get; set; }
    public int Deaths { get; set; }
    public int Suicides { get; set; }
    public int Kills { get; set; }
    public int Headshots { get; set; }
    public int Wounded { get; set; }
    public int Recoveries { get; set; }
    public int CraftedItems { get; set; }
    public int RepairedItems { get; set; }
    public int ExplosivesThrown { get; set; }
    public int VoiceBytes { get; set; }
    public int HammerHits { get; set; }
    public int Reloads { get; set; }
    public int Shots { get; set; }
    public int CollectiblesPickedUp { get; set; }
    public int GrowablesGathered { get; set; }
    public int Chats { get; set; }
    public int NPCKills { get; set; }
    public int MeleeAttacks { get; set; }
    public int MapMarkers { get; set; }
    public int Respawns { get; set; }
    public int RocketsLaunched { get; set; }
    public int AntiHackViolations { get; set; }
    public int NPCSpeaks { get; set; }
    public int ResearchedItems { get; set; }
    public int KilledByNPC { get; set; }
    public int LootContainer { get; set; }
    public int LootBradHeli { get; set; }
    public int LootHackable { get; set; }
    public int LootContainerUnderWater { get; set; }
    public void Clear();
}

public class WebRequester
{
    static Dictionary<string, string> _headers;
    public void Post(string url, object data, Action<int,string> response);
    internal void Get(string url, object data, Action<int, string> response);
}

public class WordPressBridgeResponse
{
    public string code;
    public string message;
    public object data;
}

public class WordPressBridgeRequest
{
    public WordPressBridgeRequest(string secret);
    public void SetPlayerData(List<WPBPlayer> playerData);
    public void SetServerData(WPBServer serverData);
     string _secret;
     List<WPBPlayer> _playerData;
     WPBServer _serverData;
    [JsonProperty(PropertyName = "Secret")]
     string Secret { get; set; }
    [JsonProperty(PropertyName = "PlayerData")]
     List<WPBPlayer> PlayerData { get; set; }
    [JsonProperty(PropertyName = "ServerData")]
     WPBServer ServerData { get; set; }
}

 class WordPressJson
{
    public string name { get; set; }
    public string description { get; set; }
    public string url { get; set; }
    public string home { get; set; }
    public WordPressJsonRoutes routes { get; set; }
}

 class WordPressJsonRoutes
{
    [JsonProperty("/wpbridge")]
    public WordPressJsonRouteWPBridge Wpbridge { get; set; }
}

 class WordPressJsonRouteWPBridge
{
    public List<string> methods { get; set; }
}


```

---

## XmasMini by TheFriendlyChap - Spawns some festive lights on the minicopters.

```csharp
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;
using System;

Oxide.Plugins
[Info("Xmas Mini", "The Friendly Chap", "1.0.4")]
[Description("Spawns Christmas lights on the minicopter. Merry X-Mas.")]
 class XmasMini : RustPlugin
{
    const string prefabName;
    private static readonly Vector3 prefabPosition;
    private static readonly Quaternion prefabRotation;
    private static readonly Vector3 prefabPosition2;
    private static readonly Quaternion prefabRotation2;
     void OnEntitySpawned(BaseEntity entity);
    public void Setup(Minicopter minicopter);
     void SpawnLights(Minicopter minicopter, Vector3 position, Quaternion rotation);
}


```

---

## XPerience by MACHIN3 - RPG based levels and experience mod with stats and skills

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using MySql.Data.MySqlClient;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Database;
using Oxide.Core.Libraries.Covalence;
using Oxide.Plugins.XPerienceEx;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using Random = UnityEngine.Random;
using WebSocketSharp;
using Facepunch;
using Facepunch.Math;
using ConVar;
using System.IO;
using System.Net;

Oxide.Plugins
[Info("XPerience", "MACHIN3", "1.8.800")]
[Description("Player level system with xp, stats, and skills")]
public class XPerience : RustPlugin
{
    public const string version;
    [PluginReference]
    private readonly Plugin XPerienceAddon;
    private readonly Plugin WeaponMechanics;
    private readonly Plugin KillRecords;
    private readonly Plugin Economics;
    private readonly Plugin ServerRewards;
    private readonly Plugin ImageLibrary;
    private readonly Plugin TeaModifiers;
    private readonly Plugin BetterChat;
    private readonly Plugin ColouredChat;
    private readonly Plugin IQChat;
    private readonly Plugin Backpacks;
    private readonly Plugin RaidableBases;
    private readonly Plugin ZoneManager;
    private readonly Plugin PersonalAnimal;
    private readonly Plugin SkinBox;
    private readonly Plugin BuildingGrades;
    private readonly Plugin ItemRetriever;
    private readonly Plugin BotReSpawn;
    private readonly Plugin NeverWear;
    private readonly Plugin Cooking;
    private readonly Plugin EventHelper;
    private readonly Plugin SurvivalArena;
    private readonly Plugin MonumentOwner;
    private readonly Plugin Triangulation;
    private XPData _xpData;
    private DailyData _dailyData;
    private LootData _lootData;
    private CorpseData _corpseData;
    private HorseData _horseData;
    private WeaponData _weaponData;
    private BoatData _boatData;
    private VehicleData _vehicleData;
    private MinicopterData _minicopterData;
    private SnowmobData _snowmobData;
    private SmithyData _smithyData;
    private ElectricianData _electricianData;
    private HeliHits _heliHits;
    private DynamicConfigFile _XPerienceData;
    private DynamicConfigFile _DailyXPerienceData;
    private DynamicConfigFile _LootContainData;
    private DynamicConfigFile _CorpseContainData;
    private DynamicConfigFile _HorseData;
    private DynamicConfigFile _WeaponData;
    private DynamicConfigFile _BoatData;
    private DynamicConfigFile _VehicleData;
    private DynamicConfigFile _MinicopterData;
    private DynamicConfigFile _SnowmobData;
    private DynamicConfigFile _SmithyData;
    private DynamicConfigFile _ElectricianData;
    private Dictionary<string, XPRecord> _xperienceCache;
    private Dictionary<string, DailyRecord> _dailyxperienceCache;
    private Dictionary<ulong, Loot> _lootCache;
    private Dictionary<ulong, Corpse> _corpseCache;
    private Dictionary<ulong, Horse> _horseCache;
    private Dictionary<ulong, Weapon> _weaponCache;
    private Dictionary<ulong, Boat> _boatCache;
    private Dictionary<ulong, Vehicle> _vehicleCache;
    private Dictionary<ulong, MiniCopterP> _minicopterCache;
    private Dictionary<ulong, Snowmob> _snowmobCache;
    private Dictionary<string, SmithyD> _smithyCache;
    private Dictionary<ulong, ElectricianD> _electricianCache;
    private Dictionary<ulong, Heli> _heliCache;
    public Configuration config;
    private static Configuration configData;
    private static readonly RNGCryptoServiceProvider _generator;
    private const string Admin;
    private const string VIP;
    private const string PermMentality;
    private const string PermDexterity;
    private const string PermMight;
    private const string PermCaptaincy;
    private const string PermWeaponry;
    private const string PermNinjary;
    private const string PermWoodCutter;
    private const string PermSmithy;
    private const string PermMiner;
    private const string PermForager;
    private const string PermHunter;
    private const string PermFisher;
    private const string PermCrafter;
    private const string PermFramer;
    private const string PermMedic;
    private const string PermScavenger;
    private const string PermElectrician;
    private const string PermDemolitionist;
    private const string PermTamer;
    private const string PermXPBoost;
    private readonly Hash<ulong, double> _notifyCooldowns;
    private readonly Hash<ulong, double> _buildCooldowns;
    private readonly Hash<ulong, double> _craftCooldowns;
    private readonly Hash<ulong, int> _TopUIPage;
    private Timer DashPanelTimer;
    private Timer _helitracker;
    private double CurrentTime { get; set; }
    private bool _isXPReady;
    private bool _isRestart;
    private int _imageLibraryCheck;
    private Dictionary<string, string> _xperienceImageList;
    private Dictionary<string, string> _CheckImageList;
    private Dictionary<string, string> _CheckImageListReload;
    public static class RandomNumber
    {
        private static readonly RNGCryptoServiceProvider _generator;
        public static int Between(int minimumValue, int maximumValue);
    }

    public class Configuration : SerializableConfiguration
    {
        [JsonProperty("Player Chat Commands")]
        public PlayerChatCommands playerchatCommands;
        [JsonProperty("Admin Chat Commands")]
        public AdminChatCommands adminchatCommands;
        [JsonProperty("Player Info Box")]
        public PlayerProfileSettings playerprofilesettings;
        [JsonProperty("Default Options")]
        public DefaultOptions defaultOptions;
        [JsonProperty("Sound Effects")]
        public SoundEffects soundEffects;
        [JsonProperty("UI Text Colors")]
        public UITextColor uitextColor;
        [JsonProperty("Image Icons")]
        public ImageIcons imageicons;
        [JsonProperty("XP - Level Config")]
        public XpLevel xpLevel;
        [JsonProperty("Daily Timer Config")]
        public DailyTimer dailytimer;
        [JsonProperty("Daily XP Limit Config")]
        public DailyXpLimit dailyxpLimit;
        [JsonProperty("Daily Reset Limit Config")]
        public DailyResetLimit dailyresetLimit;
        [JsonProperty("XP - Level Ranks")]
        public XpLevelRanks xpLevelRanks;
        [JsonProperty("Rank Boosts")]
        public RankBoostsSettings Rankboostssettings;
        [JsonProperty("Special Groups")]
        public SpecialGroups specialGroups;
        [JsonProperty("XP - Night Bonus")]
        public NightBonus nightBonus;
        [JsonProperty("XP - Gain Amounts")]
        public XpGain xpGain;
        [JsonProperty("XP - Gather Amounts")]
        public XpGather xpGather;
        [JsonProperty("XP - Building Amounts")]
        public XpBuilding xpBuilding;
        [JsonProperty("XP - Teams")]
        public XpTeams xpTeams;
        [JsonProperty("XP - Mission Amounts")]
        public XpMissions xpMissions;
        [JsonProperty("XP - Reducer Amounts")]
        public XpReducer xpReducer;
        [JsonProperty("BonusXP - Bonus Amounts (requires KillRecords plugin)")]
        public XpBonus xpBonus;
        [JsonProperty("Economics Rewards (requires Economics plugin)")]
        public XpEcon xpEcon;
        [JsonProperty("Server Rewards (requires ServerRewards plugin)")]
        public SRewards sRewards;
        [JsonProperty("Mentality Stat")]
        public Mentality mentality;
        [JsonProperty("Dexterity Stat")]
        public Dexterity dexterity;
        [JsonProperty("Might Stat")]
        public Might might;
        [JsonProperty("Captaincy Stat")]
        public Captaincy captaincy;
        [JsonProperty("Weaponry Stat")]
        public Weaponry weaponry;
        [JsonProperty("Ninjary Stat")]
        public Ninjary ninjary;
        [JsonProperty("WoodCutter Skill")]
        public Woodcutter woodcutter;
        [JsonProperty("Smithy Skill")]
        public Smithy smithy;
        [JsonProperty("Miner Skill")]
        public Miner miner;
        [JsonProperty("Forager Skill")]
        public Forager forager;
        [JsonProperty("Hunter Skill")]
        public Hunter hunter;
        [JsonProperty("Fisher Skill")]
        public Fisher fisher;
        [JsonProperty("Crafter Skill")]
        public Crafter crafter;
        [JsonProperty("Framer Skill")]
        public Framer framer;
        [JsonProperty("Medic Skill")]
        public Medic medic;
        [JsonProperty("Scavenger Skill")]
        public Scavenger scavenger;
        [JsonProperty("Electrician Skill")]
        public Electrician electrician;
        [JsonProperty("Demolitionist Skill")]
        public Demolitionist demolitionist;
        [JsonProperty("Tamer Skill")]
        public Tamer tamer;
        [JsonProperty("SQL Info")]
        public SQL sql;
        [JsonProperty("Backpacks Mod")]
        public BackpacksMod backpacksmod;
        [JsonProperty("ZoneManager Mod")]
        public ZoneManagerMod zonemanagermod;
        [JsonProperty("EventHelper Mod")]
        public EventHelperMod eventhelpermod;
        [JsonProperty("SurvivalArena Mod")]
        public SurvivalArenaMod survivalarenamod;
        [JsonProperty("Raidable Bases")]
        public RaidableBasesMod raidablebasesmod;
    }

    public class PlayerChatCommands
    {
        public string openplayerstats;
        public string openplayerstats2;
        public string openplayerstats3;
        public string showplayerstatschat;
        public string opentopplayers;
        public string playeraddstat;
        public string playeraddskill;
        public string playerresetstats;
        public string playerresetskills;
        public string playerresetall;
        public string playerliveuichange;
        public string openhelp;
    }

    public class AdminChatCommands
    {
        public string showadminhelp;
        public string openadminpanel;
        public string adminresetxperience;
        public string adminxpgive;
        public string adminxpgiveall;
        public string adminpointsgive;
        public string adminxptake;
        public string adminresetplayer;
        public string adminfixdata;
        public string adminitemchange;
        public string adminresetharvest;
        public string adminresetlevelonly;
        public string adminresetrankonly;
        public string adminresetstat;
        public string adminresetskill;
        public string adminresetlevelonlyall;
        public string adminresetrankonlyall;
        public string adminexcludeplayer;
        public string admingiveitem;
    }

    public class PlayerProfileSettings
    {
        public bool showunusedeffects;
        public bool useplayeravatar;
        public bool profilemenusettings;
        public bool profilemenutopplayers;
        public bool profilemenuraids;
        public bool profilemenuhelp;
        public bool profilemenucalculations;
        public bool skillshelp;
        public bool profilemenuwelcome;
        public bool playtime;
        public bool alivetime;
        public bool sleepingtime;
        public bool swimingtime;
        public bool drivingtime;
        public bool flyingtime;
        public bool boatingtime;
        public bool basetime;
        public bool monumenttime;
        public bool wildernesstime;
        public bool metersran;
        public bool meterswalked;
        public bool lastdmgrec;
        public bool lastdmgrecby;
        public bool lastdmgdelt;
        public bool lastdmgdeltto;
        public string AnchorMin;
        public string AnchorMax;
        public string OffsetMin;
        public string OffsetMax;
        public string InsideAnchorMin;
        public string InsideAnchorMax;
        public int menutype;
        public bool usebgimage;
        public int profilebg;
        public bool allowprofilebgchange;
        public bool usemenubgimage;
        public double bgfadein;
        public double menuwidth;
        public double menuheight;
        public double menubuttonheight;
        public int menubuttonfont;
    }

    public class DefaultOptions
    {
        public bool userpermissions;
        public int liveuistatslocation;
        public bool liveuistatslocationmoveable;
        public bool showchatprofileonconnect;
        public int NotifcationCooldown;
        public bool restristresets;
        public bool allowrespec;
        public int resetminsstats;
        public int resetminsskills;
        public bool bypassadminreset;
        public int vipresetminstats;
        public int vipresetminsskills;
        public int playerfixdatatimer;
        public bool disableplayerfixdata;
        public bool disablearmorchat;
        public bool hardcorenoreset;
        public bool allowplayersearch;
        public bool allowplayerreset;
        public int topplayersperpage;
        public bool showonlinestatus;
        public bool useprogressivelevelicons;
        public bool showfuelguage;
        public bool showspeedometer;
        public int speedometertype;
        public bool dropsgotoplayerinventory;
        public bool wipedataonnewsave;
        public bool enabledashpanel;
        public bool enableconfirmationprompt;
        public bool showchatnotifications;
        public bool showlevelinchat;
        public bool hidechatnotifications;
        public bool debugmode;
    }

    public class SoundEffects
    {
        public bool levelup;
        public bool leveldown;
        public bool rankup;
        public bool statup;
        public bool skillup;
        public bool statreset;
        public bool skillreset;
        public bool scavengerloot;
        public bool foragerloot;
        public string levelupeffect;
        public string leveldowneffect;
        public string rankupeffect;
        public string statupeffect;
        public string skillupeffect;
        public string statreseteffect;
        public string skillreseteffect;
        public string scavengerlooteffect;
        public string foragerlooteffect;
    }

    public class UITextColor
    {
        public string defaultcolor;
        public string level;
        public string ranklevel;
        public string rankxp;
        public string rankname;
        public string experience;
        public string nextlevel;
        public string remainingxp;
        public string statskilllevels;
        public string perks;
        public string unspentpoints;
        public string spentpoints;
        public string pets;
        public string mentality;
        public string dexterity;
        public string might;
        public string captaincy;
        public string weaponry;
        public string Ninjary;
        public string woodcutter;
        public string smithy;
        public string miner;
        public string forager;
        public string hunter;
        public string fisher;
        public string crafter;
        public string framer;
        public string medic;
        public string scavenger;
        public string electrician;
        public string demolitionist;
        public string tamer;
        public string xpbar;
        public string armorbar;
    }

    public class ImageIcons
    {
        public bool uselocalpath;
        public string rootpath;
        public string xperiencelogo;
        public string mainicon;
        public string mentality;
        public string dexterity;
        public string might;
        public string captaincy;
        public string weaponry;
        public string ninjary;
        public string woodcutter;
        public string smithy;
        public string miner;
        public string forager;
        public string hunter;
        public string fisher;
        public string crafter;
        public string framer;
        public string medic;
        public string scavenger;
        public string electrician;
        public string demolitionist;
        public string tamer;
        public string chicken;
        public string boar;
        public string stag;
        public string wolf;
        public string bear;
        public string polarbear;
        public string archery;
        public string wizardry;
        public string online;
        public string offline;
        public string backpack;
        public string xp;
        public string level;
        public string armor;
        public string level0;
        public string level2;
        public string level4;
        public string level6;
        public string level8;
        public string level10;
        public string dash;
        public string raideasy;
        public string raidmedium;
        public string raidhard;
        public string raidexpert;
        public string raidnightmare;
        public string profilebg;
        public string menubg;
        public Dictionary<int, BackgroundImgs> bgimages;
    }

    public class BackgroundImgs
    {
        public string name;
        public string url;
    }

    public class XpLevel
    {
        public double levelstart;
        public double levelmultiplier;
        public int maxlevel;
        public double levelxpboost;
        public int statpointsperlvl;
        public int skillpointsperlvl;
        public bool alwaysearnxp;
        public bool fullhealth;
        public bool fullmetabolism;
    }

    public class XpLevelRanks
    {
        public bool enableresetranks;
        public bool resetallstatsskills;
        public bool allowplayerdisable;
        public bool increaselevelmultiplier;
        public double levelmultiplierincrease;
        public int maxresetrank;
        public bool enablerankxpboost;
        public double rankxpboost;
        public bool rankstatboost;
        public double rankstatboostamount;
        public int rankstatpointstart;
        public int rankstatpointincrease;
        public bool rankskillboost;
        public double rankskillboostamount;
        public int rankskillpointstart;
        public int rankskillpointincrease;
        public bool keepremainingxp;
        public bool showtruelevelprofile;
        public bool showrankinchat;
        public bool showtruexpprofile;
        public bool showrankinliveui;
        public bool keepgrouponrank;
        public Dictionary<int, Ranks> ranks;
    }

    public class RankBoostsSettings
    {
        public bool researchcost;
        public bool researchspeed;
        public bool block;
        public bool armor;
        public bool distance;
        public bool meleedmg;
        public bool metabolism;
        public bool woodcuttergr;
        public bool woodcutterbonus;
        public bool smithypr;
        public bool smithyps;
        public bool smithyfc;
        public bool smithyhqmc;
        public bool smithyhqma;
        public bool minergr;
        public bool minerbonus;
        public bool minermfc;
        public bool minerfuel;
        public bool minermfa;
        public bool fisherfa;
        public bool fisheria;
        public bool fisherotr;
        public bool foragergr;
        public bool foragergwa;
        public bool foragerric;
        public bool huntergr;
        public bool hunterbonus;
        public bool hunterdmg;
        public bool hunterndmg;
        public bool crafterspeed;
        public bool craftercost;
        public bool crafterri;
        public bool crafterrc;
        public bool craftercc;
        public bool crafterca;
        public bool framerucost;
        public bool framerrcost;
        public bool medicrevivala;
        public bool medicrecovera;
        public bool medictools;
        public bool scavelc;
        public bool scavelm;
        public bool scavcic;
        public bool scavcim;
    }

    public class Ranks
    {
        public string name;
        public string sig;
        public string image;
        public string group;
        public string description;
    }

    public class SpecialGroups
    {
        public Dictionary<int, Specialgroups> specialgroups;
    }

    public class Specialgroups
    {
        public string groupname;
        public string permissionname;
        public int grouppriority;
        public double xpboost;
        public int dailyxplimit;
        public int dailystatlimitboost;
        public int dailyskilllimitboost;
    }

    public class DailyTimer
    {
        public int dailyresettimerhours;
        public DateTime lastdailyreset;
    }

    public class DailyXpLimit
    {
        public bool enabledailyxplimit;
        public int dailyxplimit;
        public int dailyxplimitvip;
        public int limitmultipliertype;
        public int limitmultiplier;
        public double limitpercentage;
    }

    public class DailyResetLimit
    {
        public bool enabledailyresetlimit;
        public int dailystatlimit;
        public int dailystatlimitvip;
        public int dailyskilllimit;
        public int dailyskilllimitvip;
    }

    public class NightBonus
    {
        public bool Enable;
        public int StartTime;
        public int EndTime;
        public double Bonus;
        public bool enableskillboosts;
    }

    public class XpGain
    {
        public double chickenxp;
        public double fishxp;
        public double boarxp;
        public double stagxp;
        public double wolfxp;
        public double bearxp;
        public double polarbearxp;
        public double sharkxp;
        public double horsexp;
        public double scientistxp;
        public double sc_full;
        public double sc_heavy;
        public double sc_cargo;
        public double sc_junkpile;
        public double sc_oilrig;
        public double sc_patrol;
        public double sc_peacekeeper;
        public double sc_roam;
        public double dwellerxp;
        public double tunneldwellerxp;
        public double underwaterdwellerxp;
        public double scarecrownpc;
        public double customnpc;
        public double zombienpc;
        public double playerxp;
        public double lootcontainerxp;
        public double lootbarrel;
        public double oilbarrel;
        public double vehicleparts;
        public double toolcrate;
        public double normalcrate;
        public double elitecrate;
        public double foodcrate;
        public double medicalcrate;
        public double animalharvestxp;
        public double corpseharvestxp;
        public double underwaterlootcontainerxp;
        public double lockedcratexp;
        public double hackablecratexp;
        public double craftingxp;
        public bool craftingxpdelay;
        public double craftingxpdelayseconds;
        public double bradley;
        public double patrolhelicopter;
        public double turretxp;
        public bool allowturretxp;
        public double playerrevive;
        public bool enablexpboost;
        public double xpboostamount;
        public int xpboostorder;
        public double gifts;
        public double opengifts;
        public double opengiftsmed;
        public double opengiftslarge;
        public double upgradegiftsmed;
        public double upgradegiftslarge;
        public double craftmeal;
    }

    public class XpGather
    {
        public double treexp;
        public double orexp;
        public double metalorexp;
        public double stoneorexp;
        public double sulfurorexp;
        public double harvestxp;
        public double plantxp;
        public bool noxptools;
        public bool onetimexp;
        public double toolxpchance;
        public double toolxppercent;
    }

    public class XpBuilding
    {
        public double twigstructure;
        public double woodstructure;
        public double stonestructure;
        public double metalstructure;
        public double armoredstructure;
        public bool preventBGxp;
        public bool buildxpdelay;
        public bool requirebuildingprivlidge;
        public int buildxpdelayseconds;
        public bool reducexp;
        public double buildxpreduction;
    }

    public class XpTeams
    {
        public bool enableteamxpgain;
        public bool enableteamxploss;
        public double teamxpgainamount;
        public double teamxplossamount;
        public float teamdistance;
    }

    public class XpMissions
    {
        public double missionsucceededxp;
        public bool missionfailed;
        public double missionfailedxp;
    }

    public class XpReducer
    {
        public bool suicidereduce;
        public double suicidereduceamount;
        public bool deathreduce;
        public double deathreduceamount;
        public bool rankdeathreduce;
    }

    public class XpBonus
    {
        public bool showkrbutton;
        public bool enablebonus;
        public int requiredkills;
        public double bonusxp;
        public int endbonus;
        public bool multibonus;
        public string multibonustype;
    }

    public class XpEcon
    {
        public bool showbalanceprofile;
        public bool econlevelup;
        public bool econleveldown;
        public bool econresetstats;
        public bool econresetskills;
        public bool econresetstat;
        public bool econresetskill;
        public double econlevelreward;
        public double econlevelreduction;
        public double econresetstatscost;
        public double econresetskillscost;
        public double econresetstatcost;
        public double econresetskillcost;
        public bool econstatlevelcost;
        public bool econskilllevelcost;
        public double econstatlevelcostmultiplier;
        public double econskilllevelcostmultiplier;
        public double econmentality;
        public double econdexterity;
        public double econmight;
        public double econcaptaincy;
        public double econweaponry;
        public double econninjary;
        public double econwoodcutter;
        public double econsmithy;
        public double econminer;
        public double econforager;
        public double econhunter;
        public double econfisher;
        public double econcrafter;
        public double econframer;
        public double econmedic;
        public double econscavenger;
        public double econelectrician;
        public double econdemolitionist;
        public double econtamer;
    }

    public class SRewards
    {
        public bool srewardlevelup;
        public bool srewardleveldown;
        public bool srewardresetstats;
        public bool srewardresetskills;
        public bool srewardresetstat;
        public bool srewardresetskill;
        public int srewardlevelupamt;
        public int srewardleveldownamt;
        public int srewardresetstatscost;
        public int srewardresetskillscost;
        public int srewardresetstatcost;
        public int srewardresetskillcost;
        public bool srewardstatlevelcost;
        public bool srewardskilllevelcost;
        public int srewardstatlevelcostmultiplier;
        public int srewardskilllevelcostmultiplier;
        public int srewardmentality;
        public int srewarddexterity;
        public int srewardmight;
        public int srewardcaptaincy;
        public int srewardweaponry;
        public int srewardninjary;
        public int srewardwoodcutter;
        public int srewardsmithy;
        public int srewardminer;
        public int srewardforager;
        public int srewardhunter;
        public int srewardfisher;
        public int srewardcrafter;
        public int srewardframer;
        public int srewardmedic;
        public int srewardscavenger;
        public int srewardelectrician;
        public int srewardemolitionist;
        public int srewardtamer;
    }

    public class Mentality
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double researchcost;
        public double researchcosttechtree;
        public double researchspeed;
        public double criticalchance;
        public double criticaldgm;
        public double damageincrease;
        public bool useotherresearchmod;
        public bool locktechtree;
        public int unlocktechtreelevel;
    }

    public class Dexterity
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double blockchance;
        public double blockamount;
        public double dodgechance;
        public double reducearmordmg;
        public double horsespeed;
        public double boatspeed;
        public double vehiclespeed;
        public double fuelreduce;
    }

    public class Might
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double armor;
        public double meleedmg;
        public double metabolism;
        public double bleedreduction;
        public double radreduction;
        public double heattolerance;
        public double coldtolerance;
    }

    public class Captaincy
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public bool allownoteam;
        public double skillboost;
        public bool enablexpboost;
        public double xpboost;
        public float captaincydistance;
    }

    public class Weaponry
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double reductionchance;
        public double tool;
        public double powertools;
        public double meleeweapons;
        public double projectileweapons;
        public double mindamage;
        public double maxammo;
        public double maxammolimit;
        public bool skinboxdisable;
        public bool neverweartools;
        public bool neverwearweapons;
        public string reloadhook;
        public string excludedweapons;
        public bool useweaponmechanics;
    }

    public class Ninjary
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double patrolstealth;
        public double ch47stealth;
        public double bradleystealth;
        public double npcstealth;
        public double turretstealth;
        public double knifeincrease;
        public double swordincrease;
    }

    public class Woodcutter
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double gatherrate;
        public double bonusincrease;
        public double applechance;
    }

    public class Smithy
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double productionrate;
        public double productionspeed;
        public double fuelconsumption;
        public double metalchance;
        public int metalamount;
    }

    public class Miner
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double gatherrate;
        public double bonusincrease;
        public double fuelconsumption;
        public double metalchance;
        public int metalamount;
    }

    public class Forager
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double gatherrate;
        public double chanceincrease;
        public double grubwormincrease;
        public double randomchance;
        public Dictionary<int, RandomChanceList> randomChanceList;
    }

    public class RandomChanceList
    {
        public string shortname;
        public string displayname;
        public ulong SkinID;
        public int amount;
    }

    public class Hunter
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double gatherrate;
        public double bonusincrease;
        public double damageincrease;
        public double nightdmgincrease;
        public double bowdmgincrease;
        public bool excludelongrangeweapons;
        public bool excludemedrangeweapons;
    }

    public class Fisher
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double fishamountincrease;
        public double itemamountincrease;
        public double oxygenreduction;
        public double oxygentankreduction;
    }

    public class Crafter
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double craftspeed;
        public double craftcost;
        public double repairincrease;
        public double repaircost;
        public double conditionchance;
        public double conditionamount;
    }

    public class Framer
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double upgradecost;
        public double repaircost;
        public double repairtime;
        public int woodcost;
        public int stonecost;
        public int metalcost;
        public int armorcost;
    }

    public class Electrician
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public int solarpaneldefault;
        public int smallbatterydefault;
        public int mediumbatterydefault;
        public int largebatterydefault;
        public int smallgeneratordefault;
        public int testgeneratordefault;
        public int electricwindmilldefault;
        public double solarpanelinputincrease;
        public double solarpanelmaxincrease;
        public double smallbatterymaxincrease;
        public double mediumbatterymaxincrease;
        public double largebatterymaxincrease;
        public double smallgeneratormaxincrease;
        public double testgeneratormaxincrease;
        public double electricwindmillincrease;
        public double electricwindmillmaxincrease;
        public bool allowminsolarinput;
        public int minsolarinput;
    }

    public class Demolitionist
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double explosivedudreduction;
        public double explosivedamage;
        public double explosiveradius;
    }

    public class Medic
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double revivehp;
        public double recoverhp;
        public double crafttime;
        public double tools;
        public double teas;
        public bool preventbandageboost;
    }

    public class Scavenger
    {
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public double scavlootchance;
        public double scavchance;
        public double scavmultiplier;
        public double customscavmultiplier;
        public bool customscavrandom;
        public bool usecustomscavlist;
        public bool drops;
        public bool crates;
        public bool uncrates;
        public bool lockedcrates;
        public bool hackcrates;
        public bool scientists;
        public bool componentsonly;
        public Dictionary<int, ScavChanceList> scavChanceList;
    }

    public class ScavChanceList
    {
        public string shortname;
        public string displayname;
        public ulong SkinID;
        public int amount;
        public int maxamount;
        public int requiredlevel;
    }

    public class Tamer
    {
        public bool enabletame;
        public int maxlvl;
        public int pointcoststart;
        public int costmultiplier;
        public bool tamechicken;
        public bool tameboar;
        public bool tamestag;
        public bool tamewolf;
        public bool tamebear;
        public bool tamepolarbear;
        public int chickenlevel;
        public int boarlevel;
        public int staglevel;
        public int wolflevel;
        public int bearlevel;
        public int polarbearlevel;
    }

    public class SQL
    {
        public bool enablesql;
        public string SQLhost;
        public int SQLport;
        public string SQLdatabase;
        public string SQLusername;
        public string SQLpassword;
    }

    public class BackpacksMod
    {
        public bool enablebackpacks;
        public string statorskill;
        public bool removeonunload;
        public SortedDictionary<int, BackPackSlots> BackPackSlots;
    }

    public class BackPackSlots
    {
        public int level;
        public int slots;
    }

    public class ZoneManagerMod
    {
        public string noxpgain;
        public string noxploss;
        public string disablestatsandskills;
    }

    public class EventHelperMod
    {
        public string noxpgain;
        public string noxploss;
        public string disablestatsandskills;
    }

    public class SurvivalArenaMod
    {
        public bool noxpgain;
        public bool noxploss;
        public bool disablestatsandskills;
    }

    public class RaidableBasesMod
    {
        public bool disableabilities;
        public bool noxploss;
        public bool noxpgain;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    public class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    private void SaveData();
    private void LoadData();
    public class XPData
    {
        public Dictionary<string, XPRecord> XPerience;
    }

    public class XPRecord
    {
        public int rank;
        public int truelevel;
        public int trueexperience;
        public double level;
        public double experience;
        public double requiredxp;
        public int statpoint;
        public int skillpoint;
        public int Mentality;
        public int MentalityP;
        public int Dexterity;
        public int DexterityP;
        public int Might;
        public int MightP;
        public int Captaincy;
        public int CaptaincyP;
        public int Weaponry;
        public int WeaponryP;
        public int Ninjary;
        public int NinjaryP;
        public int WoodCutter;
        public int WoodCutterP;
        public int Smithy;
        public int SmithyP;
        public int Miner;
        public int MinerP;
        public int Forager;
        public int ForagerP;
        public int Hunter;
        public int HunterP;
        public int Fisher;
        public int FisherP;
        public int Crafter;
        public int CrafterP;
        public int Framer;
        public int FramerP;
        public int Electrician;
        public int ElectricianP;
        public int Medic;
        public int MedicP;
        public int Scavenger;
        public int ScavengerP;
        public int Demolitionist;
        public int DemolitionistP;
        public int Tamer;
        public int TamerP;
        public int Wood;
        public int Stone;
        public int Metal;
        public int Sulfur;
        public int Cactus;
        public int Berries;
        public int Pumpkin;
        public int Potato;
        public int Corn;
        public int Mushroom;
        public int Hemp;
        public int Seed;
        public bool Status;
        public bool DisableRank;
        public int UILocation;
        public string teatype;
        public double teacooldown;
        public DateTime resettimerstats;
        public DateTime resettimerskills;
        public DateTime playerfixdata;
        public int dash;
        public int dmgbar;
        public int profilebg;
        public bool fuelgauge;
        public bool speedometer;
        public int speedometertype;
        public bool enableconfirmationprompt;
        public bool showchatnotifications;
        public bool showchatprofileonconnect;
        public bool showwelcomepanel;
        public bool showchatxp;
        public bool exclude;
        public bool raidablebase;
        public string displayname;
        public string id;
    }

    public class DailyData
    {
        public Dictionary<string, DailyRecord> DailyXPerience;
    }

    public class DailyRecord
    {
        public double dailyexperience;
        public int dailystatresets;
        public int dailyskillresets;
        public DateTime lastexperiencereset;
        public DateTime laststatreset;
        public DateTime lastskillreset;
    }

    private class LootData
    {
        public Dictionary<ulong, Loot> LootRecords;
    }

    private class Loot
    {
        public List<string> id;
    }

    private class CorpseData
    {
        public Dictionary<ulong, Corpse> CorpseRecords;
    }

    private class Corpse
    {
        public ulong corpsecontainer;
        public List<string> id;
    }

    private class HorseData
    {
        public Dictionary<ulong, Horse> HorseRecords;
    }

    private class Horse
    {
        public ulong horse;
        public float maxSpeed;
        public float runSpeed;
        public float walkSpeed;
        public float trotSpeed;
        public ulong player;
    }

    private class WeaponData
    {
        public Dictionary<ulong, Weapon> WeaponRecords;
    }

    private class Weapon
    {
        public int defaultammo;
        public int maxammo;
        public double defaultreload;
        public double newreload;
        public double defaultdistance;
        public double maxdistance;
        public double defaultrange;
        public double maxrange;
        public ulong player;
        public NetworkableId weapondata;
    }

    private class BoatData
    {
        public Dictionary<ulong, Boat> BoatRecords;
    }

    private class Boat
    {
        public ulong boat;
        public float defaultSpeed;
        public ulong player;
    }

    private class VehicleData
    {
        public Dictionary<ulong, Vehicle> VehicleRecords;
    }

    private class Vehicle
    {
        public ulong vehicle;
        public float maxDriveSlip;
        public float reversePercentSpeed;
        public float driveForceToMaxSlip;
        public ulong player;
    }

    private class MinicopterData
    {
        public Dictionary<ulong, MiniCopterP> MinicopterRecords;
    }

    private class MiniCopterP
    {
        public ulong minicopter;
        public float maxRotorSpeed;
        public ulong player;
    }

    private class SnowmobData
    {
        public Dictionary<ulong, Snowmob> SnowmobRecords;
    }

    private class Snowmob
    {
        public ulong snowmob;
        public float terrain;
        public double engineKW;
        public ulong player;
    }

    private class SmithyData
    {
        public Dictionary<string, SmithyD> SmithyRecords;
    }

    private class SmithyD
    {
        public string resource;
        public float time;
    }

    private class ElectricianData
    {
        public Dictionary<ulong, ElectricianD> ElectricianRecords;
    }

    private class ElectricianD
    {
        public ulong id;
        public string type;
        public int defaultmaxoutput;
        public int newmaxoutput;
        public ulong owner;
    }

    private class HeliHits
    {
        public Dictionary<ulong, Heli> HeliRecords;
    }

    private class Heli
    {
        public ulong heli;
        public ulong player;
    }

    private readonly Core.MySql.Libraries.MySql sqlLibrary;
     Connection sqlConnection;
    private string RemoveSpecialCharacters(string name);
    private void CreatSQLTable();
    private void UpdateSQLTable();
    private void CreatePlayerDataSQL(BasePlayer player);
    private void UpdatePlayersDataSQL();
    private void UpdatePlayerDataSQL(BasePlayer player);
    private void CheckPlayerDataSQL(BasePlayer player);
    private void DeleteSQL();
    private void Init();
    private void OnServerInitialized();
    private void OnNewSave();
    private void OnPluginLoaded(Plugin name);
    private void Unload();
    private void OnServerShutdown();
    private void OnServerSave();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnPlayerRespawn(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    private void OnPlayerKicked(BasePlayer player);
    private void CheckConfigValues();
    private void LibraryCheck();
    private void LoadImages(bool forcereload);
    private void Ready();
    private void DownloadImages();
    private void DownloadImagesCompleted(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    public XPRecord GetXPRecord(BasePlayer player);
    public DailyRecord GetDailyRecord(BasePlayer player);
    public XPRecord GetPlayerRecord(string player);
    public DailyRecord GetPlayerDailyRecord(string player);
    public Ranks GetXPRank(int rank);
    public BackgroundImgs GetBGImg(int bgid);
    private static BasePlayer FindPlayer(string playerid);
    private BasePlayer GetOwnerPlayer(Item item);
    private void CheckOnlineStatus();
    private void CheckStatsAndSkills(BasePlayer player);
    private void UpdateDisplayName(BasePlayer player);
    private void AddLootData(BasePlayer player, LootContainer lootcontainer);
    private void AddHorseData(BasePlayer player, RidableHorse horse);
    private void AddBoatData(BasePlayer player, BaseBoat boat);
    private void AddVehicleData(BasePlayer player, ModularCar car);
    private void AddMiniCopterData(BasePlayer player, Minicopter mini);
    private void AddSnowMobData(BasePlayer player, Snowmobile snowmob);
    private void AddWeaponData(BasePlayer player, BaseProjectile projectile, int defaultammo, int maxammo, double defaultreload, double newreload, double defaultdistance, double maxdistance, double defaultrange, double maxrange, NetworkableId weapondata);
    private void AddCorpseData(BasePlayer player, LootableCorpse corpse);
    private void AddSmithyData(string resource, float time);
    private void AddElectricianData(ulong id, string type, int defaultmaxoutput, int newmaxoutput, ulong owner);
    private double GetPlayerCooldown(ulong userID, string type);
    private double GetTeaCooldown(BasePlayer player);
    private string GetTeaTypes(BasePlayer player);
    private bool BetterChatActv();
    private bool ColouredChatAct();
    private bool IQChatAct();
    private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    private void OverrideChatMessage(BasePlayer player, string ranksig, string displayname, string level, string message, Chat.ChatChannel channel);
    private object OnBetterChat(Dictionary<string, object> chat);
    private void DailyLimit(bool reset);
    private void DailyLimitPlayer(BasePlayer player, bool reset);
    public void GainExp(BasePlayer player, double e);
    public void GainExpBasic(BasePlayer player, double e);
    private void GainExpID(string player, double e, int truexp, bool reset);
    private void GainExpAdmin(BasePlayer player, double e, int truexp, bool reset);
    private void GainExpAdminFix(string player, double e, int truexp, bool reset);
    public void GivePoints(BasePlayer player, string type, int amount);
    public void GivePointsOther(string player, string type, int amount);
    private void LvlUp(BasePlayer player, int chatstatpoint, int chatskillpoint, bool reset);
    private void LvlUpFix(string player);
    private void RankUp(BasePlayer player, double remainingxp, bool manualrank);
    private void RankUpFix(string player, double remainingxp);
    private void RankCheck(BasePlayer player, bool reset);
    private void LoseExp(BasePlayer player, double e);
    private void LoseExpAdmin(BasePlayer player, double e);
    private void LvlDown(BasePlayer player);
    private void StatUp(BasePlayer player, string stat);
    private void SkillUp(BasePlayer player, string skill);
    private void StatReset(BasePlayer player, string stat, bool bypass);
    private void StatsResetAll(BasePlayer player);
    private void SkillReset(BasePlayer player, string skill, bool bypass);
    private void SkillsResetAll(BasePlayer player);
    private void PlayerFixDataAll(BasePlayer player, bool reset);
    private void PlayerFixData(BasePlayer player, bool reset);
    private void PlayerReset(BasePlayer player);
    private void HarvestReset(BasePlayer player);
    private void SelectedPlayerReset(BasePlayer player, BasePlayer selectplayer);
    private void SelectedPlayerResetConsole(BasePlayer selectplayer);
    private void SelectedHarvestReset(BasePlayer player, BasePlayer selectplayer);
    private void SelectedLevelReset(BasePlayer player, BasePlayer selectplayer);
    private void SelectedRankReset(BasePlayer player, BasePlayer selectplayer);
    private void PlayerAllRankReset(BasePlayer player);
    private void PlayerAllLevelReset(BasePlayer player);
    private bool IsNight();
    private void KRBonus(BasePlayer player, string KillType, int reqkills, double bonus, int bonusend, bool enablemultibonus, string multibonustype);
    private void XPTeams(BasePlayer player, double e, string type);
    private void HarvestRecord(BasePlayer player, string item, int amount);
    public const string Tame;
    public const string PTameChicken;
    public const string PTameBoar;
    public const string PTameStag;
    public const string PTameWolf;
    public const string PTameBear;
    public const string PTamePolarBear;
    private void PetChecks(BasePlayer player, bool reset);
    private void BackPackChecks(BasePlayer player, string type, bool reset);
    private string GetScientistType(string scientist);
    private string GetLootType(string loot);
    private string GetDwellerType(string dweller);
    private void OnLootSpawn(LootContainer container);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo);
    private void OnPlayerDeath(BasePlayer victim, HitInfo hitInfo);
    private void OnLootEntity(BasePlayer player, LootContainer lootcontainer);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    private void OnContainerDropItems(ItemContainer lootcontainer);
    private void CanLootEntity(BasePlayer player, LootableCorpse corpse);
    private void OnEntityKill(BaseNetworkable entity);
    private void OnHelicopterKilled(CH47HelicopterAIController heli);
    private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player);
    private object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity);
    private object CanNpcAttack(BaseNpc npc, BaseEntity entity);
    private object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity entity);
    private object OnNpcTarget(BaseEntity npc, BaseEntity entity);
    private object OnNpcTargetSense(BaseEntity owner, BaseEntity entity, AIBrainSenses brainSenses);
    private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity);
    private void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item);
    private object OnExplosiveDud(DudTimedExplosive explosive);
    private void OnMissionSucceeded(BaseMission mission, BasePlayer assignee);
    private void OnMissionFailed(BaseMission mission, BasePlayer assignee);
    private int DetermineIngredientAmount(int item, int amount, BasePlayer player);
    public void CollectIngredient(int item, int amount, List<Item> collect, ItemCrafter itemCrafter, BasePlayer player);
     bool? OnIngredientsCollect(ItemCrafter itemCrafter, ItemBlueprint blueprint, ItemCraftTask task, int amount, BasePlayer player);
    private void OnIngredientsDetermine(Dictionary<int, int> overridenIngredients, ItemBlueprint blueprint, int amount, BasePlayer player);
    private void OnItemCraft(ItemCraftTask task, BasePlayer player);
    private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter itemCrafter);
    private object OnItemUse(Item item);
    private List<ItemAmount> RepairItems(BasePlayer player, Item item);
    private List<ItemAmount> ApplyItemCostReduction(BasePlayer player, List<ItemAmount> list, Item item);
    private bool PlayerCanRepair(BasePlayer player, List<ItemAmount> list);
    private void TakeItems(BasePlayer player, List<ItemAmount> list);
    private void OnItemRepair(BasePlayer player, Item item);
    private void OnEntityBuilt(Planner plan);
    private void OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum newgrade);
    private void CheckStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum newGrade);
    public bool CanAffordUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum grade);
    private void RefundMaterials(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum grade);
    private void OnStructureRepair(BaseCombatEntity entity, BasePlayer player);
    public static readonly string[] CookedItems;
    private Dictionary<string, int> lowTemps;
    private Dictionary<string, int> highTemps;
     ItemModCookable GetCookables(string shortname);
    private void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable, BaseOven.IndustrialSlotMode IndustrialMode);
    private void OnOvenToggle(BaseOven oven, BasePlayer player, BaseOven.IndustrialSlotMode IndustrialMode);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
    private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player);
    private void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player);
     void OnMealCrafted(BasePlayer player, string meal, Dictionary<string, int> ingredients, bool isIngredient);
     bool CheckPlayerLocation(BasePlayer player, string type);
     void OnEnterZone(string ZoneID, BasePlayer player);
     void OnExitZone(string ZoneID, BasePlayer player);
    private void OnPlayerEnteredRaidableBase(BasePlayer player);
    private void OnPlayerExitedRaidableBase(BasePlayer player);
    private bool CheckMonumentOwner(BasePlayer player);
     void EMOnEventJoined(BasePlayer player, string eventname);
    private object PlayerMetabolismControl(PlayerMetabolism metabolism, BasePlayer player, float delta, int might);
    private object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player, float delta);
    private void OnPlayerHealthChange(BasePlayer player);
    private object OnHealingItemUse(MedicalTool tool, BasePlayer player);
    private void OnPlayerRevive(BasePlayer reviver, BasePlayer player);
    private void OnPlayerRecovered(BasePlayer player);
    private void MightAttributes(BasePlayer player, bool reset);
    private object OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable);
    private void PlayerArmor(BasePlayer player, bool reset);
    private void OnPlayerInput(BasePlayer player, InputState input);
    private void OnItemAction(Item item, string action, BasePlayer player);
    private readonly Dictionary<Rarity, int> rarityValues;
    private object OnResearchCostDetermine(Item item, ResearchTable researchTable);
    [HookMethod("OnResearchCost")]
    private int OnResearchCost(int rarityvalue, BasePlayer player);
    [HookMethod("OnItemResearchReduction")]
    private float OnItemResearchReduction(float value, BasePlayer player);
    private void OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player);
    private bool CheckUnlockPath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree);
    private object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree);
    private object OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player);
    private void OnMixingTableToggle(MixingTable table, BasePlayer player);
    private double CaptaincyTeamSkillBoost(BasePlayer player);
    private double CaptaincyTeamXPBoost(BasePlayer player);
    private bool CaptaincyTeamDistance(BasePlayer player);
    private void RandomForagerItem(BasePlayer player);
    private void RandomScavengerItem(BasePlayer player);
    private void IncreaseLootContainers(BasePlayer player, LootContainer lootcontainer);
    private void IncreaseLootContainerDrops(ItemContainer lootcontainer);
    private void IncreaseLootCorpse(BasePlayer player, LootableCorpse corpse);
    private void OnFishCatch(Item fish, BaseFishingRod fishingRod, BasePlayer player);
    private void OnMagazineReload(BaseProjectile projectile, int desiredAmount, BasePlayer player);
    private void OnWeaponReload(BaseProjectile projectile, BasePlayer player);
    private object OnLoseCondition(Item item, float amount);
    private void OnSolarPanelSunUpdate(SolarPanel panel, int currentEnergy);
    private void OnInputUpdate(IOEntity entity, int inputAmount, int slot);
    private void OnOutputUpdate(IOEntity entity);
    private void OnEntitySpawned(BaseNetworkable entity);
    private void LoadElectricianEntities();
    private void CheckElectricianEntities(BasePlayer player, bool reset);
    private void OnEntityMounted(BaseMountable entity, BasePlayer player);
    private void OnEntityDismounted(BaseMountable entity, BasePlayer player);
    private void DefaultHorseData(RidableHorse horse);
    private void DefaultBoatData(BaseBoat boat);
    private void DefaultVehicleData(ModularCar car);
    private void DefaultMiniCopterData(Minicopter mini);
    private void DefaultSnowMobData(Snowmobile snowmob);
    private void ChangeHorseSpeed(BasePlayer player);
    private void ChangeBoatSpeed(BasePlayer player);
    private void ChangeVehicleSpeed(BasePlayer player);
    private void ChangeMiniCopterSpeed(BasePlayer player);
    private void ChangeSnowMobSpeed(BasePlayer player);
    private int GetFuel(BaseMountable entity);
    private string GetSpeed(BasePlayer player, BaseMountable entity);
    private object CanUseFuel(EntityFuelSystem fuelSystem);
    private void Openhelp(BasePlayer player, string command, string[] args);
    private void Openplayerstats(BasePlayer player, string command, string[] args);
    private void Showplayerstatschat(BasePlayer player, string command, string[] args);
    private void Opentopplayers(BasePlayer player, string command, string[] args);
    private void Playeraddstat(BasePlayer player, string command, string[] args);
    private void Playeraddskill(BasePlayer player, string command, string[] args);
    private void Playerresetstats(BasePlayer player, string command, string[] args);
    private void Playerresetskills(BasePlayer player, string command, string[] args);
    private void Playerresetall(BasePlayer player, string command, string[] args);
    private void Playerliveuichange(BasePlayer player, string command, string[] args);
    private void Adminitemchange(BasePlayer player, string command, string[] args);
    private void Showadminhelp(BasePlayer player, string command, string[] args);
    public void Openadminpanel(BasePlayer player, string command, string[] args);
    private void Adminresetxperience(BasePlayer player, string command, string[] args);
    private void Adminxpgive(BasePlayer player, string command, string[] args);
    private void Adminpointsgive(BasePlayer player, string command, string[] args);
    private void Adminxpgiveall(BasePlayer player, string command, string[] args);
    private void Adminxptake(BasePlayer player, string command, string[] args);
    private void Adminfixdata(BasePlayer player, string command, string[] args);
    private void Adminxpresetplayer(BasePlayer player, string command, string[] args);
    private void AdminHarvestReset(BasePlayer player, string command, string[] args);
    private void AdminLevelReset(BasePlayer player, string command, string[] args);
    private void AdminRankReset(BasePlayer player, string command, string[] args);
    private void AdminStatReset(BasePlayer player, string command, string[] args);
    private void AdminSkillReset(BasePlayer player, string command, string[] args);
    private void AdminLevelResetAll(BasePlayer player, string command, string[] args);
    private void AdminRankResetAll(BasePlayer player, string command, string[] args);
    private void AdminExcludePlayer(BasePlayer player, string command, string[] args);
    private void AdminGiveItem(BasePlayer player, string command, string[] args);
    private bool CanUseConsole(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpresetall")]
    private void Consolereset(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpdailyreset")]
    private void Consoleresetdailyxptimer(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpdailyresetplayer")]
    private void Consoleresetdailyxpplayer(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpexcludeplayer")]
    private void Consoleexcludeplayer(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpresetplayer")]
    private void Consoleresetplayer(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpresetstat")]
    private void Consoleresetstat(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpresetskill")]
    private void Consoleresetskill(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpgive")]
    private void Consolegivexp(ConsoleSystem.Arg arg);
    [ConsoleCommand("xptake")]
    private void Consoletakexp(ConsoleSystem.Arg arg);
    [ConsoleCommand("xpitem")]
    private void Consolexpitem(ConsoleSystem.Arg arg);
    private const string XPerienceLivePrimary;
    private const string XPerienceLiveIcon;
    private const string XPerienceLiveData;
    private const string XPerienceLiveFuel;
    private const string XPerienceLiveFuelBar;
    private const string XPerienceLiveSpeed;
    private const string XPerienceLiveSpeedIcon;
    private const string XPerienceLiveSpeedBar;
    private const string XPerienceLiveDashPanel;
    private const string XPerienceLiveDashPanelSet;
    private const string XPeriencePlayerProfileOutside;
    private const string XPeriencePlayerProfile;
    private const string XPeriencePlayerProfileMenu;
    private const string XPeriencePlayerProfileMain;
    private const string XPeriencePlayerProfileStatsAndSkills;
    private const string XPeriencePlayerProfileStatsAndSkillsMenu;
    private const string XPeriencePlayerProfileSettings;
    private const string XPeriencePlayerProfileKills;
    private const string XPeriencePlayerProfileKillsPages;
    private const string XPeriencePlayerProfileRaids;
    private const string XPeriencePlayerProfileRaidsPages;
    private const string XPeriencePlayerProfileHelp;
    private const string XPeriencePlayerProfileHelpPages;
    private const string XPeriencePlayerControlPromptBox;
    private const string XPeriencePlayerControlPrompt;
    private const string XPeriencePlayerDMGSkins;
    private const string XPeriencePlayerBGImgs;
    private const string XPeriencePlayerCalculations;
    private const string XPeriencePlayerCalculationsLevelSelection;
    private const string XPeriencePlayerCalculationsRanksSelection;
    private const string XPerienceTopSelection;
    private const string XPerienceTopInner;
    private const string XPerienceTopPageSelection;
    private const string XPerienceAdminPanelMain;
    private const string XPerienceAdminPanelMenu;
    private const string XPerienceAdminPanelInfo;
    private const string XPerienceAdminPanelLevelXP;
    private const string XPerienceAdminPanelRanks;
    private const string XPerienceAdminPanelStats;
    private const string XPerienceAdminPanelSkills;
    private const string XPerienceAdminPanelSkillItems;
    private const string XPerienceAdminPanelTimerColor;
    private const string XPerienceAdminPanelOtherMods;
    private const string XPerienceAdminPanelSQL;
    private const string XPerienceAdminPanelReset;
    private const string XPerienceAdminPanelInfoBox;
    private const string XPerienceAdminPanelAddon;
    private const string XPerienceAdminPanelDailyLimits;
    private const string XPerienceAdminPanelSoundEffects;
    private const string XPerienceAdminPanelElectricianSettings;
    private const string XPerienceAdminPanelProfileBackgrounds;
    private const string XPerienceAdminPanelImages;
    private const string XPerienceAdminPanelSpecialGroups;
    private const string XPerienceAdminPanelBackpackSelection;
    private const string XPerienceicon;
    private const string XPeriencelogo;
    private const string XPeriencementality;
    private const string XPeriencedexterity;
    private const string XPeriencemight;
    private const string XPeriencecaptaincy;
    private const string XPerienceweaponry;
    private const string XPerienceninjary;
    private const string XPeriencewoodcutter;
    private const string XPeriencesmithy;
    private const string XPerienceminer;
    private const string XPerienceforager;
    private const string XPeriencehunter;
    private const string XPeriencefisher;
    private const string XPeriencecrafter;
    private const string XPerienceframer;
    private const string XPeriencemedic;
    private const string XPeriencescavenger;
    private const string XPerienceelectrician;
    private const string XPeriencedemolitionist;
    private const string XPeriencetamer;
    private const string XPeriencechicken;
    private const string XPerienceboar;
    private const string XPeriencestag;
    private const string XPeriencewolf;
    private const string XPeriencebear;
    private const string XPeriencepolarbear;
    private const string XPeriencearchery;
    private const string XPeriencewizardry;
    private const string XPerienceonline;
    private const string XPerienceoffline;
    private const string XPeriencebackpack;
    private const string XPeriencelevel;
    private const string XPeriencexp;
    private const string XPeriencearmor;
    private const string XPeriencelevel0;
    private const string XPeriencelevel2;
    private const string XPeriencelevel4;
    private const string XPeriencelevel6;
    private const string XPeriencelevel8;
    private const string XPeriencelevel10;
    private const string XPeriencefuelguage;
    private const string XPeriencespeedometer;
    private const string XPeriencedash;
    private const string XPerienceraideasy;
    private const string XPerienceraidmedium;
    private const string XPerienceraidhard;
    private const string XPerienceraidexpert;
    private const string XPerienceraidnightmare;
    private const string XPerienceprofilebg;
    private const string XPeriencemenubg;
    private const string XPerienceaddondmgbarhealth1;
    private const string XPerienceaddondmgbarhealth2;
    private const string XPerienceaddondmgbarhealth3;
    private const string XPerienceaddondmgbarhealth4;
    private const string XPerienceaddondmgbarhealth5;
    private const string XPerienceaddondmgbarhealth6;
    private const string XPerienceaddondmgbarhealth7;
    private const string XPerienceaddondmgbarhealth8;
    private const string XPerienceaddondmgbarhealth9;
    private const string XPerienceaddondmgbarhealth10;
    private object TextColor(BasePlayer player, string type, double value, bool enabled);
    private object ValueSymbol(string type, double value, string symbol);
    private object LiveUISelection(string selection, int value);
    private object DashSelection(int selection, int value);
    private object DisableRankSelection(string selection, bool value, string color);
    private object DisableSelection(string selection, bool value, string color);
    private object ColorConverter(string color);
    private object LiveColorConverter(string color);
    private CuiPanel XPUIPanel(string anchorMin, string anchorMax, string color);
    private CuiPanel XPUIPanel2(string anchorMin, string anchorMax, string offsetMin, string offsetMax, string color);
    private CuiLabel XPUILabel(string text, int i, float height, TextAnchor align, int fontSize, string xMin, string xMax, string color);
    private CuiButton XPUIButton(string command, double i, float rowHeight, int fontSize, string color, string content, string xMin, string xMax, TextAnchor align, string fcolor);
    private CuiButton XPUIMenuButton(string command, double i, float rowHeight, int fontSize, string color, string content, string xMin, string xMax, TextAnchor align, string fcolor, double space);
    private CuiElement XPUIImage(string parent, string image, int i, float imgheight, string xMin, string xMax);
    private CuiElement XPUIInput(string parent, string command, int i, float height, int fontSize, string content, string xMin, string xMax, TextAnchor align, string color, int limit);
    private CuiPanel XPUIInputbackground(int i, float height, string color, string xMin, string xMax);
    private CuiButton XPToggle(string command, int i, float height, bool value, string xMin, double width);
    private void DestroyUi(BasePlayer player, string name);
    [ConsoleCommand("xp.playercontrol")]
    private void Cmdplayercontrolnew(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.playeredits")]
    private void Cmdplayeredits(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.topplayers")]
    private void Cmdtopplayernew(ConsoleSystem.Arg arg);
    private string LevelIcon(BasePlayer player, int percent);
    private object PlayerTimeValues(BasePlayer player, string type, double value);
    private object PlayerInfoValues(BasePlayer player, BaseEntity entity, string type);
    private string SelectedIcon(string type, string data);
    private object SelectedData(string type, string data, string page);
    private double IconAdjustment(double adjustment, string type);
    private double RankBoosts(BasePlayer player, string type, double amount, bool enabled);
    private string ConvertUnixTimeStampToDateTime(int unixtime);
    public class Deaths
    {
        public string victim;
        public string victimname;
        public string attacker;
        public string attackername;
        public string weapon;
        public string lastdamage;
        public float distance;
        public long timestamp;
    }

    private class Raids
    {
        public Vector3 Location;
        public string BaseName;
        public int mode;
        public bool allowPVP;
        public string id;
        public float spawnTime;
        public float despawnTime;
        public float loadTime;
        public ulong ownerid;
        public List<ulong> raiders;
        public DateTime spawnDateTime;
        public DateTime despawnDateTime;
    }

    public class DmgBarImgs
    {
        public string name;
        public string url;
    }

    private static string PositionToGrid(Vector3 position);
    private object GetKillRecords(string player, string entity);
    private IEnumerable<XPRecord> GetTopXP(int page, int takeCount, string selection);
    private void ClearPlayerUIs(BasePlayer player, bool all, bool live);
    public void LiveStats(BasePlayer player, bool zone, string consumable);
    private void DashPanel(BasePlayer player, bool active, BaseMountable entity);
    public void PlayerProfile(BasePlayer player, BasePlayer otherplayer);
    public void PlayerProfileMain(BasePlayer player, BasePlayer otherplayer);
    private void PlayerProfileStatsAndSkills(BasePlayer player, string data, string type);
    private void PlayerProfileRecords(BasePlayer player, string data, BasePlayer otherplayer, int page, string ordertype, string order);
    private void PlayerProfileRaids(BasePlayer player, int page, BasePlayer otherplayer);
    private void PlayerTopList(BasePlayer player, int page, string selection, int number);
    private void PlayerSettings(BasePlayer player);
    private void PlayerHelp(BasePlayer player, string data, string type);
    private void PlayerCalculationPageLevels(BasePlayer player, int page, int rank);
    private void PlayerCalculationPageRanks(BasePlayer player, int page);
    private void PlayerCalculationPageStats(BasePlayer player);
    private void PlayerCalculationPageSkills(BasePlayer player);
    private void PlayerProfileBGImgs(BasePlayer player, int page);
    private void PlayerDamageBarSkins(BasePlayer player, int page);
    private void PlayerPromptBox(BasePlayer player, string function, string types, string name);
    private void PlayerStatsChat(BasePlayer player);
    [TextArea]
    private string UserInputText;
    [ConsoleCommand("xp.admin")]
    private void Cmdadminxp(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.config")]
    private void Cmdadminxpconfig(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.color")]
    private void Cmdadminxpcolors(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.electrician")]
    private void Cmdadminxpelectrician(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.ranks")]
    private void Cmdadminxpranks(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.images")]
    private void Cmdadminimages(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.skillitems")]
    private void Cmdadminskillitems(ConsoleSystem.Arg arg);
    [ConsoleCommand("xp.specialgroups")]
    private void Cmdadminspecialgroups(ConsoleSystem.Arg arg);
    private void ClearUIs(BasePlayer player);
    private void AdminControlPanel(BasePlayer player);
    private void AdminInfoPage(BasePlayer player);
    private void AdminLevelPage(BasePlayer player);
    private void AdminRanksPage(BasePlayer player, string page, int rank);
    private void AdminDailyLimitsPage(BasePlayer player);
    private void AdminStatsPage(BasePlayer player, string stat);
    private void AdminSkillsPage(BasePlayer player, string skill);
    private void AdminSkillItems(BasePlayer player, string page, string skill, int item);
    private void AdminSpecialGroups(BasePlayer player, string page, int groupid);
    private void AdminPlayerInfoPage(BasePlayer player);
    private void AdminTimerColorPage(BasePlayer player);
    private void AdminImagePaths(BasePlayer player, string page, int bg);
    private void AdminOtherModsPage(BasePlayer player, string mod, string page, int option);
    private void OtherMods_KillRecords(BasePlayer player);
    private void OtherMods_ZoneManager(BasePlayer player);
    private void OtherMods_EventHelper(BasePlayer player);
    private void OtherMods_Economics(BasePlayer player);
    private void OtherMods_ServerRewards(BasePlayer player);
    private void OtherMods_Pets(BasePlayer player);
    private void OtherMods_Backpacks(BasePlayer player, string page, int option);
    private void OtherMods_BackpacksSelection(BasePlayer player, string selected);
    private void AdminSoundEffectsPage(BasePlayer player);
    private void AdminSQLPage(BasePlayer player);
    private void AdminResetPage(BasePlayer player);
    private void AdminAddonPage(BasePlayer player);
    private void AdminElectricianSettings(BasePlayer player);
    private void AdminProfileBackgrounds(BasePlayer player, int selected, int page);
    private string XPLang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
    [HookMethod("GiveXPID")]
     void GiveXPID(ulong playerid, double amount);
    [HookMethod("GiveXP")]
     void GiveXP(BasePlayer player, double amount);
    [HookMethod("GiveXPBasic")]
     void GiveXPBasic(BasePlayer player, double amount);
    [HookMethod("GiveStatPoints")]
     void GiveStatPoints(BasePlayer player, int amount);
    [HookMethod("GiveSkillPoints")]
     void GiveSkillPoints(BasePlayer player, int amount);
    [HookMethod("TakeXP")]
     void TakeXP(BasePlayer player, double amount);
    [HookMethod("GetXPCache")]
     string GetXPCache(BasePlayer player, string info);
}

public static class RandomNumber
{
    private static readonly RNGCryptoServiceProvider _generator;
    public static int Between(int minimumValue, int maximumValue);
}

public class Configuration : SerializableConfiguration
{
    [JsonProperty("Player Chat Commands")]
    public PlayerChatCommands playerchatCommands;
    [JsonProperty("Admin Chat Commands")]
    public AdminChatCommands adminchatCommands;
    [JsonProperty("Player Info Box")]
    public PlayerProfileSettings playerprofilesettings;
    [JsonProperty("Default Options")]
    public DefaultOptions defaultOptions;
    [JsonProperty("Sound Effects")]
    public SoundEffects soundEffects;
    [JsonProperty("UI Text Colors")]
    public UITextColor uitextColor;
    [JsonProperty("Image Icons")]
    public ImageIcons imageicons;
    [JsonProperty("XP - Level Config")]
    public XpLevel xpLevel;
    [JsonProperty("Daily Timer Config")]
    public DailyTimer dailytimer;
    [JsonProperty("Daily XP Limit Config")]
    public DailyXpLimit dailyxpLimit;
    [JsonProperty("Daily Reset Limit Config")]
    public DailyResetLimit dailyresetLimit;
    [JsonProperty("XP - Level Ranks")]
    public XpLevelRanks xpLevelRanks;
    [JsonProperty("Rank Boosts")]
    public RankBoostsSettings Rankboostssettings;
    [JsonProperty("Special Groups")]
    public SpecialGroups specialGroups;
    [JsonProperty("XP - Night Bonus")]
    public NightBonus nightBonus;
    [JsonProperty("XP - Gain Amounts")]
    public XpGain xpGain;
    [JsonProperty("XP - Gather Amounts")]
    public XpGather xpGather;
    [JsonProperty("XP - Building Amounts")]
    public XpBuilding xpBuilding;
    [JsonProperty("XP - Teams")]
    public XpTeams xpTeams;
    [JsonProperty("XP - Mission Amounts")]
    public XpMissions xpMissions;
    [JsonProperty("XP - Reducer Amounts")]
    public XpReducer xpReducer;
    [JsonProperty("BonusXP - Bonus Amounts (requires KillRecords plugin)")]
    public XpBonus xpBonus;
    [JsonProperty("Economics Rewards (requires Economics plugin)")]
    public XpEcon xpEcon;
    [JsonProperty("Server Rewards (requires ServerRewards plugin)")]
    public SRewards sRewards;
    [JsonProperty("Mentality Stat")]
    public Mentality mentality;
    [JsonProperty("Dexterity Stat")]
    public Dexterity dexterity;
    [JsonProperty("Might Stat")]
    public Might might;
    [JsonProperty("Captaincy Stat")]
    public Captaincy captaincy;
    [JsonProperty("Weaponry Stat")]
    public Weaponry weaponry;
    [JsonProperty("Ninjary Stat")]
    public Ninjary ninjary;
    [JsonProperty("WoodCutter Skill")]
    public Woodcutter woodcutter;
    [JsonProperty("Smithy Skill")]
    public Smithy smithy;
    [JsonProperty("Miner Skill")]
    public Miner miner;
    [JsonProperty("Forager Skill")]
    public Forager forager;
    [JsonProperty("Hunter Skill")]
    public Hunter hunter;
    [JsonProperty("Fisher Skill")]
    public Fisher fisher;
    [JsonProperty("Crafter Skill")]
    public Crafter crafter;
    [JsonProperty("Framer Skill")]
    public Framer framer;
    [JsonProperty("Medic Skill")]
    public Medic medic;
    [JsonProperty("Scavenger Skill")]
    public Scavenger scavenger;
    [JsonProperty("Electrician Skill")]
    public Electrician electrician;
    [JsonProperty("Demolitionist Skill")]
    public Demolitionist demolitionist;
    [JsonProperty("Tamer Skill")]
    public Tamer tamer;
    [JsonProperty("SQL Info")]
    public SQL sql;
    [JsonProperty("Backpacks Mod")]
    public BackpacksMod backpacksmod;
    [JsonProperty("ZoneManager Mod")]
    public ZoneManagerMod zonemanagermod;
    [JsonProperty("EventHelper Mod")]
    public EventHelperMod eventhelpermod;
    [JsonProperty("SurvivalArena Mod")]
    public SurvivalArenaMod survivalarenamod;
    [JsonProperty("Raidable Bases")]
    public RaidableBasesMod raidablebasesmod;
}

public class PlayerChatCommands
{
    public string openplayerstats;
    public string openplayerstats2;
    public string openplayerstats3;
    public string showplayerstatschat;
    public string opentopplayers;
    public string playeraddstat;
    public string playeraddskill;
    public string playerresetstats;
    public string playerresetskills;
    public string playerresetall;
    public string playerliveuichange;
    public string openhelp;
}

public class AdminChatCommands
{
    public string showadminhelp;
    public string openadminpanel;
    public string adminresetxperience;
    public string adminxpgive;
    public string adminxpgiveall;
    public string adminpointsgive;
    public string adminxptake;
    public string adminresetplayer;
    public string adminfixdata;
    public string adminitemchange;
    public string adminresetharvest;
    public string adminresetlevelonly;
    public string adminresetrankonly;
    public string adminresetstat;
    public string adminresetskill;
    public string adminresetlevelonlyall;
    public string adminresetrankonlyall;
    public string adminexcludeplayer;
    public string admingiveitem;
}

public class PlayerProfileSettings
{
    public bool showunusedeffects;
    public bool useplayeravatar;
    public bool profilemenusettings;
    public bool profilemenutopplayers;
    public bool profilemenuraids;
    public bool profilemenuhelp;
    public bool profilemenucalculations;
    public bool skillshelp;
    public bool profilemenuwelcome;
    public bool playtime;
    public bool alivetime;
    public bool sleepingtime;
    public bool swimingtime;
    public bool drivingtime;
    public bool flyingtime;
    public bool boatingtime;
    public bool basetime;
    public bool monumenttime;
    public bool wildernesstime;
    public bool metersran;
    public bool meterswalked;
    public bool lastdmgrec;
    public bool lastdmgrecby;
    public bool lastdmgdelt;
    public bool lastdmgdeltto;
    public string AnchorMin;
    public string AnchorMax;
    public string OffsetMin;
    public string OffsetMax;
    public string InsideAnchorMin;
    public string InsideAnchorMax;
    public int menutype;
    public bool usebgimage;
    public int profilebg;
    public bool allowprofilebgchange;
    public bool usemenubgimage;
    public double bgfadein;
    public double menuwidth;
    public double menuheight;
    public double menubuttonheight;
    public int menubuttonfont;
}

public class DefaultOptions
{
    public bool userpermissions;
    public int liveuistatslocation;
    public bool liveuistatslocationmoveable;
    public bool showchatprofileonconnect;
    public int NotifcationCooldown;
    public bool restristresets;
    public bool allowrespec;
    public int resetminsstats;
    public int resetminsskills;
    public bool bypassadminreset;
    public int vipresetminstats;
    public int vipresetminsskills;
    public int playerfixdatatimer;
    public bool disableplayerfixdata;
    public bool disablearmorchat;
    public bool hardcorenoreset;
    public bool allowplayersearch;
    public bool allowplayerreset;
    public int topplayersperpage;
    public bool showonlinestatus;
    public bool useprogressivelevelicons;
    public bool showfuelguage;
    public bool showspeedometer;
    public int speedometertype;
    public bool dropsgotoplayerinventory;
    public bool wipedataonnewsave;
    public bool enabledashpanel;
    public bool enableconfirmationprompt;
    public bool showchatnotifications;
    public bool showlevelinchat;
    public bool hidechatnotifications;
    public bool debugmode;
}

public class SoundEffects
{
    public bool levelup;
    public bool leveldown;
    public bool rankup;
    public bool statup;
    public bool skillup;
    public bool statreset;
    public bool skillreset;
    public bool scavengerloot;
    public bool foragerloot;
    public string levelupeffect;
    public string leveldowneffect;
    public string rankupeffect;
    public string statupeffect;
    public string skillupeffect;
    public string statreseteffect;
    public string skillreseteffect;
    public string scavengerlooteffect;
    public string foragerlooteffect;
}

public class UITextColor
{
    public string defaultcolor;
    public string level;
    public string ranklevel;
    public string rankxp;
    public string rankname;
    public string experience;
    public string nextlevel;
    public string remainingxp;
    public string statskilllevels;
    public string perks;
    public string unspentpoints;
    public string spentpoints;
    public string pets;
    public string mentality;
    public string dexterity;
    public string might;
    public string captaincy;
    public string weaponry;
    public string Ninjary;
    public string woodcutter;
    public string smithy;
    public string miner;
    public string forager;
    public string hunter;
    public string fisher;
    public string crafter;
    public string framer;
    public string medic;
    public string scavenger;
    public string electrician;
    public string demolitionist;
    public string tamer;
    public string xpbar;
    public string armorbar;
}

public class ImageIcons
{
    public bool uselocalpath;
    public string rootpath;
    public string xperiencelogo;
    public string mainicon;
    public string mentality;
    public string dexterity;
    public string might;
    public string captaincy;
    public string weaponry;
    public string ninjary;
    public string woodcutter;
    public string smithy;
    public string miner;
    public string forager;
    public string hunter;
    public string fisher;
    public string crafter;
    public string framer;
    public string medic;
    public string scavenger;
    public string electrician;
    public string demolitionist;
    public string tamer;
    public string chicken;
    public string boar;
    public string stag;
    public string wolf;
    public string bear;
    public string polarbear;
    public string archery;
    public string wizardry;
    public string online;
    public string offline;
    public string backpack;
    public string xp;
    public string level;
    public string armor;
    public string level0;
    public string level2;
    public string level4;
    public string level6;
    public string level8;
    public string level10;
    public string dash;
    public string raideasy;
    public string raidmedium;
    public string raidhard;
    public string raidexpert;
    public string raidnightmare;
    public string profilebg;
    public string menubg;
    public Dictionary<int, BackgroundImgs> bgimages;
}

public class BackgroundImgs
{
    public string name;
    public string url;
}

public class XpLevel
{
    public double levelstart;
    public double levelmultiplier;
    public int maxlevel;
    public double levelxpboost;
    public int statpointsperlvl;
    public int skillpointsperlvl;
    public bool alwaysearnxp;
    public bool fullhealth;
    public bool fullmetabolism;
}

public class XpLevelRanks
{
    public bool enableresetranks;
    public bool resetallstatsskills;
    public bool allowplayerdisable;
    public bool increaselevelmultiplier;
    public double levelmultiplierincrease;
    public int maxresetrank;
    public bool enablerankxpboost;
    public double rankxpboost;
    public bool rankstatboost;
    public double rankstatboostamount;
    public int rankstatpointstart;
    public int rankstatpointincrease;
    public bool rankskillboost;
    public double rankskillboostamount;
    public int rankskillpointstart;
    public int rankskillpointincrease;
    public bool keepremainingxp;
    public bool showtruelevelprofile;
    public bool showrankinchat;
    public bool showtruexpprofile;
    public bool showrankinliveui;
    public bool keepgrouponrank;
    public Dictionary<int, Ranks> ranks;
}

public class RankBoostsSettings
{
    public bool researchcost;
    public bool researchspeed;
    public bool block;
    public bool armor;
    public bool distance;
    public bool meleedmg;
    public bool metabolism;
    public bool woodcuttergr;
    public bool woodcutterbonus;
    public bool smithypr;
    public bool smithyps;
    public bool smithyfc;
    public bool smithyhqmc;
    public bool smithyhqma;
    public bool minergr;
    public bool minerbonus;
    public bool minermfc;
    public bool minerfuel;
    public bool minermfa;
    public bool fisherfa;
    public bool fisheria;
    public bool fisherotr;
    public bool foragergr;
    public bool foragergwa;
    public bool foragerric;
    public bool huntergr;
    public bool hunterbonus;
    public bool hunterdmg;
    public bool hunterndmg;
    public bool crafterspeed;
    public bool craftercost;
    public bool crafterri;
    public bool crafterrc;
    public bool craftercc;
    public bool crafterca;
    public bool framerucost;
    public bool framerrcost;
    public bool medicrevivala;
    public bool medicrecovera;
    public bool medictools;
    public bool scavelc;
    public bool scavelm;
    public bool scavcic;
    public bool scavcim;
}

public class Ranks
{
    public string name;
    public string sig;
    public string image;
    public string group;
    public string description;
}

public class SpecialGroups
{
    public Dictionary<int, Specialgroups> specialgroups;
}

public class Specialgroups
{
    public string groupname;
    public string permissionname;
    public int grouppriority;
    public double xpboost;
    public int dailyxplimit;
    public int dailystatlimitboost;
    public int dailyskilllimitboost;
}

public class DailyTimer
{
    public int dailyresettimerhours;
    public DateTime lastdailyreset;
}

public class DailyXpLimit
{
    public bool enabledailyxplimit;
    public int dailyxplimit;
    public int dailyxplimitvip;
    public int limitmultipliertype;
    public int limitmultiplier;
    public double limitpercentage;
}

public class DailyResetLimit
{
    public bool enabledailyresetlimit;
    public int dailystatlimit;
    public int dailystatlimitvip;
    public int dailyskilllimit;
    public int dailyskilllimitvip;
}

public class NightBonus
{
    public bool Enable;
    public int StartTime;
    public int EndTime;
    public double Bonus;
    public bool enableskillboosts;
}

public class XpGain
{
    public double chickenxp;
    public double fishxp;
    public double boarxp;
    public double stagxp;
    public double wolfxp;
    public double bearxp;
    public double polarbearxp;
    public double sharkxp;
    public double horsexp;
    public double scientistxp;
    public double sc_full;
    public double sc_heavy;
    public double sc_cargo;
    public double sc_junkpile;
    public double sc_oilrig;
    public double sc_patrol;
    public double sc_peacekeeper;
    public double sc_roam;
    public double dwellerxp;
    public double tunneldwellerxp;
    public double underwaterdwellerxp;
    public double scarecrownpc;
    public double customnpc;
    public double zombienpc;
    public double playerxp;
    public double lootcontainerxp;
    public double lootbarrel;
    public double oilbarrel;
    public double vehicleparts;
    public double toolcrate;
    public double normalcrate;
    public double elitecrate;
    public double foodcrate;
    public double medicalcrate;
    public double animalharvestxp;
    public double corpseharvestxp;
    public double underwaterlootcontainerxp;
    public double lockedcratexp;
    public double hackablecratexp;
    public double craftingxp;
    public bool craftingxpdelay;
    public double craftingxpdelayseconds;
    public double bradley;
    public double patrolhelicopter;
    public double turretxp;
    public bool allowturretxp;
    public double playerrevive;
    public bool enablexpboost;
    public double xpboostamount;
    public int xpboostorder;
    public double gifts;
    public double opengifts;
    public double opengiftsmed;
    public double opengiftslarge;
    public double upgradegiftsmed;
    public double upgradegiftslarge;
    public double craftmeal;
}

public class XpGather
{
    public double treexp;
    public double orexp;
    public double metalorexp;
    public double stoneorexp;
    public double sulfurorexp;
    public double harvestxp;
    public double plantxp;
    public bool noxptools;
    public bool onetimexp;
    public double toolxpchance;
    public double toolxppercent;
}

public class XpBuilding
{
    public double twigstructure;
    public double woodstructure;
    public double stonestructure;
    public double metalstructure;
    public double armoredstructure;
    public bool preventBGxp;
    public bool buildxpdelay;
    public bool requirebuildingprivlidge;
    public int buildxpdelayseconds;
    public bool reducexp;
    public double buildxpreduction;
}

public class XpTeams
{
    public bool enableteamxpgain;
    public bool enableteamxploss;
    public double teamxpgainamount;
    public double teamxplossamount;
    public float teamdistance;
}

public class XpMissions
{
    public double missionsucceededxp;
    public bool missionfailed;
    public double missionfailedxp;
}

public class XpReducer
{
    public bool suicidereduce;
    public double suicidereduceamount;
    public bool deathreduce;
    public double deathreduceamount;
    public bool rankdeathreduce;
}

public class XpBonus
{
    public bool showkrbutton;
    public bool enablebonus;
    public int requiredkills;
    public double bonusxp;
    public int endbonus;
    public bool multibonus;
    public string multibonustype;
}

public class XpEcon
{
    public bool showbalanceprofile;
    public bool econlevelup;
    public bool econleveldown;
    public bool econresetstats;
    public bool econresetskills;
    public bool econresetstat;
    public bool econresetskill;
    public double econlevelreward;
    public double econlevelreduction;
    public double econresetstatscost;
    public double econresetskillscost;
    public double econresetstatcost;
    public double econresetskillcost;
    public bool econstatlevelcost;
    public bool econskilllevelcost;
    public double econstatlevelcostmultiplier;
    public double econskilllevelcostmultiplier;
    public double econmentality;
    public double econdexterity;
    public double econmight;
    public double econcaptaincy;
    public double econweaponry;
    public double econninjary;
    public double econwoodcutter;
    public double econsmithy;
    public double econminer;
    public double econforager;
    public double econhunter;
    public double econfisher;
    public double econcrafter;
    public double econframer;
    public double econmedic;
    public double econscavenger;
    public double econelectrician;
    public double econdemolitionist;
    public double econtamer;
}

public class SRewards
{
    public bool srewardlevelup;
    public bool srewardleveldown;
    public bool srewardresetstats;
    public bool srewardresetskills;
    public bool srewardresetstat;
    public bool srewardresetskill;
    public int srewardlevelupamt;
    public int srewardleveldownamt;
    public int srewardresetstatscost;
    public int srewardresetskillscost;
    public int srewardresetstatcost;
    public int srewardresetskillcost;
    public bool srewardstatlevelcost;
    public bool srewardskilllevelcost;
    public int srewardstatlevelcostmultiplier;
    public int srewardskilllevelcostmultiplier;
    public int srewardmentality;
    public int srewarddexterity;
    public int srewardmight;
    public int srewardcaptaincy;
    public int srewardweaponry;
    public int srewardninjary;
    public int srewardwoodcutter;
    public int srewardsmithy;
    public int srewardminer;
    public int srewardforager;
    public int srewardhunter;
    public int srewardfisher;
    public int srewardcrafter;
    public int srewardframer;
    public int srewardmedic;
    public int srewardscavenger;
    public int srewardelectrician;
    public int srewardemolitionist;
    public int srewardtamer;
}

public class Mentality
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double researchcost;
    public double researchcosttechtree;
    public double researchspeed;
    public double criticalchance;
    public double criticaldgm;
    public double damageincrease;
    public bool useotherresearchmod;
    public bool locktechtree;
    public int unlocktechtreelevel;
}

public class Dexterity
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double blockchance;
    public double blockamount;
    public double dodgechance;
    public double reducearmordmg;
    public double horsespeed;
    public double boatspeed;
    public double vehiclespeed;
    public double fuelreduce;
}

public class Might
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double armor;
    public double meleedmg;
    public double metabolism;
    public double bleedreduction;
    public double radreduction;
    public double heattolerance;
    public double coldtolerance;
}

public class Captaincy
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public bool allownoteam;
    public double skillboost;
    public bool enablexpboost;
    public double xpboost;
    public float captaincydistance;
}

public class Weaponry
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double reductionchance;
    public double tool;
    public double powertools;
    public double meleeweapons;
    public double projectileweapons;
    public double mindamage;
    public double maxammo;
    public double maxammolimit;
    public bool skinboxdisable;
    public bool neverweartools;
    public bool neverwearweapons;
    public string reloadhook;
    public string excludedweapons;
    public bool useweaponmechanics;
}

public class Ninjary
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double patrolstealth;
    public double ch47stealth;
    public double bradleystealth;
    public double npcstealth;
    public double turretstealth;
    public double knifeincrease;
    public double swordincrease;
}

public class Woodcutter
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double gatherrate;
    public double bonusincrease;
    public double applechance;
}

public class Smithy
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double productionrate;
    public double productionspeed;
    public double fuelconsumption;
    public double metalchance;
    public int metalamount;
}

public class Miner
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double gatherrate;
    public double bonusincrease;
    public double fuelconsumption;
    public double metalchance;
    public int metalamount;
}

public class Forager
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double gatherrate;
    public double chanceincrease;
    public double grubwormincrease;
    public double randomchance;
    public Dictionary<int, RandomChanceList> randomChanceList;
}

public class RandomChanceList
{
    public string shortname;
    public string displayname;
    public ulong SkinID;
    public int amount;
}

public class Hunter
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double gatherrate;
    public double bonusincrease;
    public double damageincrease;
    public double nightdmgincrease;
    public double bowdmgincrease;
    public bool excludelongrangeweapons;
    public bool excludemedrangeweapons;
}

public class Fisher
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double fishamountincrease;
    public double itemamountincrease;
    public double oxygenreduction;
    public double oxygentankreduction;
}

public class Crafter
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double craftspeed;
    public double craftcost;
    public double repairincrease;
    public double repaircost;
    public double conditionchance;
    public double conditionamount;
}

public class Framer
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double upgradecost;
    public double repaircost;
    public double repairtime;
    public int woodcost;
    public int stonecost;
    public int metalcost;
    public int armorcost;
}

public class Electrician
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public int solarpaneldefault;
    public int smallbatterydefault;
    public int mediumbatterydefault;
    public int largebatterydefault;
    public int smallgeneratordefault;
    public int testgeneratordefault;
    public int electricwindmilldefault;
    public double solarpanelinputincrease;
    public double solarpanelmaxincrease;
    public double smallbatterymaxincrease;
    public double mediumbatterymaxincrease;
    public double largebatterymaxincrease;
    public double smallgeneratormaxincrease;
    public double testgeneratormaxincrease;
    public double electricwindmillincrease;
    public double electricwindmillmaxincrease;
    public bool allowminsolarinput;
    public int minsolarinput;
}

public class Demolitionist
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double explosivedudreduction;
    public double explosivedamage;
    public double explosiveradius;
}

public class Medic
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double revivehp;
    public double recoverhp;
    public double crafttime;
    public double tools;
    public double teas;
    public bool preventbandageboost;
}

public class Scavenger
{
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public double scavlootchance;
    public double scavchance;
    public double scavmultiplier;
    public double customscavmultiplier;
    public bool customscavrandom;
    public bool usecustomscavlist;
    public bool drops;
    public bool crates;
    public bool uncrates;
    public bool lockedcrates;
    public bool hackcrates;
    public bool scientists;
    public bool componentsonly;
    public Dictionary<int, ScavChanceList> scavChanceList;
}

public class ScavChanceList
{
    public string shortname;
    public string displayname;
    public ulong SkinID;
    public int amount;
    public int maxamount;
    public int requiredlevel;
}

public class Tamer
{
    public bool enabletame;
    public int maxlvl;
    public int pointcoststart;
    public int costmultiplier;
    public bool tamechicken;
    public bool tameboar;
    public bool tamestag;
    public bool tamewolf;
    public bool tamebear;
    public bool tamepolarbear;
    public int chickenlevel;
    public int boarlevel;
    public int staglevel;
    public int wolflevel;
    public int bearlevel;
    public int polarbearlevel;
}

public class SQL
{
    public bool enablesql;
    public string SQLhost;
    public int SQLport;
    public string SQLdatabase;
    public string SQLusername;
    public string SQLpassword;
}

public class BackpacksMod
{
    public bool enablebackpacks;
    public string statorskill;
    public bool removeonunload;
    public SortedDictionary<int, BackPackSlots> BackPackSlots;
}

public class BackPackSlots
{
    public int level;
    public int slots;
}

public class ZoneManagerMod
{
    public string noxpgain;
    public string noxploss;
    public string disablestatsandskills;
}

public class EventHelperMod
{
    public string noxpgain;
    public string noxploss;
    public string disablestatsandskills;
}

public class SurvivalArenaMod
{
    public bool noxpgain;
    public bool noxploss;
    public bool disablestatsandskills;
}

public class RaidableBasesMod
{
    public bool disableabilities;
    public bool noxploss;
    public bool noxpgain;
}

public class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

public class XPData
{
    public Dictionary<string, XPRecord> XPerience;
}

public class XPRecord
{
    public int rank;
    public int truelevel;
    public int trueexperience;
    public double level;
    public double experience;
    public double requiredxp;
    public int statpoint;
    public int skillpoint;
    public int Mentality;
    public int MentalityP;
    public int Dexterity;
    public int DexterityP;
    public int Might;
    public int MightP;
    public int Captaincy;
    public int CaptaincyP;
    public int Weaponry;
    public int WeaponryP;
    public int Ninjary;
    public int NinjaryP;
    public int WoodCutter;
    public int WoodCutterP;
    public int Smithy;
    public int SmithyP;
    public int Miner;
    public int MinerP;
    public int Forager;
    public int ForagerP;
    public int Hunter;
    public int HunterP;
    public int Fisher;
    public int FisherP;
    public int Crafter;
    public int CrafterP;
    public int Framer;
    public int FramerP;
    public int Electrician;
    public int ElectricianP;
    public int Medic;
    public int MedicP;
    public int Scavenger;
    public int ScavengerP;
    public int Demolitionist;
    public int DemolitionistP;
    public int Tamer;
    public int TamerP;
    public int Wood;
    public int Stone;
    public int Metal;
    public int Sulfur;
    public int Cactus;
    public int Berries;
    public int Pumpkin;
    public int Potato;
    public int Corn;
    public int Mushroom;
    public int Hemp;
    public int Seed;
    public bool Status;
    public bool DisableRank;
    public int UILocation;
    public string teatype;
    public double teacooldown;
    public DateTime resettimerstats;
    public DateTime resettimerskills;
    public DateTime playerfixdata;
    public int dash;
    public int dmgbar;
    public int profilebg;
    public bool fuelgauge;
    public bool speedometer;
    public int speedometertype;
    public bool enableconfirmationprompt;
    public bool showchatnotifications;
    public bool showchatprofileonconnect;
    public bool showwelcomepanel;
    public bool showchatxp;
    public bool exclude;
    public bool raidablebase;
    public string displayname;
    public string id;
}

public class DailyData
{
    public Dictionary<string, DailyRecord> DailyXPerience;
}

public class DailyRecord
{
    public double dailyexperience;
    public int dailystatresets;
    public int dailyskillresets;
    public DateTime lastexperiencereset;
    public DateTime laststatreset;
    public DateTime lastskillreset;
}

private class LootData
{
    public Dictionary<ulong, Loot> LootRecords;
}

private class Loot
{
    public List<string> id;
}

private class CorpseData
{
    public Dictionary<ulong, Corpse> CorpseRecords;
}

private class Corpse
{
    public ulong corpsecontainer;
    public List<string> id;
}

private class HorseData
{
    public Dictionary<ulong, Horse> HorseRecords;
}

private class Horse
{
    public ulong horse;
    public float maxSpeed;
    public float runSpeed;
    public float walkSpeed;
    public float trotSpeed;
    public ulong player;
}

private class WeaponData
{
    public Dictionary<ulong, Weapon> WeaponRecords;
}

private class Weapon
{
    public int defaultammo;
    public int maxammo;
    public double defaultreload;
    public double newreload;
    public double defaultdistance;
    public double maxdistance;
    public double defaultrange;
    public double maxrange;
    public ulong player;
    public NetworkableId weapondata;
}

private class BoatData
{
    public Dictionary<ulong, Boat> BoatRecords;
}

private class Boat
{
    public ulong boat;
    public float defaultSpeed;
    public ulong player;
}

private class VehicleData
{
    public Dictionary<ulong, Vehicle> VehicleRecords;
}

private class Vehicle
{
    public ulong vehicle;
    public float maxDriveSlip;
    public float reversePercentSpeed;
    public float driveForceToMaxSlip;
    public ulong player;
}

private class MinicopterData
{
    public Dictionary<ulong, MiniCopterP> MinicopterRecords;
}

private class MiniCopterP
{
    public ulong minicopter;
    public float maxRotorSpeed;
    public ulong player;
}

private class SnowmobData
{
    public Dictionary<ulong, Snowmob> SnowmobRecords;
}

private class Snowmob
{
    public ulong snowmob;
    public float terrain;
    public double engineKW;
    public ulong player;
}

private class SmithyData
{
    public Dictionary<string, SmithyD> SmithyRecords;
}

private class SmithyD
{
    public string resource;
    public float time;
}

private class ElectricianData
{
    public Dictionary<ulong, ElectricianD> ElectricianRecords;
}

private class ElectricianD
{
    public ulong id;
    public string type;
    public int defaultmaxoutput;
    public int newmaxoutput;
    public ulong owner;
}

private class HeliHits
{
    public Dictionary<ulong, Heli> HeliRecords;
}

private class Heli
{
    public ulong heli;
    public ulong player;
}

public class Deaths
{
    public string victim;
    public string victimname;
    public string attacker;
    public string attackername;
    public string weapon;
    public string lastdamage;
    public float distance;
    public long timestamp;
}

private class Raids
{
    public Vector3 Location;
    public string BaseName;
    public int mode;
    public bool allowPVP;
    public string id;
    public float spawnTime;
    public float despawnTime;
    public float loadTime;
    public ulong ownerid;
    public List<ulong> raiders;
    public DateTime spawnDateTime;
    public DateTime despawnDateTime;
}

public class DmgBarImgs
{
    public string name;
    public string url;
}

public static class PlayerEx
{
    public static void RunEffect(BasePlayer player, string prefab);
}

XPerienceEx
public static class PlayerEx
{
    public static void RunEffect(BasePlayer player, string prefab);
}


```

---


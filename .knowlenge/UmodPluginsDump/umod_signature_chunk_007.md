# uMod Plugins Dataset - Code Abstractions (Continued)

Chunk 7 - Generated: 2025-07-06 20:25:18

## Plagued by  - A plague has decimated the world's population, avoid others players to stay alive

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.SQLite;
using UnityEngine;

Oxide.Plugins
[Info("Plagued", "Psi|ocybin", "0.3.6", ResourceId = 1991)]
[Description("Everyone is infected")]
 class Plagued : RustPlugin
{
    static int plagueRange;
    static int plagueIncreaseRate;
    static int plagueDecreaseRate;
    static int plagueMinAffinity;
    static int affinityIncRate;
    static int affinityDecRate;
    static int maxKin;
    static int maxKinChanges;
    static int playerLayer;
    static bool disableSleeperAffinity;
     Dictionary<ulong, PlayerState> playerStates;
    protected override void LoadDefaultConfig();
     void Unload();
     void OnServerInitialized();
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void OnRunPlayerMetabolism(PlayerMetabolism metabolism);
     void OnPlayerProximity(BasePlayer player, List<BasePlayer> players);
     void OnPlayerAlone(BasePlayer player);
    [ChatCommand("plagued")]
     void cmdPlagued(BasePlayer player, string command, string[] args);
     void cmdAddKin(BasePlayer player);
     bool cmdDelKin(BasePlayer player);
     bool cmdDelKin(BasePlayer player, int id);
     void cmdListKin(BasePlayer player);
     void cmdListAssociates(BasePlayer player);
     bool cmdInfo(BasePlayer player);
    public static void MsgPlayer(BasePlayer player, string format, object[] args);
    public void displayList(BasePlayer player, string listName, List<string> stringList);
     bool getPlayerLookedAt(BasePlayer player, BasePlayer targetPlayer);
     bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, object closestEnt, Vector3 closestHitpoint);
     bool TryGetPlayerView(BasePlayer player, Quaternion viewAngle);
    public class PlayerState
    {
        static readonly Core.SQLite.Libraries.SQLite sqlite;
        static Core.Database.Connection sqlConnection;
         BasePlayer player;
         int id;
         int plagueLevel;
         int kinChangesCount;
         bool pristine;
         Dictionary<ulong, Association> associations;
         Dictionary<ulong, Kin> kins;
         List<ulong> kinRequests;
        const string UpdateAssociation;
        const string InsertAssociation;
        const string CheckAssociationExists;
        const string DeleteAssociation;
        const string InsertPlayer;
        const string SelectPlayer;
        const string UpdatePlayerPlagueLevel;
        const string SelectAssociations;
        const string SelectKinList;
        const string InsertKin;
        const string DeleteKin;
        const string SelectKinRequestList;
        public PlayerState(BasePlayer newPlayer, Func<PlayerState, bool> callback);
        public static void setupDatabase(RustPlugin plugin);
        public static void closeDatabase();
         Association increaseAssociateAffinity(BasePlayer associate);
        public void increasePlaguePenalty(List<BasePlayer> associates);
        public void decreasePlaguePenalty();
        public void increasePlagueLevel(int contagionVectorCount);
        public void decreasePlagueLevel();
        public void decreaseAssociationsLevel();
        public bool isKinByUserID(ulong userID);
        public bool hasKinRequest(ulong kinID);
        public bool addKinRequest(ulong kinID);
        public bool addKin(ulong kinUserID);
        public bool removeKinById(int id);
        public bool removeKin(ulong kinUserID);
        public bool forceRemoveKin(ulong kinUserID);
        public List<string> getKinList();
        public List<string> getAssociatesList();
        public int getPlagueLevel();
        public int getId();
        public bool getPristine();
         Kin createKin(ulong kinUserId);
         void createAssociation(ulong associate_user_id, Func<Association, bool> callback);
         void syncPlagueLevel();
         void loadAssociations();
         void loadKinList();
         void loadKinRequestList();
         class Association
        {
            public int id;
            public int player_id;
            public int associate_id;
            public ulong associate_user_id;
            public string associate_name;
            public int level;
            public void create();
            public void load(Dictionary<string, object> association);
            public string getAffinityLabel();
        }

         class Kin
        {
            public int self_id;
            public int kin_id;
            public ulong kin_user_id;
            public string kin_name;
            public int player_one_id;
            public int player_two_id;
             Kin();
            public Kin(int p_self_id);
            public void create();
            public void load(Dictionary<string, object> kin);
        }

    }

    public class ProximityDetector : MonoBehaviour
    {
        public BasePlayer player;
        public void disableProximityCheck();
         void Awake();
         void OnDestroy();
         void CheckProximity();
         void notifyPlayerProximity(List<BasePlayer> players);
         void notifyPlayerAlone();
    }

}

public class PlayerState
{
    static readonly Core.SQLite.Libraries.SQLite sqlite;
    static Core.Database.Connection sqlConnection;
     BasePlayer player;
     int id;
     int plagueLevel;
     int kinChangesCount;
     bool pristine;
     Dictionary<ulong, Association> associations;
     Dictionary<ulong, Kin> kins;
     List<ulong> kinRequests;
    const string UpdateAssociation;
    const string InsertAssociation;
    const string CheckAssociationExists;
    const string DeleteAssociation;
    const string InsertPlayer;
    const string SelectPlayer;
    const string UpdatePlayerPlagueLevel;
    const string SelectAssociations;
    const string SelectKinList;
    const string InsertKin;
    const string DeleteKin;
    const string SelectKinRequestList;
    public PlayerState(BasePlayer newPlayer, Func<PlayerState, bool> callback);
    public static void setupDatabase(RustPlugin plugin);
    public static void closeDatabase();
     Association increaseAssociateAffinity(BasePlayer associate);
    public void increasePlaguePenalty(List<BasePlayer> associates);
    public void decreasePlaguePenalty();
    public void increasePlagueLevel(int contagionVectorCount);
    public void decreasePlagueLevel();
    public void decreaseAssociationsLevel();
    public bool isKinByUserID(ulong userID);
    public bool hasKinRequest(ulong kinID);
    public bool addKinRequest(ulong kinID);
    public bool addKin(ulong kinUserID);
    public bool removeKinById(int id);
    public bool removeKin(ulong kinUserID);
    public bool forceRemoveKin(ulong kinUserID);
    public List<string> getKinList();
    public List<string> getAssociatesList();
    public int getPlagueLevel();
    public int getId();
    public bool getPristine();
     Kin createKin(ulong kinUserId);
     void createAssociation(ulong associate_user_id, Func<Association, bool> callback);
     void syncPlagueLevel();
     void loadAssociations();
     void loadKinList();
     void loadKinRequestList();
     class Association
    {
        public int id;
        public int player_id;
        public int associate_id;
        public ulong associate_user_id;
        public string associate_name;
        public int level;
        public void create();
        public void load(Dictionary<string, object> association);
        public string getAffinityLabel();
    }

     class Kin
    {
        public int self_id;
        public int kin_id;
        public ulong kin_user_id;
        public string kin_name;
        public int player_one_id;
        public int player_two_id;
         Kin();
        public Kin(int p_self_id);
        public void create();
        public void load(Dictionary<string, object> kin);
    }

}

 class Association
{
    public int id;
    public int player_id;
    public int associate_id;
    public ulong associate_user_id;
    public string associate_name;
    public int level;
    public void create();
    public void load(Dictionary<string, object> association);
    public string getAffinityLabel();
}

 class Kin
{
    public int self_id;
    public int kin_id;
    public ulong kin_user_id;
    public string kin_name;
    public int player_one_id;
    public int player_two_id;
     Kin();
    public Kin(int p_self_id);
    public void create();
    public void load(Dictionary<string, object> kin);
}

public class ProximityDetector : MonoBehaviour
{
    public BasePlayer player;
    public void disableProximityCheck();
     void Awake();
     void OnDestroy();
     void CheckProximity();
     void notifyPlayerProximity(List<BasePlayer> players);
     void notifyPlayerAlone();
}


```

---

## PlaguedNPCs by MrBlue - Customize NPC player health, attire, skins, and weapons

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Plagued NPCs", "Wulf", "3.1.1")]
[Description("Customize NPC player health, attire, skins and weapons")]
public class PlaguedNPCs : CovalencePlugin
{
    private Configuration _config;
    public class PlaguedNPC
    {
        [JsonProperty("Enable NPC")]
        public bool Enable;
        [JsonProperty("Health")]
        public int Health;
        [JsonProperty("Max Health")]
        public int MaxHealth;
        [JsonProperty("Speed")]
        public float Speed;
        [JsonProperty("No Loot")]
        public bool NoLoot;
        [JsonProperty("Glowing Eyes")]
        public bool GlowingEyes;
        [JsonProperty("Sound Effect")]
        public bool SoundEffect;
        [JsonProperty("Attire", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<string>> Attire;
        [JsonProperty("Weapons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Weapons;
        [JsonProperty("Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<ulong>> Skins;
        [JsonProperty("Use Kits")]
        public bool UseKits;
        [JsonProperty("Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Kits;
    }

    private class Configuration
    {
        [JsonProperty("Scarecrows")]
        public PlaguedNPC Scarecrows;
        [JsonProperty("Scientists")]
        public PlaguedNPC Scientists;
        [JsonProperty("Tunnel Dwellers")]
        public PlaguedNPC TunnelDwellers;
        [JsonProperty("Underwater Dwellers")]
        public PlaguedNPC UnderwaterDwellers;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    [PluginReference]
    private Plugin Kits;
    private const int plaguedFlag;
    private PlaguedNPC GetPlaguedNpc(NPCPlayer npc);
    private void OnEntitySpawned(NPCPlayer npc);
    private void OnNpcTarget(NPCPlayer npc);
    private void OnCorpsePopulate(NPCPlayer npc, LootableCorpse corpse);
    private void OnPlayerCorpseSpawned(NPCPlayer npc, LootableCorpse corpse);
    private void ClotheNpc(NPCPlayer npc, PlaguedNPC plaguedNpc);
    private void EmptyCorpse(NPCPlayer npc, LootableCorpse corpse);
    private Item GetItem(List<string> items, PlaguedNPC plaguedNpc);
    private void GiveKit(NPCPlayer npc, string kitName);
    private bool IsPlagued(NPCPlayer npc);
}

public class PlaguedNPC
{
    [JsonProperty("Enable NPC")]
    public bool Enable;
    [JsonProperty("Health")]
    public int Health;
    [JsonProperty("Max Health")]
    public int MaxHealth;
    [JsonProperty("Speed")]
    public float Speed;
    [JsonProperty("No Loot")]
    public bool NoLoot;
    [JsonProperty("Glowing Eyes")]
    public bool GlowingEyes;
    [JsonProperty("Sound Effect")]
    public bool SoundEffect;
    [JsonProperty("Attire", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<string>> Attire;
    [JsonProperty("Weapons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Weapons;
    [JsonProperty("Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<ulong>> Skins;
    [JsonProperty("Use Kits")]
    public bool UseKits;
    [JsonProperty("Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Kits;
}

private class Configuration
{
    [JsonProperty("Scarecrows")]
    public PlaguedNPC Scarecrows;
    [JsonProperty("Scientists")]
    public PlaguedNPC Scientists;
    [JsonProperty("Tunnel Dwellers")]
    public PlaguedNPC TunnelDwellers;
    [JsonProperty("Underwater Dwellers")]
    public PlaguedNPC UnderwaterDwellers;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## PlantDrop by misticos - Allows planting crops anywhere by dropping seeds

```csharp
using System;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using Random = System.Random;

Oxide.Plugins
[Info("Plant Drop", "Iv Misticos", "1.2.3")]
[Description("Allows planting growables anywhere by dropping the seed")]
 class PlantDrop : RustPlugin
{
    private const string PrefabCorn;
    private const string PrefabHemp;
    private const string PrefabPotato;
    private const string PrefabPumpkin;
    private readonly Random _random;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Randomize Position")]
        public bool RandomizePosition;
        [JsonProperty(PropertyName = "Randomize Position On N")]
        public float RandomizePositionOn;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnItemDropped(Item item, BaseNetworkable entity);
    private void CreatePlant(BaseNetworkable seed, string prefab, Vector3 pos, int amount);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Randomize Position")]
    public bool RandomizePosition;
    [JsonProperty(PropertyName = "Randomize Position On N")]
    public float RandomizePositionOn;
}


```

---

## PlanterboxDefender by Kaucsenta - The goal of this plugin to block the possibility to steal from other player planterboxes.

```csharp
using HarmonyLib;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using System;
using Oxide.Core;

Oxide.Plugins
[Info("Planterbox Defender", "kaucsenta", "3.0.0")]
[Description("Only owner, owner team or if clans plugin present, clan can harvest grownable entities")]
public class PlanterboxDefender : RustPlugin
{
    [PluginReference]
    private Plugin Clans;
    private Plugin Friends;
    private static PlanterboxDefender _instance;
    [AutoPatch]
    [HarmonyPatch(typeof(GrowableEntity), "TakeClones", new Type[]
        {
            typeof(BasePlayer)
        })]
    public class Patch_TakeClones
    {
        public static bool Prefix(GrowableEntity __instance, BasePlayer player);
    }

    [AutoPatch]
    [HarmonyPatch(typeof(GrowableEntity), "PickFruit", new Type[]
        {
            typeof(BasePlayer),
            typeof(bool)
        })]
    public class Patch_PickFruit
    {
        public static bool Prefix(GrowableEntity __instance, BasePlayer player, bool eat);
    }

    private void OnServerInitialized();
    private void OnEntityBuilt(Planner plan, GameObject seed);
     object CanLootGrowableEntity(GrowableEntity plant, BasePlayer player);
    private bool SameTeam(ulong playerID, ulong friendID);
    private bool HasFriend(ulong playerID, ulong friendID);
    private bool SameClan(ulong playerID, ulong friendID);
    protected override void LoadDefaultMessages();
}

[AutoPatch]
[HarmonyPatch(typeof(GrowableEntity), "TakeClones", new Type[]
        {
            typeof(BasePlayer)
        })]
public class Patch_TakeClones
{
    public static bool Prefix(GrowableEntity __instance, BasePlayer player);
}

[AutoPatch]
[HarmonyPatch(typeof(GrowableEntity), "PickFruit", new Type[]
        {
            typeof(BasePlayer),
            typeof(bool)
        })]
public class Patch_PickFruit
{
    public static bool Prefix(GrowableEntity __instance, BasePlayer player, bool eat);
}


```

---

## PlayerActivity by RayMods - API for player's total and session play time, AFK time, and connection times

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Libraries;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Player Activity", "RayMods", "0.3.2")]
[Description("A plugin API for player's total and session play time, AFK time, and connection times.")]
 class PlayerActivity : CovalencePlugin
{
    private Dictionary<string, ActivityData> _activityDataCache;
    private Dictionary<string, SessionData> _playerSessions;
    private Dictionary<string, Timer> _playerTimers;
    private Dictionary<string, PlayerLocation> _playerLoc;
    private DynamicConfigFile _playerData;
    private PluginConfig _config;
    private Timer _saveTimer;
    private void Init();
    private void OnServerInitialized();
    private void OnUserConnected(IPlayer player);
    private void OnUserDisconnected(IPlayer player);
    private void Loaded();
    private void Unload();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private void InitPlayer(IPlayer player);
    private void InitSession(IPlayer player);
    private void InitCache(IPlayer player);
    private void BootstrapPlayerData();
    private void SaveActivityData();
    private bool IsAfk(IPlayer player);
    private void UpdatePosition(IPlayer player);
    private void UpdatePlayerSession(IPlayer player);
    private Nullable<DateTime> GetFirstConnectionDate(string playerId);
    private Nullable<DateTime> GetLastConnectionDate(string playerId);
    private Nullable<double> GetTotalPlayTime(string playerId);
    private Nullable<double> GetTotalIdleTime(string playerId);
    private Nullable<double> GetSessionPlayTime(string playerId);
    private Nullable<double> GetSessionIdleTime(string playerId);
    private Nullable<DateTime> GetSessionStartTime(string playerId);
    private bool GetIsAfk(string playerId);
    private PluginConfig GetDefaultConfig();
    private class PluginConfig
    {
        public int AFK_TIMEOUT;
        public int SAVE_INTERVAL;
        public int STATUS_CHECK_INTERVAL;
    }

    private class RawActivityData
    {
        public Dictionary<string, ActivityData> PlayerActivityData;
    }

    private class ActivityData
    {
        public double PlayTime;
        public double IdleTime;
        public DateTime FirstConnection;
        public DateTime LastConnection;
    }

    private class SessionData
    {
        public double PlayTime;
        public double IdleTime;
        public DateTime ConnectionTime;
        public DateTime LastUpdateTime;
    }

    private class PlayerLocation
    {
        public GenericPosition Location;
        public DateTime LastMoved;
    }

}

private class PluginConfig
{
    public int AFK_TIMEOUT;
    public int SAVE_INTERVAL;
    public int STATUS_CHECK_INTERVAL;
}

private class RawActivityData
{
    public Dictionary<string, ActivityData> PlayerActivityData;
}

private class ActivityData
{
    public double PlayTime;
    public double IdleTime;
    public DateTime FirstConnection;
    public DateTime LastConnection;
}

private class SessionData
{
    public double PlayTime;
    public double IdleTime;
    public DateTime ConnectionTime;
    public DateTime LastUpdateTime;
}

private class PlayerLocation
{
    public GenericPosition Location;
    public DateTime LastMoved;
}


```

---

## PlayerAdministration by ThibmoRozier - Allows server admins to moderate users using a GUI from within the game

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Game.Rust.Libraries;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using UnityEngine;
using RustLib = Oxide.Game.Rust.Libraries.Rust;

Oxide.Plugins
[Info("PlayerAdministration", "ThibmoRozier", "1.6.9")]
[Description("Allows server admins to moderate users using a GUI from within the game.")]
public class PlayerAdministration : CovalencePlugin
{
    [PluginReference]
    private Plugin Economics;
    [PluginReference]
    private Plugin ServerRewards;
    [PluginReference]
    private Plugin Freeze;
    [PluginReference]
    private Plugin PermissionsManager;
    [PluginReference]
    private Plugin DiscordMessages;
    [PluginReference]
    private Plugin BetterChatMute;
    [PluginReference]
    private Plugin Backpacks;
    [PluginReference]
    private Plugin InventoryViewer;
    [PluginReference]
    private Plugin ServerArmour;
    [PluginReference]
    private Plugin Godmode;
    private readonly RustLib rust;
    private readonly Player Player;
    private class CuiColor
    {
        public byte R { get; set; }
        public byte G { get; set; }
        public byte B { get; set; }
        public float A { get; set; }
        public CuiColor(byte aRed, byte aGreen, byte aBlue, float aAlpha);
        public override string ToString();
        public static readonly CuiColor Background;
        public static readonly CuiColor BackgroundMedium;
        public static readonly CuiColor BackgroundDark;
        public static readonly CuiColor Button;
        public static readonly CuiColor ButtonInactive;
        public static readonly CuiColor ButtonDecline;
        public static readonly CuiColor ButtonDanger;
        public static readonly CuiColor ButtonWarning;
        public static readonly CuiColor ButtonSuccess;
        public static readonly CuiColor Text;
        public static readonly CuiColor TextAlt;
        public static readonly CuiColor TextTitle;
        public static readonly CuiColor None;
    }

    private class CuiPoint
    {
        public float X { get; set; }
        public float Y { get; set; }
        public CuiPoint(float aX, float aY);
        public override string ToString();
        public static readonly CuiPoint Zero;
    }

    private class CuiInputField
    {
        public CuiInputFieldComponent InputField { get; set; }
        public CuiRectTransformComponent RectTransform { get; set; }
        public float FadeOut { get; set; }
    }

    private class CustomCuiElementContainer : CuiElementContainer
    {
        private readonly Action<string> LogError;
        public CustomCuiElementContainer(Action<string> aLogErrorFunc);
        public string Add(CuiInputField aInputField, string aParent, string aName);
    }

    private class Cui
    {
        public const string ParentHud;
        public const string ParentOverlay;
        private readonly Action<string> LogDebug;
        private readonly Action<string> LogError;
        private readonly CustomCuiElementContainer FContainer;
        private readonly BasePlayer FPlayer;
        public readonly ulong PlayerId;
        public readonly string PlayerIdString;
        public readonly float StartTime;
        public Cui(BasePlayer aPlayer, Action<string> aLogDebugFunc, Action<string> aLogErrorFunc);
        public string AddPanel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, bool aIndCursorEnabled, CuiColor aColor, string aName, string aPng);
        public string AddPanel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, bool aIndCursorEnabled, CuiColor aColor, string aName, string aPng);
        public string AddLabel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aColor, string aText, string aName, int aFontSize, TextAnchor aAlign);
        public string AddLabel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aColor, string aText, string aName, int aFontSize, TextAnchor aAlign);
        public string AddButton(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aButtonColor, CuiColor aTextColor, string aText, string aCommand, string aClose, string aName, int aFontSize, TextAnchor aAlign);
        public string AddButton(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aButtonColor, CuiColor aTextColor, string aText, string aCommand, string aClose, string aName, int aFontSize, TextAnchor aAlign);
        public string AddInputField(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aColor, string aText, int aCharsLimit, string aCommand, bool aIndPassword, string aName, int aFontSize, TextAnchor aAlign);
        public string AddInputField(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aColor, string aText, int aCharsLimit, string aCommand, bool aIndPassword, string aName, int aFontSize, TextAnchor aAlign);
        public string AddElement(string aParent, CuiPanel aElement, string aName);
        public string AddElement(string aParent, CuiLabel aElement, string aName);
        public string AddElement(string aParent, CuiButton aElement, string aName);
        public string AddElement(string aParent, CuiInputField aElement, string aName);
        public bool Draw();
        public string JSON { get; set; }
    }

    private void AddTabMenuBtn(Cui aUIObj, string aParent, string aCaption, string aCommand, int aPos, bool aIndActive);
    private void AddPlayerButtons(Cui aUIObj, string aParent, IEnumerable<KeyValuePair<ulong, string>> aUserList, string aCommandFmt, int aPage);
    private void LogError(string aMessage);
    private void LogInfo(string aMessage);
    private void LogDebug(string aMessage);
    private bool VerifyPermission(BasePlayer aPlayer, string aPermission, bool aIndReport);
    private bool VerifyPermission(ulong aPlayerId, string aPermission);
    private IEnumerable<KeyValuePair<ulong, string>> GetServerUserList(bool aIndFiltered, ulong aUserId, bool aIndOffline);
    private IEnumerable<KeyValuePair<ulong, string>> GetBannedUserList(bool aIndFiltered, ulong aUserId);
    private bool GetTargetFromArg(string[] aArgs, ulong aTarget);
    private bool GetTargetAmountFromArg(string[] aArgs, ulong aTarget, float aAmount);
    private bool GetIsMuted(BasePlayer aPlayer);
    private bool GetIsFrozen(ulong aPlayerId);
    private void SendDiscordKickBanMessage(string aAdminName, ulong aAdminId, string aTargetName, ulong aTargetId, string aReason, bool aIndIsBan);
    private string StringArrToString(string[] aObj);
    private string StringDictToString(Dictionary<string, string> aObj);
    private string EscapeString(string aStr);
    private string GetReason(ulong playerId, string targetId, bool indIsKick);
    private void BroadcastKickBan(string aAdminId, ulong aTargetId, string aReason, bool aIndIsKick);
    private bool UpgradeTo1310();
    private bool UpgradeTo1313();
    private bool UpgradeTo156();
    private bool UpgradeTo1519();
    private bool UpgradeTo164();
    private void BuildTabMenu(Cui aUIObj, UiPage aPageType);
    private void BuildMainPage(Cui aUIObj);
    private void BuildUserButtons(Cui aUIObj, string aParent, UiPage aPageType, int aPage, string aBtnCommandFmt, int aUserCount, bool aIndFiltered);
    private void BuildUserBtnPage(Cui aUIObj, UiPage aPageType, int aPage, bool aIndFiltered);
    private void AddUserPageInfoLabels(Cui aUIObj, string aParent, ulong aPlayerId, BasePlayer aPlayer);
    private void BuildUserPage(Cui aUIObj, UiPage aPageType, ulong aPlayerId);
    private void BuildUI(BasePlayer aPlayer, UiPage aPageType, string aArg, bool aIndFiltered);
    private class ConfigData
    {
        [DefaultValue(true)]
        [JsonProperty("Use Permission System", DefaultValueHandling = DefaultValueHandling.Populate)]
        public bool UsePermSystem { get; set; }
        [DefaultValue("")]
        [JsonProperty("Discord Webhook url for ban messages", DefaultValueHandling = DefaultValueHandling.Populate)]
        public string BanMsgWebhookUrl { get; set; }
        [DefaultValue("")]
        [JsonProperty("Discord Webhook url for kick messages", DefaultValueHandling = DefaultValueHandling.Populate)]
        public string KickMsgWebhookUrl { get; set; }
        [DefaultValue(true)]
        [JsonProperty("Broadcast Kicks", DefaultValueHandling = DefaultValueHandling.Populate)]
        public bool BroadcastKicks { get; set; }
        [DefaultValue(true)]
        [JsonProperty("Broadcast Bans", DefaultValueHandling = DefaultValueHandling.Populate)]
        public bool BroadcastBans { get; set; }
    }

    private const bool CDebugEnabled;
    private const int CMaxPlayerCols;
    private const int CMaxPlayerRows;
    private const int CMaxPlayerButtons;
    private const string CBasePanelName;
    private const string CMainPanelName;
    private static readonly List<string> CUnknownNameList;
    private const string CPadminCmd;
    private const string CCloseUiCmd;
    private const string CSwitchUiCmd;
    private const string CKickUserCmd;
    private const string CBanUserCmd;
    private const string CMainPageBanByIdCmd;
    private const string CUnbanUserCmd;
    private const string CPermsCmd;
    private const string CMuteUserCmd;
    private const string CUnmuteUserCmd;
    private const string CFreezeCmd;
    private const string CUnFreezeCmd;
    private const string CClearUserInventoryCmd;
    private const string CResetUserBPCmd;
    private const string CResetUserMetabolismCmd;
    private const string CRecoverUserMetabolismCmd;
    private const string CHurtUserCmd;
    private const string CKillUserCmd;
    private const string CHealUserCmd;
    private const string CTeleportToUserCmd;
    private const string CTeleportUserCmd;
    private const string CSpectateUserCmd;
    private const string CMainPageBanIdInputTextCmd;
    private const string CUserBtnPageSearchInputTextCmd;
    private const string CUserPageReasonInputTextCmd;
    private const string CBackpackViewCmd;
    private const string CInventoryViewCmd;
    private const string CGodmodeCmd;
    private const string CUnGodmodeCmd;
    private const string CFreezeFreezeCmd;
    private const string CFreezeUnfreezeCmd;
    private const string CCmdArgMain;
    private const string CCmdArgPlayersOnline;
    private const string CCmdArgPlayersOnlineSearch;
    private const string CCmdArgPlayersOffline;
    private const string CCmdArgPlayersOfflineSearch;
    private const string CCmdArgPlayersBanned;
    private const string CCmdArgPlayersBannedSearch;
    private const string CCmdArgPlayerPage;
    private const string CCmdArgPlayerPageBanned;
    private const string CPermUiShow;
    private const string CPermKick;
    private const string CPermBan;
    private const string CPermKill;
    private const string CPermPerms;
    private const string CPermMute;
    private const string CPermFreeze;
    private const string CPermClearInventory;
    private const string CPermResetBP;
    private const string CPermResetMetabolism;
    private const string CPermRecoverMetabolism;
    private const string CPermHurt;
    private const string CPermHeal;
    private const string CPermTeleport;
    private const string CPermSpectate;
    private const string CPermDetailInfo;
    private const string CPermProtectBan;
    private const string CPermProtectHurt;
    private const string CPermProtectKick;
    private const string CPermProtectKill;
    private const string CPermProtectReset;
    private const string CPermFreezeFrozen;
    private const string CPermBackpacks;
    private const string CPermInventory;
    private const string CPermGodmode;
    private static readonly CuiPoint CMainLbAnchor;
    private static readonly CuiPoint CMainRtAnchor;
    private static readonly CuiPoint CMainMenuHeaderContainerLbAnchor;
    private static readonly CuiPoint CMainMenuHeaderContainerRtAnchor;
    private static readonly CuiPoint CMainMenuTabBtnContainerLbAnchor;
    private static readonly CuiPoint CMainMenuTabBtnContainerRtAnchor;
    private static readonly CuiPoint CMainMenuHeaderLblLbAnchor;
    private static readonly CuiPoint CMainMenuHeaderLblRtAnchor;
    private static readonly CuiPoint CMainMenuCloseBtnLbAnchor;
    private static readonly CuiPoint CMainMenuCloseBtnRtAnchor;
    private static readonly CuiPoint CMainPanelLbAnchor;
    private static readonly CuiPoint CMainPanelRtAnchor;
    private static readonly CuiPoint CMainLblTitleLbAnchor;
    private static readonly CuiPoint CMainLblTitleRtAnchor;
    private static readonly CuiPoint CMainPageLblBanByIdTitleLbAnchor;
    private static readonly CuiPoint CMainPageLblBanByIdTitleRtAnchor;
    private static readonly CuiPoint CMainPageLblBanByIdLbAnchor;
    private static readonly CuiPoint CMainPageLblBanByIdRtAnchor;
    private static readonly CuiPoint CMainPagePanelBanByIdLbAnchor;
    private static readonly CuiPoint CMainPagePanelBanByIdRtAnchor;
    private static readonly CuiPoint CMainPageEdtBanByIdLbAnchor;
    private static readonly CuiPoint CMainPageEdtBanByIdRtAnchor;
    private static readonly CuiPoint CMainPageBtnBanByIdLbAnchor;
    private static readonly CuiPoint CMainPageBtnBanByIdRtAnchor;
    private static readonly CuiPoint CUserBtnPageLblTitleLbAnchor;
    private static readonly CuiPoint CUserBtnPageLblTitleRtAnchor;
    private static readonly CuiPoint CUserBtnPageLblSearchLbAnchor;
    private static readonly CuiPoint CUserBtnPageLblSearchRtAnchor;
    private static readonly CuiPoint CUserBtnPagePanelSearchInputLbAnchor;
    private static readonly CuiPoint CUserBtnPagePanelSearchInputRtAnchor;
    private static readonly CuiPoint CUserBtnPageEdtSearchInputLbAnchor;
    private static readonly CuiPoint CUserBtnPageEdtSearchInputRtAnchor;
    private static readonly CuiPoint CUserBtnPageBtnSearchLbAnchor;
    private static readonly CuiPoint CUserBtnPageBtnSearchRtAnchor;
    private static readonly CuiPoint CUserBtnPageBtnPreviousLbAnchor;
    private static readonly CuiPoint CUserBtnPageBtnPreviousRtAnchor;
    private static readonly CuiPoint CUserBtnPageBtnNextLbAnchor;
    private static readonly CuiPoint CUserBtnPageBtnNextRtAnchor;
    private static readonly CuiPoint CUserPageInfoPanelLbAnchor;
    private static readonly CuiPoint CUserPageInfoPanelRtAnchor;
    private static readonly CuiPoint CUserPageActionPanelLbAnchor;
    private static readonly CuiPoint CUserPageActionPanelRtAnchor;
    private static readonly CuiPoint CUserPageLblinfoTitleLbAnchor;
    private static readonly CuiPoint CUserPageLblinfoTitleRtAnchor;
    private static readonly CuiPoint CUserPageLblActionTitleLbAnchor;
    private static readonly CuiPoint CUserPageLblActionTitleRtAnchor;
    private static readonly CuiPoint CUserPageLblIdLbAnchor;
    private static readonly CuiPoint CUserPageLblIdRtAnchor;
    private static readonly CuiPoint CUserPageLblAuthLbAnchor;
    private static readonly CuiPoint CUserPageLblAuthRtAnchor;
    private static readonly CuiPoint CUserPageLblConnectLbAnchor;
    private static readonly CuiPoint CUserPageLblConnectRtAnchor;
    private static readonly CuiPoint CUserPageLblSleepLbAnchor;
    private static readonly CuiPoint CUserPageLblSleepRtAnchor;
    private static readonly CuiPoint CUserPageLblFlagLbAnchor;
    private static readonly CuiPoint CUserPageLblFlagRtAnchor;
    private static readonly CuiPoint CUserPageLblPosLbAnchor;
    private static readonly CuiPoint CUserPageLblPosRtAnchor;
    private static readonly CuiPoint CUserPageLblRotLbAnchor;
    private static readonly CuiPoint CUserPageLblRotRtAnchor;
    private static readonly CuiPoint CUserPageLblAdminCheatLbAnchor;
    private static readonly CuiPoint CUserPageLblAdminCheatRtAnchor;
    private static readonly CuiPoint CUserPageLblIdleLbAnchor;
    private static readonly CuiPoint CUserPageLblIdleRtAnchor;
    private static readonly CuiPoint CUserPageLblUsrNetAddrLbAnchor;
    private static readonly CuiPoint CUserPageLblUsrNetAddrRtAnchor;
    private static readonly CuiPoint CUserPageLblUsrAvrPingLbAnchor;
    private static readonly CuiPoint CUserPageLblUsrAvrPingRtAnchor;
    private static readonly CuiPoint CUserPageLblBalanceLbAnchor;
    private static readonly CuiPoint CUserPageLblBalanceRtAnchor;
    private static readonly CuiPoint CUserPageLblRewardPointsLbAnchor;
    private static readonly CuiPoint CUserPageLblRewardPointsRtAnchor;
    private static readonly CuiPoint CUserPageLblGodmodeLbAnchor;
    private static readonly CuiPoint CUserPageLblGodmodeRtAnchor;
    private static readonly CuiPoint CUserPageLblHealthLbAnchor;
    private static readonly CuiPoint CUserPageLblHealthRtAnchor;
    private static readonly CuiPoint CUserPageLblCalLbAnchor;
    private static readonly CuiPoint CUserPageLblCalRtAnchor;
    private static readonly CuiPoint CUserPageLblHydraLbAnchor;
    private static readonly CuiPoint CUserPageLblHydraRtAnchor;
    private static readonly CuiPoint CUserPageLblTempLbAnchor;
    private static readonly CuiPoint CUserPageLblTempRtAnchor;
    private static readonly CuiPoint CUserPageLblWetLbAnchor;
    private static readonly CuiPoint CUserPageLblWetRtAnchor;
    private static readonly CuiPoint CUserPageLblComfortLbAnchor;
    private static readonly CuiPoint CUserPageLblComfortRtAnchor;
    private static readonly CuiPoint CUserPageLblBleedLbAnchor;
    private static readonly CuiPoint CUserPageLblBleedRtAnchor;
    private static readonly CuiPoint CUserPageLblRads1LbAnchor;
    private static readonly CuiPoint CUserPageLblRads1RtAnchor;
    private static readonly CuiPoint CUserPageLblRads2LbAnchor;
    private static readonly CuiPoint CUserPageLblRads2RtAnchor;
    private static readonly CuiPoint CUserPageBtnBanLbAnchor;
    private static readonly CuiPoint CUserPageBtnBanRtAnchor;
    private static readonly CuiPoint CUserPageBtnKickLbAnchor;
    private static readonly CuiPoint CUserPageBtnKickRtAnchor;
    private static readonly CuiPoint CUserPageLblReasonLbAnchor;
    private static readonly CuiPoint CUserPageLblReasonRtAnchor;
    private static readonly CuiPoint CUserPagePanelReasonLbAnchor;
    private static readonly CuiPoint CUserPagePanelReasonRtAnchor;
    private static readonly CuiPoint CUserPageEdtReasonLbAnchor;
    private static readonly CuiPoint CUserPageEdtReasonRtAnchor;
    private static readonly CuiPoint CUserPageBtnUnmuteLbAnchor;
    private static readonly CuiPoint CUserPageBtnUnmuteRtAnchor;
    private static readonly CuiPoint CUserPageBtnMuteLbAnchor;
    private static readonly CuiPoint CUserPageBtnMuteRtAnchor;
    private static readonly CuiPoint CUserPageBtnMuteFifteenLbAnchor;
    private static readonly CuiPoint CUserPageBtnMuteFifteenRtAnchor;
    private static readonly CuiPoint CUserPageBtnMuteThirtyLbAnchor;
    private static readonly CuiPoint CUserPageBtnMuteThirtyRtAnchor;
    private static readonly CuiPoint CUserPageBtnMuteSixtyLbAnchor;
    private static readonly CuiPoint CUserPageBtnMuteSixtyRtAnchor;
    private static readonly CuiPoint CUserPageBtnUnFreezeLbAnchor;
    private static readonly CuiPoint CUserPageBtnUnFreezeRtAnchor;
    private static readonly CuiPoint CUserPageBtnFreezeLbAnchor;
    private static readonly CuiPoint CUserPageBtnFreezeRtAnchor;
    private static readonly CuiPoint CUserPageBtnClearInventoryLbAnchor;
    private static readonly CuiPoint CUserPageBtnClearInventoryRtAnchor;
    private static readonly CuiPoint CUserPageBtnResetBPLbAnchor;
    private static readonly CuiPoint CUserPageBtnResetBPRtAnchor;
    private static readonly CuiPoint CUserPageBtnResetMetabolismLbAnchor;
    private static readonly CuiPoint CUserPageBtnResetMetabolismRtAnchor;
    private static readonly CuiPoint CUserPageBtnRecoverMetabolismLbAnchor;
    private static readonly CuiPoint CUserPageBtnRecoverMetabolismRtAnchor;
    private static readonly CuiPoint CUserPageBtnTeleportToLbAnchor;
    private static readonly CuiPoint CUserPageBtnTeleportToRtAnchor;
    private static readonly CuiPoint CUserPageBtnTeleportLbAnchor;
    private static readonly CuiPoint CUserPageBtnTeleportRtAnchor;
    private static readonly CuiPoint CUserPageBtnSpectateLbAnchor;
    private static readonly CuiPoint CUserPageBtnSpectateRtAnchor;
    private static readonly CuiPoint CUserPageBtnPermsLbAnchor;
    private static readonly CuiPoint CUserPageBtnPermsRtAnchor;
    private static readonly CuiPoint CUserPageBtnBackpacksLbAnchor;
    private static readonly CuiPoint CUserPageBtnBackpacksRtAnchor;
    private static readonly CuiPoint CUserPageBtnInventoryLbAnchor;
    private static readonly CuiPoint CUserPageBtnInventoryRtAnchor;
    private static readonly CuiPoint CUserPageBtnGodmodeLbAnchor;
    private static readonly CuiPoint CUserPageBtnGodmodeRtAnchor;
    private static readonly CuiPoint CUserPageBtnUnGodmodeLbAnchor;
    private static readonly CuiPoint CUserPageBtnUnGodmodeRtAnchor;
    private static readonly CuiPoint CUserPageBtnHurt25LbAnchor;
    private static readonly CuiPoint CUserPageBtnHurt25RtAnchor;
    private static readonly CuiPoint CUserPageBtnHurt50LbAnchor;
    private static readonly CuiPoint CUserPageBtnHurt50RtAnchor;
    private static readonly CuiPoint CUserPageBtnHurt75LbAnchor;
    private static readonly CuiPoint CUserPageBtnHurt75RtAnchor;
    private static readonly CuiPoint CUserPageBtnHurt100LbAnchor;
    private static readonly CuiPoint CUserPageBtnHurt100RtAnchor;
    private static readonly CuiPoint CUserPageBtnKillLbAnchor;
    private static readonly CuiPoint CUserPageBtnKillRtAnchor;
    private static readonly CuiPoint CUserPageBtnHeal25LbAnchor;
    private static readonly CuiPoint CUserPageBtnHeal25RtAnchor;
    private static readonly CuiPoint CUserPageBtnHeal50LbAnchor;
    private static readonly CuiPoint CUserPageBtnHeal50RtAnchor;
    private static readonly CuiPoint CUserPageBtnHeal75LbAnchor;
    private static readonly CuiPoint CUserPageBtnHeal75RtAnchor;
    private static readonly CuiPoint CUserPageBtnHeal100LbAnchor;
    private static readonly CuiPoint CUserPageBtnHeal100RtAnchor;
    private static readonly CuiPoint CUserPageBtnHealWoundsLbAnchor;
    private static readonly CuiPoint CUserPageBtnHealWoundsRtAnchor;
    private static readonly CuiPanel CBasePanel;
    private static readonly CuiPanel CMainPanel;
    private static readonly CuiPanel CTabHeaderPanel;
    private static readonly CuiPanel CTabTabBtnPanel;
    private static readonly CuiPanel CMainPagePanel;
    private static readonly CuiPanel CBanByIdGroupPanel;
    private static readonly CuiPanel CUserBtnPageSearchInputPanel;
    private static readonly CuiLabel CTabMenuHeaderLbl;
    private static readonly CuiLabel CMainPageTitleLbl;
    private static readonly CuiButton CTabMenuCloseBtn;
    private static readonly CuiButton CBanByIdActiveBtn;
    private static readonly CuiButton CBanByIdInactiveBtn;
    private static readonly CuiButton CUserBtnPagePreviousInactiveBtn;
    private static readonly CuiButton CUserBtnPageNextInactiveBtn;
    private static readonly CuiInputField CBanByIdEdt;
    private ConfigData FConfigData;
    private readonly Dictionary<ulong, string> FMainPageBanIdInputText;
    private readonly Dictionary<ulong, string> FUserBtnPageSearchInputText;
    private readonly Dictionary<ulong, string> FUserPageReasonInputText;
    private readonly Dictionary<ulong, string> FOnlineUserList;
    private readonly Dictionary<ulong, string> FOfflineUserList;
     void Loaded();
     void Unload();
     void OnServerInitialized();
     void OnUserConnected(IPlayer aPlayer);
     void OnUserDisconnected(IPlayer aPlayer);
     void OnUserNameUpdated(string aId, string aOldName, string aNewName);
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    protected override void SaveConfig();
    [Command(CPadminCmd)]
    private void PlayerAdministrationUICallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CCloseUiCmd)]
    private void PlayerAdministrationCloseUICallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CSwitchUiCmd)]
    private void PlayerAdministrationSwitchUICallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CUnbanUserCmd)]
    private void PlayerAdministrationUnbanUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CBanUserCmd)]
    private void PlayerAdministrationBanUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CMainPageBanByIdCmd)]
    private void PlayerAdministrationMainPageBanByIdCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CKickUserCmd)]
    private void PlayerAdministrationKickUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CUnmuteUserCmd)]
    private void PlayerAdministrationUnmuteUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CMuteUserCmd)]
    private void PlayerAdministrationMuteUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CUnFreezeCmd)]
    private void PlayerAdministrationUnfreezeCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CFreezeCmd)]
    private void PlayerAdministrationFreezeCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CBackpackViewCmd)]
    private void PlayerAdministrationViewBackpackCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CInventoryViewCmd)]
    private void PlayerAdministrationViewInventoryCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CGodmodeCmd)]
    private void PlayerAdministrationGodmodeCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CUnGodmodeCmd)]
    private void PlayerAdministrationUnGodmodeCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CClearUserInventoryCmd)]
    private void PlayerAdministrationClearUserInventoryCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CResetUserBPCmd)]
    private void PlayerAdministrationResetUserBlueprintsCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CResetUserMetabolismCmd)]
    private void PlayerAdministrationResetUserMetabolismCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CRecoverUserMetabolismCmd)]
    private void PlayerAdministrationRecoverUserMetabolismCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CTeleportToUserCmd)]
    private void PlayerAdministrationTeleportToUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CTeleportUserCmd)]
    private void PlayerAdministrationTeleportUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CSpectateUserCmd)]
    private void PlayerAdministrationSpectateUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CPermsCmd)]
    private void PlayerAdministrationRunPermsCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CHurtUserCmd)]
    private void PlayerAdministrationHurtUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CKillUserCmd)]
    private void PlayerAdministrationKillUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CHealUserCmd)]
    private void PlayerAdministrationHealUserCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CMainPageBanIdInputTextCmd)]
    private void PlayerAdministrationMainPageBanIdInputTextCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CUserBtnPageSearchInputTextCmd)]
    private void PlayerAdministrationUserBtnPageSearchInputTextCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
    [Command(CUserPageReasonInputTextCmd)]
    private void PlayerAdministrationUserPageReasonInputTextCallback(IPlayer aPlayer, string aCommand, string[] aArgs);
}

private class CuiColor
{
    public byte R { get; set; }
    public byte G { get; set; }
    public byte B { get; set; }
    public float A { get; set; }
    public CuiColor(byte aRed, byte aGreen, byte aBlue, float aAlpha);
    public override string ToString();
    public static readonly CuiColor Background;
    public static readonly CuiColor BackgroundMedium;
    public static readonly CuiColor BackgroundDark;
    public static readonly CuiColor Button;
    public static readonly CuiColor ButtonInactive;
    public static readonly CuiColor ButtonDecline;
    public static readonly CuiColor ButtonDanger;
    public static readonly CuiColor ButtonWarning;
    public static readonly CuiColor ButtonSuccess;
    public static readonly CuiColor Text;
    public static readonly CuiColor TextAlt;
    public static readonly CuiColor TextTitle;
    public static readonly CuiColor None;
}

private class CuiPoint
{
    public float X { get; set; }
    public float Y { get; set; }
    public CuiPoint(float aX, float aY);
    public override string ToString();
    public static readonly CuiPoint Zero;
}

private class CuiInputField
{
    public CuiInputFieldComponent InputField { get; set; }
    public CuiRectTransformComponent RectTransform { get; set; }
    public float FadeOut { get; set; }
}

private class CustomCuiElementContainer : CuiElementContainer
{
    private readonly Action<string> LogError;
    public CustomCuiElementContainer(Action<string> aLogErrorFunc);
    public string Add(CuiInputField aInputField, string aParent, string aName);
}

private class Cui
{
    public const string ParentHud;
    public const string ParentOverlay;
    private readonly Action<string> LogDebug;
    private readonly Action<string> LogError;
    private readonly CustomCuiElementContainer FContainer;
    private readonly BasePlayer FPlayer;
    public readonly ulong PlayerId;
    public readonly string PlayerIdString;
    public readonly float StartTime;
    public Cui(BasePlayer aPlayer, Action<string> aLogDebugFunc, Action<string> aLogErrorFunc);
    public string AddPanel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, bool aIndCursorEnabled, CuiColor aColor, string aName, string aPng);
    public string AddPanel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, bool aIndCursorEnabled, CuiColor aColor, string aName, string aPng);
    public string AddLabel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aColor, string aText, string aName, int aFontSize, TextAnchor aAlign);
    public string AddLabel(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aColor, string aText, string aName, int aFontSize, TextAnchor aAlign);
    public string AddButton(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aButtonColor, CuiColor aTextColor, string aText, string aCommand, string aClose, string aName, int aFontSize, TextAnchor aAlign);
    public string AddButton(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aButtonColor, CuiColor aTextColor, string aText, string aCommand, string aClose, string aName, int aFontSize, TextAnchor aAlign);
    public string AddInputField(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiColor aColor, string aText, int aCharsLimit, string aCommand, bool aIndPassword, string aName, int aFontSize, TextAnchor aAlign);
    public string AddInputField(string aParent, CuiPoint aLeftBottomAnchor, CuiPoint aRightTopAnchor, CuiPoint aLeftBottomOffset, CuiPoint aRightTopOffset, CuiColor aColor, string aText, int aCharsLimit, string aCommand, bool aIndPassword, string aName, int aFontSize, TextAnchor aAlign);
    public string AddElement(string aParent, CuiPanel aElement, string aName);
    public string AddElement(string aParent, CuiLabel aElement, string aName);
    public string AddElement(string aParent, CuiButton aElement, string aName);
    public string AddElement(string aParent, CuiInputField aElement, string aName);
    public bool Draw();
    public string JSON { get; set; }
}

private class ConfigData
{
    [DefaultValue(true)]
    [JsonProperty("Use Permission System", DefaultValueHandling = DefaultValueHandling.Populate)]
    public bool UsePermSystem { get; set; }
    [DefaultValue("")]
    [JsonProperty("Discord Webhook url for ban messages", DefaultValueHandling = DefaultValueHandling.Populate)]
    public string BanMsgWebhookUrl { get; set; }
    [DefaultValue("")]
    [JsonProperty("Discord Webhook url for kick messages", DefaultValueHandling = DefaultValueHandling.Populate)]
    public string KickMsgWebhookUrl { get; set; }
    [DefaultValue(true)]
    [JsonProperty("Broadcast Kicks", DefaultValueHandling = DefaultValueHandling.Populate)]
    public bool BroadcastKicks { get; set; }
    [DefaultValue(true)]
    [JsonProperty("Broadcast Bans", DefaultValueHandling = DefaultValueHandling.Populate)]
    public bool BroadcastBans { get; set; }
}


```

---

## PlayerBlinder by MrBlue - Gives an extra way of punishing players

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Globalization;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Player Blinder", "redBDGR", "1.0.5")]
[Description("Gives an extra way of punishing players")]
 class PlayerBlinder : CovalencePlugin
{
    public bool Changed;
    public const string permissionName;
    public bool useImage;
    public string ImageURL;
    public string ImageAMIN;
    public string ImageAMAX;
    public bool useText;
    public string TextTEXT;
    public int TextSize;
    public string BlindColour;
     Dictionary<string, bool> GUIinfo;
     Dictionary<string, int> adminProtection;
     void Init();
    private new void LoadDefaultMessages();
     void LoadVariables();
    protected override void LoadDefaultConfig();
     void Unload();
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    [Command("blind")]
     void BlindCMD(IPlayer player, string command, string[] args);
    [Command("unblind")]
     void UnblindCMD(IPlayer player, string command, string[] args);
    [ChatCommand("blindprotect")]
     void BlindProtect(BasePlayer player, string command, string[] args);
     void GUIDestroy(BasePlayer player);
     void DoGUI(BasePlayer targetplayer, float length, bool indic, string message);
    private static List<BasePlayer> FindPlayer(string nameOrId);
    private string Panel;
    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateTextOutline(CuiElementContainer element, string panel, string text, string colorText, string colorOutline, string DistanceA, string DistanceB, int size, string aMin, string aMax, TextAnchor align);
        static public void CreateImage(CuiElementContainer element, string panel, string imageURL, string aMin, string aMax);
    }

     object GetConfig(string menu, string datavalue, object defaultValue);
     string msg(string key, string id);
}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateTextOutline(CuiElementContainer element, string panel, string text, string colorText, string colorOutline, string DistanceA, string DistanceB, int size, string aMin, string aMax, TextAnchor align);
    static public void CreateImage(CuiElementContainer element, string panel, string imageURL, string aMin, string aMax);
}


```

---

## PlayerChallenges by k1lly0u - Allows titles to be set when certain criteria are met, with a UI Leader board

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using System.Globalization;

Oxide.Plugins
[Info("Player Challenges", "k1lly0u", "2.0.52")]
[Description("Keep track of various statistics and set titles to players when certain criteria have been met or when they are a leader of a challenge category")]
 class PlayerChallenges : RustPlugin
{
    [PluginReference]
     Plugin BetterChat;
    [PluginReference]
     Plugin EventManager;
    [PluginReference]
     Plugin LustyMap;
    [PluginReference]
     Plugin Clans;
    [PluginReference]
     Plugin Friends;
     ChallengeData chData;
    private DynamicConfigFile data;
    private Dictionary<ulong, StatData> statCache;
    private Dictionary<Challenges, LeaderData> titleCache;
    private Dictionary<ulong, WoundedData> woundedData;
    private Hash<ulong, Hash<ulong, float>> damageData;
    private static Dictionary<string, string> uiColors;
    private bool UIDisabled;
    public static class UI
    {
        public static CuiElementContainer Container(string panelName, string aMin, string aMax, bool cursor);
        public static void Panel(CuiElementContainer container, string panel, string aMin, string aMax, bool cursor);
        public static void Label(CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align, float fadein);
        public static void Button(CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, string command, TextAnchor align, float fadein);
        public static string Color(string hexColor, float alpha);
    }

    private string UIMain;
    private void CreateMenu(BasePlayer player);
    private void CreateMenuContents(BasePlayer player, int page);
    private void AddMenuStats(CuiElementContainer MenuElement, string panel, Challenges type, float left, float bottom, float right, float top);
    [ConsoleCommand("PCUI_ChangePage")]
    private void cmdChangePage(ConsoleSystem.Arg arg);
    [ConsoleCommand("PCUI_DestroyAll")]
    private void cmdDestroyAll(ConsoleSystem.Arg arg);
    private string GetLeaders(Challenges type);
    private object GetTypeFromString(string name);
    private void DestroyUI(BasePlayer player);
    private void CloseMap(BasePlayer player);
    private void OpenMap(BasePlayer player);
    private bool IsPlaying(BasePlayer player);
    private bool IsClanmate(ulong playerId, ulong friendId);
    private bool IsFriend(ulong playerId, ulong friendId);
    private void Loaded();
    private void OnServerInitialized();
    private void Unload();
    private void OnPluginLoaded(Plugin plugin);
    private void OnServerSave();
    private void OnPlayerConnected(BasePlayer player);
    private void OnRocketLaunched(BasePlayer player, BaseEntity entity);
    private void OnHealingItemUse(HeldEntity item, BasePlayer target);
    private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter itemCrafter);
    private void OnGrowableGather(GrowableEntity growable, Item item, BasePlayer player);
    private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnEntityBuilt(Planner plan, GameObject go);
    private void CanBeWounded(BasePlayer player, HitInfo hitInfo);
    private void OnPlayerRecover(BasePlayer player);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private void OnExplosiveThrown(BasePlayer player, BaseEntity entity);
    private void OnStructureRepair(BaseCombatEntity block, BasePlayer player);
    [HookMethod("CompletedQuest")]
    public void CompletedQuest(BasePlayer player);
    private void AddPoints(BasePlayer player, Challenges type, int amount);
    private void AddPoints(ulong playerId, Challenges type, int amount);
    private void AddDistance(BasePlayer player, Challenges type, int amount);
    private void CheckForUpdate(ulong playerId, Challenges type);
    private void SwitchLeader(ulong newId, ulong oldId, Challenges type);
    private void CheckUpdateTimer();
     class UpdateInfo
    {
        public ulong newId;
        public ulong oldId;
        public int count;
    }

    [ChatCommand("pc")]
    private void cmdPC(BasePlayer player, string command, string[] args);
    [ChatCommand("pc_wipe")]
    private void cmdPCWipe(BasePlayer player, string command, string[] args);
    [ConsoleCommand("pc_wipe")]
    private void ccmdPCWipe(ConsoleSystem.Arg arg);
    private void CheckEntry(BasePlayer player);
    private void CheckEntry(ulong playerId);
    private string GetGroupName(Challenges type);
    private double GrabCurrentTime();
    private void RegisterGroups();
    private void RegisterGroup(Challenges type);
    private void RegisterTitles();
    private string GetPlayerTitles(IPlayer player);
    private void AddAllUsergroups();
    private void RemoveAllUsergroups();
    private bool GroupExists(string name);
    private bool UserInGroup(string name, string playerId);
    private void AddUserToGroup(string name, string playerId);
    private void RemoveUserFromGroup(string name, string playerId);
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Challenge Settings")]
        public Dictionary<Challenges, ChallengeInfo> ChallengeSettings { get; set; }
        public Option Options { get; set; }
        public TextColor Colors { get; set; }
        public class ChallengeInfo
        {
            [JsonProperty(PropertyName = "Title for name tag")]
            public string Title;
            [JsonProperty(PropertyName = "Enable this challenge")]
            public bool Enabled;
            [JsonProperty(PropertyName = "Position in the UI leaderboard")]
            public int UIPosition;
            [JsonProperty(PropertyName = "Title priority")]
            public int Priority;
        }

        public class Option
        {
            [JsonProperty(PropertyName = "Ignore kills against sleeping players (Players killed)")]
            public bool IgnoreSleepers;
            [JsonProperty(PropertyName = "Kills against NPC players are counted seperate to player kills")]
            public bool NPCKillSeperate;
            [JsonProperty(PropertyName = "NPC kill distance counts as PVE distance")]
            public bool NPCPVEKills;
            [JsonProperty(PropertyName = "Show challenge leader title tags (Requires BetterChat)")]
            public bool UseBetterChat;
            [JsonProperty(PropertyName = "Ignore all statistics recorded by admins")]
            public bool IgnoreAdmins;
            [JsonProperty(PropertyName = "Ignore kills for event players (Players killed)")]
            public bool IgnoreEventKills;
            [JsonProperty(PropertyName = "Ignore supply signals thrown (Explosives thrown)")]
            public bool IgnoreSupplySignals;
            [JsonProperty(PropertyName = "Ignore survey charges thrown (Explosives thrown)")]
            public bool IgnoreSurveyCharges;
            [JsonProperty(PropertyName = "Ignore beancan grenades thrown (Explosives thrown)")]
            public bool IgnoreBeanCans;
            [JsonProperty(PropertyName = "Ignore flares thrown (Explosives thrown)")]
            public bool IgnoreFlares;
            [JsonProperty(PropertyName = "Broadcast new challenge leaders to chat")]
            public bool AnnounceNewLeaders;
            [JsonProperty(PropertyName = "Update leaders on a timer (Recommended)")]
            public bool UseUpdateTimer;
            [JsonProperty(PropertyName = "Create and use Oxide groups for each challenge type")]
            public bool UseOxideGroups;
            [JsonProperty(PropertyName = "Update timer (hours)")]
            public int UpdateTimer;
            [JsonProperty(PropertyName = "Maximum tags to display (Requires BetterChat)")]
            public int MaximumTags;
            [JsonProperty(PropertyName = "Format of tags displayed (Requires BetterChat)")]
            public string TagFormat;
        }

        public class TextColor
        {
            [JsonProperty(PropertyName = "Primary message color (hex)")]
            public string TextColor1;
            [JsonProperty(PropertyName = "Secondary message color (hex)")]
            public string TextColor2;
            [JsonProperty(PropertyName = "Title color (hex) (Requires BetterChat)")]
            public string TitleColor;
            [JsonProperty(PropertyName = "UI Color - Background")]
            public UIColor Background;
            [JsonProperty(PropertyName = "UI Color - Panel")]
            public UIColor Panel;
            [JsonProperty(PropertyName = "UI Color - Button")]
            public UIColor Button;
            public class UIColor
            {
                [JsonProperty(PropertyName = "Color (hex)")]
                public string Color;
                [JsonProperty(PropertyName = "Alpha (0.0 - 1.0)")]
                public float Alpha;
            }

        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private void SaveData();
    private void LoadData();
    private void CheckValidData();
    private class ChallengeData
    {
        public Dictionary<ulong, StatData> Stats;
        public Dictionary<Challenges, LeaderData> Titles;
        public double LastUpdate;
    }

    private class StatData
    {
        public string DisplayName;
        public Dictionary<Challenges, int> Stats;
    }

    private class LeaderData
    {
        public ulong UserID;
        public string DisplayName;
        public int Count;
    }

    private class WoundedData
    {
        public float distance;
        public ulong attackerId;
    }

     List<string> meleeShortnames;
     List<string> bladeShortnames;
     List<string> plantShortnames;
    private string MSG(string key, string id);
     Dictionary<string, string> Messages;
}

public static class UI
{
    public static CuiElementContainer Container(string panelName, string aMin, string aMax, bool cursor);
    public static void Panel(CuiElementContainer container, string panel, string aMin, string aMax, bool cursor);
    public static void Label(CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, TextAnchor align, float fadein);
    public static void Button(CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, string command, TextAnchor align, float fadein);
    public static string Color(string hexColor, float alpha);
}

 class UpdateInfo
{
    public ulong newId;
    public ulong oldId;
    public int count;
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Challenge Settings")]
    public Dictionary<Challenges, ChallengeInfo> ChallengeSettings { get; set; }
    public Option Options { get; set; }
    public TextColor Colors { get; set; }
    public class ChallengeInfo
    {
        [JsonProperty(PropertyName = "Title for name tag")]
        public string Title;
        [JsonProperty(PropertyName = "Enable this challenge")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Position in the UI leaderboard")]
        public int UIPosition;
        [JsonProperty(PropertyName = "Title priority")]
        public int Priority;
    }

    public class Option
    {
        [JsonProperty(PropertyName = "Ignore kills against sleeping players (Players killed)")]
        public bool IgnoreSleepers;
        [JsonProperty(PropertyName = "Kills against NPC players are counted seperate to player kills")]
        public bool NPCKillSeperate;
        [JsonProperty(PropertyName = "NPC kill distance counts as PVE distance")]
        public bool NPCPVEKills;
        [JsonProperty(PropertyName = "Show challenge leader title tags (Requires BetterChat)")]
        public bool UseBetterChat;
        [JsonProperty(PropertyName = "Ignore all statistics recorded by admins")]
        public bool IgnoreAdmins;
        [JsonProperty(PropertyName = "Ignore kills for event players (Players killed)")]
        public bool IgnoreEventKills;
        [JsonProperty(PropertyName = "Ignore supply signals thrown (Explosives thrown)")]
        public bool IgnoreSupplySignals;
        [JsonProperty(PropertyName = "Ignore survey charges thrown (Explosives thrown)")]
        public bool IgnoreSurveyCharges;
        [JsonProperty(PropertyName = "Ignore beancan grenades thrown (Explosives thrown)")]
        public bool IgnoreBeanCans;
        [JsonProperty(PropertyName = "Ignore flares thrown (Explosives thrown)")]
        public bool IgnoreFlares;
        [JsonProperty(PropertyName = "Broadcast new challenge leaders to chat")]
        public bool AnnounceNewLeaders;
        [JsonProperty(PropertyName = "Update leaders on a timer (Recommended)")]
        public bool UseUpdateTimer;
        [JsonProperty(PropertyName = "Create and use Oxide groups for each challenge type")]
        public bool UseOxideGroups;
        [JsonProperty(PropertyName = "Update timer (hours)")]
        public int UpdateTimer;
        [JsonProperty(PropertyName = "Maximum tags to display (Requires BetterChat)")]
        public int MaximumTags;
        [JsonProperty(PropertyName = "Format of tags displayed (Requires BetterChat)")]
        public string TagFormat;
    }

    public class TextColor
    {
        [JsonProperty(PropertyName = "Primary message color (hex)")]
        public string TextColor1;
        [JsonProperty(PropertyName = "Secondary message color (hex)")]
        public string TextColor2;
        [JsonProperty(PropertyName = "Title color (hex) (Requires BetterChat)")]
        public string TitleColor;
        [JsonProperty(PropertyName = "UI Color - Background")]
        public UIColor Background;
        [JsonProperty(PropertyName = "UI Color - Panel")]
        public UIColor Panel;
        [JsonProperty(PropertyName = "UI Color - Button")]
        public UIColor Button;
        public class UIColor
        {
            [JsonProperty(PropertyName = "Color (hex)")]
            public string Color;
            [JsonProperty(PropertyName = "Alpha (0.0 - 1.0)")]
            public float Alpha;
        }

    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class ChallengeInfo
{
    [JsonProperty(PropertyName = "Title for name tag")]
    public string Title;
    [JsonProperty(PropertyName = "Enable this challenge")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Position in the UI leaderboard")]
    public int UIPosition;
    [JsonProperty(PropertyName = "Title priority")]
    public int Priority;
}

public class Option
{
    [JsonProperty(PropertyName = "Ignore kills against sleeping players (Players killed)")]
    public bool IgnoreSleepers;
    [JsonProperty(PropertyName = "Kills against NPC players are counted seperate to player kills")]
    public bool NPCKillSeperate;
    [JsonProperty(PropertyName = "NPC kill distance counts as PVE distance")]
    public bool NPCPVEKills;
    [JsonProperty(PropertyName = "Show challenge leader title tags (Requires BetterChat)")]
    public bool UseBetterChat;
    [JsonProperty(PropertyName = "Ignore all statistics recorded by admins")]
    public bool IgnoreAdmins;
    [JsonProperty(PropertyName = "Ignore kills for event players (Players killed)")]
    public bool IgnoreEventKills;
    [JsonProperty(PropertyName = "Ignore supply signals thrown (Explosives thrown)")]
    public bool IgnoreSupplySignals;
    [JsonProperty(PropertyName = "Ignore survey charges thrown (Explosives thrown)")]
    public bool IgnoreSurveyCharges;
    [JsonProperty(PropertyName = "Ignore beancan grenades thrown (Explosives thrown)")]
    public bool IgnoreBeanCans;
    [JsonProperty(PropertyName = "Ignore flares thrown (Explosives thrown)")]
    public bool IgnoreFlares;
    [JsonProperty(PropertyName = "Broadcast new challenge leaders to chat")]
    public bool AnnounceNewLeaders;
    [JsonProperty(PropertyName = "Update leaders on a timer (Recommended)")]
    public bool UseUpdateTimer;
    [JsonProperty(PropertyName = "Create and use Oxide groups for each challenge type")]
    public bool UseOxideGroups;
    [JsonProperty(PropertyName = "Update timer (hours)")]
    public int UpdateTimer;
    [JsonProperty(PropertyName = "Maximum tags to display (Requires BetterChat)")]
    public int MaximumTags;
    [JsonProperty(PropertyName = "Format of tags displayed (Requires BetterChat)")]
    public string TagFormat;
}

public class TextColor
{
    [JsonProperty(PropertyName = "Primary message color (hex)")]
    public string TextColor1;
    [JsonProperty(PropertyName = "Secondary message color (hex)")]
    public string TextColor2;
    [JsonProperty(PropertyName = "Title color (hex) (Requires BetterChat)")]
    public string TitleColor;
    [JsonProperty(PropertyName = "UI Color - Background")]
    public UIColor Background;
    [JsonProperty(PropertyName = "UI Color - Panel")]
    public UIColor Panel;
    [JsonProperty(PropertyName = "UI Color - Button")]
    public UIColor Button;
    public class UIColor
    {
        [JsonProperty(PropertyName = "Color (hex)")]
        public string Color;
        [JsonProperty(PropertyName = "Alpha (0.0 - 1.0)")]
        public float Alpha;
    }

}

public class UIColor
{
    [JsonProperty(PropertyName = "Color (hex)")]
    public string Color;
    [JsonProperty(PropertyName = "Alpha (0.0 - 1.0)")]
    public float Alpha;
}

private class ChallengeData
{
    public Dictionary<ulong, StatData> Stats;
    public Dictionary<Challenges, LeaderData> Titles;
    public double LastUpdate;
}

private class StatData
{
    public string DisplayName;
    public Dictionary<Challenges, int> Stats;
}

private class LeaderData
{
    public ulong UserID;
    public string DisplayName;
    public int Count;
}

private class WoundedData
{
    public float distance;
    public ulong attackerId;
}


```

---

## PlayerDatabase by FakeNinja - Big database with light weight way to save it to prevent lag

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.SQLite.Libraries;
using Oxide.Core.MySql.Libraries;
using Newtonsoft.Json.Linq;
using Oxide.Core.Database;
using Newtonsoft.Json;
using System.Linq;

Oxide.Plugins
[Info("Player Database", "Reneb / Maintained by FakeNinja", "1.6.2")]
 class PlayerDatabase : CovalencePlugin
{
     List<string> changedPlayersData;
     DataType dataType;
    static int dataTypeCfg;
    static string sqlitename;
    static string sql_host;
    static int sql_port;
    static string sql_db;
    static string sql_table;
    static string sql_user;
    static string sql_pass;
    protected override void LoadDefaultConfig();
    private void CheckCfg(string Key, T var);
     void Init();
     void FatalError(string msg);
     string GetMsg(string key, object steamid);
     List<string> KnownPlayers();
     bool isKnownPlayer(string userid);
     List<string> GetAllKnownPlayers();
     object FindPlayer(string arg);
     void OnServerSave();
     void Unload();
     void SetupDatabase();
     void OnUserConnected(IPlayer player);
     void OnPlayerJoined(string steamid, string name, string ip);
     void LoadData();
     void LoadPlayers();
     void LoadPlayer(string userid);
     void SavePlayerDatabase();
     void SetPlayerData(string userid, string key, object data, bool serializeData);
     object GetPlayerDataRaw(string userid, string key);
     object GetPlayerData(string userid, string key);
    public static DataFileSystem datafile;
     string subDirectory;
     Hash<string, DynamicConfigFile> playersData;
     StoredData storedData;
     class StoredData
    {
        public HashSet<string> knownPlayers;
        public StoredData();
    }

     void LoadFiles();
     void LoadPlayerData(string userid);
     void SavePlayerData(string userid);
     void SaveKnownPlayers();
     Core.SQLite.Libraries.SQLite Sqlite;
     Connection Sqlite_conn;
     List<string> sqliteColumns;
     Dictionary<string, Hash<string, string>> sqliteData;
     bool isValidColumn(string column);
     void CreateNewColumn(string column);
     void LoadSQLite();
     void LoadPlayerSQLite(string userid);
     void SavePlayerSQLite(string userid);
     Core.MySql.Libraries.MySql Sql;
     Connection Sql_conn;
     List<string> sqlColumns;
     Dictionary<string, Hash<string, string>> sqlData;
     bool isValidColumn2(string column);
     void CreateNewColumn2(string column);
     void LoadMySQL();
     void LoadPlayerSQL(string userid);
     void SavePlayerSQL(string userid);
}

 class StoredData
{
    public HashSet<string> knownPlayers;
    public StoredData();
}


```

---

## PlayerDemos by OfficerJAKE - Allows players and admins to record demos to the server via chat commands

```csharp
using System;
using Newtonsoft.Json;
using System.Collections.Generic;

Oxide.Plugins
[Info("Player Demos", "OfficerJAKE", "1.1.5")]
[Description("Allow players to record demo files to the server, and more")]
public class PlayerDemos : RustPlugin
{
    public const string PERM_ALLOW;
    public const string PERM_ADMIN;
    public const string CHAT_COMMAND_START;
    public const string CHAT_COMMAND_STOP;
    public const string CHAT_COMMAND_ADMIN_START;
    public const string CHAT_COMMAND_ADMIN_STOP;
    public const string CHAT_COMMAND_ADMIN_STOP_ALL;
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Global settings")]
        public GlobalSettings globalSettings;
        public class GlobalSettings
        {
            [JsonProperty(PropertyName = "Log To Console")]
            public bool LogToConsole;
            [JsonProperty(PropertyName = "Alert Player")]
            public bool AlertPlayer;
            [JsonProperty(PropertyName = "Max record time")]
            public float MaxDemoRecordTime;
        }

    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    [ChatCommand(CHAT_COMMAND_START)]
    private void ChatCommandDemoStart(BasePlayer player, string command, string[] args);
    [ChatCommand(CHAT_COMMAND_STOP)]
    private void ChatCommandDemoStop(BasePlayer player, string command, string[] args);
    [ChatCommand(CHAT_COMMAND_ADMIN_START)]
    private void AdminStartDemo(BasePlayer player, string command, string[] args);
    [ChatCommand(CHAT_COMMAND_ADMIN_STOP)]
    private void AdminStopDemo(BasePlayer player, string command, string[] args);
    [ChatCommand(CHAT_COMMAND_ADMIN_STOP_ALL)]
    private void AdminStopAllDemos(BasePlayer player, string command, string[] args);
    private void Unload();
     void Init();
    private void StartRecordingDemo(BasePlayer player);
    private void StopRecordingDemo(BasePlayer player);
    private void StartAdminDemo(BasePlayer player, BasePlayer WhoToRecord);
    private void StopAdminDemo(BasePlayer player, BasePlayer WhoToRecord);
    private void AdminStopAllDemos(BasePlayer player);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Global settings")]
    public GlobalSettings globalSettings;
    public class GlobalSettings
    {
        [JsonProperty(PropertyName = "Log To Console")]
        public bool LogToConsole;
        [JsonProperty(PropertyName = "Alert Player")]
        public bool AlertPlayer;
        [JsonProperty(PropertyName = "Max record time")]
        public float MaxDemoRecordTime;
    }

}

public class GlobalSettings
{
    [JsonProperty(PropertyName = "Log To Console")]
    public bool LogToConsole;
    [JsonProperty(PropertyName = "Alert Player")]
    public bool AlertPlayer;
    [JsonProperty(PropertyName = "Max record time")]
    public float MaxDemoRecordTime;
}


```

---

## PlayerEffects by Paulsimik - Adds Effect trails to the Player

```csharp
using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Libraries;
using VLB;

Oxide.Plugins
[Info("Player Effects", "paulsimik", "1.0.0")]
[Description("Adds Effect to the Player")]
 class PlayerEffects : RustPlugin
{
    private bool DEBUG;
    private const string permUse;
    private const string MISSING_EFFECT;
    private const string BARRICADE_EFFECT;
    private const string FIRE2_EFFECT;
    private void Init();
    private void Unload();
    private void OnPlayerDisconnected(BasePlayer player);
    private PlayerEffect GetPlayer(BasePlayer player);
    private void DestroyPlayerComponent(BasePlayer player);
    private void AddEffect(PlayerEffect playerEffect, string typeEffect);
    [ChatCommand("pe")]
    private void cmdPlayerEffect(BasePlayer player, string command, string[] args);
    public class PlayerEffect : MonoBehaviour
    {
        public BasePlayer player;
        public string effect;
        public Vector3 effectPosition;
        public float time;
        private void Awake();
        public void RunTimer();
        public void DestroyTimer();
        private void RunEffect();
        private void OnDestroy();
    }

    private string GetLang(string key, string playerID);
    protected override void LoadDefaultMessages();
    private bool HasPermission(BasePlayer player);
    private void SendMessage(BasePlayer player, string msg);
    private void PrintDebug(object message);
}

public class PlayerEffect : MonoBehaviour
{
    public BasePlayer player;
    public string effect;
    public Vector3 effectPosition;
    public float time;
    private void Awake();
    public void RunTimer();
    public void DestroyTimer();
    private void RunEffect();
    private void OnDestroy();
}


```

---

## PlayerEntityRemover by zeeuss - Removes all entities of certain player.

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Player Entity Remover", "Zeeuss", "0.1.6")]
[Description("Removes certain player's entities")]
public class PlayerEntityRemover : CovalencePlugin
{
    const string entRemoveUse;
    const string entRemoveBypass;
     void Init();
     void Loaded();
    protected override void LoadDefaultMessages();
    [Command("entremove")]
    private void entityRemoveCmnd(IPlayer player, string command, string[] args);
     void OnPlayerBanned(string name, ulong id, string address, string reason);
     void OnPlayerDeath(BasePlayer player, HitInfo info);
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Remove player's entities if banned")]
        public bool removeOnBan;
        [JsonProperty(PropertyName = "Remove player's entities on death")]
        public bool removeOnDeath;
    }

    private bool LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConfig(ConfigData config);
     IEnumerator KillEntities(List<BaseEntity> entities);
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Remove player's entities if banned")]
    public bool removeOnBan;
    [JsonProperty(PropertyName = "Remove player's entities on death")]
    public bool removeOnDeath;
}


```

---

## PlayerGravestone by Lincoln - Spawns a gravestone at a player's death location

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using UnityEngine;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Player Gravestone", "Lincoln", "1.2.2")]
[Description("Spawns a gravestone at a player's death location")]
 class PlayerGravestone : RustPlugin
{
    private const string PermUse;
    private const string GravestonePrefab;
    private const string GravestoneShortName;
    private Dictionary<ulong, KillInfo> killInfos;
    private PluginConfig config;
    private class PluginConfig
    {
        public int GraveStoneDespawnTimeInSeconds;
        public int KillInfoPersistenceTimeInSeconds;
        public bool SpawnGraveStoneInAuthZone;
        public bool OnlyOwnerCanDamageGraveStone;
        public bool BroadcastDeathMessageToServer;
    }

    protected override void LoadConfig();
    private void Init();
    private object OnPlayerDeath(BasePlayer player, HitInfo hitInfo);
    private void OnEntityTakeDamage(BaseEntity entity, HitInfo info);
    private void OnPlayerInput(BasePlayer player, InputState input);
    private void RemoveExistingGravestones(ulong playerID);
    private void SpawnGravestone(BasePlayer player, HitInfo hitInfo);
    private string ExtractAttackerName(string attackerString);
    private void DisplayDeathMessage(BasePlayer player, ulong gravestoneOwnerID);
    private void ChatMessage(BasePlayer player, string messageName, object[] args);
    protected override void LoadDefaultMessages();
    private class KillInfo
    {
        public string VictimName { get; set; }
        public string AttackerName { get; set; }
    }

}

private class PluginConfig
{
    public int GraveStoneDespawnTimeInSeconds;
    public int KillInfoPersistenceTimeInSeconds;
    public bool SpawnGraveStoneInAuthZone;
    public bool OnlyOwnerCanDamageGraveStone;
    public bool BroadcastDeathMessageToServer;
}

private class KillInfo
{
    public string VictimName { get; set; }
    public string AttackerName { get; set; }
}


```

---

## PlayerHider by birthdates - Don't network players that are out of view

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using Network.Visibility;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Player Hider", "birthdates", "1.3.0")]
[Description("Don't network players that are out of view")]
public class PlayerHider : RustPlugin
{
    private class ViewBehaviour : FacepunchBehaviour
    {
        private readonly HashSet<BasePlayer> _hiddenPlayers;
        private readonly List<Connection> _list;
        private bool _lastChangeable;
        private Vector3 _lastPos;
        private BasePlayer _player;
        public Group Group { get; set; }
        private void Awake();
        public void OnDestroy();
        public void Tick();
        public void ShowPlayer(BasePlayer player);
        public void HidePlayer(BasePlayer player);
        public bool CanSee(BasePlayer player);
        public void Kill();
    }

    private const float MaxDistance;
    private int ObstructionMask { get; set; }
    private int ModifiableObstructionMask { get; set; }
    private static PlayerHider Instance { get; set; }
    private readonly IDictionary<ulong, ViewBehaviour> _idToBehaviour;
    [HookMethod("CanSee")]
    private bool CanSee(BasePlayer player, BasePlayer target);
    private void OnNetworkGroupLeft(BasePlayer player, Group group);
    private static bool IsFiring(BasePlayer player);
    private void Init();
    private void OnServerInitialized();
    private void OnNetworkableChanged(Networkable networkable, bool removed);
    private static void CheckPlayers();
    private void Unload();
    private static void MapGroupSubscribers(ListHashSet<Networkable> newValue);
    private void OnPlayerRespawned(BasePlayer player);
    private class UpdateListHashSet : ListHashSet<T>
    {
        private readonly Action<T, bool> _callback;
        public UpdateListHashSet(Action<T, bool> callback);
        public new void Add(T value);
        public new bool Remove(T value);
    }

    private ConfigFile _config;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class ConfigFile
    {
        [JsonProperty("Minimum Distance")]
        public float MinimumDistance { get; set; }
        [JsonProperty("Show a Player if Firing")]
        public bool ShowOnFire { get; set; }
        [JsonProperty("Check Interval (seconds)")]
        public float CheckInterval { get; set; }
        public static ConfigFile DefaultConfig();
    }

}

private class ViewBehaviour : FacepunchBehaviour
{
    private readonly HashSet<BasePlayer> _hiddenPlayers;
    private readonly List<Connection> _list;
    private bool _lastChangeable;
    private Vector3 _lastPos;
    private BasePlayer _player;
    public Group Group { get; set; }
    private void Awake();
    public void OnDestroy();
    public void Tick();
    public void ShowPlayer(BasePlayer player);
    public void HidePlayer(BasePlayer player);
    public bool CanSee(BasePlayer player);
    public void Kill();
}

private class UpdateListHashSet : ListHashSet<T>
{
    private readonly Action<T, bool> _callback;
    public UpdateListHashSet(Action<T, bool> callback);
    public new void Add(T value);
    public new bool Remove(T value);
}

private class ConfigFile
{
    [JsonProperty("Minimum Distance")]
    public float MinimumDistance { get; set; }
    [JsonProperty("Show a Player if Firing")]
    public bool ShowOnFire { get; set; }
    [JsonProperty("Check Interval (seconds)")]
    public float CheckInterval { get; set; }
    public static ConfigFile DefaultConfig();
}


```

---

## PlayerInformations by austinv900 - Stores player IPs , usernames, positions, last seen, first connection ...

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;

Oxide.Plugins
[Info("PlayerInformations", "austinv900", "1.2.14")]
[Description("Logs players informations.")]
public class PlayerInformations : CovalencePlugin
{
    [PluginReference]
     Plugin PlayerDatabase;
    static DateTime epoch;
     string GetMsg(string key, object steamid);
     bool IsConnected(string steamid);
     string NormalizeIP(string ip);
     void SendHelpText(IPlayer player);
     string HelpText(string steamid);
     bool hasPermission(string steamid, string permissionName, int authLevel);
     void OnPlayerJoined(string steamid, string name, string ip);
     void OnPlayerLeave(IPlayer player);
    static double LogTime();
     string TimeMinToString(string time);
     string TimeMinToString(double time);
     string SecondsToString(string time);
     string SecondsToString(decimal time);
    private object FindPlayer(string arg);
    private static bool IPuse;
    private static string IPpermission;
    private static int IPauthlevel;
    private static int IPmaxLogs;
    private static bool NAMESuse;
    private static string NAMESpermission;
    private static int NAMESauthlevel;
    private static int NAMESmaxLogs;
    private static bool FCuse;
    private static string FCpermission;
    private static int FCauthlevel;
    private static bool LSuse;
    private static string LSpermission;
    private static int LSauthlevel;
    private static bool LPuse;
    private static string LPpermission;
    private static int LPauthlevel;
    private static bool TPuse;
    private static string TPpermission;
    private static int TPauthlevel;
     void Init();
    protected override void LoadDefaultConfig();
     void CheckCfg(string Key, T var);
     void LoadDefaultMessages();
     void OnServerInitialized();
     void Unload();
     void OnUserConnected(IPlayer player);
     void OnUserDisconnected(IPlayer player);
     Dictionary<string, double> recordPlayTime;
    [Command("played")]
     void cmdChatPlayed(IPlayer player, string command, string[] args);
     string CMD_chatPlayed(string steamid, string[] args);
     void StartRecordTimeAll();
     void EndRecordTimeAll();
     double LastRecordTime(string steamid);
     double SessionRecordTime(string steamid);
     double TimePlayed(string steamid);
     void StartRecordTime(string steamid);
     void EndRecordTime(string steamid);
    [Command("lastposition")]
     void cmdChatLastPosition(IPlayer player, string command, string[] args);
     GenericPosition FindPosition(string steamid);
     GenericPosition FindCurrentPosition(string steamid);
     GenericPosition FindLastPosition(string steamid);
     void RecordPosition(string steamid, float x, float y, float z);
     string CMD_chatLastPosition(string steamid, string[] args);
    [Command("lastseen")]
     void cmdChatLastseen(IPlayer player, string command, string[] args);
     void RecordLastSeen(string steamid);
     float LastSeen(string steamid);
     string CMD_chatLastseen(string steamid, string[] args);
    [Command("lastips")]
     void cmdChatLastIps(IPlayer player, string command, string[] args);
    [Command("ipowners")]
     void cmdChatIpOwners(IPlayer player, string command, string[] args);
     void RecordIP(string steamid, string playerip);
     string CMD_lastIps(string steamid, string[] args);
     string CMD_chatIps(string steamid, string[] args);
    [Command("firstconnection")]
     void cmdChatFirstconnection(IPlayer player, string command, string[] args);
     float FirstConnection(string steamid);
     void RecordFirstConnection(string steamid);
     string CMD_chatFirstconnection(string steamid, string[] args);
    [Command("lastnames")]
     void cmdChatLastname(IPlayer player, string command, string[] args);
     List<string> LastNames(string steamid);
     void RecordName(string steamid, string playername);
     string CMD_chatLastname(string steamid, string[] args);
}


```

---

## PlayerList by MrBlue - Shows a list and count of all online, non-hidden players

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("PlayerList", "Wulf/lukespragg", "0.3.2", ResourceId = 2126)]
[Description("Shows a list and count of all online, non-hidden players")]
 class PlayerList : CovalencePlugin
{
    const string permAllow;
    const string permHide;
     bool adminSeparate;
     string adminColor;
    protected override void LoadDefaultConfig();
     void Init();
     void LoadDefaultMessages();
    [Command("online")]
     void OnlineCommand(IPlayer player, string command, string[] args);
    [Command("players", "who")]
     void PlayersCommand(IPlayer player, string command, string[] args);
     T GetConfig(string name, T value);
     string Lang(string key, string id, object[] args);
}


```

---

## PlayerLocation by seacowz - Displays the location of all active and sleeping players on the server

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("Player Location", "seacowz", "0.1.7")]
[Description("Find the location of players on the server")]
public class PlayerLocation : CovalencePlugin
{
    private class PlayerData
    {
        public DateTime lastawaketime { get; set; }
        public DateTime lastdeathtime { get; set; }
        public Vector3 lastdeathloc { get; set; }
        public PlayerData();
    }

    private Dictionary<string, PlayerData> playerdict;
    private const string permAdmin;
    protected override void LoadDefaultMessages();
    private void Init();
    private void OnPlayerSleep(BasePlayer player);
    private void OnPlayerSleepEnded(BasePlayer player);
    private void OnPlayerDeath(BasePlayer player, HitInfo info);
     void Unload();
    [Command("location")]
    private void LocationCmd(IPlayer player, string command, string[] args);
    private void LoadDataFile();
    private void SaveDataFile();
    private void FindLocation(IPlayer callingplayer, string search, List<Tuple<double, string>> locationlist);
    private void FindDLocation(IPlayer callingplayer, string search, List<Tuple<double, string>> locationlist);
    private string MapPosition(Vector3 position);
}

private class PlayerData
{
    public DateTime lastawaketime { get; set; }
    public DateTime lastdeathtime { get; set; }
    public Vector3 lastdeathloc { get; set; }
    public PlayerData();
}


```

---

## PlayerLootLogs by IrishOfficial - Detailed logging for player loot events. Supports logging to Console, File System, and Discord

```csharp
using Oxide.Core.Plugins;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Player Loot Logs", "hizentv + Irish", "1.5.2")]
[Description("Detailed logging for player looting events. Optionally log to Console, File, and/or Discord.")]
 class PlayerLootLogs : RustPlugin
{
    [PluginReference]
    private Plugin DiscordLogger;
     class PlayerLootLogConfig
    {
        public Dictionary<LootTarget, bool> Tracking { get; set; }
        public LogSource Console { get; set; }
        public FileLogSource File { get; set; }
        public DiscordLogSource Discord { get; set; }
        public PlayerLootLogConfig InitDefaults();
        public bool IsTracking(BasePlayer player, BaseEntity target);
        private bool IsTrackingTeam(BasePlayer player, BaseEntity target);
        public class LogSource
        {
            const string defaultPrefix;
            public bool Enabled { get; set; }
            public string FormatLootGive { get; set; }
            public string FormatLootTake { get; set; }
            public string FormatLootDropSelf { get; set; }
            public string FormatLootDropTarget { get; set; }
            private string GetFormat(LootAction type);
            public string FormatMessage(LootAction lootType, LootChange change, LootItem item, PlayerInfo[] looters);
            private string FormatMessage(string format, LootChange change, LootItem item, PlayerInfo[] looters);
        }

        public class FileLogSource : LogSource
        {
            public string FileNameFormat { get; set; }
            public int DelaySeconds { get; set; }
        }

        public class DiscordLogSource : LogSource
        {
            public string WebHookUrl { get; set; }
        }

    }

     PlayerLootLogConfig config;
    protected override void LoadDefaultConfig();
     void Init();
     void Unload();
    private void LogChange(LootChange change);
    public ConcurrentQueue<string> FileLogQueue { get; set; }
    private void SendLog(PlayerLootLogConfig.LogSource.LootAction lootType, LootChange change, LootItem item, PlayerInfo[] looters);
     bool isFlushingLogQueue;
     object flushLock;
    private void FlushLogQueue();
     void OnLootEntity(BasePlayer player, BaseEntity entity);
     void OnLootNetworkUpdate(PlayerLoot loot);
     void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, bool broadcast);
     void OnPlayerLootEnd(PlayerLoot inventory);
     void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
    private Dictionary<ulong, ulong> LinkToLootEvent { get; set; }
    private Dictionary<ulong, LootEvent> TargetLootEvents { get; set; }
    private void EnterLootEvent(BasePlayer player, BaseEntity target);
    private void ExitLootEvent(BasePlayer player, BaseEntity target);
    private class LootEvent
    {
        public Dictionary<ulong, BasePlayer> Looters { get; set; }
        public BaseEntity Target { get; set; }
        public Dictionary<ulong, List<LootItem>> Items { get; set; }
        public bool Active { get; set; }
        public LootEvent(BasePlayer player, BaseEntity baseTarget);
        public bool RecordChange(BasePlayer player, BaseEntity baseTarget, LootChange lootChange);
        public void RemoveLooter(BasePlayer player);
        private void UpdateItems();
    }

}

 class PlayerLootLogConfig
{
    public Dictionary<LootTarget, bool> Tracking { get; set; }
    public LogSource Console { get; set; }
    public FileLogSource File { get; set; }
    public DiscordLogSource Discord { get; set; }
    public PlayerLootLogConfig InitDefaults();
    public bool IsTracking(BasePlayer player, BaseEntity target);
    private bool IsTrackingTeam(BasePlayer player, BaseEntity target);
    public class LogSource
    {
        const string defaultPrefix;
        public bool Enabled { get; set; }
        public string FormatLootGive { get; set; }
        public string FormatLootTake { get; set; }
        public string FormatLootDropSelf { get; set; }
        public string FormatLootDropTarget { get; set; }
        private string GetFormat(LootAction type);
        public string FormatMessage(LootAction lootType, LootChange change, LootItem item, PlayerInfo[] looters);
        private string FormatMessage(string format, LootChange change, LootItem item, PlayerInfo[] looters);
    }

    public class FileLogSource : LogSource
    {
        public string FileNameFormat { get; set; }
        public int DelaySeconds { get; set; }
    }

    public class DiscordLogSource : LogSource
    {
        public string WebHookUrl { get; set; }
    }

}

public class LogSource
{
    const string defaultPrefix;
    public bool Enabled { get; set; }
    public string FormatLootGive { get; set; }
    public string FormatLootTake { get; set; }
    public string FormatLootDropSelf { get; set; }
    public string FormatLootDropTarget { get; set; }
    private string GetFormat(LootAction type);
    public string FormatMessage(LootAction lootType, LootChange change, LootItem item, PlayerInfo[] looters);
    private string FormatMessage(string format, LootChange change, LootItem item, PlayerInfo[] looters);
}

public class FileLogSource : LogSource
{
    public string FileNameFormat { get; set; }
    public int DelaySeconds { get; set; }
}

public class DiscordLogSource : LogSource
{
    public string WebHookUrl { get; set; }
}

private class LootEvent
{
    public Dictionary<ulong, BasePlayer> Looters { get; set; }
    public BaseEntity Target { get; set; }
    public Dictionary<ulong, List<LootItem>> Items { get; set; }
    public bool Active { get; set; }
    public LootEvent(BasePlayer player, BaseEntity baseTarget);
    public bool RecordChange(BasePlayer player, BaseEntity baseTarget, LootChange lootChange);
    public void RemoveLooter(BasePlayer player);
    private void UpdateItems();
}


```

---

## PlayerNames by  - Logs and stores all names used by players.

```csharp
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Player Names", "Arainrr", "1.1.2")]
[Description("Logs and stores all names used by players.")]
public class PlayerNames : CovalencePlugin
{
    private const string PERMISSION_USE;
    private bool changed;
    private void Init();
    private void Unload();
    private void OnServerSave();
    private void OnUserConnected(IPlayer iPlayer);
    private string GetPlayerNames(string playerID);
    [Command("name")]
    private void CmdName(IPlayer iPlayer, string command, string[] args);
    private Dictionary<string, HashSet<string>> playerData;
    private void LoadData();
    private void SaveData();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
}


```

---

## PlayerRankings by Ankawi - Automatically gives players ranks based on playtime

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Player Rankings", "Ankawi", "3.0.3")]
[Description("Gives players ranks based on playtime on a server")]
 class PlayerRankings : RustPlugin
{
    [PluginReference]
     Plugin ConnectionDB;
     Plugin PlaytimeTracker;
     Plugin BetterChat;
     void OnServerInitialized();
     bool IsUserInGroup(BasePlayer player, string group);
     void AddUserToGroup(BasePlayer player, string group);
     void RemoveUserFromGroup(BasePlayer player, string group);
     void CreateGroup(string group);
     bool GroupExists(string group);
    new void LoadConfig();
    protected override void LoadDefaultConfig();
     void SetConfig(object[] args);
    [ChatCommand("ranks")]
    private void RanksCommand(BasePlayer player, string command, string[] args);
     void UpdateGroups(BasePlayer player);
     void RevokeLower(BasePlayer player, double time);
     double GetPlayTime(BasePlayer player);
}


```

---

## PlayerReport by  - GUI reporting for players after being killed

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

Oxide.Plugins
[Info("Player Report", "hoppel", "1.0.8")]
[Description("GUI reporting for players after being killed")]
public class PlayerReport : RustPlugin
{
    [PluginReference]
    private Plugin DiscordMessages;
    private List<string> openUI;
    private HashSet<ulong> cooldowns;
    private const string Permname;
    private const string Permnameblock;
    private void Cooldownhandling(BasePlayer player);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private void OnPlayerRespawned(BasePlayer player);
    private void Loaded();
    private void Unload();
    [ConsoleCommand("ReportHacking")]
    private void cmdReportHacking(ConsoleSystem.Arg arg);
    [ConsoleCommand("ReportGroupLimit")]
    private void cmdReportGroupLimit(ConsoleSystem.Arg arg);
    [ConsoleCommand("ReportBugAbuse")]
    private void cmdReportBugAbuse(ConsoleSystem.Arg arg);
    private void DiscordMessage(string displayName, string userId, string reportFunction, string killerName, string killerUserId, string distance, string weapon, int reported, int reports);
    public class Fields
    {
        public string name { get; set; }
        public string value { get; set; }
        public bool inline { get; set; }
        public Fields(string name, string value, bool inline);
    }

    private void DeathReportUI(BasePlayer player, string killer, string distance, string killername, string weaponName);
    private void DestroyUI(BasePlayer player);
    private int requiredReports;
    private string Servername;
    private float Cooldown;
    private string webhookURL;
    private bool Alert;
    private bool enableTickets;
    private bool enableDiscordMessages;
    private bool Button1Enabled;
    private string Button1Color;
    private string Button1AnchMin;
    private string Button1AnchMax;
    private bool Button2Enabled;
    private string Button2Color;
    private string Button2AnchMin;
    private string Button2AnchMax;
    private bool Button3Enabled;
    private string Button3Color;
    private string Button3AnchMin;
    private string Button3AnchMax;
    private new void LoadConfig();
    private void Init();
    private void GetConfig(T variable, string[] path);
    protected override void LoadDefaultConfig();
    public string RemoveFormatting(string source);
    public string msg(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
    private StoredData storedData;
    private class StoredData
    {
        public Dictionary<string, ReportInfo> PlayerInformation;
        public StoredData();
        public void Read();
        public void Save();
    }

    private class ReportInfo
    {
        public int Reports;
        public int Reported;
    }

}

public class Fields
{
    public string name { get; set; }
    public string value { get; set; }
    public bool inline { get; set; }
    public Fields(string name, string value, bool inline);
}

private class StoredData
{
    public Dictionary<string, ReportInfo> PlayerInformation;
    public StoredData();
    public void Read();
    public void Save();
}

private class ReportInfo
{
    public int Reports;
    public int Reported;
}


```

---

## PlayerTracker by nivex - Gives players with permission the ability to easily watch the movement of certain players

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("PlayerTracker", "redBDGR", "1.0.1", ResourceId = 2584)]
[Description("Easily track the movements of players")]
 class PlayerTracker : RustPlugin
{
    private static PlayerTracker plugin;
    private bool Changed;
    private float intervalTime;
    private float drawLength;
    private bool clearPositionsOnCheck;
    private bool trackAllPlayers;
    private float startDeleteTime;
    private float arrowHead;
    private const string permissionName;
    private void Init();
    protected override void LoadDefaultConfig();
     void LoadVariables();
    private void Unload();
    private void OnPlayerSleepEnded(BasePlayer player);
    [ChatCommand("track")]
    private void TrackCMD(BasePlayer player, string command, string[] args);
    private class Tracker : MonoBehaviour
    {
        private BasePlayer player;
        private float nextTime;
        private readonly float intervalTime;
        public List<Vector3> locationList;
        private float startDeleteTime;
        private Vector3 lastPos;
        private void Awake();
        private void Update();
    }

    private void DoDraws(BasePlayer player, float length, Vector3 pos1, Vector3 pos2);
    private object GetConfig(string menu, string datavalue, object defaultValue);
     string msg(string key, string id);
}

private class Tracker : MonoBehaviour
{
    private BasePlayer player;
    private float nextTime;
    private readonly float intervalTime;
    public List<Vector3> locationList;
    private float startDeleteTime;
    private Vector3 lastPos;
    private void Awake();
    private void Update();
}


```

---

## PlayFX by misticos - Play any effect on a player, such as an explosion sound

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("Play FX", "misticos", "2.0.1")]
[Description("Play any effect on a player, such as an explosion sound.")]
 class PlayFX : CovalencePlugin
{
    private const string PermissionUse;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] Commands;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void Init();
    private void CommandRun(IPlayer player, string command, string[] args);
    private Effect _effect;
    private void RunEffect(IEnumerable<BasePlayer> targets, string prefab, uint prefabId);
    private string GetMsg(string key, string id);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] Commands;
}


```

---

## PlaytimeSupplySignal by  - Gives players a Supply Signal, based on time played on server at configurable rate

```csharp
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core;
using Convert = System.Convert;
using System.Linq;

Oxide.Plugins
[Info("Playtime Supply Signal", "Krungh Crow", "1.1.3")]
[Description("Give player a Supply Signal, based on time played on server and configurable rate.")]
public class PlaytimeSupplySignal : RustPlugin
{
    [PluginReference]
    private Plugin VehicleAirdrops;
    private Timer clock;
     bool debug;
     bool ConfigChanged;
     float clockrate;
     float bonusratemin;
     bool spawnbonus;
     bool VAUse;
    private List<object> VASpawn;
    private List<object> VABonus;
     int VASpawnAmount;
     int VABonusAmount;
     string Prefix;
     string PrefixColor;
     string ChatColor;
     ulong SteamIDIcon;
    const string Bonus_Perm;
     class StoredData
    {
        public Dictionary<ulong, bool> playerIDhadfirst;
        public Dictionary<ulong, float> playerIDbonusclock;
        public List<ulong> playerIDpending;
        public StoredData();
    }

    private StoredData storedData;
    protected override void LoadDefaultConfig();
    private void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
     void Init();
     void OnServerInitialized();
     void Unload();
    protected override void LoadDefaultMessages();
     void LetsClockOnActivePlaytime();
     void LetsClockOnSleeperPlaytime();
     void CountDaTime(List<BasePlayer> playerlist);
     void GiveSupplyDropToPlayer(BasePlayer player);
}

 class StoredData
{
    public Dictionary<ulong, bool> playerIDhadfirst;
    public Dictionary<ulong, float> playerIDbonusclock;
    public List<ulong> playerIDpending;
    public StoredData();
}


```

---

## PlaytimeTracker by k1lly0u - Tracks playtime and AFK time of players with optional rewards

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Playtime Tracker", "k1lly0u", "0.2.2")]
[Description("Track player time spent on the server")]
 class PlaytimeTracker : CovalencePlugin
{
    private StoredData storedData;
    private DynamicConfigFile data;
    private static Action<string, double> TimeReward;
    private static Action<string, string> ReferralReward;
    private static PluginTimers Timer;
    private static Plugin RewardPlugin;
    protected override void LoadDefaultMessages();
     void Init();
    private void OnServerInitialized();
    private void OnUserConnected(IPlayer user);
    private void OnUserDisconnected(IPlayer user);
    private void OnPluginLoaded(Plugin plugin);
    private void Unload();
    private void ValididateRewardSystem();
    private static double CurrentTime { get; set; }
    private static string FormatTime(double time);
    internal void IssueReward(string id, double amount);
    internal void IssueReward(string referrer, string referee);
    private double _nextTopUpdate;
    private List<StoredData.UserData> topList;
    [Command("playtime")]
    private void cmdPlaytime(IPlayer user, string command, string[] args);
    [Command("refer")]
    private void cmdRefer(IPlayer user, string command, string[] args);
    private object GetPlayTime(string id);
    private object GetAFKTime(string id);
    private object GetReferrals(string id);
    private static ConfigData Configuration;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "General Options")]
        public GeneralOptions General { get; set; }
        [JsonProperty(PropertyName = "Reward Options")]
        public RewardOptions Reward { get; set; }
        public class GeneralOptions
        {
            [JsonProperty(PropertyName = "Data save interval (seconds)")]
            public int SaveInterval { get; set; }
            [JsonProperty(PropertyName = "Track player AFK time")]
            public bool TrackAFK { get; set; }
            [JsonProperty(PropertyName = "Number of entries to display in the top playtime list")]
            public int TopCount { get; set; }
        }

        public class RewardOptions
        {
            [JsonProperty(PropertyName = "Reward plugin (ServerRewards, Economics)")]
            public string Plugin { get; set; }
            [JsonProperty(PropertyName = "Playtime rewards")]
            public PlaytimeRewards Playtime { get; set; }
            [JsonProperty(PropertyName = "Referral rewards")]
            public ReferralRewards Referral { get; set; }
            [JsonProperty(PropertyName = "Custom reward multipliers (permission / multiplier)")]
            public Hash<string, float> CustomMultipliers { get; set; }
            public class PlaytimeRewards
            {
                [JsonProperty(PropertyName = "Issue rewards for playtime")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Reward interval (seconds)")]
                public int Interval { get; set; }
                [JsonProperty(PropertyName = "Reward amount")]
                public int Reward { get; set; }
            }

            public class ReferralRewards
            {
                [JsonProperty(PropertyName = "Issue rewards for player referrals")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Referrer reward amount")]
                public int InviteReward { get; set; }
                [JsonProperty(PropertyName = "Referee reward amount")]
                public int JoinReward { get; set; }
            }

            [JsonIgnore]
            private Permission permission;
            internal void RegisterPermissions(CovalencePlugin plugin, Permission permission);
        }

        public VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private void TimedSaveData();
    private void SaveData();
    private void LoadData();
    [Command("ptt.restorenames")]
    private void FindMissingNames(IPlayer player, string message, string[] args);
    private class StoredData
    {
        [JsonProperty]
        internal Hash<string, UserData> _userData;
        [JsonProperty]
        internal HashSet<string> _referredUsers;
        public bool HasBeenReferred(string id);
        public void ReferPlayer(string referrer, string referree);
        public void OnUserConnected(IPlayer user);
        public void OnUserDisconnected(IPlayer user);
        public double GetPlayTimeForPlayer(string id);
        public double GetAFKTimeForPlayer(string id);
        public int GetReferralsForPlayer(string id);
        public void GetTopPlayTime(List<UserData> list);
        internal void InsertData(string id, string displayName, double playTime, double afkTime, double lastReward, int referrals);
        internal void InsertReferral(string id);
        public class UserData
        {
            public double playtime;
            public double afkTime;
            public double lastRewardTime;
            public int referrals;
            public string displayName;
            [JsonIgnore]
            private IPlayer _user;
            [JsonIgnore]
            private Timer _timer;
            [JsonIgnore]
            private double _timeStarted;
            [JsonIgnore]
            private GenericPosition _lastPosition;
            private const float TIMER_INTERVAL;
            public double PlayTime { get; set; }
            public double AFKTime { get; set; }
            public void OnUserConnected(IPlayer user);
            private void StartTimer();
            public void OnUserDisconnected();
            private void OnTimerTick();
            private bool EqualPosition(GenericPosition a, GenericPosition b);
        }

    }

    private void RestoreOldData();
    private void LoadOldData();
    private PlayData playData;
    private PermData permData;
    private RefData referData;
    private DynamicConfigFile TimeData;
    private DynamicConfigFile PermissionData;
    private DynamicConfigFile ReferralData;
    private class PlayData
    {
        public Dictionary<string, TimeInfo> timeData;
        public class TimeInfo
        {
            public double playTime;
            public double afkTime;
            public double lastReward;
            public int referrals;
        }

    }

    private class PermData
    {
        public Dictionary<string, float> permissions;
    }

    private class RefData
    {
        public List<string> referrals;
    }

    private void Message(IPlayer user, string key, object[] args);
    private readonly Dictionary<string, string> Messages;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "General Options")]
    public GeneralOptions General { get; set; }
    [JsonProperty(PropertyName = "Reward Options")]
    public RewardOptions Reward { get; set; }
    public class GeneralOptions
    {
        [JsonProperty(PropertyName = "Data save interval (seconds)")]
        public int SaveInterval { get; set; }
        [JsonProperty(PropertyName = "Track player AFK time")]
        public bool TrackAFK { get; set; }
        [JsonProperty(PropertyName = "Number of entries to display in the top playtime list")]
        public int TopCount { get; set; }
    }

    public class RewardOptions
    {
        [JsonProperty(PropertyName = "Reward plugin (ServerRewards, Economics)")]
        public string Plugin { get; set; }
        [JsonProperty(PropertyName = "Playtime rewards")]
        public PlaytimeRewards Playtime { get; set; }
        [JsonProperty(PropertyName = "Referral rewards")]
        public ReferralRewards Referral { get; set; }
        [JsonProperty(PropertyName = "Custom reward multipliers (permission / multiplier)")]
        public Hash<string, float> CustomMultipliers { get; set; }
        public class PlaytimeRewards
        {
            [JsonProperty(PropertyName = "Issue rewards for playtime")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Reward interval (seconds)")]
            public int Interval { get; set; }
            [JsonProperty(PropertyName = "Reward amount")]
            public int Reward { get; set; }
        }

        public class ReferralRewards
        {
            [JsonProperty(PropertyName = "Issue rewards for player referrals")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Referrer reward amount")]
            public int InviteReward { get; set; }
            [JsonProperty(PropertyName = "Referee reward amount")]
            public int JoinReward { get; set; }
        }

        [JsonIgnore]
        private Permission permission;
        internal void RegisterPermissions(CovalencePlugin plugin, Permission permission);
    }

    public VersionNumber Version { get; set; }
}

public class GeneralOptions
{
    [JsonProperty(PropertyName = "Data save interval (seconds)")]
    public int SaveInterval { get; set; }
    [JsonProperty(PropertyName = "Track player AFK time")]
    public bool TrackAFK { get; set; }
    [JsonProperty(PropertyName = "Number of entries to display in the top playtime list")]
    public int TopCount { get; set; }
}

public class RewardOptions
{
    [JsonProperty(PropertyName = "Reward plugin (ServerRewards, Economics)")]
    public string Plugin { get; set; }
    [JsonProperty(PropertyName = "Playtime rewards")]
    public PlaytimeRewards Playtime { get; set; }
    [JsonProperty(PropertyName = "Referral rewards")]
    public ReferralRewards Referral { get; set; }
    [JsonProperty(PropertyName = "Custom reward multipliers (permission / multiplier)")]
    public Hash<string, float> CustomMultipliers { get; set; }
    public class PlaytimeRewards
    {
        [JsonProperty(PropertyName = "Issue rewards for playtime")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Reward interval (seconds)")]
        public int Interval { get; set; }
        [JsonProperty(PropertyName = "Reward amount")]
        public int Reward { get; set; }
    }

    public class ReferralRewards
    {
        [JsonProperty(PropertyName = "Issue rewards for player referrals")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Referrer reward amount")]
        public int InviteReward { get; set; }
        [JsonProperty(PropertyName = "Referee reward amount")]
        public int JoinReward { get; set; }
    }

    [JsonIgnore]
    private Permission permission;
    internal void RegisterPermissions(CovalencePlugin plugin, Permission permission);
}

public class PlaytimeRewards
{
    [JsonProperty(PropertyName = "Issue rewards for playtime")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Reward interval (seconds)")]
    public int Interval { get; set; }
    [JsonProperty(PropertyName = "Reward amount")]
    public int Reward { get; set; }
}

public class ReferralRewards
{
    [JsonProperty(PropertyName = "Issue rewards for player referrals")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Referrer reward amount")]
    public int InviteReward { get; set; }
    [JsonProperty(PropertyName = "Referee reward amount")]
    public int JoinReward { get; set; }
}

private class StoredData
{
    [JsonProperty]
    internal Hash<string, UserData> _userData;
    [JsonProperty]
    internal HashSet<string> _referredUsers;
    public bool HasBeenReferred(string id);
    public void ReferPlayer(string referrer, string referree);
    public void OnUserConnected(IPlayer user);
    public void OnUserDisconnected(IPlayer user);
    public double GetPlayTimeForPlayer(string id);
    public double GetAFKTimeForPlayer(string id);
    public int GetReferralsForPlayer(string id);
    public void GetTopPlayTime(List<UserData> list);
    internal void InsertData(string id, string displayName, double playTime, double afkTime, double lastReward, int referrals);
    internal void InsertReferral(string id);
    public class UserData
    {
        public double playtime;
        public double afkTime;
        public double lastRewardTime;
        public int referrals;
        public string displayName;
        [JsonIgnore]
        private IPlayer _user;
        [JsonIgnore]
        private Timer _timer;
        [JsonIgnore]
        private double _timeStarted;
        [JsonIgnore]
        private GenericPosition _lastPosition;
        private const float TIMER_INTERVAL;
        public double PlayTime { get; set; }
        public double AFKTime { get; set; }
        public void OnUserConnected(IPlayer user);
        private void StartTimer();
        public void OnUserDisconnected();
        private void OnTimerTick();
        private bool EqualPosition(GenericPosition a, GenericPosition b);
    }

}

public class UserData
{
    public double playtime;
    public double afkTime;
    public double lastRewardTime;
    public int referrals;
    public string displayName;
    [JsonIgnore]
    private IPlayer _user;
    [JsonIgnore]
    private Timer _timer;
    [JsonIgnore]
    private double _timeStarted;
    [JsonIgnore]
    private GenericPosition _lastPosition;
    private const float TIMER_INTERVAL;
    public double PlayTime { get; set; }
    public double AFKTime { get; set; }
    public void OnUserConnected(IPlayer user);
    private void StartTimer();
    public void OnUserDisconnected();
    private void OnTimerTick();
    private bool EqualPosition(GenericPosition a, GenericPosition b);
}

private class PlayData
{
    public Dictionary<string, TimeInfo> timeData;
    public class TimeInfo
    {
        public double playTime;
        public double afkTime;
        public double lastReward;
        public int referrals;
    }

}

public class TimeInfo
{
    public double playTime;
    public double afkTime;
    public double lastReward;
    public int referrals;
}

private class PermData
{
    public Dictionary<string, float> permissions;
}

private class RefData
{
    public List<string> referrals;
}


```

---

## PluginUpdateNotifications by Whispers88 - Periodically checks uMod.org for newer versions of plugins and notifies

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.Networking;

Oxide.Plugins
[Info("Plugin Update Notifications", "Whispers88", "1.1.0")]
[Description("Checks Umod plugins for updates")]
public class PluginUpdateNotifications : CovalencePlugin
{
    private const string vurl;
    private IEnumerator coroutine;
    private List<string> mismatchedplugins;
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("Frequency to check for updates (hours)")]
        public float CheckFrequency;
        [JsonProperty("Ignore lower versions (ignores when the official version is a lower version number)")]
        public bool IgnoreLowVer;
        [JsonProperty("Check Unloaded Plugins")]
        public bool CheckUnloadedPlugins;
        [JsonProperty("Enable Discord Notifications")]
        public bool DiscordNotifications;
        [JsonProperty("Discord Webhook URL")]
        public string DiscordWebhookURL;
        [JsonProperty("Avatar URL")]
        public string AvatarUrl;
        [JsonProperty("Discord Username")]
        public string DiscordUsername;
        [JsonProperty("Automatic Blacklist")]
        public bool AutomaticBacklist;
        [JsonProperty("Blacklist of plugins names not to check", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlacklistedPlugins;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void CheckForUpdatesCommand(IPlayer iplayer, string command, string[] args);
     void OnServerInitialized();
    private void Unload();
    private IEnumerator CheckForUpdates();
    private string GetLang(string langKey, string playerId, object[] args);
    private Message DiscordMessage(string servername, string pluginname, string curversion, string umodversion, string umodchanges, string time);
    private static string StripMarkUp(string value);
    public class Datum
    {
        public string version { get; set; }
        public string description { get; set; }
        public int visible { get; set; }
        public string checksum { get; set; }
        public object tags { get; set; }
        public int downloads { get; set; }
        public string created_at { get; set; }
        public string description_md { get; set; }
        public string download_url { get; set; }
        public string revert_url { get; set; }
        public string toggle_url { get; set; }
        public string delete_url { get; set; }
        public string edit_url { get; set; }
        public bool is_latest { get; set; }
        public string text_class { get; set; }
        public bool revertable { get; set; }
        public string toggle_icon { get; set; }
        public string version_formatted { get; set; }
        public string downloads_shortened { get; set; }
        public string downloads_lang { get; set; }
        public DateTime created_at_atom { get; set; }
        public DateTime updated_at_atom { get; set; }
    }

    public class Root
    {
        public int current_page { get; set; }
        public List<Datum> data { get; set; }
        public string first_page_url { get; set; }
        public int from { get; set; }
        public int last_page { get; set; }
        public string last_page_url { get; set; }
        public object next_page_url { get; set; }
        public string path { get; set; }
        public int per_page { get; set; }
        public object prev_page_url { get; set; }
        public int to { get; set; }
        public int total { get; set; }
    }

    public class Message
    {
        public string username { get; set; }
        public string avatar_url { get; set; }
        public List<Embeds> embeds { get; set; }
        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline);
        }

        public class Footer
        {
            public string text { get; set; }
            public Footer(string text);
        }

        public class Embeds
        {
            public string title { get; set; }
            public string description { get; set; }
            public List<Fields> fields { get; set; }
            public Footer footer { get; set; }
            public Embeds(string title, string description, List<Fields> fields, Footer footer);
        }

        public Message(string username, string avatar_url, List<Embeds> embeds);
    }

    private void AddLocalizedCommand(string command);
    private bool HasPerm(string id, string perm);
}

public class Configuration
{
    [JsonProperty("Frequency to check for updates (hours)")]
    public float CheckFrequency;
    [JsonProperty("Ignore lower versions (ignores when the official version is a lower version number)")]
    public bool IgnoreLowVer;
    [JsonProperty("Check Unloaded Plugins")]
    public bool CheckUnloadedPlugins;
    [JsonProperty("Enable Discord Notifications")]
    public bool DiscordNotifications;
    [JsonProperty("Discord Webhook URL")]
    public string DiscordWebhookURL;
    [JsonProperty("Avatar URL")]
    public string AvatarUrl;
    [JsonProperty("Discord Username")]
    public string DiscordUsername;
    [JsonProperty("Automatic Blacklist")]
    public bool AutomaticBacklist;
    [JsonProperty("Blacklist of plugins names not to check", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlacklistedPlugins;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

public class Datum
{
    public string version { get; set; }
    public string description { get; set; }
    public int visible { get; set; }
    public string checksum { get; set; }
    public object tags { get; set; }
    public int downloads { get; set; }
    public string created_at { get; set; }
    public string description_md { get; set; }
    public string download_url { get; set; }
    public string revert_url { get; set; }
    public string toggle_url { get; set; }
    public string delete_url { get; set; }
    public string edit_url { get; set; }
    public bool is_latest { get; set; }
    public string text_class { get; set; }
    public bool revertable { get; set; }
    public string toggle_icon { get; set; }
    public string version_formatted { get; set; }
    public string downloads_shortened { get; set; }
    public string downloads_lang { get; set; }
    public DateTime created_at_atom { get; set; }
    public DateTime updated_at_atom { get; set; }
}

public class Root
{
    public int current_page { get; set; }
    public List<Datum> data { get; set; }
    public string first_page_url { get; set; }
    public int from { get; set; }
    public int last_page { get; set; }
    public string last_page_url { get; set; }
    public object next_page_url { get; set; }
    public string path { get; set; }
    public int per_page { get; set; }
    public object prev_page_url { get; set; }
    public int to { get; set; }
    public int total { get; set; }
}

public class Message
{
    public string username { get; set; }
    public string avatar_url { get; set; }
    public List<Embeds> embeds { get; set; }
    public class Fields
    {
        public string name { get; set; }
        public string value { get; set; }
        public bool inline { get; set; }
        public Fields(string name, string value, bool inline);
    }

    public class Footer
    {
        public string text { get; set; }
        public Footer(string text);
    }

    public class Embeds
    {
        public string title { get; set; }
        public string description { get; set; }
        public List<Fields> fields { get; set; }
        public Footer footer { get; set; }
        public Embeds(string title, string description, List<Fields> fields, Footer footer);
    }

    public Message(string username, string avatar_url, List<Embeds> embeds);
}

public class Fields
{
    public string name { get; set; }
    public string value { get; set; }
    public bool inline { get; set; }
    public Fields(string name, string value, bool inline);
}

public class Footer
{
    public string text { get; set; }
    public Footer(string text);
}

public class Embeds
{
    public string title { get; set; }
    public string description { get; set; }
    public List<Fields> fields { get; set; }
    public Footer footer { get; set; }
    public Embeds(string title, string description, List<Fields> fields, Footer footer);
}


```

---

## PoliceSedan by NotBad - Spawn a police sedan with police lights

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Network;
using Oxide.Core;
using System;

Oxide.Plugins
[Info("Police Sedan", "NotBad", "1.0.9")]
[Description("Spawn a police sedan with police lights")]
public class PoliceSedan : RustPlugin
{
    private StoredData storedData;
    public HashSet<uint> LightsON;
    public string bluelight;
    public string redlight;
    public string orangelight;
    public string strobelight;
    public string hornSound;
    public string buttonPrefab;
    private void Init();
    private void Unload();
     void OnButtonPress(PressButton button, BasePlayer player);
     void OnEntityMounted(BaseMountable entity, BasePlayer player);
    private void OnEntityKill(BaseNetworkable entity);
    public void CreateSiren(BasePlayer player);
     void MakeSiren(BaseVehicle vehicle, string entityToSpawn, Vector3 position);
     void SirenTurnONorOFF(BasePlayer player, BaseVehicle vehicle, bool turnON);
    [ChatCommand("policesedan")]
    private void CommandSpawnSedan(BasePlayer player, string cmd, string[] args);
    [ChatCommand("destroyps")]
    private void CommandDestroySedan(BasePlayer player, string cmd, string[] args);
    private TimeSpan CeilingTimeSpan(TimeSpan timeSpan);
    public class StoredData
    {
        public Dictionary<string, uint> sedan;
    }

    private ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Create Red Light")]
        public bool CreateRedLight;
        [JsonProperty(PropertyName = "Create Orange Light")]
        public bool CreateOrangeLight;
        [JsonProperty(PropertyName = "Blue Light Position")]
        public Vector3 BlueLightPosition;
        [JsonProperty(PropertyName = "Blue Light Position 2")]
        public Vector3 BlueLightPosition2;
        [JsonProperty(PropertyName = "Red Light Position")]
        public Vector3 RedLightPosition;
        [JsonProperty(PropertyName = "Strobe Light Position")]
        public Vector3 StrobeLightPosition;
        [JsonProperty(PropertyName = "Strobe Light Position 2")]
        public Vector3 StrobeLightPosition2;
        [JsonProperty(PropertyName = "Orange Light Position")]
        public Vector3 OrangeLightPosition;
        [JsonProperty(PropertyName = "Button Position")]
        public Vector3 ButtonPosition;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
}

public class StoredData
{
    public Dictionary<string, uint> sedan;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Create Red Light")]
    public bool CreateRedLight;
    [JsonProperty(PropertyName = "Create Orange Light")]
    public bool CreateOrangeLight;
    [JsonProperty(PropertyName = "Blue Light Position")]
    public Vector3 BlueLightPosition;
    [JsonProperty(PropertyName = "Blue Light Position 2")]
    public Vector3 BlueLightPosition2;
    [JsonProperty(PropertyName = "Red Light Position")]
    public Vector3 RedLightPosition;
    [JsonProperty(PropertyName = "Strobe Light Position")]
    public Vector3 StrobeLightPosition;
    [JsonProperty(PropertyName = "Strobe Light Position 2")]
    public Vector3 StrobeLightPosition2;
    [JsonProperty(PropertyName = "Orange Light Position")]
    public Vector3 OrangeLightPosition;
    [JsonProperty(PropertyName = "Button Position")]
    public Vector3 ButtonPosition;
}


```

---

## PoliticalSurvival by Pho3niX90 - Become the ruler, tax the server, and subjugate everyone

```csharp
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("PoliticalSurvival", "Pho3niX90", "0.9.15")]
[Description("Political Survival - Become the ruler, tax your subjects and keep them in line!")]
 class PoliticalSurvival : RustPlugin
{
     bool firstRun;
    public bool DebugMode;
     Ruler ruler;
    private PSConfig config;
    private Core.Libraries.Time _time;
    static PoliticalSurvival _instance;
    private List<Ruler> rulerList;
    private Dictionary<ulong, MapMarkerGenericRadius> _mapMarker;
    private VendingMachineMapMarker _mapMarkerVending;
    public class TaxSource
    {
        public bool DispenserGather;
        public bool CropGather;
        public bool DispenserBonus;
        public bool QuarryGather;
        public bool ExcavatorGather;
        public bool CollectiblePickup;
        public bool SurveyGather;
        public bool RecyclerScrap;
        public TaxSource createDefault();
    }

    public class Ruler
    {
        public Vector3 taxContainerVector3;
        public NetworkableId taxContainerID;
        public double tax;
        public ulong userId;
        public string displayName;
        public ulong rulerId;
        public uint rulerSince;
        public int resourcesGot;
        public string realm;
        public Ruler(Vector3 tcv4, NetworkableId txId, double tx, ulong rlr, string rlrname, string rlm, ulong rid);
        public Ruler();
        public int GetResourceCount();
        public Ruler SetRulerSince(uint since);
        public Ruler SetResourcesGot(int amnt);
        public long GetRulerSince();
        public Ruler SetTaxContainerVector3(Vector3 vec);
        public Vector3 GetTaxContainerVector3();
        public Ruler SetTaxContainerID(NetworkableId storage);
        public NetworkableId GetTaxContainerID();
        public Ruler SetTaxLevel(double tx);
        public double GetTaxLevel();
        public Ruler SetRuler(ulong rlr);
        public ulong GetRuler();
        public double GetRuleLengthInMinutes();
        public double GetRulerOfflineMinutes();
        public Ruler SetRulerName(string name);
        public string GetRulerName();
        public Ruler SetRealmName(string rlm);
        public string GetRealmName();
    }

    public int HeliLifeTimeMinutes;
    public float HeliBaseHealth;
    public float HeliSpeed;
    public float HeliSpeedMax;
    public int NumRockets;
    public float ScanFrequencySeconds;
    public float TargetVisible;
    public float MaxTargetRange;
    public bool NotifyPlayers;
    public BasePlayer target;
     class HeliComponent : FacepunchBehaviour
    {
        private BaseHelicopter heli;
        private PatrolHelicopterAI AI;
        private bool isFlying;
        private bool isRetiring;
         float timer;
         float timerAdd;
         void Awake();
         void FixedUpdate();
        internal void ScanForTargets();
         void UpdateAi();
         void UpdateTargets(BasePlayer Player);
        internal void attachGuns(PatrolHelicopterAI helicopter);
        internal void heliRetire();
        public void UnloadComponent();
         void OnDestroy();
    }

     Dictionary<string, string> serverMessages;
     int worldSize;
     BasePlayer currentRuler;
     uint rulerOfflineAt;
    private ILocator liveLocator;
    private ILocator locator;
    private bool Changed;
    protected Dictionary<string, Timer> Timers { get; set; }
     void Init();
    private void Loaded();
     void Unload();
     void OnPlayerConnected(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
     void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item);
     void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player);
    private void OnQuarryGather(MiningQuarry quarry, Item item);
    private void OnExcavatorGather(ExcavatorArm excavator, Item item);
    private void OnCollectiblePickup(Item item, BasePlayer player);
    private void OnSurveyGather(SurveyCharge surveyCharge, Item item);
    private int OnRecycleItemOutput(string itemName, int itemAmount);
     void AddToTaxContainer(Item item, string displayName, int netAmount);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    public void TryForceRuler();
    public bool TryForceNewRuler(bool force);
    [ChatCommand("fnr")]
     void TryForceRulerCmd(BasePlayer player, string command, string[] args);
    [ConsoleCommand("forcenewruler")]
     void TryForceNewRulerConsoleCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("heli")]
     void HeliCommmand(BasePlayer player, string command, string[] args);
    [ChatCommand("taxrange")]
     void AdmSetTaxChestCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("settaxchest")]
     void SetTaxChestCommand(BasePlayer player, string command, string[] arguments);
    [ChatCommand("tax")]
     void InfoCommand2(BasePlayer player, string command, string[] arguments);
    [ChatCommand("rinfo")]
     void InfoCommand(BasePlayer player, string command, string[] arguments);
    [ChatCommand("claimruler")]
     void ClaimRuler(BasePlayer player, string command, string[] arguments);
    [ChatCommand("settax")]
     void SetTaxCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("realmname")]
     void RealmNameCommand(BasePlayer player, string command, string[] arguments);
    [ChatCommand("rplayers")]
     void PlayersCommand(BasePlayer player, string command, string[] arguments);
     bool IsPlayerOnline(string partialNameOrID);
     bool IsChestSet();
     BasePlayer GetPlayer(string partialNameOrID);
     string MergeParams(int start, string[] paramz);
     bool IsRuler(ulong steamId);
    public bool CanAffordheliStrike(BasePlayer player);
    public void OrderheliStrike(BasePlayer playerToAttack);
     void SetRuler(BasePlayer bpruler);
     void SetTaxLevel(double newTaxLevel);
     void SetRealmName(string newName);
     StorageContainer FindStorageContainer(Vector3 position);
     StorageContainer FindStorageContainer(NetworkableId netid);
    public class RustIOLocator : ILocator
    {
        public RustIOLocator(int worldSize);
        private readonly float translate;
        private readonly float scale;
        private readonly float gridWidth;
        public string GridReference(Vector3 pos, bool moved);
    }

    public class LocatorWithDelay : ILocator
    {
        public LocatorWithDelay(ILocator liveLocator, int updateInterval);
        private readonly ILocator liveLocator;
        private readonly int updateInterval;
        private readonly Dictionary<Vector3, ExpiringCoordinates> locations;
        public string GridReference(Vector3 pos, bool moved);
         class ExpiringCoordinates
        {
            public string Location { get; set; }
            public bool GridChanged { get; set; }
            public DateTime Expires { get; set; }
        }

    }

    private MonumentInfo FindMonument(Vector3 pos);
     void UpdateMarker(BasePlayer ruler);
     void RemoveMarkers();
     void RemoveMarkersForce();
     void AdviseRulerPosition();
     BasePlayer GetRandomPlayer();
     void SaveRuler();
     void LoadRuler();
     void DebugLog(string msg);
     string GetMsg(string msg, string userId);
     void LoadServerMessages();
    private class PSConfig
    {
        public bool Debug;
        public bool showWelcomeMsg;
        public int maxHelis;
        public string heliItemCost;
        public int heliItemCostQty;
        public bool broadcastRulerPosition;
        public int broadcastRulerPositionEvery;
        public int broadcastRulerPositionAfterPercentage;
        public bool chooseNewRulerOnDisconnect;
        public int chooseNewRulerOnDisconnectMinutes;
        public int taxMin;
        public int taxMax;
        public ulong taxBoxSkinId;
        public int reasignAfterMinutes;
        public bool reasignOnAfk;
        public int worldSize;
        private PoliticalSurvival plugin;
        public PSConfig(PoliticalSurvival plugin);
        private void GetConfig(T variable, string[] path);
        private void SetConfig(T variable, string[] path);
    }

    protected override void LoadDefaultConfig();
}

public class TaxSource
{
    public bool DispenserGather;
    public bool CropGather;
    public bool DispenserBonus;
    public bool QuarryGather;
    public bool ExcavatorGather;
    public bool CollectiblePickup;
    public bool SurveyGather;
    public bool RecyclerScrap;
    public TaxSource createDefault();
}

public class Ruler
{
    public Vector3 taxContainerVector3;
    public NetworkableId taxContainerID;
    public double tax;
    public ulong userId;
    public string displayName;
    public ulong rulerId;
    public uint rulerSince;
    public int resourcesGot;
    public string realm;
    public Ruler(Vector3 tcv4, NetworkableId txId, double tx, ulong rlr, string rlrname, string rlm, ulong rid);
    public Ruler();
    public int GetResourceCount();
    public Ruler SetRulerSince(uint since);
    public Ruler SetResourcesGot(int amnt);
    public long GetRulerSince();
    public Ruler SetTaxContainerVector3(Vector3 vec);
    public Vector3 GetTaxContainerVector3();
    public Ruler SetTaxContainerID(NetworkableId storage);
    public NetworkableId GetTaxContainerID();
    public Ruler SetTaxLevel(double tx);
    public double GetTaxLevel();
    public Ruler SetRuler(ulong rlr);
    public ulong GetRuler();
    public double GetRuleLengthInMinutes();
    public double GetRulerOfflineMinutes();
    public Ruler SetRulerName(string name);
    public string GetRulerName();
    public Ruler SetRealmName(string rlm);
    public string GetRealmName();
}

 class HeliComponent : FacepunchBehaviour
{
    private BaseHelicopter heli;
    private PatrolHelicopterAI AI;
    private bool isFlying;
    private bool isRetiring;
     float timer;
     float timerAdd;
     void Awake();
     void FixedUpdate();
    internal void ScanForTargets();
     void UpdateAi();
     void UpdateTargets(BasePlayer Player);
    internal void attachGuns(PatrolHelicopterAI helicopter);
    internal void heliRetire();
    public void UnloadComponent();
     void OnDestroy();
}

public class RustIOLocator : ILocator
{
    public RustIOLocator(int worldSize);
    private readonly float translate;
    private readonly float scale;
    private readonly float gridWidth;
    public string GridReference(Vector3 pos, bool moved);
}

public class LocatorWithDelay : ILocator
{
    public LocatorWithDelay(ILocator liveLocator, int updateInterval);
    private readonly ILocator liveLocator;
    private readonly int updateInterval;
    private readonly Dictionary<Vector3, ExpiringCoordinates> locations;
    public string GridReference(Vector3 pos, bool moved);
     class ExpiringCoordinates
    {
        public string Location { get; set; }
        public bool GridChanged { get; set; }
        public DateTime Expires { get; set; }
    }

}

 class ExpiringCoordinates
{
    public string Location { get; set; }
    public bool GridChanged { get; set; }
    public DateTime Expires { get; set; }
}

private class PSConfig
{
    public bool Debug;
    public bool showWelcomeMsg;
    public int maxHelis;
    public string heliItemCost;
    public int heliItemCostQty;
    public bool broadcastRulerPosition;
    public int broadcastRulerPositionEvery;
    public int broadcastRulerPositionAfterPercentage;
    public bool chooseNewRulerOnDisconnect;
    public int chooseNewRulerOnDisconnectMinutes;
    public int taxMin;
    public int taxMax;
    public ulong taxBoxSkinId;
    public int reasignAfterMinutes;
    public bool reasignOnAfk;
    public int worldSize;
    private PoliticalSurvival plugin;
    public PSConfig(PoliticalSurvival plugin);
    private void GetConfig(T variable, string[] path);
    private void SetConfig(T variable, string[] path);
}


```

---

## Pollless by  - Allows players to vote on polls made by admin

```csharp
using Oxide.Core;
using System;
using Newtonsoft.Json;
using System.Collections.Generic;
using Rust;
using UnityEngine;
using System.Linq;

Oxide.Plugins
[Info("Pollless", "Kechless", "0.0.4")]
[Description("Players can vote for certain things.")]
 class Pollless : RustPlugin
{
    const string permission_create;
    const string permission_delete;
    const string permission_show;
    const string permission_vote;
    const string mainFolder;
    const string mainFile;
    protected override void LoadDefaultMessages();
    private void Init();
    [ChatCommand("poll")]
     void pollCommand(BasePlayer player, string command, string[] args);
    public void votePollByIndex(BasePlayer player, int index, string vote);
    public void getInfoPollByIndex(int index);
    public void votePoll(int index, Boolean voting, string playerID);
    public void UpdatePoll(Poll item, int index);
    public Poll getPollByindex(int index);
    public void deletePoll(int index);
    public void showPollList(BasePlayer player, int page);
    public void createPoll(string pollName, string content, string creator);
    public Boolean checkPollName(string pollName);
    public List<Poll> getPolls();
    public void updatePollList(List<Poll> list);
    public void addToPollList(Poll newPoll);
    public class Poll
    {
        private string _pollName;
        private string _content;
        private string _creator;
        private DateTime _dateOfCreation;
        private List<string> _yesVotes;
        private List<string> _noVotes;
        public string getPollName();
        public string getContent();
        public string getCreator();
        public void addYesVote(string playerID);
        public void addNoVote(string playerID);
        public bool hasVoted(string PlayerID);
        public Poll();
        [JsonConstructor]
        public Poll(string pollName, string content, string creator, DateTime date);
        override public string ToString();
    }

    public void SendMessage(BasePlayer player, string message);
    public void SendListMessage(BasePlayer player, List<string> list);
    public bool hasPerm(BasePlayer player, string perm);
}

public class Poll
{
    private string _pollName;
    private string _content;
    private string _creator;
    private DateTime _dateOfCreation;
    private List<string> _yesVotes;
    private List<string> _noVotes;
    public string getPollName();
    public string getContent();
    public string getCreator();
    public void addYesVote(string playerID);
    public void addNoVote(string playerID);
    public bool hasVoted(string PlayerID);
    public Poll();
    [JsonConstructor]
    public Poll(string pollName, string content, string creator, DateTime date);
    override public string ToString();
}


```

---

## PopupNotifications by k1lly0u - Popup notifications that can be created by admin and other plugins

```csharp
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Popup Notifications", "emu / k1lly0u", "0.2.0", ResourceId = 1252)]
public class PopupNotifications : RustPlugin
{
    private static PopupNotifications ins;
    const string popupPanel;
    private string panelColor;
    private string buttonColor;
    private string font;
    private int fontSize;
    private void OnServerInitialized();
    private void Unload();
    private Notifier GetPlayerNotifier(BasePlayer player);
    private void CreatePopupOnPlayer(string message, BasePlayer player, float duration);
    private void CreateGlobalPopup(string message, float duration);
    [HookMethod("CreatePopupNotification")]
    private void CreatePopupNotification(string message, BasePlayer player, float duration);
    private class Notifier : MonoBehaviour
    {
        private BasePlayer player;
        private List<string> openPanels;
        private List<MessageData> messageQueue;
        private Vector2 initialPos;
        private Vector2 dimensions;
        private int lastElementId;
        private int activeElements;
        private int maxElements;
        private void Awake();
        private void OnDestroy();
        public void PopupMessage(string message, float duration);
        private void UpdateMessages();
        private IEnumerator DestroyNotification(MessageData messageData);
        public void DestroyNotification(string elementId);
        private void AddUi(CuiElementContainer container, string elementId);
        private void DestroyUi(string elementId);
        private void ClearAllElements();
        private float[] GetFeedPosition(int number);
        private CuiElementContainer CreateNotification(MessageData messageData, int number);
        public class MessageData
        {
            public string message { get; set; }
            public string elementId { get; set; }
            public float duration { get; set; }
            public bool started { get; set; }
            public MessageData(string message, string elementId, float duration);
        }

    }

    static public class UI
    {
        static public CuiElementContainer Container(string panel, string aMin, string aMax);
        static public void Label(CuiElementContainer container, string panel, string text);
        static public void Button(CuiElementContainer container, string panel, string text, string command);
        static public string Color(string hexColor, float alpha);
    }

    [ChatCommand("popupmsg")]
    private void cmdSendPopupMessage(BasePlayer player, string command, string[] args);
    [ConsoleCommand("popupmsg.global")]
    private void ccmdPopupMessageGlobal(ConsoleSystem.Arg arg);
    [ConsoleCommand("popupmsg.toplayer")]
    private void ccmdPopupMessageToPlayer(ConsoleSystem.Arg arg);
    private object GetPlayerByName(string name);
    [ConsoleCommand("popupmsg.close")]
    private void ccmdCloseCommand(ConsoleSystem.Arg arg);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Notification duration (in seconds)")]
        public int Duration { get; set; }
        [JsonProperty(PropertyName = "Maximum notifications shown at any time")]
        public int MaximumMessages { get; set; }
        [JsonProperty(PropertyName = "UI Positioning")]
        public UIPosition Position { get; set; }
        [JsonProperty(PropertyName = "UI Options")]
        public UIOptions Options { get; set; }
        public class UIPosition
        {
            [JsonProperty(PropertyName = "Position of the left side of notification (0.0 - 1.0)")]
            public float PositionX { get; set; }
            [JsonProperty(PropertyName = "Position of the bottom of noticiation (0.0 - 1.0)")]
            public float PositionY { get; set; }
            [JsonProperty(PropertyName = "Width (0.0 - 1.0)")]
            public float Width { get; set; }
            [JsonProperty(PropertyName = "Height (0.0 - 1.0)")]
            public float Height { get; set; }
            [JsonProperty(PropertyName = "Space between notification (0.0 - 1.0)")]
            public float Spacing { get; set; }
        }

        public class UIOptions
        {
            [JsonProperty(PropertyName = "Show close button")]
            public bool Close { get; set; }
            [JsonProperty(PropertyName = "Panel color (hex)")]
            public string Color { get; set; }
            [JsonProperty(PropertyName = "Panel transparency (0.0 - 1.0)")]
            public float Alpha { get; set; }
            [JsonProperty(PropertyName = "Close button color (hex)")]
            public string CloseColor { get; set; }
            [JsonProperty(PropertyName = "Close button transparency (0.0 - 1.0)")]
            public float CloseAlpha { get; set; }
            [JsonProperty(PropertyName = "Font")]
            public string Font { get; set; }
            [JsonProperty(PropertyName = "Font size")]
            public int FontSize { get; set; }
        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private string msg(string key, string id);
     Dictionary<string, string> Messages;
}

private class Notifier : MonoBehaviour
{
    private BasePlayer player;
    private List<string> openPanels;
    private List<MessageData> messageQueue;
    private Vector2 initialPos;
    private Vector2 dimensions;
    private int lastElementId;
    private int activeElements;
    private int maxElements;
    private void Awake();
    private void OnDestroy();
    public void PopupMessage(string message, float duration);
    private void UpdateMessages();
    private IEnumerator DestroyNotification(MessageData messageData);
    public void DestroyNotification(string elementId);
    private void AddUi(CuiElementContainer container, string elementId);
    private void DestroyUi(string elementId);
    private void ClearAllElements();
    private float[] GetFeedPosition(int number);
    private CuiElementContainer CreateNotification(MessageData messageData, int number);
    public class MessageData
    {
        public string message { get; set; }
        public string elementId { get; set; }
        public float duration { get; set; }
        public bool started { get; set; }
        public MessageData(string message, string elementId, float duration);
    }

}

public class MessageData
{
    public string message { get; set; }
    public string elementId { get; set; }
    public float duration { get; set; }
    public bool started { get; set; }
    public MessageData(string message, string elementId, float duration);
}

static public class UI
{
    static public CuiElementContainer Container(string panel, string aMin, string aMax);
    static public void Label(CuiElementContainer container, string panel, string text);
    static public void Button(CuiElementContainer container, string panel, string text, string command);
    static public string Color(string hexColor, float alpha);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Notification duration (in seconds)")]
    public int Duration { get; set; }
    [JsonProperty(PropertyName = "Maximum notifications shown at any time")]
    public int MaximumMessages { get; set; }
    [JsonProperty(PropertyName = "UI Positioning")]
    public UIPosition Position { get; set; }
    [JsonProperty(PropertyName = "UI Options")]
    public UIOptions Options { get; set; }
    public class UIPosition
    {
        [JsonProperty(PropertyName = "Position of the left side of notification (0.0 - 1.0)")]
        public float PositionX { get; set; }
        [JsonProperty(PropertyName = "Position of the bottom of noticiation (0.0 - 1.0)")]
        public float PositionY { get; set; }
        [JsonProperty(PropertyName = "Width (0.0 - 1.0)")]
        public float Width { get; set; }
        [JsonProperty(PropertyName = "Height (0.0 - 1.0)")]
        public float Height { get; set; }
        [JsonProperty(PropertyName = "Space between notification (0.0 - 1.0)")]
        public float Spacing { get; set; }
    }

    public class UIOptions
    {
        [JsonProperty(PropertyName = "Show close button")]
        public bool Close { get; set; }
        [JsonProperty(PropertyName = "Panel color (hex)")]
        public string Color { get; set; }
        [JsonProperty(PropertyName = "Panel transparency (0.0 - 1.0)")]
        public float Alpha { get; set; }
        [JsonProperty(PropertyName = "Close button color (hex)")]
        public string CloseColor { get; set; }
        [JsonProperty(PropertyName = "Close button transparency (0.0 - 1.0)")]
        public float CloseAlpha { get; set; }
        [JsonProperty(PropertyName = "Font")]
        public string Font { get; set; }
        [JsonProperty(PropertyName = "Font size")]
        public int FontSize { get; set; }
    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class UIPosition
{
    [JsonProperty(PropertyName = "Position of the left side of notification (0.0 - 1.0)")]
    public float PositionX { get; set; }
    [JsonProperty(PropertyName = "Position of the bottom of noticiation (0.0 - 1.0)")]
    public float PositionY { get; set; }
    [JsonProperty(PropertyName = "Width (0.0 - 1.0)")]
    public float Width { get; set; }
    [JsonProperty(PropertyName = "Height (0.0 - 1.0)")]
    public float Height { get; set; }
    [JsonProperty(PropertyName = "Space between notification (0.0 - 1.0)")]
    public float Spacing { get; set; }
}

public class UIOptions
{
    [JsonProperty(PropertyName = "Show close button")]
    public bool Close { get; set; }
    [JsonProperty(PropertyName = "Panel color (hex)")]
    public string Color { get; set; }
    [JsonProperty(PropertyName = "Panel transparency (0.0 - 1.0)")]
    public float Alpha { get; set; }
    [JsonProperty(PropertyName = "Close button color (hex)")]
    public string CloseColor { get; set; }
    [JsonProperty(PropertyName = "Close button transparency (0.0 - 1.0)")]
    public float CloseAlpha { get; set; }
    [JsonProperty(PropertyName = "Font")]
    public string Font { get; set; }
    [JsonProperty(PropertyName = "Font size")]
    public int FontSize { get; set; }
}


```

---

## PortableVehicles by Paulsimik - Gives vehicles as item to players

```csharp
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using VLB;

Oxide.Plugins
[Info("Portable Vehicles", "Paulsimik", "1.1.9")]
[Description("Give vehicles as item to your players")]
public class PortableVehicles : RustPlugin
{
    private static Configuration config;
    private const string permUse;
    private const string permAdmin;
    private const string permPickup;
    private const string permFuel;
    private string[] chatCommands;
    private void Init();
    private void OnEntityBuilt(Planner plan, GameObject go);
    private object OnHammerHit(BasePlayer player, HitInfo info);
    private void CheckPlacement(Planner plan, GameObject go);
    private object CheckPickup(BasePlayer player, BaseVehicle entity);
    private object CheckPickupBalloon(BasePlayer player, HotAirBalloon balloon);
    private void GiveItem(BasePlayer player, ulong skin);
    private void GiveItem(BasePlayer player, VehicleEntry vehicle);
    private ulong GetSkin(string name);
    private void AddFuel(BasePlayer player, BaseVehicle baseVehicle);
    private void AddFuelBalloon(BasePlayer player, HotAirBalloon hotAirBalloon);
    private void cmdPortableVehicles(BasePlayer player, string command, string[] args);
    [ConsoleCommand("portablevehicles.give")]
    private void cmdGiveConsole(ConsoleSystem.Arg arg);
    private class Configuration
    {
        [JsonProperty(PropertyName = "Chat Icon")]
        public ulong chatIcon;
        [JsonProperty("Hits count to pickup vehicle")]
        public int hitsToPickup;
        [JsonProperty("Pickup any vehicles")]
        public bool pickupAnyVehicles;
        [JsonProperty("Pickup only your own vehicles")]
        public bool pickupOwnVehicles;
        [JsonProperty("Pickup require building priviledge")]
        public bool requireBuildingPrivilege;
        [JsonProperty("Automatically mount players")]
        public bool autoMount;
        [JsonProperty("Check storages before pickup")]
        public bool checkStorages;
        [JsonProperty("Need repair vehicles before pickup")]
        public bool needRepair;
        [JsonProperty(PropertyName = "Auto amount fuel to vehicle")]
        public int vehicleFuel;
        [JsonProperty(PropertyName = "Item shortname for water entity")]
        public string waterEntityShortName;
        [JsonProperty(PropertyName = "Item shortname for big models")]
        public string bigModelEntityShortName;
        [JsonProperty(PropertyName = "Item shortname for ground entity")]
        public string groundEntityShortName;
        [JsonProperty(PropertyName = "Blacklist pickupable vehicles shortname")]
        public List<string> pickupableBlacklist;
        public VersionNumber version;
    }

    private class VehicleEntry
    {
        public ulong skinId;
        public string displayName;
        public string prefab;
        public bool bigModel;
        public bool isWaterVehicle;
    }

    private VehicleEntry[] AllVehicles;
    private class PickupScript : MonoBehaviour
    {
        private BaseEntity entity;
        private int hits;
        private void Awake();
        public void AddHit();
        private void ResetHits();
        public int GetHitsLeft();
    }

    private Configuration GetDefaultConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadConfig();
    private void UpdateConfig();
    private string GetLang(string key, string playerID, object[] args);
    protected override void LoadDefaultMessages();
    private bool IsAdmin(BasePlayer player);
    private BasePlayer FindPlayer(ConsoleSystem.Arg arg, string nameOrID);
    private BasePlayer FindPlayer(BasePlayer player, string nameOrID);
    private void Message(ConsoleSystem.Arg arg, string messageKey, object[] args);
    private void Message(BasePlayer player, string messageKey, object[] args);
    private void SendMessage(BasePlayer player, string msg);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Chat Icon")]
    public ulong chatIcon;
    [JsonProperty("Hits count to pickup vehicle")]
    public int hitsToPickup;
    [JsonProperty("Pickup any vehicles")]
    public bool pickupAnyVehicles;
    [JsonProperty("Pickup only your own vehicles")]
    public bool pickupOwnVehicles;
    [JsonProperty("Pickup require building priviledge")]
    public bool requireBuildingPrivilege;
    [JsonProperty("Automatically mount players")]
    public bool autoMount;
    [JsonProperty("Check storages before pickup")]
    public bool checkStorages;
    [JsonProperty("Need repair vehicles before pickup")]
    public bool needRepair;
    [JsonProperty(PropertyName = "Auto amount fuel to vehicle")]
    public int vehicleFuel;
    [JsonProperty(PropertyName = "Item shortname for water entity")]
    public string waterEntityShortName;
    [JsonProperty(PropertyName = "Item shortname for big models")]
    public string bigModelEntityShortName;
    [JsonProperty(PropertyName = "Item shortname for ground entity")]
    public string groundEntityShortName;
    [JsonProperty(PropertyName = "Blacklist pickupable vehicles shortname")]
    public List<string> pickupableBlacklist;
    public VersionNumber version;
}

private class VehicleEntry
{
    public ulong skinId;
    public string displayName;
    public string prefab;
    public bool bigModel;
    public bool isWaterVehicle;
}

private class PickupScript : MonoBehaviour
{
    private BaseEntity entity;
    private int hits;
    private void Awake();
    public void AddHit();
    private void ResetHits();
    public int GetHitsLeft();
}


```

---

## Portals by LaserHydra - Create portals allowing players to walk through to another location

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Collections;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Portals", "LaserHydra", "3.1.0")]
[Description("Allows to place Portals which you can step into to teleport")]
public class Portals : RustPlugin
{
    private const int PortalLayer;
    private const string UsagePermission;
    private const string AdminPermission;
    private Configuration _config;
    private static Portals _instance;
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    [ChatCommand("portal")]
    private void PortalCommand(BasePlayer player, string cmd, string[] args);
    private static void SendMessage(BasePlayer player, string key, object[] args);
    private static PortalPointBehaviour GetPortalPointInView(BasePlayer player);
    private static void Teleport(BasePlayer player, Vector3 destination);
    protected override void LoadDefaultMessages();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class Configuration
    {
        [JsonProperty("Sphere Radius")]
        public float SphereRadius { get; set; }
        [JsonProperty("Sphere Density (Enterable)")]
        public ushort SphereEntityCount { get; set; }
        [JsonProperty("Sphere Density (Not Enterable)")]
        public ushort ExitSphereEntityCount { get; set; }
        public HashSet<Portal> Portals { get; set; }
    }

    private class PlayerTeleporter : MonoBehaviour
    {
        public BasePlayer Player { get; set; }
        public bool IsRunning { get; set; }
        public Vector3 Destination { get; set; }
        public int Seconds { get; set; }
        public bool ReachedDestination { get; set; }
        public void Start();
        public void Stop();
        public void Remove();
        private void Awake();
        private IEnumerator Teleport();
    }

    private class PortalPointBehaviour : MonoBehaviour
    {
        private SphereEntity[] _sphereEntities;
        public Portal Portal { get; set; }
        public Portal.PointType PointType { get; set; }
        public Vector3 Position { get; set; }
        private bool _isEnterable;
        private Portal.PointType _opposingPointType;
        private float _radius;
        private ushort _sphereEntityCount;
        private void Awake();
        private void SpawnSphereEntities();
        private void OnTriggerEnter(Collider collider);
        private void OnTriggerExit(Collider collider);
        private void Teleport(BasePlayer player, Vector3 destination);
        public void Destroy();
        public static PortalPointBehaviour Create(Portal portal, Portal.PointType pointType, Vector3 position);
    }

    private class Portal
    {
        private readonly List<PortalPointBehaviour> _portalPoints;
        public string Name { get; set; }
        public bool IsOneWay { get; set; }
        public bool RequiresIndiviualPermission { get; set; }
        public int TeleportationTime { get; set; }
        public List<Vector3> Entrances { get; set; }
        public List<Vector3> Exits { get; set; }
        public bool HasPermission(BasePlayer player);
        public string GetUsagePermission();
        public void Spawn();
        public void Destroy();
        public void RemovePoint(Vector3 position);
        public void RemovePointsOfType(PointType pointType);
        public Vector3? GetRandomPoint(PointType pointType);
        private void DestroyPointBehaviour(Vector3 position);
    }

}

private class Configuration
{
    [JsonProperty("Sphere Radius")]
    public float SphereRadius { get; set; }
    [JsonProperty("Sphere Density (Enterable)")]
    public ushort SphereEntityCount { get; set; }
    [JsonProperty("Sphere Density (Not Enterable)")]
    public ushort ExitSphereEntityCount { get; set; }
    public HashSet<Portal> Portals { get; set; }
}

private class PlayerTeleporter : MonoBehaviour
{
    public BasePlayer Player { get; set; }
    public bool IsRunning { get; set; }
    public Vector3 Destination { get; set; }
    public int Seconds { get; set; }
    public bool ReachedDestination { get; set; }
    public void Start();
    public void Stop();
    public void Remove();
    private void Awake();
    private IEnumerator Teleport();
}

private class PortalPointBehaviour : MonoBehaviour
{
    private SphereEntity[] _sphereEntities;
    public Portal Portal { get; set; }
    public Portal.PointType PointType { get; set; }
    public Vector3 Position { get; set; }
    private bool _isEnterable;
    private Portal.PointType _opposingPointType;
    private float _radius;
    private ushort _sphereEntityCount;
    private void Awake();
    private void SpawnSphereEntities();
    private void OnTriggerEnter(Collider collider);
    private void OnTriggerExit(Collider collider);
    private void Teleport(BasePlayer player, Vector3 destination);
    public void Destroy();
    public static PortalPointBehaviour Create(Portal portal, Portal.PointType pointType, Vector3 position);
}

private class Portal
{
    private readonly List<PortalPointBehaviour> _portalPoints;
    public string Name { get; set; }
    public bool IsOneWay { get; set; }
    public bool RequiresIndiviualPermission { get; set; }
    public int TeleportationTime { get; set; }
    public List<Vector3> Entrances { get; set; }
    public List<Vector3> Exits { get; set; }
    public bool HasPermission(BasePlayer player);
    public string GetUsagePermission();
    public void Spawn();
    public void Destroy();
    public void RemovePoint(Vector3 position);
    public void RemovePointsOfType(PointType pointType);
    public Vector3? GetRandomPoint(PointType pointType);
    private void DestroyPointBehaviour(Vector3 position);
}


```

---

## PortForward by MrBlue - Automatic port forwarding for DD-WRT routers

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Text;

Oxide.Plugins
[Info("Port Forward", "Wulf/lukespragg", "0.0.1")]
[Description("Automatic port forwarding for DD-WRT routers")]
public class PortForward : CovalencePlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "DD-WRT username (default is root)")]
        public string Username { get; set; }
        [JsonProperty(PropertyName = "DD-WRT password (default is admin)")]
        public string Password { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private static Dictionary<string, string> headers;
    private static IPAddress localIp;
    private static IPAddress routerIp;
    private void OnServerInitialized();
    private void Unload();
    [Command("pf.net")]
    private void NetCommand(IPlayer player, string command, string[] args);
    [Command("pf.toggle")]
    private void ToggleCommand(IPlayer player, string command, string[] args);
    private void ToggleForward(string state);
    private static IPAddress GetGateway();
    private static IPAddress GetLocalIp();
}

public class Configuration
{
    [JsonProperty(PropertyName = "DD-WRT username (default is root)")]
    public string Username { get; set; }
    [JsonProperty(PropertyName = "DD-WRT password (default is admin)")]
    public string Password { get; set; }
}


```

---

## Portgun by MrBlue - Teleports player to object or terrain they are looking at

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Portgun", "Wulf/lukespragg", "3.3.2")]
[Description("Teleports players with permission to object or terrain they are looking at")]
public class Portgun : CovalencePlugin
{
    private new void LoadDefaultMessages();
    private readonly HashSet<string> protection;
    private const string permUse;
    private float mapSize;
    private int layers;
    private void OnServerInitialized();
    private void PortCommand(IPlayer player, string command, string[] args);
    private bool IsValidMapCoordinates(float x, float y, float z);
    private void AddLocalizedCommand(string key, string command);
    private string Lang(string key, string id, object[] args);
}


```

---

## PoundBot by MrPoundsign - A connector for the PoundBot Discord bot

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Pound Bot", "MrPoundsign", "2.0.1")]
[Description("Connector for the Discord bot PoundBot.")]
 class PoundBot : CovalencePlugin
{
    const string EntityDeathURI;
    const string ApiMessageBaseURI;
    const string ApiRolesURI;
    const string ApiChatURI;
    const string ApiRegisteredPlayersURI;
    const string ApiDiscordAuthURI;
    const string ApiClansURI;
    private string ApiBaseURI;
    protected string DebugURI;
    protected int DebugLevel;
    protected int ApiRetrySeconds;
    protected int ApiRetryNotify;
    protected string RegisteredUsersGroup;
    protected bool ApiInError;
    protected bool ApiRetry;
    protected uint ApiRetryAttempts;
    protected DateTime ApiErrorTime;
    protected DateTime LastApiAttempt;
    private Dictionary<string, string> RequestHeaders;
    protected bool RegisteredUsersInFlight;
    private ChannelList KnownChannelList;
     class ApiErrorResponse
    {
        public string Error;
    }

     class ApiRequest
    {
        public RequestMethod Method;
        public string URI;
        public string Body;
        public Plugin Plugin;
        public string RequestUUID;
        public ApiRequest(RequestMethod method, string uri, string body, Plugin plugin);
    }

     class Channel
    {
        public string ID;
        public string Name;
        public bool CanSend;
        public bool CanStyle;
        public bool IsAvailable();
    }

     class ChannelList
    {
        public Channel[] Channels;
        public bool CanSendTo(string channel);
        public bool CanStyleTo(string channel);
    }

     class DiscordAuth
    {
        public string PlayerID;
        public string DisplayName;
        public string ClanTag;
        public string DiscordName;
        public int Pin;
        public DateTime CreatedAt;
        public DiscordAuth(string displayName, string discordName, string playerid);
    }

    public class GameMessageEmbedStyle
    {
        public string Color { get; set; }
    }

     class GameMessagePart
    {
        public string Content { get; set; }
        public bool Escape { get; set; }
    }

     class GameMessage
    {
        public GameMessagePart[] MessageParts { get; set; }
        public int Type { get; set; }
        public GameMessageEmbedStyle EmbedStyle { get; set; }
    }

     class RoleSyncRequest
    {
        public string GuildID;
        public string[] PlayerIDs;
    }

     class EntityDeath
    {
        public string Name;
        public string GridPos;
        public string[] OwnerIDs;
        public DateTime CreatedAt;
        public EntityDeath(string name, string gridpos, string[] ownerIDs);
    }

    protected override void LoadDefaultConfig();
     void UpgradeConfig();
    protected override void LoadDefaultMessages();
     void Init();
    private void ApplyConfig();
    private string API_RegisteredUsersGroup();
    private string ApiBase();
    private bool ApiRequestOk();
    private void ApiError(int code, string response, string requestID);
    private bool ApiSuccess(bool success);
    private bool Request(ApiRequest api_request, Func<int, string, bool> callback);
    private bool API_Request(string uri, string body, Func<int, string, bool> callback, Plugin owner, RequestMethod method, Dictionary<string, string> headers);
    private bool API_SendChannelMessage(Plugin owner, string channel, KeyValuePair<string, bool>[] message_parts, string embed_color, Func<int, string, bool> callback, Dictionary<string, string> headers, string type);
    private bool API_GetChannelMessage(Plugin owner, string channel, Func<int, string, bool> callback);
    private bool API_SendRole(Plugin owner, string[] groupPlayerIDs, string role, Func<int, string, bool> callback);
    private bool API_SendEntityDeath(Plugin owner, string name, string gridPos, string[] owners, Func<int, string, bool> callback);
    private bool API_SendClans(Plugin owner, List<JObject> clans, Func<int, string, bool> callback);
    private bool API_SendClan(Plugin owner, string tag, JObject clan, Func<int, string, bool> callback);
    private bool API_DeleteClan(Plugin owner, string tag, Func<int, string, bool> callback);
    private void Connected();
    private void UpdateChannels();
    public void PrintChannels(bool all);
    private void AddLocalizedCommand(string key, string command);
    private void CommandPoundBotRegister(IPlayer player, string command, string[] args);
    [Command("pb.update_channels")]
    private void ConsoleCommandUpdateChannels(IPlayer player, string command, string[] args);
    [Command("pb.channels")]
    private void ConsoleCommandChannels(IPlayer player, string command, string[] args);
    [Command("pb.set_api_key")]
    private void ConsoleCommandSetAPIKey(IPlayer player, string command, string[] args);
    [Command("pb.set_debug_uri")]
    private void ConsoleCommandSetDebugURI(IPlayer player, string command, string[] args);
}

 class ApiErrorResponse
{
    public string Error;
}

 class ApiRequest
{
    public RequestMethod Method;
    public string URI;
    public string Body;
    public Plugin Plugin;
    public string RequestUUID;
    public ApiRequest(RequestMethod method, string uri, string body, Plugin plugin);
}

 class Channel
{
    public string ID;
    public string Name;
    public bool CanSend;
    public bool CanStyle;
    public bool IsAvailable();
}

 class ChannelList
{
    public Channel[] Channels;
    public bool CanSendTo(string channel);
    public bool CanStyleTo(string channel);
}

 class DiscordAuth
{
    public string PlayerID;
    public string DisplayName;
    public string ClanTag;
    public string DiscordName;
    public int Pin;
    public DateTime CreatedAt;
    public DiscordAuth(string displayName, string discordName, string playerid);
}

public class GameMessageEmbedStyle
{
    public string Color { get; set; }
}

 class GameMessagePart
{
    public string Content { get; set; }
    public bool Escape { get; set; }
}

 class GameMessage
{
    public GameMessagePart[] MessageParts { get; set; }
    public int Type { get; set; }
    public GameMessageEmbedStyle EmbedStyle { get; set; }
}

 class RoleSyncRequest
{
    public string GuildID;
    public string[] PlayerIDs;
}

 class EntityDeath
{
    public string Name;
    public string GridPos;
    public string[] OwnerIDs;
    public DateTime CreatedAt;
    public EntityDeath(string name, string gridpos, string[] ownerIDs);
}


```

---

## PoundBotChatRelay by MrPoundsign - Bidirectional Discord chat for use with PoundBot

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Pound Bot Chat Relay", "MrPoundsign", "2.0.3")]
[Description("Chat relay for use with PoundBot")]
 class PoundBotChatRelay : CovalencePlugin
{
    [PluginReference]
    private Plugin PoundBot;
    private Plugin Clans;
    protected int ApiChatRunnersCount;
    private bool RelayDiscordChat;
    private bool RelayGiveNotices;
    private bool RelayServerChat;
    private bool UseBetterChat;
    private string RelayChatChannel;
    private string RelayChatColor;
    private string RelayServerChatColor;
    private string RelayServerChannel;
     class ChatMessage
    {
        public string ClanTag { get; set; }
        public string DisplayName { get; set; }
        public string Message { get; set; }
    }

     class ChatRunner
    {
        public string ID { get; set; }
        public DateTime LastRun { get; set; }
        public bool Running { get; set; }
        public bool LastStartOK { get; set; }
        public Timer Timer { get; set; }
        public ChatRunner();
    }

    private List<ChatRunner> ChatRunners;
    protected override void LoadDefaultConfig();
     void UpgradeConfig();
    protected override void LoadDefaultMessages();
     void OnServerInitialized();
     void ApplyConfig();
     void Unload();
     void KillChatRunners();
     void StartChatRunners();
     void RestartChatRunner(string id);
    private ChatRunner StartChatRunner();
     void OnServerMessage(string message, string name);
     void OnUserChat(IPlayer player, string message);
     void OnBetterChat(Dictionary<string, object> data);
     void SendToPoundBot(IPlayer player, string message, string channel, string embed_color);
     void SendToPoundBot(string player, string message, string channel, string embed_color);
    [Command("pb.chat_config")]
    private void ConsoleCommandSetChatConfig(IPlayer player, string command, string[] args);
}

 class ChatMessage
{
    public string ClanTag { get; set; }
    public string DisplayName { get; set; }
    public string Message { get; set; }
}

 class ChatRunner
{
    public string ID { get; set; }
    public DateTime LastRun { get; set; }
    public bool Running { get; set; }
    public bool LastStartOK { get; set; }
    public Timer Timer { get; set; }
    public ChatRunner();
}


```

---

## PoundBotClans by MrPoundsign - Clans integration for PoundBot

```csharp
using System.Collections.Generic;
using System;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Pound Bot Clans", "MrPoundsign", "2.0.1")]
[Description("Clans support for PoundBot")]
 class PoundBotClans : CovalencePlugin
{
    [PluginReference]
    private Plugin PoundBot;
    private Plugin Clans;
    protected override void LoadDefaultMessages();
     void OnServerInitialized();
    private bool AcceptedHandler(int code, string response);
     void SendClans();
     void OnClanCreate(string tag);
     void OnClanUpdate(string tag);
     void OnClanDestroy(string tag);
     void OnPoundBotConnected();
}


```

---

## PoundBotRaidAlerts by MrPoundsign - Discord Raid Alerts for use with PoundBot

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Pound Bot Raid Alerts", "MrPoundsign", "2.0.4")]
[Description("Raid Alerts for use with PoundBot")]
 class PoundBotRaidAlerts : CovalencePlugin
{
    [PluginReference]
    private Plugin PoundBot;
    private bool ShowOwnDamage;
    private bool PermittedOnly;
    const string RaidAlertsPermission;
    const string RaidAlertsTestPermission;
    protected override void LoadDefaultMessages();
    private void Init();
     void OnServerInitialized();
    protected override void LoadDefaultConfig();
    private void ApplyConfig();
     void UpgradeConfig();
     void OnEntityDeath(BaseEntity victim, HitInfo info);
     void SendEntityDeath(BaseEntity entity, BaseEntity initiator, bool test);
    private bool EntityDeathHandler(int code, string response);
    private string GridPos(BaseEntity entity);
    public string NumberToLetter(int num);
    private void AddLocalizedCommand(string key, string command, string perm);
    private void CommandRaidAlertsTest(IPlayer iplayer, string command, string[] args);
    [Command("pb.ra.show_own_damage")]
    private void ConsoleCommandShowOwnDamage(IPlayer player, string command, string[] args);
    [Command("pb.ra.permitted_only")]
    private void ConsoleCommandPermittedOnly(IPlayer player, string command, string[] args);
}


```

---

## PowerlessElectronics by WhiteThunder - Allows electrical entities to generate their own power when not plugged in

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Powerless Electronics", "WhiteThunder", "1.2.5")]
[Description("Allows electrical entities to generate their own power when not plugged in.")]
internal class PowerlessElectronics : CovalencePlugin
{
    private const string PermissionAll;
    private const string PermissionEntityFormat;
    private Configuration _config;
    private void Init();
    private void OnServerInitialized();
    private void OnEntitySpawned(IOEntity ioEntity);
    private void OnIORefCleared(IOEntity.IORef ioRef, IOEntity ioEntity);
    private static bool InputUpdateWasBlocked(IOEntity ioEntity, int inputSlot, int amount);
    private static bool IsHybridIOEntity(IOEntity ioEntity);
    private static BaseEntity GetOwnerEntity(IOEntity ioEntity);
    private static bool ShouldIgnoreEntity(IOEntity ioEntity);
    private static void MaybeProvidePower(IOEntity ioEntity, EntityConfig entityConfig);
    private static T GetChildEntity(BaseEntity entity);
    private static bool HasConnectedInput(IOEntity ioEntity, int inputSlot);
    private static void TryProvidePower(IOEntity ioEntity, int inputSlot, int powerAmount);
    private void ProcessIOEntity(IOEntity ioEntity, bool delay);
    private bool EntityOwnerHasPermission(IOEntity ioEntity, EntityConfig entityConfig);
    private EntityConfig GetEntityConfig(IOEntity ioEntity);
    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : BaseConfiguration
    {
        private static readonly string[] IgnoredEntities;
        private static bool HasElectricalInput(IOEntity ioEntity);
        [JsonProperty("Entities")]
        public Dictionary<string, EntityConfig> Entities;
        public List<string> AddMissingPrefabs();
        public void GeneratePermissionNames();
        private void SortEntities();
    }

    [JsonObject(MemberSerialization.OptIn)]
    internal class EntityConfig
    {
        private static readonly int[] StandardInputSlot;
        [JsonProperty("RequirePermission")]
        public bool RequirePermission;
        [JsonProperty("InputSlots")]
        public int[] InputSlots;
        public bool ShouldSerializeInputSlots();
        [JsonProperty("PowerAmount")]
        public int PowerAmount;
        public bool ShouldSerializePowerAmount();
        [JsonProperty("PowerAmounts", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int[] PowerAmounts;
        public string PermissionName;
        public bool Enabled { get; set; }
        public int GetPowerForSlot(int slotNumber);
    }

    private Configuration GetDefaultConfig();
    [JsonObject(MemberSerialization.OptIn)]
    private class BaseConfiguration
    {
        public bool UsingDefaults;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : BaseConfiguration
{
    private static readonly string[] IgnoredEntities;
    private static bool HasElectricalInput(IOEntity ioEntity);
    [JsonProperty("Entities")]
    public Dictionary<string, EntityConfig> Entities;
    public List<string> AddMissingPrefabs();
    public void GeneratePermissionNames();
    private void SortEntities();
}

[JsonObject(MemberSerialization.OptIn)]
internal class EntityConfig
{
    private static readonly int[] StandardInputSlot;
    [JsonProperty("RequirePermission")]
    public bool RequirePermission;
    [JsonProperty("InputSlots")]
    public int[] InputSlots;
    public bool ShouldSerializeInputSlots();
    [JsonProperty("PowerAmount")]
    public int PowerAmount;
    public bool ShouldSerializePowerAmount();
    [JsonProperty("PowerAmounts", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public int[] PowerAmounts;
    public string PermissionName;
    public bool Enabled { get; set; }
    public int GetPowerForSlot(int slotNumber);
}

[JsonObject(MemberSerialization.OptIn)]
private class BaseConfiguration
{
    public bool UsingDefaults;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## PowerlessTurrets by August - Allows SAMs and autoturrets to operate without electricity

```csharp
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Powerless Turrets", "August", "3.2.9")]
[Description("Allows SAMs and autoturrets to operate without electricity")]
public class PowerlessTurrets : RustPlugin
{
    private const string PermUse;
    private const string PermUseRadius;
    private const string PermUseSamRadius;
    private static PowerlessTurrets _instance;
    private TurretManager _turretManager;
    private PluginConfig _config;
    private PluginData _stored;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Range at which turrets can be toggled")]
        public float Range { get; set; }
        [JsonProperty(PropertyName = "Command for toggling individual turrets")]
        public string ToggleCommand { get; set; }
        [JsonProperty(PropertyName = "Command for toggling turrets in TC zone")]
        public string ToggleTcCommand { get; set; }
        [JsonProperty(PropertyName = "Command for toggling sams in TC zone")]
        public string ToggleSamTcCommand { get; set; }
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private PluginConfig GetDefaultConfig();
    private class PluginData
    {
        public List<ulong> AutoTurrets;
        public List<ulong> SamSites;
    }

    private void SaveData();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnServerSave();
    private void TurretCommand(BasePlayer player);
    private void ToggleTurretsInTc(BasePlayer player, string command, string[] args);
    private void ToggleSamsInTc(BasePlayer player, string command, string[] args);
    private class TurretManager
    {
        private readonly List<AutoTurret> _onlineTurrets;
        public List<ulong> OnlineTurrets { get; set; }
        public void ToggleTurret(AutoTurret turret, BasePlayer player);
        public void PowerTurretOn(AutoTurret turret);
        private void PowerTurretOff(AutoTurret turret);
        public void ToggleTurretsInTcRange(BasePlayer player, string arg);
        private readonly List<SamSite> _onlineSams;
        public List<ulong> OnlineSams { get; set; }
        public void ToggleSamsite(SamSite samSite, BasePlayer player);
        public void PowerSamsiteOn(SamSite sam);
        private void PowerSamsiteOff(SamSite sam);
        public void ToggleSamsInTcRange(BasePlayer player, string arg);
    }

}

private class PluginConfig
{
    [JsonProperty(PropertyName = "Range at which turrets can be toggled")]
    public float Range { get; set; }
    [JsonProperty(PropertyName = "Command for toggling individual turrets")]
    public string ToggleCommand { get; set; }
    [JsonProperty(PropertyName = "Command for toggling turrets in TC zone")]
    public string ToggleTcCommand { get; set; }
    [JsonProperty(PropertyName = "Command for toggling sams in TC zone")]
    public string ToggleSamTcCommand { get; set; }
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class PluginData
{
    public List<ulong> AutoTurrets;
    public List<ulong> SamSites;
}

private class TurretManager
{
    private readonly List<AutoTurret> _onlineTurrets;
    public List<ulong> OnlineTurrets { get; set; }
    public void ToggleTurret(AutoTurret turret, BasePlayer player);
    public void PowerTurretOn(AutoTurret turret);
    private void PowerTurretOff(AutoTurret turret);
    public void ToggleTurretsInTcRange(BasePlayer player, string arg);
    private readonly List<SamSite> _onlineSams;
    public List<ulong> OnlineSams { get; set; }
    public void ToggleSamsite(SamSite samSite, BasePlayer player);
    public void PowerSamsiteOn(SamSite sam);
    private void PowerSamsiteOff(SamSite sam);
    public void ToggleSamsInTcRange(BasePlayer player, string arg);
}


```

---

## PowerSpawn by misticos - Powerful position generation tool with API

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;
using Random = System.Random;

[Info("Power Spawn", "misticos", "1.4.0")]
[Description("Powerful position generation tool with API")]
internal class PowerSpawn : CovalencePlugin
{
    private static PowerSpawn _ins;
    private readonly Random _random;
    private int _halfWorldSize;
    private const string PermissionLocation;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty("Profiles", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, Profile> Profiles { get; set; }
        [JsonProperty("Respawn Configurations", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<RespawnConfiguration> RespawnConfigurations { get; set; }
        [JsonProperty("Respawn Profile", NullValueHandling = NullValueHandling.Ignore)]
        public string RespawnProfileName { get; set; }
        [JsonProperty("Respawn Locations Group", NullValueHandling = NullValueHandling.Ignore)]
        public int? RespawnGroup { get; set; }
        [JsonProperty("Enable Respawn Locations Group", NullValueHandling = NullValueHandling.Ignore)]
        public bool? EnableRespawnGroup { get; set; }
        [JsonProperty("Enable Respawn Management")]
        public bool EnableRespawn { get; set; }
        [JsonProperty("Location Management Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] LocationCommand { get; set; }
        public class RespawnConfiguration
        {
            [JsonProperty("Permission")]
            public string Permission { get; set; }
            [JsonProperty("Profile Name")]
            public string ProfileName { get; set; }
            [JsonProperty("Locations Group")]
            public int? Group { get; set; }
            [JsonIgnore]
            public Profile Profile;
        }

        public class Profile
        {
            [JsonProperty("Minimal Distance To Building")]
            public int DistanceBuilding { get; set; }
            [JsonProperty("Minimal Distance To Collider")]
            public int DistanceCollider { get; set; }
            [JsonProperty("Raycast Distance Above")]
            public float DistanceRaycast { get; set; }
            [JsonProperty("Number Of Attempts To Find A Position Per Frame")]
            public int AttemptsPerFrame { get; set; }
            [JsonProperty("Number Of Positions Per Frame")]
            public int PositionsPerFrame { get; set; }
            [JsonProperty("Number Of Attempts To Find A Pregenerated Position")]
            public int AttemptsPregenerated { get; set; }
            [JsonProperty("Pregenerated Positions Amount")]
            public int PregeneratedAmount { get; set; }
            [JsonProperty("Pregenerated Amount Check Frequency (Seconds)")]
            public float PregeneratedCheck { get; set; }
            [JsonProperty("Biomes Threshold", NullValueHandling = NullValueHandling.Ignore)]
            public Dictionary<TerrainBiome.Enum, float> BiomesThresholdOld { get; set; }
            [JsonProperty("Biomes Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMinimum { get; set; }
            [JsonProperty("Biomes Maximum Threshold",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMaximum { get; set; }
            [JsonProperty("Biomes Allowed",
                ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainBiome.Enum> BiomesAllowed { get; set; }
            [JsonProperty("Biomes Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainBiome.Enum> BiomesBlocked { get; set; }
            [JsonProperty("Splat Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainSplat.Enum, float> SplatThresholdMinimum { get; set; }
            [JsonProperty("Splat Maximum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<TerrainSplat.Enum, float> SplatThresholdMaximum { get; set; }
            [JsonProperty("Splat Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainSplat.Enum> SplatAllowed { get; set; }
            [JsonProperty("Splat Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainSplat.Enum> SplatBlocked { get; set; }
            [JsonProperty("Topologies Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainTopology.Enum> TopologiesAllowed { get; set; }
            [JsonProperty("Topologies Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
            public List<TerrainTopology.Enum> TopologiesBlocked { get; set; }
            [JsonIgnore]
            public Coroutine Coroutine;
            [JsonIgnore]
            public List<Vector3> Positions;
            public bool IsValidPosition(Vector3 position);
            private const int LayerMaskAbove;
            public bool IsValidAbove(Vector3 position);
            private const int LayerMaskBuilding;
            public bool IsValidBuilding(Vector3 position);
            private const int LayerMaskColliders;
            public bool IsValidColliders(Vector3 position);
            public bool IsValidTopology(Vector3 position);
            public bool IsValidBiome(Vector3 position);
            public bool IsValidSplat(Vector3 position);
        }

    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private PluginData _data;
    private class PluginData
    {
        public List<Location> Locations;
        [JsonIgnore]
        public Dictionary<int, List<Location>> LocationsByGroup;
        public int LastID;
        public void AddLocation(Location location);
        public void RemoveLocation(int index);
        public class Location
        {
            public string Name;
            public int ID;
            public int Group;
            public Vector3 Position;
            public string Format(string player);
            public static int? FindIndexById(int id);
            public static IReadOnlyList<Location> FindByGroup(int group);
        }

    }

    private void SaveData();
    private void LoadData();
    protected override void LoadDefaultMessages();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private object OnPlayerRespawn(BasePlayer player);
    private void CommandLocation(IPlayer player, string command, string[] args);
    private class CommandLocationData
    {
        public IPlayer Player;
        public PluginData.Location Location;
        private const int FirstArgumentIndex;
        public void Apply(string[] args);
        private Vector3? ParseVector(string argument);
    }

    private Vector3? GetLocation(int id);
    private JObject GetGroupLocations(int group);
    private Vector3? GetPregeneratedLocation(string profileName);
    private IEnumerator PositionGeneration(Configuration.Profile profile, string name);
    private Vector3? FindPregeneratedPosition(Configuration.Profile profile);
    private Vector3? TryFindPosition(Configuration.Profile profile);
    private int GetRandomPosition();
    private static string GetMsg(string key, string userId);
    internal static class DDraw
    {
        public static void Line(BasePlayer player, float duration, Color? color, Vector3? from, Vector3? to);
        public static void Arrow(BasePlayer player, float duration, Color? color, Vector3? from, Vector3? to, float headSize);
        public static void Sphere(BasePlayer player, float duration, Color? color, Vector3? from, string text);
        public static void Text(BasePlayer player, float duration, Color? color, Vector3? from, string text);
        public static void Box(BasePlayer player, float duration, Color? color, Vector3? from, float size);
        private static string Format(Color? color);
        private static string Format(Vector3? pos);
    }

}

private class Configuration
{
    [JsonProperty("Profiles", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, Profile> Profiles { get; set; }
    [JsonProperty("Respawn Configurations", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<RespawnConfiguration> RespawnConfigurations { get; set; }
    [JsonProperty("Respawn Profile", NullValueHandling = NullValueHandling.Ignore)]
    public string RespawnProfileName { get; set; }
    [JsonProperty("Respawn Locations Group", NullValueHandling = NullValueHandling.Ignore)]
    public int? RespawnGroup { get; set; }
    [JsonProperty("Enable Respawn Locations Group", NullValueHandling = NullValueHandling.Ignore)]
    public bool? EnableRespawnGroup { get; set; }
    [JsonProperty("Enable Respawn Management")]
    public bool EnableRespawn { get; set; }
    [JsonProperty("Location Management Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] LocationCommand { get; set; }
    public class RespawnConfiguration
    {
        [JsonProperty("Permission")]
        public string Permission { get; set; }
        [JsonProperty("Profile Name")]
        public string ProfileName { get; set; }
        [JsonProperty("Locations Group")]
        public int? Group { get; set; }
        [JsonIgnore]
        public Profile Profile;
    }

    public class Profile
    {
        [JsonProperty("Minimal Distance To Building")]
        public int DistanceBuilding { get; set; }
        [JsonProperty("Minimal Distance To Collider")]
        public int DistanceCollider { get; set; }
        [JsonProperty("Raycast Distance Above")]
        public float DistanceRaycast { get; set; }
        [JsonProperty("Number Of Attempts To Find A Position Per Frame")]
        public int AttemptsPerFrame { get; set; }
        [JsonProperty("Number Of Positions Per Frame")]
        public int PositionsPerFrame { get; set; }
        [JsonProperty("Number Of Attempts To Find A Pregenerated Position")]
        public int AttemptsPregenerated { get; set; }
        [JsonProperty("Pregenerated Positions Amount")]
        public int PregeneratedAmount { get; set; }
        [JsonProperty("Pregenerated Amount Check Frequency (Seconds)")]
        public float PregeneratedCheck { get; set; }
        [JsonProperty("Biomes Threshold", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<TerrainBiome.Enum, float> BiomesThresholdOld { get; set; }
        [JsonProperty("Biomes Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMinimum { get; set; }
        [JsonProperty("Biomes Maximum Threshold",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMaximum { get; set; }
        [JsonProperty("Biomes Allowed",
                ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
        public List<TerrainBiome.Enum> BiomesAllowed { get; set; }
        [JsonProperty("Biomes Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
        public List<TerrainBiome.Enum> BiomesBlocked { get; set; }
        [JsonProperty("Splat Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<TerrainSplat.Enum, float> SplatThresholdMinimum { get; set; }
        [JsonProperty("Splat Maximum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<TerrainSplat.Enum, float> SplatThresholdMaximum { get; set; }
        [JsonProperty("Splat Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
        public List<TerrainSplat.Enum> SplatAllowed { get; set; }
        [JsonProperty("Splat Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
        public List<TerrainSplat.Enum> SplatBlocked { get; set; }
        [JsonProperty("Topologies Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
        public List<TerrainTopology.Enum> TopologiesAllowed { get; set; }
        [JsonProperty("Topologies Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
        public List<TerrainTopology.Enum> TopologiesBlocked { get; set; }
        [JsonIgnore]
        public Coroutine Coroutine;
        [JsonIgnore]
        public List<Vector3> Positions;
        public bool IsValidPosition(Vector3 position);
        private const int LayerMaskAbove;
        public bool IsValidAbove(Vector3 position);
        private const int LayerMaskBuilding;
        public bool IsValidBuilding(Vector3 position);
        private const int LayerMaskColliders;
        public bool IsValidColliders(Vector3 position);
        public bool IsValidTopology(Vector3 position);
        public bool IsValidBiome(Vector3 position);
        public bool IsValidSplat(Vector3 position);
    }

}

public class RespawnConfiguration
{
    [JsonProperty("Permission")]
    public string Permission { get; set; }
    [JsonProperty("Profile Name")]
    public string ProfileName { get; set; }
    [JsonProperty("Locations Group")]
    public int? Group { get; set; }
    [JsonIgnore]
    public Profile Profile;
}

public class Profile
{
    [JsonProperty("Minimal Distance To Building")]
    public int DistanceBuilding { get; set; }
    [JsonProperty("Minimal Distance To Collider")]
    public int DistanceCollider { get; set; }
    [JsonProperty("Raycast Distance Above")]
    public float DistanceRaycast { get; set; }
    [JsonProperty("Number Of Attempts To Find A Position Per Frame")]
    public int AttemptsPerFrame { get; set; }
    [JsonProperty("Number Of Positions Per Frame")]
    public int PositionsPerFrame { get; set; }
    [JsonProperty("Number Of Attempts To Find A Pregenerated Position")]
    public int AttemptsPregenerated { get; set; }
    [JsonProperty("Pregenerated Positions Amount")]
    public int PregeneratedAmount { get; set; }
    [JsonProperty("Pregenerated Amount Check Frequency (Seconds)")]
    public float PregeneratedCheck { get; set; }
    [JsonProperty("Biomes Threshold", NullValueHandling = NullValueHandling.Ignore)]
    public Dictionary<TerrainBiome.Enum, float> BiomesThresholdOld { get; set; }
    [JsonProperty("Biomes Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMinimum { get; set; }
    [JsonProperty("Biomes Maximum Threshold",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<TerrainBiome.Enum, float> BiomesThresholdMaximum { get; set; }
    [JsonProperty("Biomes Allowed",
                ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
    public List<TerrainBiome.Enum> BiomesAllowed { get; set; }
    [JsonProperty("Biomes Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
    public List<TerrainBiome.Enum> BiomesBlocked { get; set; }
    [JsonProperty("Splat Minimum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<TerrainSplat.Enum, float> SplatThresholdMinimum { get; set; }
    [JsonProperty("Splat Maximum Threshold", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<TerrainSplat.Enum, float> SplatThresholdMaximum { get; set; }
    [JsonProperty("Splat Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
    public List<TerrainSplat.Enum> SplatAllowed { get; set; }
    [JsonProperty("Splat Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
    public List<TerrainSplat.Enum> SplatBlocked { get; set; }
    [JsonProperty("Topologies Allowed", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
    public List<TerrainTopology.Enum> TopologiesAllowed { get; set; }
    [JsonProperty("Topologies Blocked", ObjectCreationHandling = ObjectCreationHandling.Replace,
                ItemConverterType = typeof(StringEnumConverter))]
    public List<TerrainTopology.Enum> TopologiesBlocked { get; set; }
    [JsonIgnore]
    public Coroutine Coroutine;
    [JsonIgnore]
    public List<Vector3> Positions;
    public bool IsValidPosition(Vector3 position);
    private const int LayerMaskAbove;
    public bool IsValidAbove(Vector3 position);
    private const int LayerMaskBuilding;
    public bool IsValidBuilding(Vector3 position);
    private const int LayerMaskColliders;
    public bool IsValidColliders(Vector3 position);
    public bool IsValidTopology(Vector3 position);
    public bool IsValidBiome(Vector3 position);
    public bool IsValidSplat(Vector3 position);
}

private class PluginData
{
    public List<Location> Locations;
    [JsonIgnore]
    public Dictionary<int, List<Location>> LocationsByGroup;
    public int LastID;
    public void AddLocation(Location location);
    public void RemoveLocation(int index);
    public class Location
    {
        public string Name;
        public int ID;
        public int Group;
        public Vector3 Position;
        public string Format(string player);
        public static int? FindIndexById(int id);
        public static IReadOnlyList<Location> FindByGroup(int group);
    }

}

public class Location
{
    public string Name;
    public int ID;
    public int Group;
    public Vector3 Position;
    public string Format(string player);
    public static int? FindIndexById(int id);
    public static IReadOnlyList<Location> FindByGroup(int group);
}

private class CommandLocationData
{
    public IPlayer Player;
    public PluginData.Location Location;
    private const int FirstArgumentIndex;
    public void Apply(string[] args);
    private Vector3? ParseVector(string argument);
}

internal static class DDraw
{
    public static void Line(BasePlayer player, float duration, Color? color, Vector3? from, Vector3? to);
    public static void Arrow(BasePlayer player, float duration, Color? color, Vector3? from, Vector3? to, float headSize);
    public static void Sphere(BasePlayer player, float duration, Color? color, Vector3? from, string text);
    public static void Text(BasePlayer player, float duration, Color? color, Vector3? from, string text);
    public static void Box(BasePlayer player, float duration, Color? color, Vector3? from, float size);
    private static string Format(Color? color);
    private static string Format(Vector3? pos);
}


```

---

## PrefabLimit by HoverCatz - Limit spawning of prefabs using percentages

```csharp
using Oxide.Core;
using System.Collections.Generic;

Oxide.Plugins
[Info("Prefab Limit", "HoverCatz", "1.0.2")]
[Description("Limit spawning of prefabs using percentages")]
 class PrefabLimit : RustPlugin
{
    readonly string PluginName;
     Dictionary<string, int> spawnChances;
     void OnServerInitialized();
     void Unload();
     void ReLoadConfig();
    private void AddDefaultConfig();
    [ConsoleCommand("prefablimitreload")]
     void ReloadConfigCommand(ConsoleSystem.Arg arg);
     void OnEntitySpawned(BaseNetworkable entity);
}


```

---

## PrefabSniffer by MrBlue - Searches the game files for prefab file locations

```csharp
using System;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Prefab Sniffer", "Wulf", "2.0.2")]
[Description("Searches the game files for prefab file locations")]
public class PrefabSniffer : CovalencePlugin
{
    protected override void LoadDefaultMessages();
    private const string permissionUse;
    private Dictionary<string, UnityEngine.Object> files;
    private GameManifest.PooledString[] manifest;
    private void OnServerInitialized();
    private void CommandPrefab(IPlayer player, string command, string[] args);
    private void AddLocalizedCommand(string command);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string textOrLang, object[] args);
}


```

---

## PremiumQuarry by Mevent - Use of quarries by permission

```csharp
using System.Collections.Generic;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Premium Quarry", "Mevent", "1.0.1")]
[Description("Use of quarries by permission")]
public class PremiumQuarry : CovalencePlugin
{
    [PluginReference]
    private Plugin UINotify;
    private const string Permission;
    private void Init();
    private void OnQuarryToggled(MiningQuarry quarry, BasePlayer player);
    private const string NoPermission;
    protected override void LoadDefaultMessages();
    private string Msg(BasePlayer player, string key, object[] obj);
    private void Reply(BasePlayer player, string key, object[] obj);
    private void SendNotify(BasePlayer player, string key, int type, object[] obj);
}


```

---

## PreventLooting by CaseMan - Provides protection of players' entities from looting by other players

```csharp
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Game.Rust;
using UnityEngine;
using System.Reflection;
using Oxide.Core.Libraries.Covalence;
using System.Linq;

Oxide.Plugins
[Info("PreventLooting", "CaseMan", "1.15.0", ResourceId = 2469)]
[Description("Prevent looting by other players")]
 class PreventLooting : RustPlugin
{
    [PluginReference]
     Plugin Friends;
    [PluginReference]
     Plugin ZoneManager;
    [PluginReference]
     Plugin DynamicPVP;
     bool UsePermission;
     bool UseFriendsAPI;
     bool UseTeams;
     bool AdminCanLoot;
     bool CanAuthCB;
     bool CanLootPl;
     bool CanLootCorpse;
     bool CanLootEnt;
     bool CanRWMount;
     bool CanRWSwap;
     bool CanRWTake;
     bool CanRWUnload;
     bool CanRWLoad;
     bool CanLootBackpack;
     bool CanLootBackpackPlugin;
     bool CanPickup;
     bool CanOvenToggle;
     bool IncludeZoneMode;
     bool UseZoneManager;
     bool UseDynamicPVP;
     bool UseExcludeEntities;
     bool UseCupboard;
     List<object> UseCupboardInclude;
     bool UseOnlyInCupboardRange;
     List<object> UseOnlyInCupboardRangeInclude;
     bool WipeDetected;
     List<object> ZoneID;
     List<object> ExcludeEntities;
     string PLPerm;
     string PlayerPerm;
     string CorpsePerm;
     string BackpackPerm;
     string StoragePerm;
     string AdmPerm;
     class StoredData
    {
        public Dictionary<ulong, EntityData> Data;
        public StoredData();
    }

     class EntityData
    {
        public List<ulong> Share;
        public Dictionary<string, List<ulong>> Quarry;
        public EntityData();
    }

     StoredData storedData;
     void Init();
     void OnServerInitialized();
     void OnServerSave();
     void Unload();
     void OnNewSave(string filename);
    protected override void LoadDefaultConfig();
     void LoadDefaultMessages();
    private object CanLootEntity(BasePlayer player, LootableCorpse corpse);
    private void OnItemDropped(Item item, BaseEntity entity);
    private object OnItemPickup(Item item, BasePlayer player);
    private void OnLootEntity(BasePlayer player, BaseEntity entity);
    private object CanLootEntity(BasePlayer player, DroppedItemContainer container);
    private object CanLootPlayer(BasePlayer target, BasePlayer player);
    private bool CheckHelper(BasePlayer player, BaseEntity entity);
    private bool CheckDynamicPVP(BasePlayer player);
    private object CanLootEntity(BasePlayer player, StorageContainer container);
    private bool CheckRackedWeapon(BasePlayer player, BaseEntity entity);
    private object OnRackedWeaponMount(Item weapon, BasePlayer player, WeaponRack rack);
    private object OnRackedWeaponSwap(Item weaponMounting, WeaponRackSlot weaponTaking, BasePlayer player, WeaponRack rack);
    private object OnRackedWeaponTake(Item weapon, BasePlayer player, WeaponRack rack);
    private object OnRackedWeaponUnload(Item weapon, BasePlayer player, WeaponRack rack);
    private object OnRackedWeaponLoad(Item weapon, ItemDefinition ammoItem, BasePlayer player, WeaponRack rack);
    private object OnOvenToggle(BaseOven oven, BasePlayer player);
    private object CanPickupEntity(BasePlayer player, BaseCombatEntity ent);
    private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player);
    private BaseEntity CheckParent(BaseEntity entity);
     object CanAdministerVending(BasePlayer player, VendingMachine machine);
     bool IsVendingOpen(BasePlayer player, BaseEntity entity);
     bool IsDropBoxOpen(BasePlayer player, BaseEntity entity);
     bool IsFriend(ulong friendid, ulong playerid);
     bool FindEntityFromRay(BasePlayer player, object success);
     bool CheckAuthCupboard(object ent, BasePlayer player);
    private IPlayer CheckPlayer(BasePlayer player, string[] args);
    [ChatCommand("share")]
     void Share(BasePlayer player, string command, string[] args);
    [ChatCommand("unshare")]
     void Unshare(BasePlayer player, string command, string[] args);
    [ChatCommand("sharelist")]
     void Sharelist(BasePlayer player);
    [ChatCommand("shareclear")]
     void Shareclear(BasePlayer player);
    [ChatCommand("checkit")]
     void CheckBP(BasePlayer player);
     T GetConfig(string name, T defaultValue);
}

 class StoredData
{
    public Dictionary<ulong, EntityData> Data;
    public StoredData();
}

 class EntityData
{
    public List<ulong> Share;
    public Dictionary<string, List<ulong>> Quarry;
    public EntityData();
}


```

---

## PreventQuarryToggle by Rezx - turns quarrys/pumpjacks back on when a player that isn't the owner or in a team try's to shut it off

```csharp
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Prevent Quarry Toggle", "Rezx", "1.0.2")]
[Description("This plugin prevents players that are not in a team with the owner from turning quarry/pumpjacks off")]
internal class PreventQuarryToggle : CovalencePlugin
{
    private static bool SameTeam(ulong playerId, ulong friendId);
     void OnQuarryToggled(MiningQuarry quarry, BasePlayer player);
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
}


```

---

## PrivateAdminMessage by waayne - Allows admins to send private messages to players via console/chat

```csharp
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Private Admin Message", "waayne", "0.2.0")]
[Description("Allows admins to send private messages to players via console/chat")]
internal class PrivateAdminMessage : CovalencePlugin
{
    private const string PRIVATE_ADMIN_MESSAGE;
    private const string PRIVATE_ADMIN_MESSAGE_RECEIVE;
    private void Init();
    protected override void LoadDefaultMessages();
    private void AdminToPlayerMessageCommand(IPlayer player, string command, string[] args);
    private void PlayerToAdminMessageCommand(IPlayer player, string command, string[] args);
}


```

---

## PrivateCrops by  - Protects players' crops from being stolen, that are inside planters. Uses TC Auth system

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Private Crops", "Khan", "1.2.0")]
[Description("Protects player's crops from being stolen!")]
 class PrivateCrops : CovalencePlugin
{
    [PluginReference]
    private Plugin Clans;
    private Plugin Friends;
    private PluginConfig _config;
    private const string messagebypass;
    private const string protectionbypass;
    private const string instant;
    private void Init();
    protected override void LoadDefaultMessages();
    private class PluginConfig
    {
        [JsonProperty("Use Tool Cupboard Protection")]
        public bool EnableTC;
        [JsonProperty("Set Max Seasons the plant regrows")]
        public int MaxSeasons;
        [JsonProperty("Set Max Harvests")]
        public int MaxHarvests;
        [JsonProperty("Prevent Plants from dying")]
        public bool Dying;
        [JsonProperty("Warning Message Color")]
        public string MessageColor;
        [JsonProperty("Use Clan Protection")]
        public bool EnableClans;
        [JsonProperty("Use Teams Protection")]
        public bool EnableTeams;
        [JsonProperty("Use Friends only Protection")]
        public bool EnableFriends;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private void OnEntityBuilt(Planner planner, GameObject seed);
    private object CanTakeCutting(BasePlayer player, GrowableEntity growable);
    private object OnGrowableGather(GrowableEntity growable, BasePlayer player);
    private object OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player);
    private bool? OnGrowableStateChange(GrowableEntity growableEntity, PlantProperties.State state);
    private object CropsProtected(BasePlayer player, GrowableEntity growable);
    public void WarnPlayer(BasePlayer player);
    private bool IsOwner(ulong userID, ulong owner);
    private bool SameTeam(ulong playerID, ulong friendID);
    private bool AreFriends(ulong playerID, ulong friendID);
    private bool SameClan(ulong playerID, ulong friendID);
}

private class PluginConfig
{
    [JsonProperty("Use Tool Cupboard Protection")]
    public bool EnableTC;
    [JsonProperty("Set Max Seasons the plant regrows")]
    public int MaxSeasons;
    [JsonProperty("Set Max Harvests")]
    public int MaxHarvests;
    [JsonProperty("Prevent Plants from dying")]
    public bool Dying;
    [JsonProperty("Warning Message Color")]
    public string MessageColor;
    [JsonProperty("Use Clan Protection")]
    public bool EnableClans;
    [JsonProperty("Use Teams Protection")]
    public bool EnableTeams;
    [JsonProperty("Use Friends only Protection")]
    public bool EnableFriends;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## PrivateMessages by misticos - Allows players to send private messages to other players

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("PrivateMessages", "MisterPixie", "1.1.11")]
[Description("Allows users to send private messages to each other")]
 class PrivateMessages : CovalencePlugin
{
    private readonly Dictionary<string, string> pmHistory;
    private Dictionary<string, double> cooldown;
    private List<LastFivePms> lastFivePms;
    private const string allowPerm;
     class LastFivePms
    {
        public string target { get; set; }
        public string sender { get; set; }
        public List<string> messages { get; set; }
    }

    [PluginReference]
    private Plugin Ignore;
    private Plugin UFilter;
    private Plugin BetterChatMute;
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
    private void Init();
    private void OnUserDisconnected(IPlayer player);
    private void cmdPm(IPlayer player, string command, string[] args);
    private void cmdPmReply(IPlayer player, string command, string[] args);
    private void AddHistoryAndLogging(IPlayer initiator, IPlayer target, string message);
    private void AddPmHistory(string initiatorId, string targetId);
    private bool CheckMuteStatus(IPlayer player, IPlayer target);
    private void cmdPmHistory(IPlayer player, string command, string[] args);
    private string RemoveRichText(string message);
    private IPlayer FindPlayer(string nameOrIdOrIp);
    private void AddToHistory(string sender, string target, string msg);
    private LastFivePms GetLastFivePms(string sender, string target);
    private bool IsIgnored(IPlayer sender, IPlayer target);
    private string IsUFilter(string[] args, bool isR);
    private bool IsCooldowned(IPlayer player);
    private double GetTimeStamp();
    private ConfigData configData;
    private class ConfigData
    {
        public bool UseUFilter;
        public bool UseIgnore;
        public bool UseCooldown;
        public bool UseBetterChatMute;
        public bool EnableLogging;
        public bool EnableHistory;
        public bool UsePermission;
        public int CooldownTime;
        public string PmCommand;
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
}

 class LastFivePms
{
    public string target { get; set; }
    public string sender { get; set; }
    public List<string> messages { get; set; }
}

private class ConfigData
{
    public bool UseUFilter;
    public bool UseIgnore;
    public bool UseCooldown;
    public bool UseBetterChatMute;
    public bool EnableLogging;
    public bool EnableHistory;
    public bool UsePermission;
    public int CooldownTime;
    public string PmCommand;
}


```

---

## PrivateMessagesGUI by  - Shows the sent messages of the PrivateMessages plugin as game tips

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using System;

Oxide.Plugins
[Info("Private Messages GUI", "Tricky/TurtleInBlack", "1.1.0")]
[Description("Shows the sent messages of the PrivateMessages plugin as game tips.")]
public class PrivateMessagesGUI : CovalencePlugin
{
    [PluginReference]
    private Plugin PrivateMessages;
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Game Tip Duration In Seconds")]
        public float GameTipDuration { get; set; }
        [JsonProperty(PropertyName = "Show To Sender")]
        public bool ShowToSender { get; set; }
        [JsonProperty(PropertyName = "Show To Receiver")]
        public bool ShowToReceiver { get; set; }
    }

    private Configuration DefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void Unload();
    private void OnPMProcessed(IPlayer sender, IPlayer receiver, string message);
    private void SendGameTip(IPlayer player, string message);
    private string GetMessage(string messageKey, string playerId, object[] args);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Game Tip Duration In Seconds")]
    public float GameTipDuration { get; set; }
    [JsonProperty(PropertyName = "Show To Sender")]
    public bool ShowToSender { get; set; }
    [JsonProperty(PropertyName = "Show To Receiver")]
    public bool ShowToReceiver { get; set; }
}


```

---

## PrivilegeDeploy by k1lly0u - Block specific items from being deployed outside of a authorized build radius

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("PrivilegeDeploy", "k1lly0u", "0.1.7")]
[Description("Choose which deployable items require building privilege to deploy")]
 class PrivilegeDeploy : RustPlugin
{
    private readonly Hash<string, ItemDefinition> prefabToItem;
    private readonly Hash<string, List<ItemAmount>> constructionToIngredients;
    private void Loaded();
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private void OnEntitySpawned(BaseEntity baseEntity);
    private void InitValidList();
    private T[] GetAllPrefabs();
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "deployables")]
        public List<string> Deployables { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "deployables")]
    public List<string> Deployables { get; set; }
}


```

---

## Prod by Quapi - Gets owners of deployable, building structures and whitelist of tool cupboards

```csharp
using System;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;
using System.Text;

Oxide.Plugins
[Info("Prod", "Quapi", "2.5.4")]
 class Prod : RustPlugin
{
    private DynamicConfigFile BuildingData;
    private int prodAuth;
    private string helpProd;
    private string noAccess;
    private string noTargetfound;
    private string noCupboardPlayers;
    private string Toolcupboard;
    private string noBlockOwnerfound;
    private string noCodeAccess;
    private string codeLockList;
    private string informationAdded;
    private bool passiveMode;
    private string passive_Codelock_List;
    private string boxNeedsCode;
    private string boxCode;
    private static bool serverInitialized;
    private bool printToConsoleInsteadOfChat;
    private FieldInfo serverinput;
    private FieldInfo codelockwhitelist;
    private FieldInfo codenum;
    private Vector3 eyesAdjust;
    private bool Changed;
    [PluginReference]
     Plugin PlayerDatabase;
     void Loaded();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private bool isPluginDev;
    private bool dumpAll;
    private string prodCommand;
    private void LoadVariables();
    protected override void LoadDefaultConfig();
     void OnServerInitialized();
     void OnServerSave();
     void OnServerQuit();
     void OnEntityBuilt(HeldEntity heldentity, GameObject gameobject);
     void SaveData();
     void SetBlockData(BuildingBlock block, string steamid);
     object FindBlockData(BuildingBlock block);
    private bool hasAccess(BasePlayer player);
     void cmdChatProd(BasePlayer player, string command, string[] args);
    private void GetDeployableCode(BasePlayer player, BaseEntity block);
    private void GetDeployedItemOwner(BasePlayer player, SleepingBag ditem);
    private object FindOwnerBlock(BuildingBlock block);
    private string FindPlayerName(ulong userId);
    private void SendBasePlayerFind(BasePlayer player, List<ulong> ownerid);
    private void GetBuildingblockOwner(BasePlayer player, BuildingBlock block);
    private void GetToolCupboardUsers(BasePlayer player, BuildingPrivlidge cupboard);
    private void Dump(BaseEntity col);
    private BaseEntity DoRay(Ray ray);
     void SendHelpText(BasePlayer player);
    public new void SendReply(BasePlayer player, string format, object[] args);
    private void Passive_GetBuildingBlockOwner(BasePlayer player, BuildingBlock block);
    private void Passive_GetCodelockWhitelisted(BasePlayer player, BaseEntity block);
    private void Passive_SendBasePlayerFind(BasePlayer player, ulong ownerid);
}


```

---

## Promocodes by LaserHydra - Create promotion codes which run commands when redeemed by players

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Promocodes", "LaserHydra", "3.0.0", ResourceId = 1471)]
[Description("Create promotion codes which run commands when redeemed by players")]
public sealed class Promocodes : CovalencePlugin
{
    private static Promocodes _instance;
    private List<PromocodeGroup> _promocodeGroups;
    private void Init();
    protected override void LoadDefaultMessages();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    [Command("redeem")]
    private void RedeemCommand(IPlayer player, string cmd, string[] args);
    private sealed class PromocodeGroup
    {
        [JsonProperty("Automatically Fill To (Amount)")]
        private int _fillAmount;
        [JsonProperty("Codes")]
        private List<string> _codes;
        [JsonProperty("Commands")]
        private CommandCall[] _commands;
        public bool IsValidCode(string code);
        public void RedeemCode(IPlayer player, string code);
        public void FillCodes();
        private static string GenerateCode();
        public static PromocodeGroup GetDefaultGroup();
    }

    public sealed class CommandCall
    {
        [JsonProperty("Parameters")]
        private string[] _parameters;
        [JsonProperty("Command")]
        public string Command { get; set; }
        public string[] GetParameters(IPlayer player);
        public CommandCall();
        public CommandCall(string command, string[] parameters);
    }

}

private sealed class PromocodeGroup
{
    [JsonProperty("Automatically Fill To (Amount)")]
    private int _fillAmount;
    [JsonProperty("Codes")]
    private List<string> _codes;
    [JsonProperty("Commands")]
    private CommandCall[] _commands;
    public bool IsValidCode(string code);
    public void RedeemCode(IPlayer player, string code);
    public void FillCodes();
    private static string GenerateCode();
    public static PromocodeGroup GetDefaultGroup();
}

public sealed class CommandCall
{
    [JsonProperty("Parameters")]
    private string[] _parameters;
    [JsonProperty("Command")]
    public string Command { get; set; }
    public string[] GetParameters(IPlayer player);
    public CommandCall();
    public CommandCall(string command, string[] parameters);
}


```

---

## PropControl by VisEntities - Become an animal or a scientist

```csharp
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using UnityEngine;

Oxide.Plugins
[Info("Prop Control", "Dana", "0.1.3")]
[Description("Become an animal")]
public class PropControl : RustPlugin
{
    [PluginReference]
    private Plugin Vanish;
    private Plugin BetterVanish;
    private const string permallow;
    private List<Props> data;
    private PluginConfig _pluginConfig;
     object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    public class Props
    {
        public BasePlayer player { get; set; }
        public BaseEntity entity { get; set; }
    }

    private class NPCController : MonoBehaviour
    {
        public BasePlayer player;
        public NpcAI npcAi;
        private void Awake();
    }

    private class NpcAI : MonoBehaviour
    {
        internal Vector3 targetPos;
        internal BaseCombatEntity targetEnt { get; set; }
        internal BaseMountable mountable;
        public BasePlayer npc;
        public NPCController owner;
        public BaseEntity entity;
        public RidableHorse horse;
        public BaseNpc baseNpc;
        public Transform transformer;
        public ResourceDispenser dispenser;
        private void Awake();
        private void OnDestroy();
        private void Update();
    }

    protected override void LoadDefaultMessages();
    private string Message(string key, string id, object[] args);
    private void Init();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private void Unload();
    [ChatCommand("leave")]
    private void LeaveCommand(BasePlayer player);
    [ChatCommand("become")]
    private void BecomeCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("props")]
    private void PropsCommand(BasePlayer player);
    private static BaseEntity FindObject(Ray ray, float distance);
    private string DeterminePrefab(string argument);
    private class PluginConfig
    {
        public PropControlConfig PropControlConfig { get; set; }
    }

    private class PropControlConfig
    {
        [JsonProperty(PropertyName = "Use - BetterVanish")]
        public bool UseBetterVanish { get; set; }
        [JsonProperty(PropertyName = "Use - Vanish")]
        public bool UseVanish { get; set; }
        [JsonProperty(PropertyName = "PropPrefabMap")]
        public Dictionary<string, string> PropPrefabMap { get; set; }
        [JsonProperty(PropertyName = "Invulnerable Props - Enabled")]
        public bool InvulnerableProps { get; set; }
    }

}

public class Props
{
    public BasePlayer player { get; set; }
    public BaseEntity entity { get; set; }
}

private class NPCController : MonoBehaviour
{
    public BasePlayer player;
    public NpcAI npcAi;
    private void Awake();
}

private class NpcAI : MonoBehaviour
{
    internal Vector3 targetPos;
    internal BaseCombatEntity targetEnt { get; set; }
    internal BaseMountable mountable;
    public BasePlayer npc;
    public NPCController owner;
    public BaseEntity entity;
    public RidableHorse horse;
    public BaseNpc baseNpc;
    public Transform transformer;
    public ResourceDispenser dispenser;
    private void Awake();
    private void OnDestroy();
    private void Update();
}

private class PluginConfig
{
    public PropControlConfig PropControlConfig { get; set; }
}

private class PropControlConfig
{
    [JsonProperty(PropertyName = "Use - BetterVanish")]
    public bool UseBetterVanish { get; set; }
    [JsonProperty(PropertyName = "Use - Vanish")]
    public bool UseVanish { get; set; }
    [JsonProperty(PropertyName = "PropPrefabMap")]
    public Dictionary<string, string> PropPrefabMap { get; set; }
    [JsonProperty(PropertyName = "Invulnerable Props - Enabled")]
    public bool InvulnerableProps { get; set; }
}


```

---

## ProximityAlert by PaiN - Displays a UI warning message when players get within a set radius of the player

```csharp
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("Proximity Alert", "PaiN", "0.3.7")]
[Description("Displays a UI warning message when players get within a set radius of the player")]
 class ProximityAlert : RustPlugin
{
    [PluginReference]
    private Plugin Clans;
    private Plugin EventManager;
    private Plugin Friends;
    private Plugin HumanNPC;
    static ProximityAlert ins;
    private const string proxUI;
    private const string permUse;
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnEntityDeath(BasePlayer victim, HitInfo info);
    private void OnPlayerTeleported(BasePlayer player, Vector3 oldPos, Vector3 newPos);
    private void RegisterPermissions();
    private void CheckDependencies();
    private void OnPlayerSleepEnded(BasePlayer player);
    private void HandleVictim(BasePlayer victim, HitInfo info);
    private bool DoChecks(BasePlayer enemy);
    private void ProxCollisionEnter(BasePlayer player);
    private void ProxCollisionLeave(BasePlayer player);
    private float GetPlayerRadius(BasePlayer player);
    private bool IsClanmate(ulong playerId, ulong friendId);
    private bool IsFriend(ulong playerID, ulong friendID);
    private bool IsTeam(BasePlayer player, BasePlayer target);
    private bool IsScientist(BaseNetworkable networkable);
    private bool IsTunnelNPC(BaseNetworkable networkable);
    private bool IsBanditNPC(BaseNetworkable networkable);
    private bool IsPlaying(BasePlayer player);
    private void JoinedEvent(BasePlayer player);
    private void LeftEvent(BasePlayer player);
    public CuiElementContainer CreateUI(string text);
    [ChatCommand("prox")]
    private void cmdProx(BasePlayer player, string command, string[] args);
    private class ProximityPlayer : MonoBehaviour
    {
        public BasePlayer player;
        private Timer destroyTimer;
        public List<ulong> inProximity;
        public bool isEnabled;
        public bool justDied;
        private void Awake();
        private void OnTriggerEnter(Collider col);
        private void OnTriggerExit(Collider col);
    }

    private ConfigData configData;
    private class ConfigData
    {
        public bool DetectSleepers { get; set; }
        public bool DetectHumanNPCs { get; set; }
        public bool DetectTunnelNPCs { get; set; }
        public bool DetectScientists { get; set; }
        public bool DetectBanditNPCs { get; set; }
        public float GUI_X_Pos { get; set; }
        public float GUI_X_Dim { get; set; }
        public float GUI_Y_Pos { get; set; }
        public float GUI_Y_Dim { get; set; }
        public int FontSize { get; set; }
        public float TriggerRadius { get; set; }
        public Dictionary<string, float> CustomPermissions { get; set; }
        public bool UseCustomPermissions { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
    protected override void LoadDefaultMessages();
}

private class ProximityPlayer : MonoBehaviour
{
    public BasePlayer player;
    private Timer destroyTimer;
    public List<ulong> inProximity;
    public bool isEnabled;
    public bool justDied;
    private void Awake();
    private void OnTriggerEnter(Collider col);
    private void OnTriggerExit(Collider col);
}

private class ConfigData
{
    public bool DetectSleepers { get; set; }
    public bool DetectHumanNPCs { get; set; }
    public bool DetectTunnelNPCs { get; set; }
    public bool DetectScientists { get; set; }
    public bool DetectBanditNPCs { get; set; }
    public float GUI_X_Pos { get; set; }
    public float GUI_X_Dim { get; set; }
    public float GUI_Y_Pos { get; set; }
    public float GUI_Y_Dim { get; set; }
    public int FontSize { get; set; }
    public float TriggerRadius { get; set; }
    public Dictionary<string, float> CustomPermissions { get; set; }
    public bool UseCustomPermissions { get; set; }
}


```

---

## PublicQuarryLock by Lorenzo - Public Quarry Lock is for PVE server, to protect loot on static quarry and pump jack.

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;
using Oxide.Core.Libraries.Covalence;
using System.Text;
using Facepunch;

Oxide.Plugins
[Info("Public Quarry Lock", "Lorenzo", "1.0.29")]
[Description("Lock public Quarry and pumpjack to a player/team/clan when it run")]
 class PublicQuarryLock : CovalencePlugin
{
    [PluginReference]
    private Plugin Clans;
    [PluginReference]
    private Plugin ZoneManager;
    [PluginReference]
    private Plugin DynamicPVP;
    [PluginReference]
    private Plugin Notify;
    private static PublicQuarryLock _instance;
    private static DiscordComponent _discord;
    private const string PREFAB_ITEM_DROP;
    private readonly Vector3 DropVect;
     string TraceFile;
    private const string ReadableNameQuarry;
    private const string ReadableNamePump;
    private const uint FuelStoragePumpID;
    private const uint OutputHopperPumpID;
    private const uint FuelStorageQuarryID;
    private const uint OutputHopperQuarryID;
    private int QuarryDefaultDieselStack;
    private int QuarryDefaultFuelCapacity;
    private int QuarryDefaultHopperSlots;
    private int PumpDefaultDieselStack;
    private int PumpDefaultFuelCapacity;
    private int PumpDefaultHopperSlots;
    private float workPerFuelRestore;
    private float workToAddRestore;
    private float processRateRestore;
    const char Platform;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Use permission")]
        public bool UsePermission;
        [JsonProperty(PropertyName = "PermissionAdmin")]
        public string PermissionAdmin;
        [JsonProperty(PropertyName = "Permission for quarry only")]
        public string PermissionUseQuarry;
        [JsonProperty(PropertyName = "Permission for pumpjack only")]
        public string PermissionUsePump;
        [JsonProperty(PropertyName = "Permission bypass global cooldown")]
        public string PermissionBypassCooldown;
        [JsonProperty(PropertyName = "Allow access to quarry without permission (will not lock)")]
        public bool UseQuarryWithoutPermission;
        [JsonProperty(PropertyName = "Enable for mining quarry")]
        public bool enableMiningQuarry;
        [JsonProperty(PropertyName = "Enable for pump jack")]
        public bool enablePumpJack;
        [JsonProperty(PropertyName = "Enable player quarry")]
        public bool enablePlayerQuarry;
        [JsonProperty(PropertyName = "Enable player pumpjack")]
        public bool enablePlayerPump;
        [JsonProperty(PropertyName = "CoolDown before releasing mining quarry (min)")]
        public float CoolDown;
        [JsonProperty(PropertyName = "Send quarry available message to all")]
        public bool MessageAll;
        [JsonProperty(PropertyName = "Enable engine loot after it is started, to add fuel")]
        public bool engineloot;
        [JsonProperty(PropertyName = "Use Teams")]
        public bool UseTeams;
        [JsonProperty(PropertyName = "Use Clans plugin")]
        public bool UseClans;
        [JsonProperty(PropertyName = "Use clan table")]
        public bool UseClanTable;
        [JsonProperty(PropertyName = "Use DynamicPVP to disable lock in PVP zones")]
        public bool UseDynamicPVP;
        [JsonProperty(PropertyName = "CoolDown in min. before a player or team can restart the quarry (0 is disabled)")]
        public float PlayerCoolDown;
        [JsonIgnore]
        public float _PlayerCoolDown;
        [JsonProperty(PropertyName = "Usage cooldown to all quarry")]
        public bool CoolDownGlobal;
        [JsonProperty(PropertyName = "Maximum stack size for diesel engine (-1 to disable function)")]
        public int DieselFuelMaxStackSize;
        [JsonProperty(PropertyName = "Number of slots for diesel storage (-1 to disable function)")]
        public int FuelSlots;
        [JsonProperty(PropertyName = "Number of slots for output storage (-1 to disable function)")]
        public int HopperSlots;
        [JsonProperty(PropertyName = "Time per barrel of diesel in second (-1 to disable function, default time 125 sec)")]
        public int TimePerBarrel;
        [JsonProperty(PropertyName = "quarry chat command")]
        public string quarryquerry;
        [JsonProperty(PropertyName = "Quarry clear status")]
        public string quarryclearstatus;
        [JsonProperty(PropertyName = "Quarry stop command")]
        public string quarrystopcommand;
        [JsonProperty(PropertyName = "Empty the output hopper when quarry/pumpjack start")]
        public bool FlushOutputHopper;
        [JsonProperty(PropertyName = "Clear quarry lock after all player from team/clan disconnect")]
        public bool ClearQuarryLockOnAllTeamDisconnect;
        [JsonProperty(PropertyName = "Clear quarry lock after player owner disconnect")]
        public bool ClearQuarryLockOnPlayerOwnerDisconnect;
        [JsonProperty(PropertyName = "Time after all player disconnect before quarry clear (minutes)")]
        public long CooldownQuarryLockOnDisconnect;
        [JsonProperty(PropertyName = "Items in report list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] ReportItems;
        [JsonProperty("Use Discord hook")]
        public bool Discordena;
        [JsonProperty("Use Discord timestamp")]
        public bool UseDiscordTimestamp;
        [JsonProperty("Discord hook url")]
        public string DiscordHookUrl;
        [JsonProperty(PropertyName = "Use Notify plugin")]
        public bool useNotify;
        [JsonProperty(PropertyName = "Debug")]
        public bool Debug;
        [JsonProperty(PropertyName = "Log to file")]
        public bool LogToFile;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private Dictionary<ulong, QuarryInfo> Quarrys;
    private Dictionary<ulong, ulong> Associate;
    private class QuarryInfo
    {
        public ulong playerid;
        public string displayName;
        public string ShortPrefabName;
        [JsonIgnore]
        public string readablename;
        [JsonIgnore]
        public miningtype type;
        [JsonIgnore]
        public double FuelTimeRemaining;
        public bool state;
        public bool EnableLock;
        public DateTime checkfueltime;
        public DateTime stoptime;
        public string Name;
        public float processRate;
        public Dictionary<ulong, CooldownTime> PlayerCooldown;
        [JsonIgnore]
        public DateTime PlayerDisconnectTime;
        [JsonIgnore]
        public int CountTick;
        [JsonIgnore]
        public MiningQuarry Quarry;
        [JsonIgnore]
        public Timer timerQuarryStopped;
        public QuarryInfo();
    }

    public class CooldownTime
    {
        public bool IsOnline;
        public bool IgnoreOnline;
        public DateTime Time;
        public CooldownTime();
    }

    private void LoadData();
    private void SaveData();
    private string Lang(string key, string id, object[] args);
    private new void LoadDefaultMessages();
    private void Init();
    private void Unload();
    private void OnServerInitialized(bool initial);
     void OnEntitySpawned(MiningQuarry quarry);
    private object OnQuarryToggle(MiningQuarry quarry, BasePlayer player);
     float CalcFuelTime(MiningQuarry quarry);
     void OnQuarryToggled(MiningQuarry quarry, BasePlayer player);
     void OnQuarryToggledOff(MiningQuarry quarry, bool enableMsg);
     object CanLootEntity(BasePlayer player, StorageContainer container);
     void OnLootEntityEnd(BasePlayer player, StorageContainer container);
     void LootDieselEngineEnd(BasePlayer player, StorageContainer fueltank);
     object LootQuarryOutput(BasePlayer player, StorageContainer container);
     object LootQuarryFuel(BasePlayer player, StorageContainer container);
     void OnQuarryGather(MiningQuarry quarry, Item item);
     void OnPlayerConnected(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string strReason);
     bool CheckPlayerCooldown(ulong PlayerID, QuarryInfo quarryinfo);
     int PlayerCooldownTime(ulong PlayerID, QuarryInfo quarryinfo);
     void AddPlayerCooldown(ulong playerID, double extra, QuarryInfo quarryinfo);
     void AddSinglePlayerCooldown(ulong PlayerID, QuarryInfo quarryinfo, CooldownTime Cooldown);
     bool isEntityInDynamicPVP(BaseEntity entity);
     bool IspluginLoaded(Plugin a);
    private void Quarry_info(IPlayer iplayer, string command, string[] args);
    private void Quarry_clearstatus(IPlayer iplayer, string command, string[] args);
    private void Mining_stopcommand(IPlayer iplayer, string command, string[] args);
     void ClearQuarry(QuarryInfo quarry, bool clearcooldownlist);
     bool IsQuarryAvailable(QuarryInfo quarryinfo);
    private static void DropItemContainer(ItemContainer itemContainer, Vector3 dropPosition, Quaternion rotation);
     string ReportInventory(StorageContainer storage);
    private void PrintToLog(string message);
    private bool IsAdmin(ulong id);
    private bool IsAdmin(string id);
    private bool CanPlayerUseQuarry(ulong id);
    private bool CanPlayerUsePump(ulong id);
    private bool CanPlayerBypassCooldown(ulong id);
    private bool SameClan(ulong playerID, ulong friendID);
    private bool SameTeam(ulong playerID, ulong friendID);
    private void BroadcastMessage(string msg, object[] args);
    public void SendChatMessage(BasePlayer player, string msg, object[] args);
    private void PrintToDiscord(string message, double seconds);
    private string PositionToString(Vector3 position);
    private class DiscordComponent : MonoBehaviour
    {
        private const float PostDelay;
        public long MsgCooldown;
        private readonly Queue<object> _queue;
        private string _url;
        private bool _busy;
        public DiscordComponent Configure(string url);
        public DiscordComponent SendTextMessage(string message, object[] args);
        private DiscordComponent AddQueue(object request);
        private IEnumerator ProcessQueue();
        private IEnumerator ProcessRequest(object request);
        private class MessageRequest
        {
            [JsonProperty("content")]
            public string Content { get; set; }
            public MessageRequest(string content);
        }

    }

    public class QuarryDetector : MonoBehaviour
    {
        private MiningQuarry quarry;
        private bool state;
         void Awake();
         void OnDestroy();
         void CheckMiningQuarry();
         void notifyQuarryStopped(MiningQuarry quarry);
    }

}

private class Configuration
{
    [JsonProperty(PropertyName = "Use permission")]
    public bool UsePermission;
    [JsonProperty(PropertyName = "PermissionAdmin")]
    public string PermissionAdmin;
    [JsonProperty(PropertyName = "Permission for quarry only")]
    public string PermissionUseQuarry;
    [JsonProperty(PropertyName = "Permission for pumpjack only")]
    public string PermissionUsePump;
    [JsonProperty(PropertyName = "Permission bypass global cooldown")]
    public string PermissionBypassCooldown;
    [JsonProperty(PropertyName = "Allow access to quarry without permission (will not lock)")]
    public bool UseQuarryWithoutPermission;
    [JsonProperty(PropertyName = "Enable for mining quarry")]
    public bool enableMiningQuarry;
    [JsonProperty(PropertyName = "Enable for pump jack")]
    public bool enablePumpJack;
    [JsonProperty(PropertyName = "Enable player quarry")]
    public bool enablePlayerQuarry;
    [JsonProperty(PropertyName = "Enable player pumpjack")]
    public bool enablePlayerPump;
    [JsonProperty(PropertyName = "CoolDown before releasing mining quarry (min)")]
    public float CoolDown;
    [JsonProperty(PropertyName = "Send quarry available message to all")]
    public bool MessageAll;
    [JsonProperty(PropertyName = "Enable engine loot after it is started, to add fuel")]
    public bool engineloot;
    [JsonProperty(PropertyName = "Use Teams")]
    public bool UseTeams;
    [JsonProperty(PropertyName = "Use Clans plugin")]
    public bool UseClans;
    [JsonProperty(PropertyName = "Use clan table")]
    public bool UseClanTable;
    [JsonProperty(PropertyName = "Use DynamicPVP to disable lock in PVP zones")]
    public bool UseDynamicPVP;
    [JsonProperty(PropertyName = "CoolDown in min. before a player or team can restart the quarry (0 is disabled)")]
    public float PlayerCoolDown;
    [JsonIgnore]
    public float _PlayerCoolDown;
    [JsonProperty(PropertyName = "Usage cooldown to all quarry")]
    public bool CoolDownGlobal;
    [JsonProperty(PropertyName = "Maximum stack size for diesel engine (-1 to disable function)")]
    public int DieselFuelMaxStackSize;
    [JsonProperty(PropertyName = "Number of slots for diesel storage (-1 to disable function)")]
    public int FuelSlots;
    [JsonProperty(PropertyName = "Number of slots for output storage (-1 to disable function)")]
    public int HopperSlots;
    [JsonProperty(PropertyName = "Time per barrel of diesel in second (-1 to disable function, default time 125 sec)")]
    public int TimePerBarrel;
    [JsonProperty(PropertyName = "quarry chat command")]
    public string quarryquerry;
    [JsonProperty(PropertyName = "Quarry clear status")]
    public string quarryclearstatus;
    [JsonProperty(PropertyName = "Quarry stop command")]
    public string quarrystopcommand;
    [JsonProperty(PropertyName = "Empty the output hopper when quarry/pumpjack start")]
    public bool FlushOutputHopper;
    [JsonProperty(PropertyName = "Clear quarry lock after all player from team/clan disconnect")]
    public bool ClearQuarryLockOnAllTeamDisconnect;
    [JsonProperty(PropertyName = "Clear quarry lock after player owner disconnect")]
    public bool ClearQuarryLockOnPlayerOwnerDisconnect;
    [JsonProperty(PropertyName = "Time after all player disconnect before quarry clear (minutes)")]
    public long CooldownQuarryLockOnDisconnect;
    [JsonProperty(PropertyName = "Items in report list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] ReportItems;
    [JsonProperty("Use Discord hook")]
    public bool Discordena;
    [JsonProperty("Use Discord timestamp")]
    public bool UseDiscordTimestamp;
    [JsonProperty("Discord hook url")]
    public string DiscordHookUrl;
    [JsonProperty(PropertyName = "Use Notify plugin")]
    public bool useNotify;
    [JsonProperty(PropertyName = "Debug")]
    public bool Debug;
    [JsonProperty(PropertyName = "Log to file")]
    public bool LogToFile;
}

private class QuarryInfo
{
    public ulong playerid;
    public string displayName;
    public string ShortPrefabName;
    [JsonIgnore]
    public string readablename;
    [JsonIgnore]
    public miningtype type;
    [JsonIgnore]
    public double FuelTimeRemaining;
    public bool state;
    public bool EnableLock;
    public DateTime checkfueltime;
    public DateTime stoptime;
    public string Name;
    public float processRate;
    public Dictionary<ulong, CooldownTime> PlayerCooldown;
    [JsonIgnore]
    public DateTime PlayerDisconnectTime;
    [JsonIgnore]
    public int CountTick;
    [JsonIgnore]
    public MiningQuarry Quarry;
    [JsonIgnore]
    public Timer timerQuarryStopped;
    public QuarryInfo();
}

public class CooldownTime
{
    public bool IsOnline;
    public bool IgnoreOnline;
    public DateTime Time;
    public CooldownTime();
}

private class DiscordComponent : MonoBehaviour
{
    private const float PostDelay;
    public long MsgCooldown;
    private readonly Queue<object> _queue;
    private string _url;
    private bool _busy;
    public DiscordComponent Configure(string url);
    public DiscordComponent SendTextMessage(string message, object[] args);
    private DiscordComponent AddQueue(object request);
    private IEnumerator ProcessQueue();
    private IEnumerator ProcessRequest(object request);
    private class MessageRequest
    {
        [JsonProperty("content")]
        public string Content { get; set; }
        public MessageRequest(string content);
    }

}

private class MessageRequest
{
    [JsonProperty("content")]
    public string Content { get; set; }
    public MessageRequest(string content);
}

public class QuarryDetector : MonoBehaviour
{
    private MiningQuarry quarry;
    private bool state;
     void Awake();
     void OnDestroy();
     void CheckMiningQuarry();
     void notifyQuarryStopped(MiningQuarry quarry);
}


```

---

## PumpkinBombs by k1lly0u - Turns pumpkins into explosive Jack'O'Lanterns

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Newtonsoft.Json;

Oxide.Plugins
[Info("PumpkinBombs", "k1lly0u", "0.1.2", ResourceId = 2070)]
 class PumpkinBombs : RustPlugin
{
    static PumpkinBombs ins;
    private Dictionary<string, ItemDefinition> itemDefs;
    private List<ulong> craftedBombs;
    const string jackAngry;
    const string jackHappy;
     void Loaded();
     void OnServerInitialized();
     void OnPlayerDisconnected(BasePlayer player);
     void OnEntitySpawned(BaseNetworkable entity);
     bool CanUse(BasePlayer player);
     bool IsFree(BasePlayer player);
    private bool HasEnoughRes(BasePlayer player, int itemid, int amount);
    private void TakeResources(BasePlayer player, int itemid, int amount);
     class BombLight : MonoBehaviour
    {
        private BaseOven entity;
        private bool lastOn;
        public void Awake();
        public void OnDestroy();
        private void ToggleLight();
    }

    [ChatCommand("pb")]
     void cmdPB(BasePlayer player, string command, string[] args);
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Explosive Settings")]
        public Explosive Explosives { get; set; }
        [JsonProperty(PropertyName = "Crafting Costs")]
        public List<CraftCost> Costs { get; set; }
        [JsonProperty(PropertyName = "Message Color (hex)")]
        public string Main { get; set; }
        public class CraftCost
        {
            [JsonProperty(PropertyName = "Item shortname")]
            public string Name;
            [JsonProperty(PropertyName = "Amount required")]
            public int Amount;
        }

        public class Explosive
        {
            [JsonProperty(PropertyName = "Detonation timer (seconds)")]
            public int Timer { get; set; }
            [JsonProperty(PropertyName = "Explosive radius")]
            public float Radius { get; set; }
            [JsonProperty(PropertyName = "Damage amount")]
            public float Amount { get; set; }
        }

    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     string msg(string key, string id);
     Dictionary<string, string> Messages;
}

 class BombLight : MonoBehaviour
{
    private BaseOven entity;
    private bool lastOn;
    public void Awake();
    public void OnDestroy();
    private void ToggleLight();
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Explosive Settings")]
    public Explosive Explosives { get; set; }
    [JsonProperty(PropertyName = "Crafting Costs")]
    public List<CraftCost> Costs { get; set; }
    [JsonProperty(PropertyName = "Message Color (hex)")]
    public string Main { get; set; }
    public class CraftCost
    {
        [JsonProperty(PropertyName = "Item shortname")]
        public string Name;
        [JsonProperty(PropertyName = "Amount required")]
        public int Amount;
    }

    public class Explosive
    {
        [JsonProperty(PropertyName = "Detonation timer (seconds)")]
        public int Timer { get; set; }
        [JsonProperty(PropertyName = "Explosive radius")]
        public float Radius { get; set; }
        [JsonProperty(PropertyName = "Damage amount")]
        public float Amount { get; set; }
    }

}

public class CraftCost
{
    [JsonProperty(PropertyName = "Item shortname")]
    public string Name;
    [JsonProperty(PropertyName = "Amount required")]
    public int Amount;
}

public class Explosive
{
    [JsonProperty(PropertyName = "Detonation timer (seconds)")]
    public int Timer { get; set; }
    [JsonProperty(PropertyName = "Explosive radius")]
    public float Radius { get; set; }
    [JsonProperty(PropertyName = "Damage amount")]
    public float Amount { get; set; }
}


```

---

## Punish by MrBlue - Punish players for various actions/events

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Punish", "Wulf", "1.1.1")]
[Description("Punish players for various actions/events")]
public class Punish : CovalencePlugin
{
    private Configuration config;
    public class Punishment
    {
        [JsonProperty("Enable punishment")]
        public bool Enable;
        [JsonProperty("Ban as punishment")]
        public bool Ban;
        [JsonProperty("Hurt as punishment")]
        public float Hurt;
        [JsonProperty("Kick as punishment")]
        public bool Kick;
        [JsonProperty("Slap as punishment")]
        public bool Slap;
        [JsonProperty("Amount of damage per slap")]
        public int SlapDamage;
        [JsonProperty("Intensity of each slap")]
        public int SlapIntensity;
        [JsonProperty("Number of times to slap")]
        public int SlapAmount;
        [JsonProperty("Economics withdrawl")]
        public bool Economics;
        [JsonProperty("Economics amount")]
        public int EconomicsAmount;
        [JsonProperty("Server Rewards withdrawl")]
        public bool ServerRewards;
        [JsonProperty("Server Rewards amount")]
        public int ServerRewardsAmount;
    }

    public class Configuration
    {
        [JsonProperty("Punish for dying")]
        public Punishment PunishmentDeath;
        [JsonProperty("Punish for killing other players")]
        public Punishment PunishmentPvPDeath;
        [JsonProperty("Include actions from NPCs")]
        public bool IncludeNPCs;
        [JsonProperty("Use permission system")]
        public bool UsePermissions;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    [PluginReference]
    private Plugin Economics;
    private Plugin ServerRewards;
    private Plugin Jail;
    private Plugin Slap;
    private const string permExclude;
    private void Init();
    private void PunishPlayer(Punishment punishment, IPlayer player, string reason);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string textOrLang, object[] args);
}

public class Punishment
{
    [JsonProperty("Enable punishment")]
    public bool Enable;
    [JsonProperty("Ban as punishment")]
    public bool Ban;
    [JsonProperty("Hurt as punishment")]
    public float Hurt;
    [JsonProperty("Kick as punishment")]
    public bool Kick;
    [JsonProperty("Slap as punishment")]
    public bool Slap;
    [JsonProperty("Amount of damage per slap")]
    public int SlapDamage;
    [JsonProperty("Intensity of each slap")]
    public int SlapIntensity;
    [JsonProperty("Number of times to slap")]
    public int SlapAmount;
    [JsonProperty("Economics withdrawl")]
    public bool Economics;
    [JsonProperty("Economics amount")]
    public int EconomicsAmount;
    [JsonProperty("Server Rewards withdrawl")]
    public bool ServerRewards;
    [JsonProperty("Server Rewards amount")]
    public int ServerRewardsAmount;
}

public class Configuration
{
    [JsonProperty("Punish for dying")]
    public Punishment PunishmentDeath;
    [JsonProperty("Punish for killing other players")]
    public Punishment PunishmentPvPDeath;
    [JsonProperty("Include actions from NPCs")]
    public bool IncludeNPCs;
    [JsonProperty("Use permission system")]
    public bool UsePermissions;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## PunishFF by collectvood - Punish players for attacking their friends, or victim with permission with a strike back

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Punish Friendly Fire", "collect_vood", "1.2.1")]
[Description("Punish player by X% of the damage done to friends.")]
public class PunishFF : CovalencePlugin
{
    [PluginReference]
    private Plugin FriendlyFire;
    protected override void LoadDefaultMessages();
    private ConfigurationFile Configuration;
    private class ConfigurationFile
    {
        [JsonProperty(PropertyName = "Percentage of damage to punish")]
        public int PercentagePunish;
        [JsonProperty(PropertyName = "Only punish damage on players with permission")]
        public bool OnlyPunishPermission;
        [JsonProperty(PropertyName = "Give damage permission")]
        public string GivePermission;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Init();
    private void OnFriendAttacked(IPlayer attacker, IPlayer victim, HitInfo info);
    private string GetMessage(string key, IPlayer player, string[] args);
    private bool HasPermission(IPlayer player);
}

private class ConfigurationFile
{
    [JsonProperty(PropertyName = "Percentage of damage to punish")]
    public int PercentagePunish;
    [JsonProperty(PropertyName = "Only punish damage on players with permission")]
    public bool OnlyPunishPermission;
    [JsonProperty(PropertyName = "Give damage permission")]
    public string GivePermission;
}


```

---

## Purge by MrBlue - Allows damage and killing only between specified hours

```csharp
using System;
using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("Purge", "Wulf/lukespragg", "1.2.2", ResourceId = 1102)]
[Description("Allows damage and killing only between specific in-game hours")]
 class Purge : CovalencePlugin
{
    const string permAllow;
    const string permProtect;
     bool configChanged;
     bool purgeActive;
     bool purgeAnimal;
     bool purgeHeli;
     bool purgeLoot;
     bool purgeStructure;
     bool purgeTurret;
     bool purgeWorld;
     bool realTime;
     bool safeAnimal;
     bool safeHeli;
     bool safeLoot;
     bool safeStructure;
     bool safeTurret;
     bool safeWorld;
     TimeSpan purgeBegin;
     TimeSpan purgeEnd;
    protected override void LoadDefaultConfig();
     void OnServerInitialized();
     void LoadDefaultMessages();
     bool PurgeTime { get; set; }
     void OnTick();
     void OnEntityTakeDamage(BaseEntity entity, HitInfo info);
     T GetConfig(string parent, string key, T defaultValue);
     T GetConfig(string key, T defaultValue);
     string Lang(string key, string id, object[] args);
     void Broadcast(string key, object[] args);
}


```

---

## PurifierConfig by Shady - Allows configuration of Water Purifiers

```csharp
using System;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Purifier Config", "Shady", "1.0.4", ResourceId = 1911)]
[Description("Tweak settings for water purifiers.")]
 class PurifierConfig : RustPlugin
{
     bool init;
     int WPM;
     int WaterRatio;
    protected override void LoadDefaultConfig();
     void OnServerInitialized();
     void Init();
     void OnEntitySpawned(BaseNetworkable entity);
     void ConfigurePurifier(WaterPurifier purifier);
     T GetConfig(string name, T defaultValue);
}


```

---

## PushAPI by MrBlue - API for sending messages via various mobile notification services

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;

Oxide.Plugins
[Info("PushAPI", "Wulf/lukespragg", "1.0.1", ResourceId = 705)]
[Description("API for sending messages via various mobile notification services")]
 class PushAPI : CovalencePlugin
{
     Dictionary<string, string> pushbulletHeaders;
    const string pushalotUrl;
    const string pushbulletUrl;
    const string pushoverUrl;
    static string pushalotToken;
    static string pushbulletToken;
    static string pushoverAppKey;
    static string pushoverUserKey;
    static string serviceName;
    protected override void LoadDefaultConfig();
     void Init();
     void PushMessage(string title, string message, string priority, Action<bool> callback);
     class PushalotMessage
    {
        public string Title { get; set; }
        public string Body { get; set; }
        public bool IsImportant { get; set; }
        public bool IsQuiet { get; set; }
        public string QueryString();
    }

     void Pushalot(string title, string message, string priority, Action<bool> callback);
     bool ErrorHandling(PushalotMessage payload);
     class PushbulletNote
    {
        public string title { get; set; }
        public string body { get; set; }
        public string type { get; set; }
        public string QueryString();
    }

     class PushbulletFile : PushbulletNote
    {
        public string file_name { get; set; }
        public string file_type { get; set; }
        public string file_url { get; set; }
        public new string QueryString();
    }

     void Pushbullet(string title, string message, Action<bool> callback);
     void Pushbullet(string title, string message, string fileUrl, string fileName, string fileType, Action<bool> callback);
     bool ErrorHandling(PushbulletNote payload, Action<bool> callback);
     bool ErrorHandling(PushbulletFile payload, Action<bool> callback);
     class PushoverMessage
    {
        public string title { get; set; }
        public string message { get; set; }
        public string priority { get; set; }
        public string sound { get; set; }
        public string QueryString();
    }

     void Pushover(string title, string message, string priority, string sound, Action<bool> callback);
     bool ErrorHandling(PushoverMessage payload, Action<bool> callback);
     void WebRequest(string url, string body, Action<bool> callback, Dictionary<string, string> headers);
     T GetConfig(string name, T value);
}

 class PushalotMessage
{
    public string Title { get; set; }
    public string Body { get; set; }
    public bool IsImportant { get; set; }
    public bool IsQuiet { get; set; }
    public string QueryString();
}

 class PushbulletNote
{
    public string title { get; set; }
    public string body { get; set; }
    public string type { get; set; }
    public string QueryString();
}

 class PushbulletFile : PushbulletNote
{
    public string file_name { get; set; }
    public string file_type { get; set; }
    public string file_url { get; set; }
    public new string QueryString();
}

 class PushoverMessage
{
    public string title { get; set; }
    public string message { get; set; }
    public string priority { get; set; }
    public string sound { get; set; }
    public string QueryString();
}


```

---

## PuzzleBypass by  - Allows players to pass through security doors using only a keycard

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Puzzle Bypass", "Def", "1.0.0")]
[Description("Allows players to pass through security doors using only a keycard")]
public class PuzzleBypass : RustPlugin
{
    private Cfg _cfg;
    private static readonly Dictionary<uint, int> DoorToKeyLevelMap;
    private static readonly List<string> KeyToLang;
    private class Cfg
    {
        [JsonProperty("Door close delay, if opened from Outside (seconds)")]
        public int CloseDelayOutside;
        [JsonProperty("Door close delay, if opened from Inside (seconds)")]
        public int CloseDelayInside;
        [JsonProperty("How much condition key card will lose when used (default 1)")]
        public float LoseConditionAmt;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private string _(string key, BasePlayer player, object[] args);
    private void OnDoorKnocked(Door door, BasePlayer player);
    private void Unload();
    private void OpenSecurityDoor(Door door, int closeIn);
    private string GetNiceCardName(int aLevel, BasePlayer player);
}

private class Cfg
{
    [JsonProperty("Door close delay, if opened from Outside (seconds)")]
    public int CloseDelayOutside;
    [JsonProperty("Door close delay, if opened from Inside (seconds)")]
    public int CloseDelayInside;
    [JsonProperty("How much condition key card will lose when used (default 1)")]
    public float LoseConditionAmt;
}


```

---

## PuzzleChainRepair by  - Provide puzzle chain repair with detail log and not allow players to destroy IO entities

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Facepunch;
using Oxide.Core;

Oxide.Plugins
[Info("PuzzleChainRepair", "bazuka5801/Misstake", "1.1.0")]
public class PuzzleChainRepair : RustPlugin
{
    [ConsoleCommand("puzzlerepair")]
     void cmdPuzzleFix(ConsoleSystem.Arg arg);
}


```

---

## PuzzlePoints by rustonauts - Rewards players for swiping puzzle cards with any item(s) and amount.

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;
using System;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using Oxide.Core.Libraries;

Oxide.Plugins
[Info("Puzzle Points", "Rustonauts", "1.6.3")]
[Description("Rewards players with scrap, economics, or RP for swiping puzzle cards and completing missions. Broadcasting this is defaulted true.")]
 class PuzzlePoints : RustPlugin
{
    [PluginReference]
    private Plugin Economics;
    private Plugin ServerRewards;
    private Plugin MonumentLock;
    private Plugin MonumentNames;
    private Plugin SuperCard;
    private Dictionary<int, string> CardTypes;
    private List<Dictionary<string, object>> _monuments;
    private void Init();
    private void OnServerInitialized();
    public Configuration _config;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected void LoadDefaultRewards(Configuration config);
    private void UpdateConfigValues();
    private void UpdateConfigValues157(Configuration c);
    private void SaveConfig();
    public class SwipeReward
    {
        public int access_level;
        public string? reward_item_shortname;
        public int reward_item_id;
        public double amount;
        public bool is_active;
        public string name;
        public SwipeReward(int cardAccess, double _amount, string _name, string shortname, int id, bool _is_active);
        public SwipeReward();
    }

    public class Configuration
    {
        [JsonIgnore]
        public bool? useEconomics;
        [JsonIgnore]
        public bool? useServerRewards;
        [JsonIgnore]
        public bool? useScrap;
        [JsonIgnore]
        public int? redCardScrap;
        [JsonIgnore]
        public int? blueCardScrap;
        [JsonIgnore]
        public int? greenCardScrap;
        [JsonIgnore]
        public int? redCardRP;
        [JsonIgnore]
        public int? blueCardRP;
        [JsonIgnore]
        public int? greenCardRP;
        [JsonIgnore]
        public double? redCardMoney;
        [JsonIgnore]
        public double? blueCardMoney;
        [JsonIgnore]
        public double? greenCardMoney;
        [JsonProperty(PropertyName = "Show Console Messages")]
        public bool consoleMessages;
        [JsonProperty(PropertyName = "Show Global Chat Monument Messages (eg. Player swipped card at Launch)")]
        public bool broadcastSwipe;
        [JsonIgnore]
        public bool? debugMode;
        [JsonProperty(PropertyName = "Cooldown: Amount of time (secs) a player must wait before getting rewarded to avoid swipe spam")]
        public int cooldown;
        [JsonProperty(PropertyName = "Swipe Rewards")]
        public List<SwipeReward> rewards;
        public VersionNumber Version;
        public Configuration();
    }

    private StoredData storedData;
    public class MSession
    {
        [JsonProperty("Player Id")]
        public string player_id;
        [JsonProperty("Monument ShortName")]
        public string monument_shortname;
        [JsonProperty("Card Access Level")]
        public int access_level;
        [JsonProperty("Session started_at")]
        private string started_at;
        public MSession(string _player_id, int _access_level, string _monument_shortname);
        public string GetPlayerId();
        public BasePlayer GetPlayer(string _player_id);
        public bool InCooldown(int _cooldown);
    }

    private class StoredData
    {
        public List<MSession> m_sessions { get; set; }
        public StoredData();
        public StoredData(List<MSession> _sessions);
    }

    private void LoadData();
    private void SaveData(bool show_console);
    private void ClearData();
     object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player);
    private bool IsInCooldown(BasePlayer player, Keycard card);
    private void Reward(BasePlayer player, Keycard card);
    private void BroadcastSwipe(BasePlayer player, string cardType);
    private string GetClosestMonument(BasePlayer _player);
    private string GetShortName(string prefab_name);
    private MSession GetSession(BasePlayer player, Keycard card);
    private void BroadcastToChat(string langkey, object[] args);
    private string GetDisplayName(string _shortName);
    private bool UseMonumentNames();
    private bool UseEconomics();
    private bool UseRewards();
    private string GetGridPosition(Vector3 position);
    private string GetLang(string langKey, string playerId, object[] args);
    protected override void LoadDefaultMessages();
}

public class SwipeReward
{
    public int access_level;
    public string? reward_item_shortname;
    public int reward_item_id;
    public double amount;
    public bool is_active;
    public string name;
    public SwipeReward(int cardAccess, double _amount, string _name, string shortname, int id, bool _is_active);
    public SwipeReward();
}

public class Configuration
{
    [JsonIgnore]
    public bool? useEconomics;
    [JsonIgnore]
    public bool? useServerRewards;
    [JsonIgnore]
    public bool? useScrap;
    [JsonIgnore]
    public int? redCardScrap;
    [JsonIgnore]
    public int? blueCardScrap;
    [JsonIgnore]
    public int? greenCardScrap;
    [JsonIgnore]
    public int? redCardRP;
    [JsonIgnore]
    public int? blueCardRP;
    [JsonIgnore]
    public int? greenCardRP;
    [JsonIgnore]
    public double? redCardMoney;
    [JsonIgnore]
    public double? blueCardMoney;
    [JsonIgnore]
    public double? greenCardMoney;
    [JsonProperty(PropertyName = "Show Console Messages")]
    public bool consoleMessages;
    [JsonProperty(PropertyName = "Show Global Chat Monument Messages (eg. Player swipped card at Launch)")]
    public bool broadcastSwipe;
    [JsonIgnore]
    public bool? debugMode;
    [JsonProperty(PropertyName = "Cooldown: Amount of time (secs) a player must wait before getting rewarded to avoid swipe spam")]
    public int cooldown;
    [JsonProperty(PropertyName = "Swipe Rewards")]
    public List<SwipeReward> rewards;
    public VersionNumber Version;
    public Configuration();
}

public class MSession
{
    [JsonProperty("Player Id")]
    public string player_id;
    [JsonProperty("Monument ShortName")]
    public string monument_shortname;
    [JsonProperty("Card Access Level")]
    public int access_level;
    [JsonProperty("Session started_at")]
    private string started_at;
    public MSession(string _player_id, int _access_level, string _monument_shortname);
    public string GetPlayerId();
    public BasePlayer GetPlayer(string _player_id);
    public bool InCooldown(int _cooldown);
}

private class StoredData
{
    public List<MSession> m_sessions { get; set; }
    public StoredData();
    public StoredData(List<MSession> _sessions);
}


```

---

## PVPCaps by WhiteDragon - PvP handicap and anti-cheat system

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("PVP Caps", "WhiteDragon", "1.1.5")]
[Description("Applies a PvP damage handicap to players, based on PvP kills/deaths.")]
internal class PVPCaps : RustPlugin
{
    internal static PVPCaps instance;
    private static bool config_changed;
    private static Configuration config;
    private static Dictionary<ulong, List<AttackInfo>> attacks;
    private static Dictionary<ulong, ulong> teams;
    private static DB db;
    private const string PERMISSIONADMIN;
    private const string PERMISSIONEXCLUDED;
    private const string PERMISSIONUSE;
    private const string MAP_LABEL;
    private const string MAP_ICON;
    protected readonly Dictionary<int, WeaponStats> weapons;
    internal class AddressInfo
    {
        public List<ulong> userid;
        public bool whitelist;
    }

    internal class AttackInfo
    {
        public DateTime time;
        public ulong userid;
        public double penalty;
    }

    internal class DB
    {
        public Dictionary<ulong, Handicap> handicaps;
        public Dictionary<string, AddressInfo> ip_table;
        public DB();
    }

    internal class Fire : MonoBehaviour
    {
        public BaseEntity Initiator;
    }

    internal class Handicap
    {
        public string display_name;
        public double damage_amount;
        public DateTime decay_timer;
        public DateTime online_time;
        public ulong warning_count;
        public DateTime warning_time;
        public ulong cripple_count;
        public DateTime cripple_timer;
        public bool crippled;
        public ulong ban_count;
        public DateTime ban_timer;
        public bool banned;
        public void processDeath(double penalty);
        public void processKill(double penalty);
    }

    internal class WeaponStats
    {
        public double accuracy;
        public double aim_sway;
        public double aimcone;
        public bool aimcone_degrees;
        public double aimcone_hip;
        public double attachments;
        public double attack_rate;
        public double attack_size;
        public double blast_radius;
        public double capacity;
        public double damage;
        public string displayname;
        public double draw;
        public double dud_chance;
        public double explosive_dmg;
        public double fuse_length_min;
        public double fuse_length_max;
        public double lethality;
        public bool melee;
        public double range;
        public double recoil;
        public double reload;
        public string shortname;
        public double throw_distance;
        public bool thrown;
        public double velocity;
        public double zoom;
    }

    internal class Configuration
    {
        public ulong config_version;
        public bool general_pvp_enabled;
        public bool general_pvp_ff_enabled;
        public bool general_pvp_team_scale;
        public double handicap_assist_scale;
        public ulong handicap_ban_count;
        public ulong handicap_ban_time;
        public double handicap_build_authed;
        public ulong handicap_cripple_count;
        public double handicap_cripple_limit;
        public ulong handicap_cripple_time;
        public double handicap_damage_max;
        public double handicap_damage_min;
        public double handicap_decay_amount;
        public ulong handicap_decay_time;
        public double handicap_killer_scale;
        public double handicap_penalty_head;
        public double handicap_penalty_chest;
        public double handicap_penalty_arm;
        public double handicap_penalty_stomach;
        public double handicap_penalty_leg;
        public double handicap_penalty_hand;
        public double handicap_penalty_foot;
        public double handicap_penalty_generic;
        public double handicap_movement_rate;
        public double handicap_range_normal;
        public ulong handicap_warning_count;
        public double handicap_warning_limit;
        public bool output_console;
        public bool output_logfile;
        public static Configuration Defaults();
    }

    private void CheckRange(double value, double min, double max);
    private void CheckRange(ulong value, ulong min, ulong max);
    protected override void LoadDefaultConfig();
    private void LoadConfiguration();
    private void SaveConfiguration();
    private const string c_assist;
    private const string c_auto_ban_cripple_count;
    private const string c_auto_ban_inherited;
    private const string c_ban_no_reason;
    private const string c_error_bad_config;
    private const string c_killer;
    private const string c_pvp_admin_banned_perm;
    private const string c_pvp_admin_banned_time;
    private const string c_pvp_admin_crippled_perm;
    private const string c_pvp_admin_crippled_time;
    private const string c_status;
    private const string c_victim;
    private const string m_error_admin_ipshare;
    private const string m_error_admin_syntax;
    private const string m_error_no_permission;
    private const string m_handicap_admin;
    private const string m_prefix;
    private const string m_pvp_admin_ambiguous;
    private const string m_pvp_admin_ban;
    private const string m_pvp_admin_cripple;
    private const string m_pvp_admin_disabled;
    private const string m_pvp_admin_disabled_reason;
    private const string m_pvp_admin_enabled;
    private const string m_pvp_admin_ff_disabled;
    private const string m_pvp_admin_ff_enabled;
    private const string m_pvp_admin_ipshare_list;
    private const string m_pvp_admin_ipshare_off;
    private const string m_pvp_admin_ipshare_on;
    private const string m_pvp_admin_modifier;
    private const string m_pvp_admin_not_crippled;
    private const string m_pvp_admin_not_handicapped;
    private const string m_pvp_admin_not_found;
    private const string m_pvp_admin_reset;
    private const string m_pvp_admin_reset_all;
    private const string m_pvp_admin_team_disabled;
    private const string m_pvp_admin_team_enabled;
    private const string m_pvp_admin_team_list;
    private const string m_pvp_admin_unban;
    private const string m_pvp_admin_unban_all;
    private const string m_pvp_admin_uncripple;
    private const string m_pvp_admin_uncripple_all;
    private const string m_pvp_admin_warning;
    private const string m_pvp_damage_decrease;
    private const string m_pvp_damage_increase;
    private const string m_pvp_damage_modifier;
    private const string m_pvp_ff_is_disabled;
    private const string m_pvp_ff_is_enabled;
    private const string m_pvp_is_disabled;
    private const string m_pvp_is_enabled;
    private const string m_pvp_team_is_disabled;
    private const string m_pvp_team_is_enabled;
    private const string m_suffix;
    private readonly Dictionary<string, string> messages;
    internal static void ChatMessage(BasePlayer player, string key, object[] args);
    internal static void ChatMessageAdmin(string key, object[] args);
    internal static void ChatMessageBroadcast(string key, object[] args);
    internal static string CrippleStatus(ulong userid, string admin_id);
    internal static string DamagePercent(ulong userid);
    internal static string HandicapInfoAdmin(ulong userid, string admin_id);
    internal static string HandicapInfoConsole(string key, ulong userid);
    protected static string GetMessage(string key, string userid, object[] args);
    protected static string GetMessagePlain(string key);
    protected override void LoadDefaultMessages();
    internal static void LogMessage(string key, object[] args);
    internal static string NameAndID(ulong userid);
    internal static string ToPlaintext(string message);
    [ChatCommand("pvp")]
    private void ChatCmdPvP(BasePlayer player, string cmd, string[] args);
    [ConsoleCommand("pvp")]
    private void ConsoleCmdPvp(ConsoleSystem.Arg arg);
    internal void AdminBan(string admin_name, ulong userid, ulong duration, string reason, bool console);
    internal void AdminBanInherited(string admin_name, ulong userid);
    internal void AdminCripple(string admin_name, ulong userid, ulong duration, bool console);
    internal void AdminReset(string admin_name, ulong userid, bool silent, bool console);
    internal void AdminUnban(string admin_name, ulong userid, bool silent, bool console);
    internal void AdminUncripple(string admin_name, ulong userid, bool silent, bool console);
    internal bool AutoBanCountReached(ulong userid);
    internal bool AutoCrippleCountReached(ulong userid);
    internal bool AutoWarningCountReached(ulong userid);
    internal bool CanLoot(BasePlayer looter, ulong target);
    internal object CanLootHelper(BasePlayer looter, ulong target);
    internal void DBLoad();
    internal void DBStore();
    internal void ExecuteBan(string user, string reason);
    internal void ExecuteUnban(string user);
    internal string FindIPAddress(ulong userid);
    internal List<ulong> FindPlayer(string input);
    internal double GetHitPenalty(BasePlayer attacker, BasePlayer victim, HitInfo info);
    internal double GetSpeedModifier(double speed_a, double speed_b, double normal);
    internal void HandicapsDecay();
    internal void OnLootHelper(BasePlayer looter, ulong target);
    internal bool ParseDurationAndReason(string[] args, int offset, ulong duration, string reason);
    internal static double TeamDamageModifier(BasePlayer victim, BasePlayer attacker);
    internal static List<ulong> TeamList(ulong userid);
    internal static ulong TeamMembersOnline(ulong teamid);
    internal void TeamMonitor();
    internal void WorkTimer();
    private object CanLootEntity(BasePlayer looter, DroppedItemContainer target);
    private object CanLootEntity(BasePlayer looter, LootableCorpse target);
    private object CanLootPlayer(BasePlayer target, BasePlayer looter);
    private void Init();
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo info);
    private void OnFireBallSpread(FireBall fireball, BaseEntity entity);
    private void OnFlameExplosion(FlameExplosive explosive, BaseEntity entity);
    private void OnFlameThrowerBurn(FlameThrower flamethrower, BaseEntity entity);
    private void OnLootEntity(BasePlayer looter, BaseEntity target);
    private void OnLootPlayer(BasePlayer looter, BasePlayer target);
     object OnMeleeAttack(BasePlayer attacker, HitInfo info);
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerConnected(ulong userid, string name);
    private void OnServerInitialized();
    private void OnServerSave();
    private void OnUserBanned(string name, string userid_string, string ip, string reason);
    private void OnUserUnbanned(string name, string userid_string, string ip);
    private void OnWeaponFired(BaseProjectile weapon, BasePlayer attacker, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles);
    private void Unload();
}

internal class AddressInfo
{
    public List<ulong> userid;
    public bool whitelist;
}

internal class AttackInfo
{
    public DateTime time;
    public ulong userid;
    public double penalty;
}

internal class DB
{
    public Dictionary<ulong, Handicap> handicaps;
    public Dictionary<string, AddressInfo> ip_table;
    public DB();
}

internal class Fire : MonoBehaviour
{
    public BaseEntity Initiator;
}

internal class Handicap
{
    public string display_name;
    public double damage_amount;
    public DateTime decay_timer;
    public DateTime online_time;
    public ulong warning_count;
    public DateTime warning_time;
    public ulong cripple_count;
    public DateTime cripple_timer;
    public bool crippled;
    public ulong ban_count;
    public DateTime ban_timer;
    public bool banned;
    public void processDeath(double penalty);
    public void processKill(double penalty);
}

internal class WeaponStats
{
    public double accuracy;
    public double aim_sway;
    public double aimcone;
    public bool aimcone_degrees;
    public double aimcone_hip;
    public double attachments;
    public double attack_rate;
    public double attack_size;
    public double blast_radius;
    public double capacity;
    public double damage;
    public string displayname;
    public double draw;
    public double dud_chance;
    public double explosive_dmg;
    public double fuse_length_min;
    public double fuse_length_max;
    public double lethality;
    public bool melee;
    public double range;
    public double recoil;
    public double reload;
    public string shortname;
    public double throw_distance;
    public bool thrown;
    public double velocity;
    public double zoom;
}

internal class Configuration
{
    public ulong config_version;
    public bool general_pvp_enabled;
    public bool general_pvp_ff_enabled;
    public bool general_pvp_team_scale;
    public double handicap_assist_scale;
    public ulong handicap_ban_count;
    public ulong handicap_ban_time;
    public double handicap_build_authed;
    public ulong handicap_cripple_count;
    public double handicap_cripple_limit;
    public ulong handicap_cripple_time;
    public double handicap_damage_max;
    public double handicap_damage_min;
    public double handicap_decay_amount;
    public ulong handicap_decay_time;
    public double handicap_killer_scale;
    public double handicap_penalty_head;
    public double handicap_penalty_chest;
    public double handicap_penalty_arm;
    public double handicap_penalty_stomach;
    public double handicap_penalty_leg;
    public double handicap_penalty_hand;
    public double handicap_penalty_foot;
    public double handicap_penalty_generic;
    public double handicap_movement_rate;
    public double handicap_range_normal;
    public ulong handicap_warning_count;
    public double handicap_warning_limit;
    public bool output_console;
    public bool output_logfile;
    public static Configuration Defaults();
}


```

---

## PVPIndicator by  - Makes logo on entering PVP zones or PVP mode

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("PVPIndicator", "Orange", "1.2.0")]
[Description("Makes logo on entering PVP zones or PVP mode")]
public class PVPIndicator : RustPlugin
{
    [PluginReference]
    private Plugin ZoneManager;
    private void Unload();
    private void OnEnterZone(string ZoneID, BasePlayer player);
    private void OnExitZone(string ZoneID, BasePlayer player);
    private void OnEnd();
    private void CheckZone(string ZoneID, BasePlayer player, bool leave);
    private ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "DynamicPVP settings")]
        public OGUIOptions DynamicPVP;
        public class OGUIOptions
        {
            [JsonProperty(PropertyName = "Mininal Anchor (left bottom coordinate)")]
            public string anchorMin;
            [JsonProperty(PropertyName = "Maximal Anchor (right top coordinate)")]
            public string anchorMax;
            [JsonProperty(PropertyName = "Link to image that will pop up (url)")]
            public string link;
            [JsonProperty(PropertyName = "Color of image")]
            public string color;
        }

    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private const string elem;
    private void DynamicPVPGUI(BasePlayer player);
    private void DestroyGUI(BasePlayer player, string element);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "DynamicPVP settings")]
    public OGUIOptions DynamicPVP;
    public class OGUIOptions
    {
        [JsonProperty(PropertyName = "Mininal Anchor (left bottom coordinate)")]
        public string anchorMin;
        [JsonProperty(PropertyName = "Maximal Anchor (right top coordinate)")]
        public string anchorMax;
        [JsonProperty(PropertyName = "Link to image that will pop up (url)")]
        public string link;
        [JsonProperty(PropertyName = "Color of image")]
        public string color;
    }

}

public class OGUIOptions
{
    [JsonProperty(PropertyName = "Mininal Anchor (left bottom coordinate)")]
    public string anchorMin;
    [JsonProperty(PropertyName = "Maximal Anchor (right top coordinate)")]
    public string anchorMax;
    [JsonProperty(PropertyName = "Link to image that will pop up (url)")]
    public string link;
    [JsonProperty(PropertyName = "Color of image")]
    public string color;
}


```

---

## PVPStats by VisEntities - Provides PVP statistics through in-game chat and console

```csharp
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("PVP Stats", "Dana", "1.4.7")]
 class PVPStats : RustPlugin
{
    static PVPStats ins;
    static Dictionary<ulong, PVPStatsData> cachedPlayerStats;
    private const string AdminPermission;
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void OnPlayerInit(BasePlayer player);
    private void OnPlayerDeath(BasePlayer victim, HitInfo info);
    private void OnServerShutDown();
    private void Unload();
    [ConsoleCommand("stats.wipe")]
    private void WipeStatsCmd(ConsoleSystem.Arg arg);
    [ConsoleCommand("stats.reset")]
    private void ResetStatsCmd(ConsoleSystem.Arg arg);
    [ConsoleCommand("stats")]
    private void ShowStatisticsCmd(ConsoleSystem.Arg arg);
    [ChatCommand("stats")]
    private void cmdShowStatistics(BasePlayer player, string command, string[] args);
    public List<ulong> GetAllPlayers();
    public string GetPlayer(ulong id);
    public void PlayerMsg(BasePlayer player, string msg);
    private class PVPStatsData
    {
        public int Kills;
        public int Deaths;
        public float KDR { get; set; }
        internal static void TryLoad(ulong id);
        internal static void Reset(ulong id);
        internal void Save(ulong id);
    }

    public string msg(string key, ulong playerId);
}

private class PVPStatsData
{
    public int Kills;
    public int Deaths;
    public float KDR { get; set; }
    internal static void TryLoad(ulong id);
    internal static void Reset(ulong id);
    internal void Save(ulong id);
}


```

---

## PvpToggle by 0x89A - Allows PvP to be toggled on and off

```csharp
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("PvP Toggle", "0x89A", "1.1.5")]
[Description("Allows PvP to be toggled on and off ")]
 class PvpToggle : CovalencePlugin
{
    private bool pvpActive;
    private const string canuse;
     void Init();
    protected override void LoadDefaultMessages();
    [Command("pvp")]
     void ConsoleToggle(IPlayer player, string command, string[] args);
     void TogglePvp(IPlayer player, string args);
     object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo);
}


```

---

## PvXSelector by  - Allows PvE/PvP gameplay on the same server

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("PvX Selector", "Alphawar", "0.1.0")]
[Description("Allow players to play both PvP and PvE on the same server.")]
 class PvXSelector : RustPlugin
{
    private readonly string PluginName;
    private HashSet<BaseHelicopter> BaseHelicopters;
    private HashSet<CH47HelicopterAIController> ChinooksHelicopters;
    private HashSet<BradleyAPC> BradleyAPCs;
    private HashSet<FireBall> HeliFireBalls;
    private HashSet<FireBall> HeliRocket;
    private readonly string heliPrefab;
    private readonly string chinookPrefab;
    private readonly int groundLayer;
     bool initialized;
    static readonly string PvxIndicatorUI;
    static readonly string PvxAdminUI;
    static readonly string[] GuiList;
    private ConfigData configData;
     class ConfigData
    {
        public Options Options { get; set; }
        public Gui Gui { get; set; }
    }

    private void LoadVariables();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     class Options
    {
        public bool AllowTickets { get; set; }
        public bool AllowCooldowns { get; set; }
        public float ModeSwitchCooldown { get; set; }
    }

     class Gui
    {
        public bool DisableUI_FadeIn;
        public float playerIndicatorMinWid;
        public float playerIndicatorMinHei;
        public float adminIndicatorMinWid;
        public float adminIndicatorMinHei;
    }

    protected override void LoadDefaultConfig();
    private static PvXSelector PvX;
    private static Dictionary<ulong, PvXPlayer> PvXPlayers;
    private static Dictionary<ulong, double> PvXCooldowns;
    private static Dictionary<int, PvXTicket> PvXTickets;
    private static Dictionary<int, PvXLog> PvXLogs;
    private static readonly List<object> BuildEntityList;
    private static readonly List<object> BasePartEntityList;
    private static readonly List<object> CombatPartEntityList;
    private static readonly List<object> AnimalList;
    private static List<ulong> AdminsActive;
    private static List<ulong> AdminsOnline;
    private static Dictionary<ulong,PvXTicket> AdminViewedTicket;
     TicketDataManager ticketManager;
     PlayerDataManager playerManager;
     LogDataManager logManager;
    private class PvXPlayer
    {
        public string Username { get; set; }
        public string ConnectionFirst { get; set; }
        public string ConnectionLast { get; set; }
        public PvXState State { get; set; }
        public PvXNotification Notification { get; set; }
        public int TicketID { get; set; }
        public bool Ticket { get; set; }
        public double LastRequestStamp { get; set; }
    }

    private class PvXTicket
    {
        public ulong ID { get; set; }
        public string Name { get; set; }
        public string Reason { get; set; }
        public string TimeStampString { get; set; }
        public double TimeStamp { get; set; }
        public int TicketID { get; set; }
    }

    private class PvXLog
    {
        public ulong PlayerID { get; set; }
        public string PlayerName { get; set; }
        public ulong AdminID { get; set; }
        public string AdminName { get; set; }
        public string Reason { get; set; }
        public string CreatedTimeStamp { get; set; }
        public string ReviewedTimeStamp { get; set; }
        public string Outcome { get; set; }
    }

     class PlayerDataManager
    {
        private PlayerData playerData;
        private DynamicConfigFile PlayerDataFile;
         class PlayerData
        {
            public Dictionary<ulong, PvXPlayer> StoredPlayers;
            public Dictionary<ulong, double> StoredCooldowns;
        }

        internal PlayerDataManager();
        private void Initiate();
        private void Load();
        public void Save();
    }

     class TicketDataManager
    {
        private TicketData ticketData;
        private DynamicConfigFile TicketDataFile;
         class TicketData
        {
            public Dictionary<int, PvXTicket> StoredTickets;
        }

        public TicketDataManager();
        private void Initiate();
        private void Load();
        public void Save();
    }

     class LogDataManager
    {
        private LogData logData;
        private DynamicConfigFile LogDataFile;
         class LogData
        {
            public Dictionary<int, PvXLog> StoredLogs;
        }

        internal LogDataManager();
        private void Initiate();
        private void Load();
        public void Save();
    }

     void Init();
     void OnServerInitialized();
     void Unload();
     void OnPlayerInit(BasePlayer player);
     void PlayerLoaded(IPlayer iplayer);
     void RegisterPermissions();
    private PvXPlayer CreatePlayerData(BasePlayer player);
    private PvXTicket CreateTicketData(BasePlayer player, int ticketnumber);
    private int GetNewLogID();
    private int GetNewTicketID();
    private string GetDateStamp();
    private double GetTimeStamp();
    private bool HasPerm(BasePlayer Player, string perm, string reason);
    public static BasePlayer FindBasePlayer(string StringID);
    public static IPlayer FindIPlayer(string StringID);
    private PvXState GetObjectPvXState(BaseEntity baseEntity);
    private string GetPvXStateString(PvXState state);
    private void SaveAll();
    private void SavePlayerTicket();
    private void CheckHelicopter();
    private int BaseHeliCount { get; set; }
    private int CH47Count { get; set; }
    private int BradleyCount { get; set; }
    private int HeliCounts();
    [ChatCommand("pvx")]
     void PvXChatCmd(BasePlayer player, string cmd, string[] args);
     void OnEntitySpawned(BaseNetworkable entity);
     void OnEntityKill(BaseNetworkable entity);
     void OnEntityTakeDamage(BaseCombatEntity Target, HitInfo HitInfo);
     void PlayerAttacker(BaseEntity Target, BasePlayer Attacker, HitInfo HitInfo);
     void FireBallAttacker(BaseEntity Target, HitInfo hitInfo);
     void HelicopterAttacker(BaseEntity Target, HitInfo hitInfo);
     void BradleyAPCAttacker(BaseEntity Target, HitInfo hitInfo);
     void AnimalAttacker(BaseEntity Target, HitInfo hitInfo);
     void DamageDebuger(HitInfo hitInfo);
     void ModifyDamage(HitInfo HitInfo, float scale);
    [PluginReference]
    public Plugin HumanNPC;
    internal static bool IsNPC(ulong Player);
    internal static bool IsNPC(BaseCombatEntity Player);
    internal static bool IsNPC(PlayerCorpse Corpse);
    private void PlayerNotification(IPlayer iplayer);
    private string GetMSG(string key, string userid, object[] args);
    private readonly Dictionary<string, string> Messages;
     class UIColours
    {
        public static readonly UIColours Black_100;
        public static readonly UIColours Black_050;
        public static readonly UIColours Black_015;
        public static readonly UIColours Grey2_100;
        public static readonly UIColours Grey2_050;
        public static readonly UIColours Grey2_015;
        public static readonly UIColours Grey5_100;
        public static readonly UIColours Grey5_050;
        public static readonly UIColours Grey5_015;
        public static readonly UIColours Grey8_100;
        public static readonly UIColours Grey8_050;
        public static readonly UIColours Grey8_015;
        public static readonly UIColours White_100;
        public static readonly UIColours White_050;
        public static readonly UIColours White_015;
        public static readonly UIColours Red_100;
        public static readonly UIColours Red_050;
        public static readonly UIColours Red_015;
        public static readonly UIColours Green_100;
        public static readonly UIColours Green_050;
        public static readonly UIColours Green_015;
        public static readonly UIColours Blue_100;
        public static readonly UIColours Blue_050;
        public static readonly UIColours Blue_015;
        public static readonly UIColours Yellow_100;
        public static readonly UIColours Yellow_050;
        public static readonly UIColours Yellow_015;
        public static readonly UIColours Gold_100;
        public string Value;
        public int Index;
        private UIColours(string value);
    }

    public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor, string parent);
    public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, float fadein, TextAnchor align);
    public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, float fadein, TextAnchor align);
    public void LoadImage(CuiElementContainer container, string panel, string png, string aMin, string aMax);
    public void CreateTextOverlay(CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align, float fadein);
    public void AdminIndicatorGui(BasePlayer Player);
    public void PlayerIndicatorGui(BasePlayer Player);
    private void UpdatePlayersGui(BasePlayer player);
    private void UpdateAdminsGui();
    private void UpdateAdminGui(BasePlayer player);
    private void DestroyAllPvXUI(BasePlayer player);
    private void DestroyUIElement(BasePlayer player, string _ui);
}

 class ConfigData
{
    public Options Options { get; set; }
    public Gui Gui { get; set; }
}

 class Options
{
    public bool AllowTickets { get; set; }
    public bool AllowCooldowns { get; set; }
    public float ModeSwitchCooldown { get; set; }
}

 class Gui
{
    public bool DisableUI_FadeIn;
    public float playerIndicatorMinWid;
    public float playerIndicatorMinHei;
    public float adminIndicatorMinWid;
    public float adminIndicatorMinHei;
}

private class PvXPlayer
{
    public string Username { get; set; }
    public string ConnectionFirst { get; set; }
    public string ConnectionLast { get; set; }
    public PvXState State { get; set; }
    public PvXNotification Notification { get; set; }
    public int TicketID { get; set; }
    public bool Ticket { get; set; }
    public double LastRequestStamp { get; set; }
}

private class PvXTicket
{
    public ulong ID { get; set; }
    public string Name { get; set; }
    public string Reason { get; set; }
    public string TimeStampString { get; set; }
    public double TimeStamp { get; set; }
    public int TicketID { get; set; }
}

private class PvXLog
{
    public ulong PlayerID { get; set; }
    public string PlayerName { get; set; }
    public ulong AdminID { get; set; }
    public string AdminName { get; set; }
    public string Reason { get; set; }
    public string CreatedTimeStamp { get; set; }
    public string ReviewedTimeStamp { get; set; }
    public string Outcome { get; set; }
}

 class PlayerDataManager
{
    private PlayerData playerData;
    private DynamicConfigFile PlayerDataFile;
     class PlayerData
    {
        public Dictionary<ulong, PvXPlayer> StoredPlayers;
        public Dictionary<ulong, double> StoredCooldowns;
    }

    internal PlayerDataManager();
    private void Initiate();
    private void Load();
    public void Save();
}

 class PlayerData
{
    public Dictionary<ulong, PvXPlayer> StoredPlayers;
    public Dictionary<ulong, double> StoredCooldowns;
}

 class TicketDataManager
{
    private TicketData ticketData;
    private DynamicConfigFile TicketDataFile;
     class TicketData
    {
        public Dictionary<int, PvXTicket> StoredTickets;
    }

    public TicketDataManager();
    private void Initiate();
    private void Load();
    public void Save();
}

 class TicketData
{
    public Dictionary<int, PvXTicket> StoredTickets;
}

 class LogDataManager
{
    private LogData logData;
    private DynamicConfigFile LogDataFile;
     class LogData
    {
        public Dictionary<int, PvXLog> StoredLogs;
    }

    internal LogDataManager();
    private void Initiate();
    private void Load();
    public void Save();
}

 class LogData
{
    public Dictionary<int, PvXLog> StoredLogs;
}

 class UIColours
{
    public static readonly UIColours Black_100;
    public static readonly UIColours Black_050;
    public static readonly UIColours Black_015;
    public static readonly UIColours Grey2_100;
    public static readonly UIColours Grey2_050;
    public static readonly UIColours Grey2_015;
    public static readonly UIColours Grey5_100;
    public static readonly UIColours Grey5_050;
    public static readonly UIColours Grey5_015;
    public static readonly UIColours Grey8_100;
    public static readonly UIColours Grey8_050;
    public static readonly UIColours Grey8_015;
    public static readonly UIColours White_100;
    public static readonly UIColours White_050;
    public static readonly UIColours White_015;
    public static readonly UIColours Red_100;
    public static readonly UIColours Red_050;
    public static readonly UIColours Red_015;
    public static readonly UIColours Green_100;
    public static readonly UIColours Green_050;
    public static readonly UIColours Green_015;
    public static readonly UIColours Blue_100;
    public static readonly UIColours Blue_050;
    public static readonly UIColours Blue_015;
    public static readonly UIColours Yellow_100;
    public static readonly UIColours Yellow_050;
    public static readonly UIColours Yellow_015;
    public static readonly UIColours Gold_100;
    public string Value;
    public int Index;
    private UIColours(string value);
}


```

---

## QRTL by Quapi - Adds support for RTL languages in chat, with support for Better Chat

```csharp
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("QRTL", "Quapi", "0.2.1")]
[Description("A fix for RTL Languages")]
 class QRTL : CovalencePlugin
{
    private object OnBetterChat(Dictionary<string, object> data);
    protected string RtlText(string text);
    protected bool IsBothRTLOrSpecial(char a, char b);
    protected bool IsSpecialChar(char character);
    protected bool IsNumber(string v);
    protected bool IsRTL(string text);
    protected bool IsRTLLang(char c);
    protected string FixWord(string word);
    protected char[] SwapRTLCharacters(char[] characters);
    protected char[] SwapWordIndexes(char[] characters);
    protected bool IsRightToLeft(string text);
}


```

---

## QualityCrafting by mr01sam - Adds crafting skills allowing players to craft higher quality versions of items with improved stats.

```csharp
using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections;
using UnityEngine;
using Oxide.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System.Threading.Tasks;
using System.Text;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Quality Crafting", "mr01sam", "2.1.2")]
[Description("Players can level crafting skills to produce higher quality items that have better stats than vanilla items.")]
partial class QualityCrafting : CovalencePlugin
{
    private static QualityCrafting PLUGIN;
    public const string PermissionAdmin;
    [PluginReference]
    private Plugin ImageLibrary;
    private Guid Secret { get; set; }
     bool ServerInitialized { get; set; }
     void Init();
     void Unload();
    private void OnServerInitialized(bool initial);
     void OnPlayerSleepEnded(BasePlayer basePlayer);
     object OnPlayerDeath(BasePlayer basePlayer, HitInfo info);
     void SubscribeAll();
     void UnsubscribeAll();
     void LoadPlayer(BasePlayer basePlayer);
     void UnloadPlayer(BasePlayer basePlayer);
     void OnServerShutdown();
     void OnServerSave();
     void LoadImages();
     void LoadItemImages();
     void LoadAll();
     void SaveAll();
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    private static readonly string PREFIX;
    private static readonly CommandArgument SKILL_ARGUMENT;
    private static readonly CommandArgument CATEGORY_ARGUMENT;
    private static readonly CommandArgument QUALITY_ARGUMENT;
    private static readonly CommandArgument XP_RATE_ARGUMENT;
    private static readonly CommandArgument XP_ARGUMENT;
    private static readonly CommandArgument LEVEL_ARGUMENT;
    public static readonly List<CommandInfo> Commands;
    [Command("qc")]
    private void CmdController(IPlayer player, string command, string[] args);
    private void CmdSkills(IPlayer player, string command, string[] args);
    private void CmdButtons(IPlayer player, string command, string[] args);
    private void CmdHelp(IPlayer player, string command, string[] args);
    private void CmdWipeSkills(IPlayer player, string command, string[] args);
    private void CmdGrantXp(IPlayer player, string command, string[] args);
    private void CmdSetLevel(IPlayer player, string command, string[] args);
    private void CmdSetQuality(IPlayer player, string command, string[] args);
    private void CmdSetXpMultiplier(IPlayer player, string command, string[] args);
    private void CmdGrantLevel(IPlayer player, string command, string[] args);
    private void CmdGetLevel(IPlayer player, string command, string[] args);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    private Configuration config;
    private partial class Configuration
    {
        [JsonProperty(PropertyName = "Version")]
        public VersionNumber Version { get; set; }
        [JsonProperty(PropertyName = "General")]
        public GeneralConfig Settings { get; set; }
        [JsonProperty(PropertyName = "Categories")]
        public Dictionary<string, CraftingCategoryConfig> Categories { get; set; }
        [JsonProperty(PropertyName = "Quality Tiers")]
        public QualityConfig Qualities { get; set; }
        [JsonProperty(PropertyName = "Notifications")]
        public NotificationConfig Notifications;
        [JsonProperty(PropertyName = "HUD")]
        public HUDConfig HUD;
        [JsonProperty(PropertyName = "Colors")]
        public ColorsConfig Colors;
        [JsonProperty(PropertyName = "Sounds")]
        public SFXConfig SFX;
        [JsonProperty(PropertyName = "UI Images")]
        public ImagesConfig Images;
    }

    public class GeneralConfig
    {
        [JsonProperty(PropertyName = "Blueprint XP Gain")]
        public bool BlueprintXPGain;
    }

    public class HUDConfig
    {
        [JsonProperty(PropertyName = "Inspect Button")]
        public HUDButton InspectButton;
        [JsonProperty(PropertyName = "Quality Button")]
        public HUDButton QualityButton;
        [JsonProperty(PropertyName = "Skills Button")]
        public HUDButton SkillsButton;
        [JsonProperty(PropertyName = "Tracked Skill")]
        public HUDElement TrackedSkill;
    }

    public class CraftingCategoryConfig
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Icon")]
        public string Icon { get; set; }
        [JsonProperty(PropertyName = "Base XP Multiplier")]
        public float XPMultiplier { get; set; }
        [JsonProperty(PropertyName = "Base Crafting Speed")]
        public float BaseCraftingSpeed { get; set; }
        [JsonProperty(PropertyName = "Perk Increases Per Level")]
        public CraftingCategoryPerkConfig PerkIncreasesPerLevel { get; set; }
    }

    public class CraftingCategoryPerkConfig
    {
        [JsonProperty(PropertyName = "Crafting Speed")]
        public float CraftingSpeed { get; set; }
        [JsonProperty(PropertyName = "Duplicate Chance")]
        public float DuplicateChance { get; set; }
    }

    public class HUDButton
    {
        [JsonProperty(PropertyName = "Icon")]
        public string Icon { get; set; }
        [JsonProperty(PropertyName = "X")]
        public int X { get; set; }
        [JsonProperty(PropertyName = "Y")]
        public int Y { get; set; }
        [JsonProperty(PropertyName = "Size")]
        public int Size { get; set; }
    }

    public class HUDElement
    {
        [JsonProperty(PropertyName = "X")]
        public int X { get; set; }
        [JsonProperty(PropertyName = "Y")]
        public int Y { get; set; }
        [JsonProperty(PropertyName = "Size")]
        public int Size { get; set; }
    }

    public class ImagesConfig
    {
        [JsonProperty(PropertyName = "Close")]
        public string Close { get; set; }
        [JsonProperty(PropertyName = "Help")]
        public string Help { get; set; }
        [JsonProperty(PropertyName = "Arrow Up")]
        public string ArrowUp { get; set; }
        [JsonProperty(PropertyName = "Arrow Down")]
        public string ArrowDown { get; set; }
    }

    public class QualityConfig
    {
        [JsonProperty(PropertyName = "Star Icon")]
        public string IconQualityStar;
        [JsonProperty(PropertyName = "Tier 0")]
        public QualityTierConfig Tier0;
        [JsonProperty(PropertyName = "Tier 1")]
        public QualityTierConfig Tier1;
        [JsonProperty(PropertyName = "Tier 2")]
        public QualityTierConfig Tier2;
        [JsonProperty(PropertyName = "Tier 3")]
        public QualityTierConfig Tier3;
        [JsonProperty(PropertyName = "Tier 4")]
        public QualityTierConfig Tier4;
        [JsonProperty(PropertyName = "Tier 5")]
        public QualityTierConfig Tier5;
        [JsonProperty(PropertyName = "Percent Stat Increases Per Tier")]
        public ModifiersConfig Modifiers;
    }

    public class QualityTierConfig
    {
        [JsonProperty(PropertyName = "Icon")]
        public string Icon { get; set; }
        [JsonProperty(PropertyName = "Color")]
        public string Color { get; set; }
    }

    public class ModifiersConfig
    {
        [JsonProperty(PropertyName = "Projectile Damage")]
        public float ProjectileDamage;
        [JsonProperty(PropertyName = "Protection")]
        public float Protection;
        [JsonProperty(PropertyName = "Melee Damage")]
        public float MeleeDamage;
        [JsonProperty(PropertyName = "Durability")]
        public float Durability;
        [JsonProperty(PropertyName = "Gather Rate")]
        public float GatherRate;
    }

    public class NotificationConfig
    {
        [JsonProperty(PropertyName = "Item Crafted Notification")]
        public NotificationUIConfig ItemCraftedNotification;
        [JsonProperty(PropertyName = "XP Gained Notification")]
        public NotificationUIConfig LevelUpItemNotification;
    }

    public class NotificationUIConfig
    {
        [JsonProperty(PropertyName = "Show")]
        public bool Show;
        [JsonProperty(PropertyName = "X")]
        public int X;
        [JsonProperty(PropertyName = "Y")]
        public int Y;
    }

    public class ColorsConfig
    {
        [JsonProperty(PropertyName = "HUD Background")]
        public string HUDBackground { get; set; }
        [JsonProperty(PropertyName = "Menu Background")]
        public string MenuBackground { get; set; }
        [JsonProperty(PropertyName = "HUD Button Toggled")]
        public string HUDButtonToggled { get; set; }
        [JsonProperty(PropertyName = "HUD Button Untoggled")]
        public string HUDButtonUntoggled { get; set; }
        [JsonProperty(PropertyName = "XP Bar")]
        public string XPBar { get; set; }
        [JsonProperty(PropertyName = "Text")]
        public string Text { get; set; }
    }

    public class SFXConfig
    {
        [JsonProperty(PropertyName = "Item Crafted Normal")]
        public string ItemCraftedNormal { get; set; }
        [JsonProperty(PropertyName = "Item Crafted Rare")]
        public string ItemCraftedRare { get; set; }
        [JsonProperty(PropertyName = "Item Duplicated")]
        public string ItemDuplicated { get; set; }
        [JsonProperty(PropertyName = "Skill Level Up")]
        public string SkillLevelUp { get; set; }
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
}

private partial class Configuration
{
    [JsonProperty(PropertyName = "Version")]
    public VersionNumber Version { get; set; }
    [JsonProperty(PropertyName = "General")]
    public GeneralConfig Settings { get; set; }
    [JsonProperty(PropertyName = "Categories")]
    public Dictionary<string, CraftingCategoryConfig> Categories { get; set; }
    [JsonProperty(PropertyName = "Quality Tiers")]
    public QualityConfig Qualities { get; set; }
    [JsonProperty(PropertyName = "Notifications")]
    public NotificationConfig Notifications;
    [JsonProperty(PropertyName = "HUD")]
    public HUDConfig HUD;
    [JsonProperty(PropertyName = "Colors")]
    public ColorsConfig Colors;
    [JsonProperty(PropertyName = "Sounds")]
    public SFXConfig SFX;
    [JsonProperty(PropertyName = "UI Images")]
    public ImagesConfig Images;
}

public class GeneralConfig
{
    [JsonProperty(PropertyName = "Blueprint XP Gain")]
    public bool BlueprintXPGain;
}

public class HUDConfig
{
    [JsonProperty(PropertyName = "Inspect Button")]
    public HUDButton InspectButton;
    [JsonProperty(PropertyName = "Quality Button")]
    public HUDButton QualityButton;
    [JsonProperty(PropertyName = "Skills Button")]
    public HUDButton SkillsButton;
    [JsonProperty(PropertyName = "Tracked Skill")]
    public HUDElement TrackedSkill;
}

public class CraftingCategoryConfig
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Icon")]
    public string Icon { get; set; }
    [JsonProperty(PropertyName = "Base XP Multiplier")]
    public float XPMultiplier { get; set; }
    [JsonProperty(PropertyName = "Base Crafting Speed")]
    public float BaseCraftingSpeed { get; set; }
    [JsonProperty(PropertyName = "Perk Increases Per Level")]
    public CraftingCategoryPerkConfig PerkIncreasesPerLevel { get; set; }
}

public class CraftingCategoryPerkConfig
{
    [JsonProperty(PropertyName = "Crafting Speed")]
    public float CraftingSpeed { get; set; }
    [JsonProperty(PropertyName = "Duplicate Chance")]
    public float DuplicateChance { get; set; }
}

public class HUDButton
{
    [JsonProperty(PropertyName = "Icon")]
    public string Icon { get; set; }
    [JsonProperty(PropertyName = "X")]
    public int X { get; set; }
    [JsonProperty(PropertyName = "Y")]
    public int Y { get; set; }
    [JsonProperty(PropertyName = "Size")]
    public int Size { get; set; }
}

public class HUDElement
{
    [JsonProperty(PropertyName = "X")]
    public int X { get; set; }
    [JsonProperty(PropertyName = "Y")]
    public int Y { get; set; }
    [JsonProperty(PropertyName = "Size")]
    public int Size { get; set; }
}

public class ImagesConfig
{
    [JsonProperty(PropertyName = "Close")]
    public string Close { get; set; }
    [JsonProperty(PropertyName = "Help")]
    public string Help { get; set; }
    [JsonProperty(PropertyName = "Arrow Up")]
    public string ArrowUp { get; set; }
    [JsonProperty(PropertyName = "Arrow Down")]
    public string ArrowDown { get; set; }
}

public class QualityConfig
{
    [JsonProperty(PropertyName = "Star Icon")]
    public string IconQualityStar;
    [JsonProperty(PropertyName = "Tier 0")]
    public QualityTierConfig Tier0;
    [JsonProperty(PropertyName = "Tier 1")]
    public QualityTierConfig Tier1;
    [JsonProperty(PropertyName = "Tier 2")]
    public QualityTierConfig Tier2;
    [JsonProperty(PropertyName = "Tier 3")]
    public QualityTierConfig Tier3;
    [JsonProperty(PropertyName = "Tier 4")]
    public QualityTierConfig Tier4;
    [JsonProperty(PropertyName = "Tier 5")]
    public QualityTierConfig Tier5;
    [JsonProperty(PropertyName = "Percent Stat Increases Per Tier")]
    public ModifiersConfig Modifiers;
}

public class QualityTierConfig
{
    [JsonProperty(PropertyName = "Icon")]
    public string Icon { get; set; }
    [JsonProperty(PropertyName = "Color")]
    public string Color { get; set; }
}

public class ModifiersConfig
{
    [JsonProperty(PropertyName = "Projectile Damage")]
    public float ProjectileDamage;
    [JsonProperty(PropertyName = "Protection")]
    public float Protection;
    [JsonProperty(PropertyName = "Melee Damage")]
    public float MeleeDamage;
    [JsonProperty(PropertyName = "Durability")]
    public float Durability;
    [JsonProperty(PropertyName = "Gather Rate")]
    public float GatherRate;
}

public class NotificationConfig
{
    [JsonProperty(PropertyName = "Item Crafted Notification")]
    public NotificationUIConfig ItemCraftedNotification;
    [JsonProperty(PropertyName = "XP Gained Notification")]
    public NotificationUIConfig LevelUpItemNotification;
}

public class NotificationUIConfig
{
    [JsonProperty(PropertyName = "Show")]
    public bool Show;
    [JsonProperty(PropertyName = "X")]
    public int X;
    [JsonProperty(PropertyName = "Y")]
    public int Y;
}

public class ColorsConfig
{
    [JsonProperty(PropertyName = "HUD Background")]
    public string HUDBackground { get; set; }
    [JsonProperty(PropertyName = "Menu Background")]
    public string MenuBackground { get; set; }
    [JsonProperty(PropertyName = "HUD Button Toggled")]
    public string HUDButtonToggled { get; set; }
    [JsonProperty(PropertyName = "HUD Button Untoggled")]
    public string HUDButtonUntoggled { get; set; }
    [JsonProperty(PropertyName = "XP Bar")]
    public string XPBar { get; set; }
    [JsonProperty(PropertyName = "Text")]
    public string Text { get; set; }
}

public class SFXConfig
{
    [JsonProperty(PropertyName = "Item Crafted Normal")]
    public string ItemCraftedNormal { get; set; }
    [JsonProperty(PropertyName = "Item Crafted Rare")]
    public string ItemCraftedRare { get; set; }
    [JsonProperty(PropertyName = "Item Duplicated")]
    public string ItemDuplicated { get; set; }
    [JsonProperty(PropertyName = "Skill Level Up")]
    public string SkillLevelUp { get; set; }
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
     object OnItemAction(Item bp, string action, BasePlayer basePlayer);
     object OnItemCraft(ItemCraftTask task, BasePlayer basePlayer, Item item);
     void OnItemCraftFinished(ItemCraftTask task, Item item);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    [Command("qc.help")]
    private void Cmdhelp(IPlayer player, string command, string[] args);
    [Command("qc.help.tab")]
    private void CmdHelpTab(IPlayer player, string command, string[] args);
    private void DestroyHelpMenu(BasePlayer basePlayer);
    private void ShowHelpMenu(BasePlayer basePlayer, bool autoHide, int index);
    private CuiElementContainer CreateOverviewHelpTab(BasePlayer basePlayer, CuiElementContainer container, string parent, int padding);
    private CuiElementContainer CreateCommandsHelpTab(BasePlayer basePlayer, CuiElementContainer container, string parent, int padding);
    private CuiElementContainer CreateSupportTab(BasePlayer basePlayer, CuiElementContainer container, string parent, int padding);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    private Dictionary<string, bool> InspectorToggled;
    private Dictionary<string, bool> QualityToggled;
    private Dictionary<string, Vector3> PreviousMouseCoords;
    private Dictionary<string, LootedEntity> PreviousLootedEntity;
    public bool IsInspectorToggled(BasePlayer basePlayer);
    public bool IsQualityToggled(BasePlayer basePlayer);
    [Command("show.inspector")]
    private void CmdInspector(IPlayer player, string command, string[] args);
    [Command("close.inspector")]
    private void CmdInspectorClose(IPlayer player, string command, string[] args);
    [Command("show.quality")]
    private void CmdQuality(IPlayer player, string command, string[] args);
    [Command("close.quality")]
    private void CmdQualityClose(IPlayer player, string command, string[] args);
    [Command("qc.inspect.item")]
    private void CmdInspectItem(IPlayer player, string command, string[] args);
    [Command("qc.inspect.item.close")]
    private void CmdInspectItemClose(IPlayer player, string command, string[] args);
    [Command("qc.toggle.inspector")]
    private void CmdInspectInventory(IPlayer player, string command, string[] args);
    [Command("qc.toggle.quality")]
    private void CmdShowQuality(IPlayer player, string command, string[] args);
    private string INSPECTOR_BUTTON;
    private string QUALITY_BUTTON;
    private void ShowInspectorButton(BasePlayer basePlayer);
    private void DestroyInspectorButton(BasePlayer basePlayer);
    private void ShowQualityButton(BasePlayer basePlayer);
    private void DestroyQualityButton(BasePlayer basePlayer);
    private void DestroyAllButtons(BasePlayer basePlayer);
    private void ShowAllButtons(BasePlayer basePlayer);
    readonly string QUALIY_ID;
    readonly string INSPECTOR_ID;
    readonly string INVENTORY_OVERLAY;
    readonly string BELT_OVERLAY;
    readonly string WEAR_OVERLAY;
    readonly string STORAGE_OVERLAY;
    readonly string LOCKER_OVERLAY;
    readonly string SHOP_OVERLAY;
    readonly string INFO_OVERLAY;
    readonly string MODIFIER_OVERLAY;
    readonly string SCREEN_OVERLAY;
    readonly string SELECTED_OVERLAY;
    readonly string NPC_OVERLAY_MAIN;
    readonly string NPC_OVERLAY_WEAR;
    readonly string NPC_OVERLAY_BELT;
    private void ShowOverlayByType(BasePlayer basePlayer, OverlayType overlayType, string id);
    private void DestroyOverlayByType(BasePlayer basePlayer, OverlayType overlayType);
    private void DestroyAllOverlays(BasePlayer basePlayer);
    private void RefreshOverlays(BasePlayer basePlayer);
    private void ShowInspectorOverlay(BasePlayer basePlayer);
    private void ToggleInspectorOverlay(BasePlayer basePlayer);
    private void DestroyInspectorOverlays(BasePlayer basePlayer);
    private void ShowQualityOverlay(BasePlayer basePlayer);
    private void ToggleQualityOverlay(BasePlayer basePlayer);
    private void DestroyQualityOverlays(BasePlayer basePlayer);
    private void ShowSelectedOverlay(BasePlayer basePlayer, Item item);
    private void DestroySelectedOverlay(BasePlayer basePlayer);
    private CuiElementContainer CreateOverlaySlot(ItemContainer inventory, Item item, CuiElementContainer container, string id, int i, int x, int y, int w, OverlayType overlayType, NetworkableId? netId);
    private CuiElementContainer CreateInventoryOverlay(ItemContainer inventory, CuiElementContainer container, string id, int rows, int cols, int size, int startX, int startY, OverlayType overlayType, int index, string layer, NetworkableId? netId);
    private CuiElementContainer CreateLockerOverlay(Locker locker, CuiElementContainer container, string id, OverlayType overlayType);
    private CuiElementContainer CreateShopOverlay(VendingMachine machine, CuiElementContainer container, string id, OverlayType overlayType);
    private void ShowInfoOverlay(BasePlayer basePlayer, Item item);
    private void RemovedLootedEntity(BasePlayer basePlayer);
    private CuiElementContainer CreateModifiersOverlay(CuiElementContainer container, BasePlayer basePlayer);
    private class LootedEntity
    {
        public BaseEntity Entity;
        public bool IsShopMenu;
    }

     void OnPlayerInput(BasePlayer basePlayer, InputState input);
     void OnActiveItemChanged(BasePlayer basePlayer, Item oldItem, Item newItem);
     void OnLootEntity(BasePlayer player, PlayerCorpse entity);
     void OnLootEntity(BasePlayer player, StashContainer entity);
     void OnLootEntity(BasePlayer player, Locker entity);
     void OnLootEntity(BasePlayer player, BoxStorage entity);
     void OnLootEntity(BasePlayer player, DroppedItemContainer entity);
     void OnVendingShopOpened(VendingMachine machine, BasePlayer player);
     void OnLootEntity(BasePlayer player, VendingMachine machine);
     void OnLootEntityEnd(BasePlayer player, PlayerCorpse entity);
     void OnLootEntityEnd(BasePlayer player, StashContainer entity);
     void OnLootEntityEnd(BasePlayer player, Locker entity);
     void OnLootEntityEnd(BasePlayer player, BoxStorage entity);
     void OnLootEntityEnd(BasePlayer player, VendingMachine entity);
     void OnLootEntityEnd(BasePlayer player, DroppedItemContainer entity);
     void OnLootNetworkUpdate(PlayerLoot loot);
     void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, bool broadcast);
}

private class LootedEntity
{
    public BaseEntity Entity;
    public bool IsShopMenu;
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private string Lang(string key, BasePlayer basePlayer, object[] args);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    [Command("show.menu")]
    private void CmdShowMenu(IPlayer player, string command, string[] args);
    [Command("close.menu")]
    private void CmdCloseMenu(IPlayer player, string command, string[] args);
    [Command("qc.menu.show")]
    private void CmdMenuShow(IPlayer player, string command, string[] args);
    [Command("qc.menu.close")]
    private void CmdMenuClose(IPlayer player, string command, string[] args);
    [Command("qc.menu.category")]
    private void CmdMenuCategory(IPlayer player, string command, string[] args);
    [Command("qc.track")]
    private void CmdTrack(IPlayer player, string command, string[] args);
    [Command("qc.untrack")]
    private void CmdUntrack(IPlayer player, string command, string[] args);
    private Dictionary<string, bool> MenuToggled;
    private string SKILLS_MENU_OVERLAY;
    private string SKILLS_MENU;
    private string SKILLS_MENU_BUTTON;
    private string SKILLS_MENU_CONTENT;
    private string SKILLS_MENU_CATEGORY;
    private string HELP_MENU_OVERLAY;
    private string HELP_MENU;
    private bool IsMenuToggled(BasePlayer basePlayer);
    private void DestroySkillsMenuButton(BasePlayer basePlayer);
    private void ShowSkillsMenuButton(BasePlayer basePlayer);
    private void DestroyAllMenus(BasePlayer basePlayer);
    private void DestroySkillsMenu(BasePlayer basePlayer);
    private void ShowSkillsMenu(BasePlayer basePlayer, bool autoHide);
    private int contentWidth;
    private int contentHeight;
    private CuiElementContainer CreateSkillsMenuSideNav(BasePlayer basePlayer, CuiElementContainer container, int header, int padding, int width);
    private CuiElementContainer CreateSkillsMenuContent(CuiElementContainer container, int header, int padding, int left, int fullWidth);
    private void DestroyCategoryPage(BasePlayer basePlayer);
    private void ShowCategoryPage(BasePlayer basePlayer, SkillCategory category, int page);
    private CuiElementContainer CreateSkillEntry(CuiElementContainer container, BasePlayer basePlayer, PlayerSkillSheet skills, Item item, int i, int x, int y, int w, int h);
    private int footerHeight;
    private CuiElementContainer CreateLeaderboardSide(CuiElementContainer container, BasePlayer basePlayer, SkillCategory category, float width, int padding);
    private CuiElementContainer CreateContentFooter(CuiElementContainer container, BasePlayer basePlayer, SkillCategory category, PlayerSkillSheet skills, int padding, int page, bool maxed);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
     object OnEntityTakeDamage(BasePlayer entity, HitInfo info);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    private static readonly string NOTIFICATION_ID;
    public void CreateProgressBar(BasePlayer basePlayer, List<CuiElement> collection, string id, string parent, string anchorMin, string anchorMax, string offsetMin, string offsetMax, float fadeOut, float fadeIn, float delay, string bgColor, string barColor, int oldLevel, int newLevel, uint xpGained, float oldPercent, float newPercent, string textColor, int textSize, bool isLevelUp, string glowElementId, float progressDelay, bool showXpGained, uint xp1, uint xp2, bool showTitle, string title);
    private void ShowXpGainedNotification(BasePlayer basePlayer, GainedXPNotification notification);
    private void ShowItemCraftedNotification(BasePlayer basePlayer, ItemCraftedNotification notification);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public static class Styles
    {
        public static readonly float FadeIn;
        public static readonly float FadeOut;
        public static readonly float Pause;
        public static readonly string Material;
        public static readonly int NotificationPadding;
    }

}

public static class Styles
{
    public static readonly float FadeIn;
    public static readonly float FadeOut;
    public static readonly float Pause;
    public static readonly string Material;
    public static readonly int NotificationPadding;
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    private readonly string TRACKING_HUD_ID;
    public void DestroyTrackingHud(BasePlayer basePlayer);
    public void ShowTrackingHud(BasePlayer basePlayer);
}

Oxide.Plugins
partial class QualityCrafting
{
    private T LoadDataFile(string fileName);
    private static string ColorToHex(string color);
    private static string ColorTextHex(string text, string hexColor);
    private static string ColorTextRGB(string text, string rgb);
    public string Offset(int x, int y);
    public int GlobalOffset;
    public string AnchorDefault { get; set; }
    public string Anchor(float x, float y);
    private static string SetOpacity(string colorString, float opacity);
    private void SaveDataFile(string fileName, T data);
    private void PlaySfx(BasePlayer player, string sound);
    public class SecurityCheck
    {
        public bool Success { get; set; }
        public string[] Args { get; set; }
        public SecurityCheck(string[] args);
    }

}

public class SecurityCheck
{
    public bool Success { get; set; }
    public string[] Args { get; set; }
    public SecurityCheck(string[] args);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public class PlayerSkillSheet
    {
        public Dictionary<int, uint> _categoryXP;
        public Dictionary<int, uint> _itemXP;
        private static int[] _ItemXpToLevelCache;
        private static int[] _CategoryXpToLevelCache;
        public PlayerSkillSheet();
        public PlayerSkillSheet SetLevel(Item item, int level);
        public PlayerSkillSheet SetLevel(SkillCategory category, int level);
        public List<int> GetCategoryItemIDs(SkillCategory category);
        public int GetLevel(Item item);
        public int GetLevelFromItemId(int itemId);
        public int GetLevel(SkillCategory category);
        public float GetCraftingSpeedMultiplier(SkillCategory category);
        public int GetDuplicateChance(SkillCategory category);
        public PlayerSkillSheet GrantXP(SkillCategory category, uint xp);
        public PlayerSkillSheet GrantXP(Item item, uint xp);
        public uint GetXP(SkillCategory category);
        public uint GetXP(Item item);
        public float GetLevelPercent(Item item);
        public float GetLevelPercent(SkillCategory category);
        private static int GetItemLevelFromXp(Item item, uint xp);
        private static int GetLevelFromXp(SkillCategory category, uint xp);
        public override string ToString();
    }

}

public class PlayerSkillSheet
{
    public Dictionary<int, uint> _categoryXP;
    public Dictionary<int, uint> _itemXP;
    private static int[] _ItemXpToLevelCache;
    private static int[] _CategoryXpToLevelCache;
    public PlayerSkillSheet();
    public PlayerSkillSheet SetLevel(Item item, int level);
    public PlayerSkillSheet SetLevel(SkillCategory category, int level);
    public List<int> GetCategoryItemIDs(SkillCategory category);
    public int GetLevel(Item item);
    public int GetLevelFromItemId(int itemId);
    public int GetLevel(SkillCategory category);
    public float GetCraftingSpeedMultiplier(SkillCategory category);
    public int GetDuplicateChance(SkillCategory category);
    public PlayerSkillSheet GrantXP(SkillCategory category, uint xp);
    public PlayerSkillSheet GrantXP(Item item, uint xp);
    public uint GetXP(SkillCategory category);
    public uint GetXP(Item item);
    public float GetLevelPercent(Item item);
    public float GetLevelPercent(SkillCategory category);
    private static int GetItemLevelFromXp(Item item, uint xp);
    private static int GetLevelFromXp(SkillCategory category, uint xp);
    public override string ToString();
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public class SkillCategory
    {
        public SkillCategory(int id, string name, string defaultIcon);
        public float? TemporaryMultiplier { get; set; }
        private static List<uint> _itemLevelXpRequirements;
        private static List<uint> _categoryLevelXpRequirements;
        public static readonly SkillCategory GUNSMITHING;
        public static readonly SkillCategory TOOLCRAFTING;
        public static readonly SkillCategory TAILORING;
        public static readonly SkillCategory BOWMAKING;
        public static readonly SkillCategory WEAPONSMITHING;
        public static readonly List<SkillCategory> ALL;
        public int ID { get; set; }
        public string DefaultIcon { get; set; }
        public string Name { get; set; }
        public string NameTitleCase { get; set; }
        public uint MinLevelXP { get; set; }
        public uint MidLevelXP { get; set; }
        public uint MaxLevelXP { get; set; }
        public string DisplayName(BasePlayer basePlayer);
        public static SkillCategory GetByName(string name);
        public static SkillCategory GetDefaultCategory();
        public static SkillCategory GetByID(int ID);
        public static SkillCategory GetByItemName(string itemDisplayName);
        public static SkillCategory GetByItemDefinition(ItemDefinition itemDefinition);
        public static SkillCategory GetByItem(Item item);
        public static bool IsCategoryEnabled(SkillCategory category);
        public float GetBaseCraftingSpeed();
        public float GetXpMultiplier();
        public uint GetItemLevelXPReq(int level);
        public uint GetCategoryLevelXPReq(int level);
    }

}

public class SkillCategory
{
    public SkillCategory(int id, string name, string defaultIcon);
    public float? TemporaryMultiplier { get; set; }
    private static List<uint> _itemLevelXpRequirements;
    private static List<uint> _categoryLevelXpRequirements;
    public static readonly SkillCategory GUNSMITHING;
    public static readonly SkillCategory TOOLCRAFTING;
    public static readonly SkillCategory TAILORING;
    public static readonly SkillCategory BOWMAKING;
    public static readonly SkillCategory WEAPONSMITHING;
    public static readonly List<SkillCategory> ALL;
    public int ID { get; set; }
    public string DefaultIcon { get; set; }
    public string Name { get; set; }
    public string NameTitleCase { get; set; }
    public uint MinLevelXP { get; set; }
    public uint MidLevelXP { get; set; }
    public uint MaxLevelXP { get; set; }
    public string DisplayName(BasePlayer basePlayer);
    public static SkillCategory GetByName(string name);
    public static SkillCategory GetDefaultCategory();
    public static SkillCategory GetByID(int ID);
    public static SkillCategory GetByItemName(string itemDisplayName);
    public static SkillCategory GetByItemDefinition(ItemDefinition itemDefinition);
    public static SkillCategory GetByItem(Item item);
    public static bool IsCategoryEnabled(SkillCategory category);
    public float GetBaseCraftingSpeed();
    public float GetXpMultiplier();
    public uint GetItemLevelXPReq(int level);
    public uint GetCategoryLevelXPReq(int level);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public static class CraftingManager
    {
        private static Dictionary<string, PlayerSkillSheet> _playerCraftingSkills;
        public static void Clear();
        public static void Clear(BasePlayer basePlayer);
        public static PlayerSkillSheet GetSkills(BasePlayer basePlayer);
        public static List<LeaderboardRank> GetTopPlayerSkills(SkillCategory category, int skip, int take);
        public static List<CraftChance> GetQualityChances(int itemLevel);
        private static int GetRelativeChanceOfQuality(int quality, int itemLevel);
        private static int GetChanceOfQuality(int quality, int itemLevel);
        public static int GetCraftedItemQuality(Item item, PlayerSkillSheet skills);
        public static void Load();
        public static void Save();
    }

}

public static class CraftingManager
{
    private static Dictionary<string, PlayerSkillSheet> _playerCraftingSkills;
    public static void Clear();
    public static void Clear(BasePlayer basePlayer);
    public static PlayerSkillSheet GetSkills(BasePlayer basePlayer);
    public static List<LeaderboardRank> GetTopPlayerSkills(SkillCategory category, int skip, int take);
    public static List<CraftChance> GetQualityChances(int itemLevel);
    private static int GetRelativeChanceOfQuality(int quality, int itemLevel);
    private static int GetChanceOfQuality(int quality, int itemLevel);
    public static int GetCraftedItemQuality(Item item, PlayerSkillSheet skills);
    public static void Load();
    public static void Save();
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public abstract class Notification
    {
        public abstract NotificationType Type { get; set; }
    }

    public class NotificationBundle
    {
        public List<Notification> Items { get; set; }
        public bool ContainsLevelup { get; set; }
    }

    public class GainedXPNotification : Notification
    {
        public override NotificationType Type { get; set; }
        public string Icon { get; set; }
        public string SkillDisplayName { get; set; }
        public float OldXP { get; set; }
        public float NewXP { get; set; }
        public int OldLevel { get; set; }
        public int NewLevel { get; set; }
        public uint XPGained { get; set; }
        public bool IsLevelUp { get; set; }
    }

    public class ItemCraftedNotification : Notification
    {
        public override NotificationType Type { get; set; }
        public string SkillDisplayName { get; set; }
        public string Icon { get; set; }
        public bool IsItem { get; set; }
        public int OldCategoryLevel { get; set; }
        public int NewCategoryLevel { get; set; }
        public int OldItemLevel { get; set; }
        public int NewItemLevel { get; set; }
        public float OldCategoryXP { get; set; }
        public float NewCategoryXP { get; set; }
        public float OldItemXP { get; set; }
        public float NewItemXP { get; set; }
        public bool IsCategoryLevelup { get; set; }
        public bool IsItemLevelup { get; set; }
        public uint CategoryXPGained { get; set; }
        public uint ItemXPGained { get; set; }
        public int Quality { get; set; }
        public string Category { get; set; }
        public bool IsRare { get; set; }
        public bool IsDuplicated { get; set; }
        public override string ToString();
    }

    public static class NotificationManager
    {
        private static Dictionary<string, List<NotificationBundle>> PlayerNotifications;
        public static void DestroyAllNotifications(BasePlayer basePlayer);
        public static void AddNotifications(BasePlayer basePlayer, Notification[] notifications);
        private static void ShowNotifications(BasePlayer basePlayer);
    }

}

public abstract class Notification
{
    public abstract NotificationType Type { get; set; }
}

public class NotificationBundle
{
    public List<Notification> Items { get; set; }
    public bool ContainsLevelup { get; set; }
}

public class GainedXPNotification : Notification
{
    public override NotificationType Type { get; set; }
    public string Icon { get; set; }
    public string SkillDisplayName { get; set; }
    public float OldXP { get; set; }
    public float NewXP { get; set; }
    public int OldLevel { get; set; }
    public int NewLevel { get; set; }
    public uint XPGained { get; set; }
    public bool IsLevelUp { get; set; }
}

public class ItemCraftedNotification : Notification
{
    public override NotificationType Type { get; set; }
    public string SkillDisplayName { get; set; }
    public string Icon { get; set; }
    public bool IsItem { get; set; }
    public int OldCategoryLevel { get; set; }
    public int NewCategoryLevel { get; set; }
    public int OldItemLevel { get; set; }
    public int NewItemLevel { get; set; }
    public float OldCategoryXP { get; set; }
    public float NewCategoryXP { get; set; }
    public float OldItemXP { get; set; }
    public float NewItemXP { get; set; }
    public bool IsCategoryLevelup { get; set; }
    public bool IsItemLevelup { get; set; }
    public uint CategoryXPGained { get; set; }
    public uint ItemXPGained { get; set; }
    public int Quality { get; set; }
    public string Category { get; set; }
    public bool IsRare { get; set; }
    public bool IsDuplicated { get; set; }
    public override string ToString();
}

public static class NotificationManager
{
    private static Dictionary<string, List<NotificationBundle>> PlayerNotifications;
    public static void DestroyAllNotifications(BasePlayer basePlayer);
    public static void AddNotifications(BasePlayer basePlayer, Notification[] notifications);
    private static void ShowNotifications(BasePlayer basePlayer);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public static class QualityItemManager
    {
        public static QualityItem SetItemQuality(Item item, int quality, BasePlayer creator);
        public static bool IsQualityItem(Item item);
        public static QualityItem GetByItem(Item item);
        private static float GetModifier(int quality, float modifier);
        public static float GetClothingStatResistance(BasePlayer basePlayer, Rust.DamageType dt, bool baseValues);
        public static List<QualityItemStat> GetItemStats(Item item);
        public static bool IsRareQuality(int quality, int level);
        private static HashSet<ulong> AuditedEntities;
        public static void AuditQualityItem(Item item, BaseEntity heldEntity);
        public static Item ApplyQualityModifiers(Item item, int quality, bool initial);
        public static int GetItemQuality(Item item);
        public static int GetWorkbenchLevel(Item item);
        public static uint GetItemXpRate(Item item);
        public static string GetColorByQuality(int quality);
    }

}

public static class QualityItemManager
{
    public static QualityItem SetItemQuality(Item item, int quality, BasePlayer creator);
    public static bool IsQualityItem(Item item);
    public static QualityItem GetByItem(Item item);
    private static float GetModifier(int quality, float modifier);
    public static float GetClothingStatResistance(BasePlayer basePlayer, Rust.DamageType dt, bool baseValues);
    public static List<QualityItemStat> GetItemStats(Item item);
    public static bool IsRareQuality(int quality, int level);
    private static HashSet<ulong> AuditedEntities;
    public static void AuditQualityItem(Item item, BaseEntity heldEntity);
    public static Item ApplyQualityModifiers(Item item, int quality, bool initial);
    public static int GetItemQuality(Item item);
    public static int GetWorkbenchLevel(Item item);
    public static uint GetItemXpRate(Item item);
    public static string GetColorByQuality(int quality);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public static class TrackingManager
    {
        private static Dictionary<string, int> _playerTracking;
        public static void Track(BasePlayer basePlayer, SkillCategory category);
        public static SkillCategory GetTrackedCategory(BasePlayer basePlayer);
        public static void Untrack(BasePlayer basePlayer);
        public static bool IsTracking(BasePlayer basePlayer, SkillCategory category);
        public static void Load();
        public static void Save();
    }

}

public static class TrackingManager
{
    private static Dictionary<string, int> _playerTracking;
    public static void Track(BasePlayer basePlayer, SkillCategory category);
    public static SkillCategory GetTrackedCategory(BasePlayer basePlayer);
    public static void Untrack(BasePlayer basePlayer);
    public static bool IsTracking(BasePlayer basePlayer, SkillCategory category);
    public static void Load();
    public static void Save();
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public class CommandInfo
    {
        public string Command { get; set; }
        public CommandArgument[] Arguments { get; set; }
        public string Description { get; set; }
        public string Method { get; set; }
        public int Rank;
        public string Permission { get; set; }
        public string[] Permissions { get; set; }
        public bool AdminOnly { get; set; }
        public int RequiredArgCount { get; set; }
        public int TotalArgCount { get; set; }
        public string ArgString { get; set; }
        public string Usage(IPlayer player, string prefix);
        public void Execute(IPlayer player, string command, string[] args);
        public ValidationResponse Validate(string[] args);
    }

    public class CommandArgument
    {
        public static readonly CommandArgument PLAYER_NAME;
        public string Parameter { get; set; }
        public bool Optional { get; set; }
        public string[] AllowedValues { get; set; }
        public Func<string, ValidationResponse> Validate { get; set; }
        public override string ToString();
    }

    public class ValidationResponse
    {
        public bool IsValid { get; set; }
        public ValidationStatusCode StatusCode { get; set; }
        public object[] Data { get; set; }
        public ValidationResponse();
        public ValidationResponse(ValidationStatusCode statusCode);
        public ValidationResponse(ValidationStatusCode statusCode, object[] data);
        public void SetData(object[] data);
    }

}

public class CommandInfo
{
    public string Command { get; set; }
    public CommandArgument[] Arguments { get; set; }
    public string Description { get; set; }
    public string Method { get; set; }
    public int Rank;
    public string Permission { get; set; }
    public string[] Permissions { get; set; }
    public bool AdminOnly { get; set; }
    public int RequiredArgCount { get; set; }
    public int TotalArgCount { get; set; }
    public string ArgString { get; set; }
    public string Usage(IPlayer player, string prefix);
    public void Execute(IPlayer player, string command, string[] args);
    public ValidationResponse Validate(string[] args);
}

public class CommandArgument
{
    public static readonly CommandArgument PLAYER_NAME;
    public string Parameter { get; set; }
    public bool Optional { get; set; }
    public string[] AllowedValues { get; set; }
    public Func<string, ValidationResponse> Validate { get; set; }
    public override string ToString();
}

public class ValidationResponse
{
    public bool IsValid { get; set; }
    public ValidationStatusCode StatusCode { get; set; }
    public object[] Data { get; set; }
    public ValidationResponse();
    public ValidationResponse(ValidationStatusCode statusCode);
    public ValidationResponse(ValidationStatusCode statusCode, object[] data);
    public void SetData(object[] data);
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public class LeaderboardRank
    {
        public string UserIdString { get; set; }
        public int Level { get; set; }
        [JsonIgnore]
        public string UserDisplayName { get; set; }
    }

}

public class LeaderboardRank
{
    public string UserIdString { get; set; }
    public int Level { get; set; }
    [JsonIgnore]
    public string UserDisplayName { get; set; }
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public class QualityItem
    {
        public QualityItem(Item item);
        public ulong UID { get; set; }
        public int Quality { get; set; }
        public ulong? CreatorId { get; set; }
        [JsonIgnore]
        public bool HasCreator { get; set; }
        [JsonIgnore]
        public string CreatorDisplayName { get; set; }
    }

}

public class QualityItem
{
    public QualityItem(Item item);
    public ulong UID { get; set; }
    public int Quality { get; set; }
    public ulong? CreatorId { get; set; }
    [JsonIgnore]
    public bool HasCreator { get; set; }
    [JsonIgnore]
    public string CreatorDisplayName { get; set; }
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public class QualityItemStat
    {
        public string StatName { get; set; }
        public float PercentModified { get; set; }
    }

}

public class QualityItemStat
{
    public string StatName { get; set; }
    public float PercentModified { get; set; }
}

Oxide.Plugins
partial class QualityCrafting : CovalencePlugin
{
    public class CraftChance
    {
        public int Percent { get; set; }
        public int Quality { get; set; }
    }

}

public class CraftChance
{
    public int Percent { get; set; }
    public int Quality { get; set; }
}


```

---

## QuantumBattery by ColonBlow - Authorized players will deploy Quantum Batteries instead of normal one; fully charged and never die

```csharp
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Quantum Battery", "Colon Blow", "1.0.3")]
[Description("Fully Charged and Endless Batteries")]
public class QuantumBattery : CovalencePlugin
{
    private const string permMax;
    private bool initComplete;
    private void Init();
    private void OnServerInitialized();
    private static PluginConfig config;
    private class PluginConfig
    {
        public QuantumSettings quantumSettings { get; set; }
        public class QuantumSettings
        {
            [JsonProperty(PropertyName = "Quantum Battery - Enable Max Connection change : ")]
            public bool enableMaxOutput { get; set; }
            [JsonProperty(PropertyName = "Quantum Battery - Reset Max Allowed Connections to : ")]
            public int maxQuantumOutput { get; set; }
        }

        public static PluginConfig DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnEntitySpawned(ElectricBattery battery);
    private void ProcessExistingBatteries();
    private void ProcessBattery(ElectricBattery battery);
    private class BatteryAutoCharger : MonoBehaviour
    {
         ElectricBattery quantumBattery;
         float maxCapacity;
        private void Awake();
        private void FixedUpdate();
        private void OnDestroy();
    }

}

private class PluginConfig
{
    public QuantumSettings quantumSettings { get; set; }
    public class QuantumSettings
    {
        [JsonProperty(PropertyName = "Quantum Battery - Enable Max Connection change : ")]
        public bool enableMaxOutput { get; set; }
        [JsonProperty(PropertyName = "Quantum Battery - Reset Max Allowed Connections to : ")]
        public int maxQuantumOutput { get; set; }
    }

    public static PluginConfig DefaultConfig();
}

public class QuantumSettings
{
    [JsonProperty(PropertyName = "Quantum Battery - Enable Max Connection change : ")]
    public bool enableMaxOutput { get; set; }
    [JsonProperty(PropertyName = "Quantum Battery - Reset Max Allowed Connections to : ")]
    public int maxQuantumOutput { get; set; }
}

private class BatteryAutoCharger : MonoBehaviour
{
     ElectricBattery quantumBattery;
     float maxCapacity;
    private void Awake();
    private void FixedUpdate();
    private void OnDestroy();
}


```

---

## QuarryCraft by  - Returns the ability to craft quarries back

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Quarry Craft", "Vlad-00003", "1.0.2")]
[Description("Allow players with permissions craft quarry")]
 class QuarryCraft : RustPlugin
{
    private PluginConfig config;
    private ItemBlueprint bp;
    private ItemDefinition def;
    private class PluginConfig
    {
        [JsonProperty("Crafting price")]
        public Dictionary<string, int> Price;
        [JsonProperty("Workbench level required")]
        public int Workbench;
        [JsonProperty("Crafting time")]
        public float Time;
        [JsonProperty("Amount to create")]
        public int Amount;
        [JsonProperty("Permission to craft")]
        public string Permission;
        [JsonProperty("Command to craft")]
        public string Command;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     void Unload();
    private string GetMsg(string langkey, BasePlayer player, object[] args);
    protected override void LoadDefaultMessages();
    private void CmdCraft(BasePlayer player, string command, string[] args);
}

private class PluginConfig
{
    [JsonProperty("Crafting price")]
    public Dictionary<string, int> Price;
    [JsonProperty("Workbench level required")]
    public int Workbench;
    [JsonProperty("Crafting time")]
    public float Time;
    [JsonProperty("Amount to create")]
    public int Amount;
    [JsonProperty("Permission to craft")]
    public string Permission;
    [JsonProperty("Command to craft")]
    public string Command;
}


```

---

## QuarryHealth by VisEntities - Changes the health of quarries and pump jacks

```csharp
using Newtonsoft.Json;
using System.Collections;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Quarry Health", "VisEntities", "2.0.0")]
[Description("Alters the health of quarries and pump jacks.")]
public class QuarryHealth : RustPlugin
{
    private Coroutine _healthRefreshCoroutine;
    private static Configuration _config;
    private const string PREFAB_PUMP_JACK;
    private const string PREFAB_MINING_QUARRY;
    private class Configuration
    {
        [JsonProperty("Version")]
        public string Version { get; set; }
        [JsonProperty("Mining Quarry Hit Points")]
        public float MiningQuarryHitPoints { get; set; }
        [JsonProperty("Pump Jack Hit Points")]
        public float PumpJackQuarryHitPoints { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private Configuration GetDefaultConfig();
    private void OnServerInitialized();
    private void Unload();
    private void OnEntitySpawned(BaseResourceExtractor resourceExtractor);
    private void StartHealthRefreshCoroutine();
    private void StopHealthRefreshCoroutine();
    private IEnumerator RefreshAllResourceExtractorsHealth();
    private void InitializeResourceExtractorHealth(BaseResourceExtractor resourceExtractor);
}

private class Configuration
{
    [JsonProperty("Version")]
    public string Version { get; set; }
    [JsonProperty("Mining Quarry Hit Points")]
    public float MiningQuarryHitPoints { get; set; }
    [JsonProperty("Pump Jack Hit Points")]
    public float PumpJackQuarryHitPoints { get; set; }
}


```

---

## QuarryLock by VisEntities - Deploy code locks onto quarries and pump jacks

```csharp
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Quarry Lock", "VisEntities", "2.3.1")]
[Description("Deploy code locks onto quarries and pump jacks.")]
public class QuarryLock : RustPlugin
{
    [PluginReference]
    private readonly Plugin Clans;
    private readonly Plugin Friends;
    private static QuarryLock _plugin;
    private static Configuration _config;
    private Coroutine _codeLockParentUpdateCoroutine;
    private const int ITEM_ID_CODE_LOCK;
    private const string PREFAB_CODE_LOCK;
    private const string PREFAB_QUARRY_ENGINE;
    private const string PREFAB_QUARRY_FUEL;
    private const string PREFAB_QUARRY_HOPPER;
    private const string PREFAB_PUMP_JACK_ENGINE;
    private const string PREFAB_PUMP_JACK_FUEL;
    private const string PREFAB_PUMP_JACK_HOPPER;
    private const string FX_CODE_LOCK_DEPLOY;
    private class Configuration
    {
        [JsonProperty("Version")]
        public string Version { get; set; }
        [JsonProperty("Only Quarry Owner Can Place Locks")]
        public bool OnlyQuarryOwnerCanPlaceLocks { get; set; }
        [JsonProperty("Enable Auto Locking On Placement")]
        public bool EnableAutoLockingOnPlacement { get; set; }
        [JsonProperty("Enable Lock Placement On Static Extractors")]
        public bool EnableLockPlacementOnStaticExtractors { get; set; }
        [JsonProperty("Auto Authorize Teammates")]
        public bool AutoAuthorizeTeammates { get; set; }
        [JsonProperty("Auto Authorize Clanmates")]
        public bool AutoAuthorizeClanmates { get; set; }
        [JsonProperty("Auto Authorize Friends")]
        public bool AutoAuthorizeFriends { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private Configuration GetDefaultConfig();
    private void Init();
    private void Unload();
    private void OnServerInitialized(bool isStartup);
    private object CanLootEntity(BasePlayer player, ResourceExtractorFuelStorage storageContainer);
    private object OnQuarryToggle(MiningQuarry miningQuarry, BasePlayer player);
    private CodeLock DeployCodeLock(BasePlayer player, Item deployerItem, BaseEntity parent, Vector3 localPosition, Quaternion localRotation);
    private string GenerateRandomCode();
    private IEnumerator UpdateAllCodeLockParentsCoroutine();
    private static class CoroutineUtil
    {
        private static readonly Dictionary<string, Coroutine> _activeCoroutines;
        public static void StartCoroutine(string coroutineName, IEnumerator coroutineFunction);
        public static void StopCoroutine(string coroutineName);
        public static void StopAllCoroutines();
    }

    private static class ClanUtil
    {
        public static string GetClanTagOfPlayer(BasePlayer player);
        public static JObject GetClanInfo(string clanTag);
    }

    private static class FriendsUtil
    {
        public static ulong[] GetFriendsOfPlayer(ulong playerId);
    }

    private static class PermissionUtil
    {
        public const string ADMIN;
        public static void RegisterPermissions();
        public static bool VerifyHasPermission(BasePlayer player, string permissionName);
    }

    private static void RunEffect(string prefab, Vector3 worldPosition, Vector3 worldDirection, Connection effectRecipient, bool sendToAll);
    private static bool VerifyPluginBeingLoaded(Plugin plugin);
    private class Lang
    {
        public const string Locked;
        public const string CodeLockDeployed;
        public const string AutoLocked;
        public const string TeamAuthorized;
        public const string ClanAuthorized;
        public const string FriendsAuthorized;
        public const string StaticExtractorLockingBlocked;
        public const string OnlyOwnerCanPlaceLocks;
    }

    protected override void LoadDefaultMessages();
    private void SendReplyToPlayer(BasePlayer player, string messageKey, object[] args);
}

private class Configuration
{
    [JsonProperty("Version")]
    public string Version { get; set; }
    [JsonProperty("Only Quarry Owner Can Place Locks")]
    public bool OnlyQuarryOwnerCanPlaceLocks { get; set; }
    [JsonProperty("Enable Auto Locking On Placement")]
    public bool EnableAutoLockingOnPlacement { get; set; }
    [JsonProperty("Enable Lock Placement On Static Extractors")]
    public bool EnableLockPlacementOnStaticExtractors { get; set; }
    [JsonProperty("Auto Authorize Teammates")]
    public bool AutoAuthorizeTeammates { get; set; }
    [JsonProperty("Auto Authorize Clanmates")]
    public bool AutoAuthorizeClanmates { get; set; }
    [JsonProperty("Auto Authorize Friends")]
    public bool AutoAuthorizeFriends { get; set; }
}

private static class CoroutineUtil
{
    private static readonly Dictionary<string, Coroutine> _activeCoroutines;
    public static void StartCoroutine(string coroutineName, IEnumerator coroutineFunction);
    public static void StopCoroutine(string coroutineName);
    public static void StopAllCoroutines();
}

private static class ClanUtil
{
    public static string GetClanTagOfPlayer(BasePlayer player);
    public static JObject GetClanInfo(string clanTag);
}

private static class FriendsUtil
{
    public static ulong[] GetFriendsOfPlayer(ulong playerId);
}

private static class PermissionUtil
{
    public const string ADMIN;
    public static void RegisterPermissions();
    public static bool VerifyHasPermission(BasePlayer player, string permissionName);
}

private class Lang
{
    public const string Locked;
    public const string CodeLockDeployed;
    public const string AutoLocked;
    public const string TeamAuthorized;
    public const string ClanAuthorized;
    public const string FriendsAuthorized;
    public const string StaticExtractorLockingBlocked;
    public const string OnlyOwnerCanPlaceLocks;
}


```

---

## QuarryManager by  - Manage the quarry that has been has placed

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Quarry Manager", "Enforcer", "2.0.3")]
[Description("Manage a quarry that has been placed down")]
 class QuarryManager : RustPlugin
{
    private static QuarryManager Instance { get; set; }
    public static List<StaticQuarry> staticQuarries;
     List<SphereEntity> sphereEntities;
     StringBuilder addedPlayerList;
     bool teamAccess;
     bool addedPlayersAccess;
    static bool isStaticQuarryToggled { get; set; }
    static ulong staticQuarryToggler { get; set; }
    private static bool LockZone { get; set; }
     int count;
    private const int layers;
    static MiningQuarry _quarry;
    private const string usePerm;
    private const string teamLockPerm;
    private const string playerLockPerm;
    private const string allowBypassPerm;
    private const string adminPerm;
    private void OnServerInitialized();
    private void Loaded();
     void Unload();
     void OnNewSave();
     ConfigData config;
    private class ConfigData
    {
        [JsonProperty("General Settings")]
        public GeneralSettings generalSettings { get; set; }
        [JsonProperty("Commands")]
        public Commands commands { get; set; }
        [JsonProperty("Chat Settings")]
        public ChatSettings chatSettings { get; set; }
        [JsonProperty("Share Settings")]
        public ShareSettings shareSettings { get; set; }
    }

    public class GeneralSettings
    {
        [JsonProperty(PropertyName = "Wipe Data on new save")]
        public bool wipeDataOnNewSave { get; set; }
    }

    public class Commands
    {
        [JsonProperty(PropertyName = "Quarry Manager Command")]
        public string qmCommand { get; set; }
    }

    public class ChatSettings
    {
        [JsonProperty(PropertyName = "Chat prefix")]
        public string chatPrefix { get; set; }
        [JsonProperty(PropertyName = "Chat prefix colour")]
        public string chatPrefixColour { get; set; }
        [JsonProperty(PropertyName = "Chat icon")]
        public ulong chatIcon { get; set; }
        [JsonProperty("Quarry Share Messages")]
        public QuarryShareMessages quarryShareMessages { get; set; }
        [JsonProperty("RCON/Server Console Messages")]
        public ServerConsoleMessages serverConsoleMessages { get; set; }
    }

    public class QuarryShareMessages
    {
        [JsonProperty(PropertyName = "Print a message if team share is enabled")]
        public bool messageOnTeamShareEnabled { get; set; }
        [JsonProperty(PropertyName = "Print a message if team share is disabled")]
        public bool messageOnTeamShareDisabled { get; set; }
        [JsonProperty(PropertyName = "Print a message if a player is added to the share list")]
        public bool messageOnAddedToPlayerList { get; set; }
        [JsonProperty(PropertyName = "Print a message if a player is removed to the share list")]
        public bool messageOnRemovedFromPlayerList { get; set; }
        [JsonProperty(PropertyName = "Print a message if a player has activated a static quarry")]
        public bool messageOnStaticQuarryBeingUsed { get; set; }
    }

    public class ServerConsoleMessages
    {
        [JsonProperty(PropertyName = "Message the console if someone enables team share")]
        public bool messageRCONOnEnabledTeamShare { get; set; }
        [JsonProperty(PropertyName = "Message the console if someone disables team share")]
        public bool messageRCONOnDisableTeamShare { get; set; }
        [JsonProperty(PropertyName = "Message the console if someone is added to the share list")]
        public bool messageRCONOnAddedToShareList { get; set; }
        [JsonProperty(PropertyName = "Message the console if a player is removed to the share list")]
        public bool messageRCONOnRemovedToPlayerList { get; set; }
        [JsonProperty(PropertyName = "Message the console on static quarry lock activated")]
        public bool messageRCONOnStaticQuarryBeingUsed { get; set; }
    }

    public class ShareSettings
    {
        [JsonProperty(PropertyName = "Players can toggle other players quarries")]
        public bool canToggleQuarry { get; set; }
        [JsonProperty(PropertyName = "Lock quarry containers")]
        public bool canOpenQuarryContainers { get; set; }
        [JsonProperty("Team Sharing")]
        public TeamSharing teamSharing { get; set; }
        [JsonProperty("Individual Player Sharing")]
        public IndividualPlayerSharing individualPlayerSharing { get; set; }
        [JsonProperty("Static Quarry Sharing")]
        public StaticQuarrySharing staticQuarrySharing { get; set; }
    }

    public class TeamSharing
    {
        [JsonProperty(PropertyName = "Allow team to toggle the quarry")]
        public bool canTeamToggleQuarry { get; set; }
        [JsonProperty(PropertyName = "Allow team to open the quarries containers")]
        public bool canTeamOpenQuarry { get; set; }
    }

    public class IndividualPlayerSharing
    {
        [JsonProperty(PropertyName = "Allow added players to toggle the quarry")]
        public bool canAddedPlayersToggleQuarry { get; set; }
        [JsonProperty(PropertyName = "Allow added players to open the quarries containers")]
        public bool canAddedPlayersOpenQuarry { get; set; }
    }

    public class StaticQuarrySharing
    {
        [JsonProperty(PropertyName = "Enable static quarry lock")]
        public bool enableStaticQuarryShare { get; set; }
        [JsonProperty("Static Quarry Sharing")]
        public LocalSharing localSharing { get; set; }
    }

    public class LocalSharing
    {
        [JsonProperty(PropertyName = "If the player leaves the dome unlock the static quarry")]
        public bool unlockStaticQuarryOnExitDome { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private PlayerData playerData;
    public class PlayerData
    {
        public Dictionary<ulong, User> players;
        public User AddPlayer(ulong playerID, bool isTeamShareEnabled, Dictionary<ulong, string> addedPlayers);
        public bool GetPlayer(ulong playerID);
    }

    public class User
    {
        public bool EnabledTeamShare;
        public Dictionary<ulong, string> addedPlayers;
    }

     void LoadData();
    private void SaveData();
    private void WipeData();
    protected override void LoadDefaultMessages();
    private bool IsAdmin(BasePlayer player);
    private void Message(string message, BasePlayer player, string[] args);
    private void MessageConsole(string message, string[] args);
     void QuarryShareCommand(BasePlayer bPlayer, string command, string[] args);
     object CanLootEntity(BasePlayer bPlayer, ResourceExtractorFuelStorage container);
    private void OnQuarryToggled(MiningQuarry quarry, BasePlayer bPlayer);
    public BasePlayer FindPlayer(string nameOrID);
    private void AddOrRemoveUser(BasePlayer player, bool isAdding, bool isRemoving, string[] args);
    private static BaseEntity GetEntity(Collider collider);
    public static Vector3 MoveLocation(Vector3 position, float distance, Vector3 target, float radius, float yAmount);
    public static bool MovePlayer(BasePlayer bPlayer, Vector3 pos);
    public static bool MoveMountable(BaseMountable bMountable, Vector3 pos, float distance, float radius);
    private static bool IsStaticQuarryContainsFuel(MiningQuarry quarry);
     void FindStaticQuarry(BaseNetworkable entity);
     void CreateSphere(Vector3 spherePosition, float radius);
    public class StaticQuarry : MonoBehaviour
    {
        private static StaticQuarry staticQuarry;
        private GameObject _gameObject;
        private float colRadius;
        public static void Init(Vector3 position, float radius);
        private void OnTriggerEnter(Collider collider);
        private void OnTriggerExit(Collider collider);
        private bool IsBypassAllowed(BasePlayer player);
    }

}

private class ConfigData
{
    [JsonProperty("General Settings")]
    public GeneralSettings generalSettings { get; set; }
    [JsonProperty("Commands")]
    public Commands commands { get; set; }
    [JsonProperty("Chat Settings")]
    public ChatSettings chatSettings { get; set; }
    [JsonProperty("Share Settings")]
    public ShareSettings shareSettings { get; set; }
}

public class GeneralSettings
{
    [JsonProperty(PropertyName = "Wipe Data on new save")]
    public bool wipeDataOnNewSave { get; set; }
}

public class Commands
{
    [JsonProperty(PropertyName = "Quarry Manager Command")]
    public string qmCommand { get; set; }
}

public class ChatSettings
{
    [JsonProperty(PropertyName = "Chat prefix")]
    public string chatPrefix { get; set; }
    [JsonProperty(PropertyName = "Chat prefix colour")]
    public string chatPrefixColour { get; set; }
    [JsonProperty(PropertyName = "Chat icon")]
    public ulong chatIcon { get; set; }
    [JsonProperty("Quarry Share Messages")]
    public QuarryShareMessages quarryShareMessages { get; set; }
    [JsonProperty("RCON/Server Console Messages")]
    public ServerConsoleMessages serverConsoleMessages { get; set; }
}

public class QuarryShareMessages
{
    [JsonProperty(PropertyName = "Print a message if team share is enabled")]
    public bool messageOnTeamShareEnabled { get; set; }
    [JsonProperty(PropertyName = "Print a message if team share is disabled")]
    public bool messageOnTeamShareDisabled { get; set; }
    [JsonProperty(PropertyName = "Print a message if a player is added to the share list")]
    public bool messageOnAddedToPlayerList { get; set; }
    [JsonProperty(PropertyName = "Print a message if a player is removed to the share list")]
    public bool messageOnRemovedFromPlayerList { get; set; }
    [JsonProperty(PropertyName = "Print a message if a player has activated a static quarry")]
    public bool messageOnStaticQuarryBeingUsed { get; set; }
}

public class ServerConsoleMessages
{
    [JsonProperty(PropertyName = "Message the console if someone enables team share")]
    public bool messageRCONOnEnabledTeamShare { get; set; }
    [JsonProperty(PropertyName = "Message the console if someone disables team share")]
    public bool messageRCONOnDisableTeamShare { get; set; }
    [JsonProperty(PropertyName = "Message the console if someone is added to the share list")]
    public bool messageRCONOnAddedToShareList { get; set; }
    [JsonProperty(PropertyName = "Message the console if a player is removed to the share list")]
    public bool messageRCONOnRemovedToPlayerList { get; set; }
    [JsonProperty(PropertyName = "Message the console on static quarry lock activated")]
    public bool messageRCONOnStaticQuarryBeingUsed { get; set; }
}

public class ShareSettings
{
    [JsonProperty(PropertyName = "Players can toggle other players quarries")]
    public bool canToggleQuarry { get; set; }
    [JsonProperty(PropertyName = "Lock quarry containers")]
    public bool canOpenQuarryContainers { get; set; }
    [JsonProperty("Team Sharing")]
    public TeamSharing teamSharing { get; set; }
    [JsonProperty("Individual Player Sharing")]
    public IndividualPlayerSharing individualPlayerSharing { get; set; }
    [JsonProperty("Static Quarry Sharing")]
    public StaticQuarrySharing staticQuarrySharing { get; set; }
}

public class TeamSharing
{
    [JsonProperty(PropertyName = "Allow team to toggle the quarry")]
    public bool canTeamToggleQuarry { get; set; }
    [JsonProperty(PropertyName = "Allow team to open the quarries containers")]
    public bool canTeamOpenQuarry { get; set; }
}

public class IndividualPlayerSharing
{
    [JsonProperty(PropertyName = "Allow added players to toggle the quarry")]
    public bool canAddedPlayersToggleQuarry { get; set; }
    [JsonProperty(PropertyName = "Allow added players to open the quarries containers")]
    public bool canAddedPlayersOpenQuarry { get; set; }
}

public class StaticQuarrySharing
{
    [JsonProperty(PropertyName = "Enable static quarry lock")]
    public bool enableStaticQuarryShare { get; set; }
    [JsonProperty("Static Quarry Sharing")]
    public LocalSharing localSharing { get; set; }
}

public class LocalSharing
{
    [JsonProperty(PropertyName = "If the player leaves the dome unlock the static quarry")]
    public bool unlockStaticQuarryOnExitDome { get; set; }
}

public class PlayerData
{
    public Dictionary<ulong, User> players;
    public User AddPlayer(ulong playerID, bool isTeamShareEnabled, Dictionary<ulong, string> addedPlayers);
    public bool GetPlayer(ulong playerID);
}

public class User
{
    public bool EnabledTeamShare;
    public Dictionary<ulong, string> addedPlayers;
}

public class StaticQuarry : MonoBehaviour
{
    private static StaticQuarry staticQuarry;
    private GameObject _gameObject;
    private float colRadius;
    public static void Init(Vector3 position, float radius);
    private void OnTriggerEnter(Collider collider);
    private void OnTriggerExit(Collider collider);
    private bool IsBypassAllowed(BasePlayer player);
}


```

---

## QuarryNearNoBuild by  - Prevent building near automatically spawned quarries.

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Quarry Near No Build", "Arainrr", "1.2.0")]
[Description("Prevent building near automatically spawned quarries.")]
internal class QuarryNearNoBuild : RustPlugin
{
    private const string PERMISSION_IGNORE;
    private readonly List<QuarryInfo> quarryInfos;
    private void Init();
    private void OnServerInitialized();
    private class QuarryInfo
    {
        public Vector3 position;
        public float radius;
    }

    private void FindMiningQuarry();
    private object CanBuild(Planner planner, Construction prefab, Construction.Target target);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Block Radius")]
        public Dictionary<QuarryType, float> blockRadius;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat Prefix Color")]
        public string prefixColor;
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong steamIDIcon;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Print(BasePlayer player, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

private class QuarryInfo
{
    public Vector3 position;
    public float radius;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Block Radius")]
    public Dictionary<QuarryType, float> blockRadius;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat Prefix Color")]
    public string prefixColor;
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong steamIDIcon;
}


```

---

## QuarryRepair by VisEntities - Brings back the ability to repair deployable quarries and pump jacks

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Quarry Repair", "VisEntities", "2.0.0")]
[Description("Brings back the ability to repair deployable quarries and pump jacks.")]
public class QuarryRepair : RustPlugin
{
    private static QuarryRepair _plugin;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty("Version")]
        public string Version { get; set; }
        [JsonProperty("Health Per Hit")]
        public float HealthPerHit { get; set; }
        [JsonProperty("Repair Cost")]
        public List<ItemInfo> RepairCost { get; set; }
    }

    public class ItemInfo
    {
        [JsonProperty("Shortname")]
        public string Shortname { get; set; }
        [JsonProperty("Amount")]
        public int Amount { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private Configuration GetDefaultConfig();
    private void Init();
    private void Unload();
    private void OnHammerHit(BasePlayer player, HitInfo hitInfo);
}

private class Configuration
{
    [JsonProperty("Version")]
    public string Version { get; set; }
    [JsonProperty("Health Per Hit")]
    public float HealthPerHit { get; set; }
    [JsonProperty("Repair Cost")]
    public List<ItemInfo> RepairCost { get; set; }
}

public class ItemInfo
{
    [JsonProperty("Shortname")]
    public string Shortname { get; set; }
    [JsonProperty("Amount")]
    public int Amount { get; set; }
}


```

---

## QuarryStopChecker by OldGuyWoody - Stops unauthorized players from turning off quarries

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Quarry Stop Checker", "OldGuyWoody", "1.0.2")]
[Description("Stop degenerates from turning off quarries they don't have access to")]
public class QuarryStopChecker : RustPlugin
{
    [PluginReference]
    private readonly Plugin Slap;
    private PluginConfig config;
    private void OnServerInitialized();
    private void OnQuarryToggled(MiningQuarry quarry);
    protected override void LoadDefaultMessages();
    private void Message(BasePlayer player, string messageKey, object[] args);
    private string GetMessage(string messageKey, string playerID, object[] args);
    private class PluginConfig
    {
        public bool EnableChatOnCaught;
        public bool EnableSlapOnCaught;
        public bool EnableServerLog;
    }

    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
}

private class PluginConfig
{
    public bool EnableChatOnCaught;
    public bool EnableSlapOnCaught;
    public bool EnableServerLog;
}


```

---

## Quests by DevGonzi - Creates quests for players to go on to earn rewards, complete with a GUI menu

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Quests", "Gonzi", "2.4.3")]
[Description("Creates quests for players to go on to earn rewards, complete with a GUI menu")]
public class Quests : RustPlugin
{
    [PluginReference]
     Plugin HumanNPC;
    [PluginReference]
     Plugin ServerRewards;
    [PluginReference]
     Plugin Economics;
    [PluginReference]
     Plugin LustyMap;
    [PluginReference]
     Plugin EventManager;
    [PluginReference]
     Plugin HuntRPG;
    [PluginReference]
     Plugin PlayerChallenges;
    [PluginReference]
     Plugin BetterChat;
     ConfigData configData;
     QuestData questData;
     PlayerData playerData;
     NPCData vendors;
     ItemNames itemNames;
    private DynamicConfigFile Quest_Data;
    private DynamicConfigFile Player_Data;
    private DynamicConfigFile Quest_Vendors;
    private DynamicConfigFile Item_Names;
    private Dictionary<ulong, PlayerQuestData> PlayerProgress;
    private Dictionary<QuestType, Dictionary<string, QuestEntry>> Quest;
    private Dictionary<string, ItemDefinition> ItemDefs;
    private Dictionary<string, string> DisplayNames;
    private Dictionary<ulong, QuestCreator> ActiveCreations;
    private Dictionary<ulong, QuestCreator> ActiveEditors;
    private Dictionary<ulong, bool> AddVendor;
    private Dictionary<QuestType, List<string>> AllObjectives;
    private Dictionary<NetworkableId, Dictionary<ulong, int>> HeliAttackers;
    private Dictionary<ulong, List<string>> OpenUI;
    private Dictionary<ItemId, ulong> Looters;
    private List<ulong> StatsMenu;
    private List<ulong> OpenMenuBind;
    static string UIMain;
    static string UIPanel;
    static string UIEntry;
    static string permission_manage;
    static string permission_use;
    private string textPrimary;
    private string textSecondary;
     class PlayerQuestData
    {
        public Dictionary<string, PlayerQuestInfo> Quests;
        public List<QuestInfo> RequiredItems;
        public ActiveDelivery CurrentDelivery;
    }

     class PlayerQuestInfo
    {
        public QuestStatus Status;
        public QuestType Type;
        public int AmountCollected;
        public bool RewardClaimed;
        public double ResetTime;
    }

     class QuestEntry
    {
        public string QuestName;
        public string Description;
        public string Objective;
        public string ObjectiveName;
        public int AmountRequired;
        public int Cooldown;
        public bool ItemDeduction;
        public List<RewardItem> Rewards;
    }

     class NPCInfo
    {
        public float x;
        public float z;
        public string ID;
        public string Name;
    }

     class DeliveryInfo
    {
        public string Description;
        public NPCInfo Info;
        public RewardItem Reward;
        public float Multiplier;
    }

     class ActiveDelivery
    {
        public string VendorID;
        public string TargetID;
        public float Distance;
    }

     class QuestInfo
    {
        public string ShortName;
        public QuestType Type;
    }

     class RewardItem
    {
        public bool isRP;
        public bool isCoins;
        public bool isHuntXP;
        public string DisplayName;
        public string ShortName;
        public int ID;
        public float Amount;
        public bool BP;
        public ulong Skin;
    }

     class QuestCreator
    {
        public QuestType type;
        public QuestEntry entry;
        public DeliveryInfo deliveryInfo;
        public RewardItem item;
        public string oldEntry;
        public int partNum;
    }

     class ItemNames
    {
        public Dictionary<string, string> DisplayNames;
    }

     class QUI
    {
        public static bool disableFade;
        static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
        static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align, float fadein);
        static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align, float fadein);
        static public void LoadImage(CuiElementContainer container, string panel, string png, string aMin, string aMax);
        static public void CreateTextOverlay(CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align, float fadein);
        static public string Color(string hexColor, float alpha);
    }

     void Loaded();
     void OnServerInitialized();
     void Unload();
     void OnPlayerConnected(BasePlayer player);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void OnEntityTakeDamage(BaseCombatEntity victim, HitInfo info);
     void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
     void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item);
     void OnGrowableGather(GrowableEntity growable, Item item, BasePlayer player);
     void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player);
     void OnItemCraftFinished(ItemCraftTask task, Item item);
     void OnItemAddedToContainer(ItemContainer container, Item item);
     void OnItemRemovedFromContainer(ItemContainer container, Item item);
     void OnUseNPC(BasePlayer npc, BasePlayer player);
     object OnPlayerChat(BasePlayer player, string message);
     object OnBetterChat(Dictionary<string, object> dict);
     void QuestChat(BasePlayer player, string[] arg);
    private bool isPlaying(BasePlayer player);
    private void CloseMap(BasePlayer player);
    private void OpenMap(BasePlayer player);
    private void AddMapMarker(float x, float z, string name, string icon, float r);
    private void RemoveMapMarker(string name);
    private object CanTeleport(BasePlayer player);
    private void FillObjectiveList();
    private void GetAllItems();
    private void GetAllCraftables();
    private void GetAllResources();
    private void GetAllKillables();
    private bool isAdmin(BasePlayer player);
     void AddMapIcons();
    private void ProcessProgress(BasePlayer player, QuestType questType, string type, int amount);
    private void TakeQuestItem(BasePlayer player, string item, int amount);
    private void CompleteQuest(BasePlayer player, string questName);
    private ItemDefinition FindItemDefinition(string shortname);
    private string GetRewardString(List<RewardItem> entry);
    private bool GiveReward(BasePlayer player, List<RewardItem> rewards);
    private void ReturnItems(BasePlayer player, string itemname, int amount);
    private RewardItem GetItem(BasePlayer player);
    private bool hasQuests(ulong player);
    private bool isQuestItem(ulong player, string name, QuestType type);
    private void CheckPlayerEntry(BasePlayer player);
    private object GetQuestType(string name);
    private QuestEntry GetQuest(string name);
    private void SaveQuest(BasePlayer player, bool isCreating);
    private void SaveRewardsEdit(BasePlayer player);
    private void ExitQuest(BasePlayer player, bool isCreating);
    private void RemoveQuest(string questName);
    private ulong GetLastAttacker(NetworkableId id);
    private string GetTypeDescription(QuestType type);
    private QuestType ConvertStringToType(string type);
    private string isNPCRegistered(string ID);
    static double GrabCurrentTime();
    private BasePlayer FindEntity(BasePlayer player);
    private object Ray(BasePlayer player, Vector3 Aim);
    private void SetVendorName();
    private void RemoveVendor(BasePlayer player, string ID, bool isVendor);
    private string GetRandomNPC(string ID);
    private string LA(string key, string userID);
    private void CreateMenu(BasePlayer player);
    private void CreateEmptyMenu(BasePlayer player);
    private void CreateMenuButton(CuiElementContainer container, string panelName, string buttonname, string command, int number);
    private void ListElement(BasePlayer player, QuestType type, int page);
    private void CreateQuestEntry(BasePlayer player, QuestEntry entry, int num);
    private void PlayerStats(BasePlayer player, int page);
    private void CreateStatEntry(BasePlayer player, QuestEntry entry, int num);
    private void PlayerDelivery(BasePlayer player);
    private void CreationMenu(BasePlayer player);
    private void CreationHelp(BasePlayer player, int page);
    private void CreateObjectiveMenu(BasePlayer player, int page);
    private void DeliveryHelp(BasePlayer player, int page);
    private void AcceptDelivery(BasePlayer player, string npcID, int page);
    private void DeletionEditMenu(BasePlayer player, string page, string command);
    private void DeleteNPCMenu(BasePlayer player);
    private void ConfirmDeletion(BasePlayer player, string questName);
    private void ConfirmCancellation(BasePlayer player, string questName);
    private void QuestEditorMenu(BasePlayer player);
    private void CreateObjectiveEntry(CuiElementContainer container, string panelName, string name, int number);
    private void CreateNewQuestButton(CuiElementContainer container, string panelName, string buttonname, string command, int number);
    private void CreateRewardTypeButton(CuiElementContainer container, string panelName, string buttonname, string command, int number);
    private void CreateDelEditButton(CuiElementContainer container, float xPos, string panelName, string buttonname, int number, string command, float width);
    private void CreateDelVendorButton(CuiElementContainer container, float xPos, string panelName, string buttonname, int number, string command);
    private void PopupMessage(BasePlayer player, string msg);
    private Vector2 CalcQuestPos(int number);
    private float[] CalcEntryPos(int number);
    private void AddUIString(BasePlayer player, string name);
    private void DestroyUI(BasePlayer player);
    private void DestroyEntries(BasePlayer player);
    [ConsoleCommand("QUI_AcceptQuest")]
    private void cmdAcceptQuest(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_AcceptDelivery")]
    private void cmdAcceptDelivery(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_CancelDelivery")]
    private void cmdCancelDelivery(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_FinishDelivery")]
    private void cmdFinishDelivery(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_ChangeElement")]
    private void cmdChangeElement(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_DestroyAll")]
    private void cmdDestroyAll(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_NewQuest")]
    private void cmdNewQuest(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_AddVendor")]
    private void cmdAddVendor(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_SelectObj")]
    private void cmdSelectObj(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_RewardType")]
    private void cmdRewardType(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_ClaimReward")]
    private void cmdClaimReward(ConsoleSystem.Arg arg);
     bool IsQuestCompleted(ulong playerId, string questName);
    [ConsoleCommand("QUI_CancelQuest")]
    private void cmdCancelQuest(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_ItemDeduction")]
    private void cmdItemDeduction(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_ConfirmCancel")]
    private void cmdConfirmCancel(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_RemoveCompleted")]
    private void cmdRemoveCompleted(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_DeleteQuest")]
    private void cmdDeleteQuest(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_DeleteNPCMenu")]
    private void cmdDeleteNPCMenu(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_RemoveVendor")]
    private void cmdRemoveVendor(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_ConfirmDelete")]
    private void cmdConfirmDelete(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_EditQuest")]
    private void cmdEditQuest(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_EditQuestVar")]
    private void cmdEditQuestVar(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_RemoveReward")]
    private void cmdEditReward(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_EndEditing")]
    private void cmdEndEditing(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_SaveQuest")]
    private void cmdSaveQuest(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_ExitQuest")]
    private void cmdExitQuest(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_AddReward")]
    private void cmdAddReward(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_RewardFinish")]
    private void cmdFinishReward(ConsoleSystem.Arg arg);
    [ConsoleCommand("QUI_OpenQuestMenu")]
    private void cmdOpenQuestMenu(ConsoleSystem.Arg arg);
    [ChatCommand("q")]
     void cmdOpenMenu(BasePlayer player, string command, string[] args);
    [ChatCommand("wipePlayerProgress")]
     void wipePlayerProgress(BasePlayer player, string command, string[] args);
    [ChatCommand("questnpc")]
     void cmdQuestNPC(BasePlayer player, string command, string[] args);
     void SaveQuestData();
     void SaveVendorData();
     void SavePlayerData();
     void SaveDisplayNames();
    private void SaveLoop();
     void LoadData();
     class QuestData
    {
        public Dictionary<QuestType, Dictionary<string, QuestEntry>> Quest;
    }

     class PlayerData
    {
        public Dictionary<ulong, PlayerQuestData> PlayerProgress;
    }

     class NPCData
    {
        public Dictionary<string, NPCInfo> QuestVendors;
        public Dictionary<string, DeliveryInfo> DeliveryVendors;
    }

     class UIColor
    {
        public string Color { get; set; }
        public float Alpha { get; set; }
    }

     class Colors
    {
        public string TextColor_Primary { get; set; }
        public string TextColor_Secondary { get; set; }
        public UIColor Background_Dark { get; set; }
        public UIColor Background_Light { get; set; }
        public UIColor Button_Standard { get; set; }
        public UIColor Button_Accept { get; set; }
        public UIColor Button_Completed { get; set; }
        public UIColor Button_Cancel { get; set; }
        public UIColor Button_Pending { get; set; }
    }

     class Keybinds
    {
        public bool Autoset_KeyBind { get; set; }
        public string KeyBind_Key { get; set; }
    }

     class LMIcons
    {
        public string Icon_Vendor { get; set; }
        public string Icon_Delivery { get; set; }
    }

     class ConfigData
    {
        public Colors Colors { get; set; }
        public Keybinds KeybindOptions { get; set; }
        public LMIcons LustyMapIntegration { get; set; }
        public bool DisableUI_FadeIn { get; set; }
        public bool UseNPCVendors { get; set; }
        public bool UseOxidePermissions { get; set; }
        public bool UsePlayerIsAdmin { get; set; }
        public int PlayerMaxQuests { get; set; }
    }

    private void LoadVariables();
    private void LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConfig(ConfigData config);
     void SendMSG(BasePlayer player, string message, string keyword);
     Dictionary<string, string> Localization;
    private bool API_GetNotChatOutput(BasePlayer player);
}

 class PlayerQuestData
{
    public Dictionary<string, PlayerQuestInfo> Quests;
    public List<QuestInfo> RequiredItems;
    public ActiveDelivery CurrentDelivery;
}

 class PlayerQuestInfo
{
    public QuestStatus Status;
    public QuestType Type;
    public int AmountCollected;
    public bool RewardClaimed;
    public double ResetTime;
}

 class QuestEntry
{
    public string QuestName;
    public string Description;
    public string Objective;
    public string ObjectiveName;
    public int AmountRequired;
    public int Cooldown;
    public bool ItemDeduction;
    public List<RewardItem> Rewards;
}

 class NPCInfo
{
    public float x;
    public float z;
    public string ID;
    public string Name;
}

 class DeliveryInfo
{
    public string Description;
    public NPCInfo Info;
    public RewardItem Reward;
    public float Multiplier;
}

 class ActiveDelivery
{
    public string VendorID;
    public string TargetID;
    public float Distance;
}

 class QuestInfo
{
    public string ShortName;
    public QuestType Type;
}

 class RewardItem
{
    public bool isRP;
    public bool isCoins;
    public bool isHuntXP;
    public string DisplayName;
    public string ShortName;
    public int ID;
    public float Amount;
    public bool BP;
    public ulong Skin;
}

 class QuestCreator
{
    public QuestType type;
    public QuestEntry entry;
    public DeliveryInfo deliveryInfo;
    public RewardItem item;
    public string oldEntry;
    public int partNum;
}

 class ItemNames
{
    public Dictionary<string, string> DisplayNames;
}

 class QUI
{
    public static bool disableFade;
    static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
    static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align, float fadein);
    static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align, float fadein);
    static public void LoadImage(CuiElementContainer container, string panel, string png, string aMin, string aMax);
    static public void CreateTextOverlay(CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align, float fadein);
    static public string Color(string hexColor, float alpha);
}

 class QuestData
{
    public Dictionary<QuestType, Dictionary<string, QuestEntry>> Quest;
}

 class PlayerData
{
    public Dictionary<ulong, PlayerQuestData> PlayerProgress;
}

 class NPCData
{
    public Dictionary<string, NPCInfo> QuestVendors;
    public Dictionary<string, DeliveryInfo> DeliveryVendors;
}

 class UIColor
{
    public string Color { get; set; }
    public float Alpha { get; set; }
}

 class Colors
{
    public string TextColor_Primary { get; set; }
    public string TextColor_Secondary { get; set; }
    public UIColor Background_Dark { get; set; }
    public UIColor Background_Light { get; set; }
    public UIColor Button_Standard { get; set; }
    public UIColor Button_Accept { get; set; }
    public UIColor Button_Completed { get; set; }
    public UIColor Button_Cancel { get; set; }
    public UIColor Button_Pending { get; set; }
}

 class Keybinds
{
    public bool Autoset_KeyBind { get; set; }
    public string KeyBind_Key { get; set; }
}

 class LMIcons
{
    public string Icon_Vendor { get; set; }
    public string Icon_Delivery { get; set; }
}

 class ConfigData
{
    public Colors Colors { get; set; }
    public Keybinds KeybindOptions { get; set; }
    public LMIcons LustyMapIntegration { get; set; }
    public bool DisableUI_FadeIn { get; set; }
    public bool UseNPCVendors { get; set; }
    public bool UseOxidePermissions { get; set; }
    public bool UsePlayerIsAdmin { get; set; }
    public int PlayerMaxQuests { get; set; }
}


```

---

## QueueHolder by Tryhard - If you disconnect when the server is full, you can rejoin

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Queue Holder", "Tryhard", "1.0.1")]
[Description("Saves your position in queue if you disconnect")]
public class QueueHolder : RustPlugin
{
    private Dictionary<ulong, DateTime> _queueHolder;
    private void Init();
    private object CanBypassQueue(Network.Connection connection);
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    static Configuration config;
    public class Configuration
    {
        [JsonProperty("Enable queue holding")]
        public bool eQueue;
        [JsonProperty("Queue holding timer")]
        public int queueTime;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class Configuration
{
    [JsonProperty("Enable queue holding")]
    public bool eQueue;
    [JsonProperty("Queue holding timer")]
    public int queueTime;
}


```

---

## QueueLimit by Ryan - Limits the number of players allowed in the connection queue

```csharp
using System.Collections.Generic;
using ConVar;

Oxide.Plugins
[Info("Queue Limit", "Ryan", "1.0.1")]
[Description("Limits the number of players allowed in the connection queue")]
 class QueueLimit : RustPlugin
{
    private int Limit;
    private string Perm;
    private void LoadDefaultConfig();
    private new void LoadDefaultMessages();
    private void Init();
    private string CanClientLogin(Network.Connection connection);
}


```

---

## QuickLoadouts by CARNY666 - Fast access to preset inventory packages.

```csharp
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Collections;

Oxide.Plugins
[Info("QuickLoadouts", "carny666", "1.0.1", ResourceId = 2731)]
 class QuickLoadouts : RustPlugin
{
    const string adminPermission;
    const string allPermission;
    const string loadoutFileName;
    const string AdminCommandChatConsole;
    const string UseCommandChatConsole;
     Loadouts loadouts;
     void Init();
    protected override void LoadDefaultMessages();
     class Loadouts
    {
        public List<Loadout> loadouts;
        public Loadouts();
        public bool AddPlayersLoadout(BasePlayer player, string Name);
        public bool ReplacePlayersLoadout(BasePlayer player, string Name);
        public bool LoadoutExistByName(string Name);
    }

     class Loadout
    {
        public object name { get; set; }
        public List<ModItem> containerWear;
        public List<ModItem> containerBelt;
        public List<ModItem> containerMain;
        public Loadout();
        public Loadout(object packName);
        public Loadout(BasePlayer player);
        public void SupplyLoadout(BasePlayer Player, bool clearInventory);
    }

     class ModItem
    {
        public string equipName;
        public int amount;
        public ulong skinId;
        public ModItemType etype;
        public List<string> addons;
        public ModItem();
        public ModItem(string EquipName, ModItemType type, int Amount);
        public ModItem(string EquipName, string[] Addons, int AmmoAmount);
        public ModItem(Item item);
        public Item Item();
    }

     void UseLoadout(BasePlayer player, string LoaoutName);
     void UseLoadout(BasePlayer player, Loadout l);
    [ChatCommand(UseCommandChatConsole)]
     void chatCommandUseLoadout(BasePlayer player, string command, string[] args);
    [ConsoleCommand(UseCommandChatConsole)]
     void consoleCommandUseLoadout(ConsoleSystem.Arg arg);
    [ChatCommand(AdminCommandChatConsole)]
     void chatCommandquickloadout(BasePlayer player, string command, string[] args);
}

 class Loadouts
{
    public List<Loadout> loadouts;
    public Loadouts();
    public bool AddPlayersLoadout(BasePlayer player, string Name);
    public bool ReplacePlayersLoadout(BasePlayer player, string Name);
    public bool LoadoutExistByName(string Name);
}

 class Loadout
{
    public object name { get; set; }
    public List<ModItem> containerWear;
    public List<ModItem> containerBelt;
    public List<ModItem> containerMain;
    public Loadout();
    public Loadout(object packName);
    public Loadout(BasePlayer player);
    public void SupplyLoadout(BasePlayer Player, bool clearInventory);
}

 class ModItem
{
    public string equipName;
    public int amount;
    public ulong skinId;
    public ModItemType etype;
    public List<string> addons;
    public ModItem();
    public ModItem(string EquipName, ModItemType type, int Amount);
    public ModItem(string EquipName, string[] Addons, int AmmoAmount);
    public ModItem(Item item);
    public Item Item();
}


```

---

## QuickSmelt by misticos - Increases the speed of the furnace smelting

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Quick Smelt", "misticos", "5.1.5")]
[Description("Increases the speed of the furnace smelting")]
 class QuickSmelt : RustPlugin
{
    private static QuickSmelt _instance;
    private const string PermissionUse;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Use Permission")]
        public bool UsePermission;
        [JsonProperty(PropertyName = "Speed Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, float> SpeedMultipliers;
        [JsonProperty(PropertyName = "Fuel Usage Speed Multipliers",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, float> FuelSpeedMultipliers;
        [JsonProperty(PropertyName = "Fuel Usage Multipliers",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, int> FuelUsageMultipliers;
        [JsonProperty(PropertyName = "Output Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, Dictionary<string, float>> OutputMultipliers;
        [JsonProperty(PropertyName = "Whitelist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<string>> Whitelist;
        [JsonProperty(PropertyName = "Blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<string>> Blacklist;
        [JsonProperty(PropertyName = "Smelting Frequencies (Smelt items every N smelting ticks)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, int> SmeltingFrequencies;
        [JsonProperty(PropertyName = "Debug")]
        public bool Debug;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Unload();
    private void OnServerInitialized();
    private void OnEntitySpawned(BaseNetworkable entity);
    private object OnOvenToggle(StorageContainer oven, BasePlayer player);
    private bool CanUse(ulong id);
    private static void PrintDebug(string message);
    public class FurnaceController : FacepunchBehaviour
    {
        private int _ticks;
        private BaseOven _oven;
        private BaseOven Furnace { get; set; }
        private float _speedMultiplier;
        private float _fuelSpeedMultiplier;
        private int _fuelUsageMultiplier;
        private int _smeltingFrequency;
        private Dictionary<string, float> _outputModifiers;
        private float OutputMultiplier(string shortname);
        private List<string> _blacklist;
        private List<string> _whitelist;
        private bool? IsAllowed(string shortname);
        private void Awake();
        private Item FindBurnable();
        public void Cook();
        private void ConsumeFuel(Item fuel, ItemModBurnable burnable);
        private void SmeltItems();
        public void StartCooking();
        public void StopCooking();
    }

}

private class Configuration
{
    [JsonProperty(PropertyName = "Use Permission")]
    public bool UsePermission;
    [JsonProperty(PropertyName = "Speed Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, float> SpeedMultipliers;
    [JsonProperty(PropertyName = "Fuel Usage Speed Multipliers",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, float> FuelSpeedMultipliers;
    [JsonProperty(PropertyName = "Fuel Usage Multipliers",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, int> FuelUsageMultipliers;
    [JsonProperty(PropertyName = "Output Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, Dictionary<string, float>> OutputMultipliers;
    [JsonProperty(PropertyName = "Whitelist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<string>> Whitelist;
    [JsonProperty(PropertyName = "Blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<string>> Blacklist;
    [JsonProperty(PropertyName = "Smelting Frequencies (Smelt items every N smelting ticks)",
                ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, int> SmeltingFrequencies;
    [JsonProperty(PropertyName = "Debug")]
    public bool Debug;
}

public class FurnaceController : FacepunchBehaviour
{
    private int _ticks;
    private BaseOven _oven;
    private BaseOven Furnace { get; set; }
    private float _speedMultiplier;
    private float _fuelSpeedMultiplier;
    private int _fuelUsageMultiplier;
    private int _smeltingFrequency;
    private Dictionary<string, float> _outputModifiers;
    private float OutputMultiplier(string shortname);
    private List<string> _blacklist;
    private List<string> _whitelist;
    private bool? IsAllowed(string shortname);
    private void Awake();
    private Item FindBurnable();
    public void Cook();
    private void ConsumeFuel(Item fuel, ItemModBurnable burnable);
    private void SmeltItems();
    public void StartCooking();
    public void StopCooking();
}


```

---

## QuickSort by MONaH - Adds a GUI that allows players to quickly sort items into containers

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Pool = Facepunch.Pool;

Oxide.Plugins
[Info("Quick Sort", "MON@H", "1.8.2")]
[Description("Adds a GUI that allows players to quickly sort items into containers")]
public class QuickSort : RustPlugin
{
    private const string GUIPanelName;
    private const string PermissionAutoLootAll;
    private const string PermissionLootAll;
    private const string PermissionUse;
    private readonly Hash<int, string> _cacheUiJson;
    private readonly Hash<string, int> _cacheLanguageIDs;
    private readonly HashSet<uint> _cacheContainersExcluded;
    private readonly HashSet<ulong> _uiViewers;
    private object[] _noteInv;
    private PlayerData _defaultPlayerData;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private ConfigData _configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Global settings")]
        public GlobalConfiguration GlobalSettings;
        [JsonProperty(PropertyName = "Custom UI Settings")]
        public UiConfiguration CustomUISettings;
        public class GlobalConfiguration
        {
            [JsonProperty(PropertyName = "Default enabled")]
            public bool DefaultEnabled;
            [JsonProperty(PropertyName = "Default UI style (center, lite, right, custom)")]
            public string DefaultUiStyle;
            [JsonProperty(PropertyName = "Loot all delay in seconds (0 to disable)")]
            public int LootAllDelay;
            [JsonProperty(PropertyName = "Enable loot all on the sleepers")]
            public bool LootSleepers;
            [JsonProperty(PropertyName = "Auto loot all enabled by default")]
            public bool AutoLootAll;
            [JsonProperty(PropertyName = "Default enabled container types")]
            public PlayerContainers Containers;
            [JsonProperty(PropertyName = "Chat steamID icon")]
            public ulong SteamIDIcon;
            [JsonProperty(PropertyName = "Chat command")]
            public string[] Commands;
            [JsonProperty(PropertyName = "Excluded containers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ContainersExcluded;
        }

        public class UiConfiguration
        {
            public string AnchorsMin;
            public string AnchorsMax;
            public string OffsetsMin;
            public string OffsetsMax;
            public string Color;
            public string ButtonsColor;
            public string LootAllColor;
            public string TextColor;
            public int TextSize;
            public int CategoriesTextSize;
        }

    }

    public class PlayerContainers
    {
        public bool Belt;
        public bool Main;
        public bool Wear;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private StoredData _storedData;
    private class StoredData
    {
        public readonly Hash<ulong, PlayerData> PlayerData;
    }

    public class PlayerData
    {
        public bool Enabled;
        public bool AutoLootAll;
        public string UiStyle;
        public PlayerContainers Containers;
    }

    public void LoadData();
    public void SaveData();
    public PlayerData GetPlayerData(ulong userID);
    public string Lang(string key, string userIDString, object[] args);
    private static class LangKeys
    {
        public static class Error
        {
            private const string Base;
            public const string NoPermission;
            public const string Syntax;
        }

        public static class Info
        {
            private const string Base;
            public const string QuickSort;
            public const string Style;
            public const string AutoLootAll;
            public const string ContainerType;
        }

        public static class Format
        {
            private const string Base;
            public const string All;
            public const string Ammo;
            public const string Attire;
            public const string Components;
            public const string Construction;
            public const string Deployables;
            public const string Deposit;
            public const string Disabled;
            public const string Electrical;
            public const string Enabled;
            public const string Existing;
            public const string Food;
            public const string LootAll;
            public const string Medical;
            public const string Misc;
            public const string Prefix;
            public const string Resources;
            public const string Tools;
            public const string Traps;
            public const string Weapons;
        }

    }

    protected override void LoadDefaultMessages();
    private void OnLootPlayer(BasePlayer player);
    private void OnLootEntity(BasePlayer player, BaseEntity entity);
    private void OnPlayerLootEnd(PlayerLoot inventory);
    private void OnEntityDeath(BasePlayer player, HitInfo info);
    private void OnEntityKill(BasePlayer player);
    private void OnPlayerSleep(BasePlayer player);
    private void CmdQuickSort(BasePlayer player, string command, string[] args);
    [ConsoleCommand("quicksortgui")]
    private void SortCommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("quicksortgui.lootall")]
    private void LootAllCommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("quicksortgui.lootdelay")]
    private void LootDelayCommand(ConsoleSystem.Arg arg);
    public void HandleLootEntity(BasePlayer player);
    public bool AutoLootAll(BasePlayer player);
    public void LootAll(BasePlayer player);
    public void SortItems(BasePlayer player, string[] args);
    public void AddExistingItems(List<Item> list, ItemContainer primary, ItemContainer secondary);
    public void AddItemsOfType(List<Item> list, ItemContainer container, ItemCategory category);
    public List<ItemContainer> GetLootedInventory(BasePlayer player);
    public void MoveItems(IEnumerable<Item> items, ItemContainer to);
    public ItemCategory StringToItemCategory(string categoryName);
    public bool IsContainerExcluded(BasePlayer player, BaseEntity entity);
    public static bool IsOwnerSleeper(ItemContainer container);
    public static bool IsPlayerContainer(ItemContainer container, BasePlayer player);
    public void UnsubscribeHooks();
    public void SubscribeHooks();
    public void RegisterPermissions();
    public void AddCommands();
    public void CreateCache();
    public void PlayerSendMessage(BasePlayer player, string message);
    public int GetUiId(BasePlayer player, PlayerData playerData);
    public void UiCreate(BasePlayer player);
    public void UiDestroy(BasePlayer player);
    public string UiGetJsonCustom(BasePlayer player);
    public string UiGetJsonCenter(BasePlayer player);
    public string UiGetJsonLite(BasePlayer player);
    public string UiGetJsonRight(BasePlayer player);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Global settings")]
    public GlobalConfiguration GlobalSettings;
    [JsonProperty(PropertyName = "Custom UI Settings")]
    public UiConfiguration CustomUISettings;
    public class GlobalConfiguration
    {
        [JsonProperty(PropertyName = "Default enabled")]
        public bool DefaultEnabled;
        [JsonProperty(PropertyName = "Default UI style (center, lite, right, custom)")]
        public string DefaultUiStyle;
        [JsonProperty(PropertyName = "Loot all delay in seconds (0 to disable)")]
        public int LootAllDelay;
        [JsonProperty(PropertyName = "Enable loot all on the sleepers")]
        public bool LootSleepers;
        [JsonProperty(PropertyName = "Auto loot all enabled by default")]
        public bool AutoLootAll;
        [JsonProperty(PropertyName = "Default enabled container types")]
        public PlayerContainers Containers;
        [JsonProperty(PropertyName = "Chat steamID icon")]
        public ulong SteamIDIcon;
        [JsonProperty(PropertyName = "Chat command")]
        public string[] Commands;
        [JsonProperty(PropertyName = "Excluded containers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> ContainersExcluded;
    }

    public class UiConfiguration
    {
        public string AnchorsMin;
        public string AnchorsMax;
        public string OffsetsMin;
        public string OffsetsMax;
        public string Color;
        public string ButtonsColor;
        public string LootAllColor;
        public string TextColor;
        public int TextSize;
        public int CategoriesTextSize;
    }

}

public class GlobalConfiguration
{
    [JsonProperty(PropertyName = "Default enabled")]
    public bool DefaultEnabled;
    [JsonProperty(PropertyName = "Default UI style (center, lite, right, custom)")]
    public string DefaultUiStyle;
    [JsonProperty(PropertyName = "Loot all delay in seconds (0 to disable)")]
    public int LootAllDelay;
    [JsonProperty(PropertyName = "Enable loot all on the sleepers")]
    public bool LootSleepers;
    [JsonProperty(PropertyName = "Auto loot all enabled by default")]
    public bool AutoLootAll;
    [JsonProperty(PropertyName = "Default enabled container types")]
    public PlayerContainers Containers;
    [JsonProperty(PropertyName = "Chat steamID icon")]
    public ulong SteamIDIcon;
    [JsonProperty(PropertyName = "Chat command")]
    public string[] Commands;
    [JsonProperty(PropertyName = "Excluded containers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> ContainersExcluded;
}

public class UiConfiguration
{
    public string AnchorsMin;
    public string AnchorsMax;
    public string OffsetsMin;
    public string OffsetsMax;
    public string Color;
    public string ButtonsColor;
    public string LootAllColor;
    public string TextColor;
    public int TextSize;
    public int CategoriesTextSize;
}

public class PlayerContainers
{
    public bool Belt;
    public bool Main;
    public bool Wear;
}

private class StoredData
{
    public readonly Hash<ulong, PlayerData> PlayerData;
}

public class PlayerData
{
    public bool Enabled;
    public bool AutoLootAll;
    public string UiStyle;
    public PlayerContainers Containers;
}

private static class LangKeys
{
    public static class Error
    {
        private const string Base;
        public const string NoPermission;
        public const string Syntax;
    }

    public static class Info
    {
        private const string Base;
        public const string QuickSort;
        public const string Style;
        public const string AutoLootAll;
        public const string ContainerType;
    }

    public static class Format
    {
        private const string Base;
        public const string All;
        public const string Ammo;
        public const string Attire;
        public const string Components;
        public const string Construction;
        public const string Deployables;
        public const string Deposit;
        public const string Disabled;
        public const string Electrical;
        public const string Enabled;
        public const string Existing;
        public const string Food;
        public const string LootAll;
        public const string Medical;
        public const string Misc;
        public const string Prefix;
        public const string Resources;
        public const string Tools;
        public const string Traps;
        public const string Weapons;
    }

}

public static class Error
{
    private const string Base;
    public const string NoPermission;
    public const string Syntax;
}

public static class Info
{
    private const string Base;
    public const string QuickSort;
    public const string Style;
    public const string AutoLootAll;
    public const string ContainerType;
}

public static class Format
{
    private const string Base;
    public const string All;
    public const string Ammo;
    public const string Attire;
    public const string Components;
    public const string Construction;
    public const string Deployables;
    public const string Deposit;
    public const string Disabled;
    public const string Electrical;
    public const string Enabled;
    public const string Existing;
    public const string Food;
    public const string LootAll;
    public const string Medical;
    public const string Misc;
    public const string Prefix;
    public const string Resources;
    public const string Tools;
    public const string Traps;
    public const string Weapons;
}


```

---

## RadHouse by misticos - Radiation house in the Rust

```csharp
using System.Collections.Generic;
using UnityEngine;
using Rust;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Reflection;
using System;
using System.Linq;

Oxide.Plugins
[Info("RadHouse", "pidorassavy", "1.0.5")]
[Description("Small plugin create RadHouse event on server")]
 class RadHouse : RustPlugin
{
    [PluginReference]
     Plugin RandomSpawns;
    [PluginReference]
     Plugin RustMap;
    [PluginReference]
     Plugin LustyMap;
    private List<ZoneList> RadiationZones;
    private static readonly int playerLayer;
    private static readonly Collider[] colBuffer;
    private ZoneList RadHouseZone;
    public List<uint> BaseEntityList;
    public List<ulong> PlayerAuth;
    private List<string> BlockedItems;
    private Dictionary<string, object> ItemList_Common;
    private Dictionary<string, object> ItemList_Rare;
    private Dictionary<string, object> ItemList_Top;
    public bool CanLoot;
    public bool NowLooted;
    public Timer mytimer;
    public Timer mytimer2;
    public Timer mytimer3;
    public Timer mytimer4;
    public int timercallbackdelay;
    public bool GuiOn;
    public string AnchorMinCfg;
    public string AnchorMaxCfg;
    public string ColorCfg;
    public string TextGUI;
    public bool RadiationTrue;
    public string ChatPrefix;
    public int TimerSpawnHouse;
    public int TimerDestroyHouse;
    public int TimerLoot;
    public int RadiationRadius;
    public int RadiationIntensity;
    protected override void LoadDefaultConfig();
    private void LoadConfigValues();
    private void GetConfig(string menu, string Key, T var);
     void OnServerInitialized();
     void Loaded();
     void Unload();
    public object success;
    [ChatCommand("rh")]
     void CreateRadHouseCommand(BasePlayer player, string cmd, string[] Args);
    private void OnServerRadiation();
     void CreateRadHouse();
     void DestroyRadHouse();
    private uint BindDecay(BaseEntity entity, uint buildingid);
     object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
     void OnLootEntity(BasePlayer player, BaseEntity entity);
     void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
    private void StopLooting(BasePlayer player, string message);
     object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player);
     void CreateGui(BasePlayer player);
     void DestroyGui(BasePlayer player);
    private void InitializeZone(Vector3 Location, float intensity, float radius, int ZoneID);
    private void DestroyZone(ZoneList zone);
    public class ZoneList
    {
        public RadZones zone;
    }

    public class RadZones : MonoBehaviour
    {
        private int ID;
        private Vector3 Position;
        private float ZoneRadius;
        private float RadiationAmount;
        private List<BasePlayer> InZone;
        private void Awake();
        public void Activate(Vector3 pos, float radius, float amount, int ZoneID);
        private void OnDestroy();
        private void UpdateCollider();
        private void UpdateTrigger();
    }

}

public class ZoneList
{
    public RadZones zone;
}

public class RadZones : MonoBehaviour
{
    private int ID;
    private Vector3 Position;
    private float ZoneRadius;
    private float RadiationAmount;
    private List<BasePlayer> InZone;
    private void Awake();
    public void Activate(Vector3 pos, float radius, float amount, int ZoneID);
    private void OnDestroy();
    private void UpdateCollider();
    private void UpdateTrigger();
}


```

---

## RadiationManager by redBDGR - Allows for slight management of radiated zones around the map

```csharp
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Radiation Manager", "redBDGR", "1.0.0")]
[Description("Allows for slight management of radiated zones around the map")]
 class RadiationManager : RustPlugin
{
    private bool Changed;
    private float minimalAmount;
    private float lowAmount;
    private float mediumAmount;
    private float highAmount;
    private void OnServerInitialized();
    protected override void LoadDefaultConfig();
    private void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
}


```

---

## RadioStationManager by Whispers88 - Allows you to easily add and remove radio stations via commands and config.

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using WebSocketSharp;

Oxide.Plugins
[Info("Radio Station Manager", "Whispers88", "1.0.4")]
[Description("Allows you to easily add and remove radio stations")]
public class RadioStationManager : RustPlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("Radio Stations (station name, station url)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, string> RadioStations;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private const string permallow;
    private List<string> commands;
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private void StationAddCMD(IPlayer iplayer, string command, string[] args);
    private void StationRemoveCMD(IPlayer iplayer, string command, string[] args);
    private void StationListCMD(IPlayer iplayer, string command, string[] args);
    private void StationClearCMD(IPlayer iplayer, string command, string[] args);
    private void UpdateStns();
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string langKey, object[] args);
    private bool HasPerm(string id, string perm);
    private void AddLocalizedCommand(string command);
}

public class Configuration
{
    [JsonProperty("Radio Stations (station name, station url)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, string> RadioStations;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## RadPockets by k1lly0u - Turn your server into a irradiated wasteland

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using Rust;
using Oxide.Core;
using Oxide.Core.Configuration;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;

Oxide.Plugins
[Info("RadPockets", "k1lly0u", "2.0.4")]
[Description("Turn your server into a irradiated wasteland")]
 class RadPockets : RustPlugin
{
    private StoredData storedData;
    private DynamicConfigFile data;
    private List<RadiationZone> radiationZones;
    private const int PLAYER_MASK;
    private void Loaded();
    private void OnServerInitialized();
    private void Unload();
    private void DestroyAllZones();
    private void CreateNewZones();
    private void CreateZone(PocketData zone, bool isNew, bool save);
    private Vector3 GetRandomPos();
    [ChatCommand("rp")]
    private void cmdRP(BasePlayer player, string command, string[] args);
    private class PocketData
    {
        public Vector3 position;
        public float radius;
        public float amount;
    }

    private class RadiationZone : MonoBehaviour
    {
        public PocketData data;
        private void Awake();
        public void Activate(PocketData data);
    }

    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty("Minimum zone radius")]
        public int Radius_Min { get; set; }
        [JsonProperty("Maximum zone radius")]
        public int Radius_Max { get; set; }
        [JsonProperty("Minimum amount of zones to create")]
        public int Count_Min { get; set; }
        [JsonProperty("Maximum amount of zones to create")]
        public int Count_Max { get; set; }
        [JsonProperty("Minimum amount of radiation")]
        public int Radiation_Min { get; set; }
        [JsonProperty("Maximum amount of radiation")]
        public int Radiation_Max { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private void SaveData();
    private void LoadData();
    private class StoredData
    {
        public List<PocketData> radData;
    }

    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private string Msg(string key, string playerid, bool color);
    private Dictionary<string, string> Messages;
}

private class PocketData
{
    public Vector3 position;
    public float radius;
    public float amount;
}

private class RadiationZone : MonoBehaviour
{
    public PocketData data;
    private void Awake();
    public void Activate(PocketData data);
}

private class ConfigData
{
    [JsonProperty("Minimum zone radius")]
    public int Radius_Min { get; set; }
    [JsonProperty("Maximum zone radius")]
    public int Radius_Max { get; set; }
    [JsonProperty("Minimum amount of zones to create")]
    public int Count_Min { get; set; }
    [JsonProperty("Maximum amount of zones to create")]
    public int Count_Max { get; set; }
    [JsonProperty("Minimum amount of radiation")]
    public int Radiation_Min { get; set; }
    [JsonProperty("Maximum amount of radiation")]
    public int Radiation_Max { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}

private class StoredData
{
    public List<PocketData> radData;
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## RadShrinkZone by  - BattleRoyale-styled radiation system

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("RadShrinkZone", "vaalberith", "1.0.6", ResourceId = 1828)]
 class RadShrinkZone : RustPlugin
{
     Vector3 target;
     float saferadius;
     float saferadiusmin;
     float eventradius;
     float radpower;
     float step;
     float period;
     string permissionrad;
     bool breaking;
     bool ok;
     List<Vector3> position;
    readonly DynamicConfigFile dataFile;
     Dictionary<string, List<string>> radzonedata;
     string GetMessage(string key, string steamId);
     void LoadDefaultMessages();
    [PluginReference]
     Plugin ZoneManager;
     void OnServerInitialized();
     void execcfg();
     void safecfg();
     void Unload();
     void Loaded();
    private List<BaseEntity> Spheres;
    private const string SphereEnt;
    private void CreateSphere(Vector3 position, float radius);
    private void DestroyAllSpheres();
    private void createZone(string zoneID, Vector3 pos, float radius, float rads);
    private void eraseZone(string zoneID);
    private void CalcPos(Vector3 pos);
    private void DelPos();
    private void started();
    private void stop();
    private void StartZoneShrink();
    private void Shrink();
     bool IsAllowed(BasePlayer player, string perm);
    [ChatCommand("rad")]
     void radchat(BasePlayer player, string cmd, string[] args);
    [ConsoleCommand("rad")]
     void radconsole(ConsoleSystem.Arg arg);
}


```

---

## RadtownAnimals by k1lly0u - Spawns animals and NPCs at designated monuments

```csharp
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;

Oxide.Plugins
[Info("Radtown Animals", "k1lly0u", "0.3.2"), Description("Spawns various NPC types at monuments")]
public class RadtownAnimals : RustPlugin
{
    private readonly List<BaseCombatEntity> pluginSpawnedEntities;
    private readonly Hash<NPC, string> prefabLookup;
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo hitInfo);
    private void Unload();
    private void InitializeSpawns();
    private IEnumerator SpawnAnimals(Vector3 position, Hash<NPC,int> spawnCounts);
    private void Spawn(NPC npc, Vector3 position);
    private void Spawn(string prefab, Vector3 position);
    private BaseCombatEntity InstantiateEntity(string type, Vector3 position);
    private void SetupBrain(BaseCombatEntity baseCombatEntity, Vector3 position);
    private void SetupBrain(BaseCombatEntity baseCombatEntity, Vector3 position);
    private Vector3 GetHomePosition(BaseCombatEntity baseCombatEntity);
    private Vector3 GetHomePosition(BaseCombatEntity baseCombatEntity);
    private static class NavmeshSpawnPoint
    {
        private static NavMeshHit navmeshHit;
        private static RaycastHit raycastHit;
        private static readonly Collider[] _buffer;
        private const int WORLD_LAYER;
        public static bool Find(Vector3 targetPosition, float maxDistance, Vector3 position);
        private static bool IsInRockPrefab(Vector3 position);
        private static bool IsNearWorldCollider(Vector3 position);
        private static readonly string[] ACCEPTED_COLLIDERS;
        private static readonly string[] BLOCKED_COLLIDERS;
    }

    public class GenericRoamState : BaseAIBrain.BasicAIState
    {
        private StateStatus status;
        private static readonly Vector3[] preferedTopologySamples;
        private static readonly Vector3[] topologySamples;
        public GenericRoamState();
        public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
        public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
        public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
        private Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 localTo, Vector3 fallback, float minRange, float maxRange);
    }

    [ChatCommand("ra_killall")]
    private void ChatCommand_KillAnimals(BasePlayer player, string command, string[] args);
    [ConsoleCommand("ra_killall")]
    private void ConsoleCommand_KillAnimals(ConsoleSystem.Arg arg);
    private static ConfigData Configuration;
    private class ConfigData
    {
        public Options Settings { get; set; }
        [JsonProperty(PropertyName = "Monument Settings")]
        public Monuments MonumentSettings { get; set; }
        public class Options
        {
            [JsonProperty(PropertyName = "Respawn timer (seconds)")]
            public int Respawn { get; set; }
            [JsonProperty(PropertyName = "Spawn spread distance from center of monument")]
            public float Spread { get; set; }
            [JsonProperty(PropertyName = "Maximum amount of animals to spawn")]
            public int Total { get; set; }
        }

        public class Monuments
        {
            public MonumentSettings Airfield { get; set; }
            public MonumentSettings Dome { get; set; }
            public MonumentSettings Junkyard { get; set; }
            public MonumentSettings Lighthouse { get; set; }
            public MonumentSettings LargeHarbor { get; set; }
            public MonumentSettings GasStation { get; set; }
            public MonumentSettings Powerplant { get; set; }
            [JsonProperty(PropertyName = "Stone Quarry")]
            public MonumentSettings Quarry_Stone { get; set; }
            [JsonProperty(PropertyName = "Sulfur Quarry")]
            public MonumentSettings Quarry_Sulfur { get; set; }
            [JsonProperty(PropertyName = "HQM Quarry")]
            public MonumentSettings Quarry_HQM { get; set; }
            public MonumentSettings Radtown { get; set; }
            public MonumentSettings RocketFactory { get; set; }
            public MonumentSettings Satellite { get; set; }
            public MonumentSettings SmallHarbor { get; set; }
            public MonumentSettings Supermarket { get; set; }
            public MonumentSettings Trainyard { get; set; }
            public MonumentSettings Tunnels { get; set; }
            public MonumentSettings Warehouse { get; set; }
            public MonumentSettings WaterTreatment { get; set; }
            public class MonumentSettings
            {
                [JsonProperty(PropertyName = "Enable spawning at this monument")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Amount of animals to spawn at this monument")]
                public Hash<NPC, int> Counts { get; set; }
            }

        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private readonly Dictionary<string, string> Messages;
}

private static class NavmeshSpawnPoint
{
    private static NavMeshHit navmeshHit;
    private static RaycastHit raycastHit;
    private static readonly Collider[] _buffer;
    private const int WORLD_LAYER;
    public static bool Find(Vector3 targetPosition, float maxDistance, Vector3 position);
    private static bool IsInRockPrefab(Vector3 position);
    private static bool IsNearWorldCollider(Vector3 position);
    private static readonly string[] ACCEPTED_COLLIDERS;
    private static readonly string[] BLOCKED_COLLIDERS;
}

public class GenericRoamState : BaseAIBrain.BasicAIState
{
    private StateStatus status;
    private static readonly Vector3[] preferedTopologySamples;
    private static readonly Vector3[] topologySamples;
    public GenericRoamState();
    public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
    public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
    public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
    private Vector3 GetBestRoamPosition(BaseNavigator navigator, Vector3 localTo, Vector3 fallback, float minRange, float maxRange);
}

private class ConfigData
{
    public Options Settings { get; set; }
    [JsonProperty(PropertyName = "Monument Settings")]
    public Monuments MonumentSettings { get; set; }
    public class Options
    {
        [JsonProperty(PropertyName = "Respawn timer (seconds)")]
        public int Respawn { get; set; }
        [JsonProperty(PropertyName = "Spawn spread distance from center of monument")]
        public float Spread { get; set; }
        [JsonProperty(PropertyName = "Maximum amount of animals to spawn")]
        public int Total { get; set; }
    }

    public class Monuments
    {
        public MonumentSettings Airfield { get; set; }
        public MonumentSettings Dome { get; set; }
        public MonumentSettings Junkyard { get; set; }
        public MonumentSettings Lighthouse { get; set; }
        public MonumentSettings LargeHarbor { get; set; }
        public MonumentSettings GasStation { get; set; }
        public MonumentSettings Powerplant { get; set; }
        [JsonProperty(PropertyName = "Stone Quarry")]
        public MonumentSettings Quarry_Stone { get; set; }
        [JsonProperty(PropertyName = "Sulfur Quarry")]
        public MonumentSettings Quarry_Sulfur { get; set; }
        [JsonProperty(PropertyName = "HQM Quarry")]
        public MonumentSettings Quarry_HQM { get; set; }
        public MonumentSettings Radtown { get; set; }
        public MonumentSettings RocketFactory { get; set; }
        public MonumentSettings Satellite { get; set; }
        public MonumentSettings SmallHarbor { get; set; }
        public MonumentSettings Supermarket { get; set; }
        public MonumentSettings Trainyard { get; set; }
        public MonumentSettings Tunnels { get; set; }
        public MonumentSettings Warehouse { get; set; }
        public MonumentSettings WaterTreatment { get; set; }
        public class MonumentSettings
        {
            [JsonProperty(PropertyName = "Enable spawning at this monument")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Amount of animals to spawn at this monument")]
            public Hash<NPC, int> Counts { get; set; }
        }

    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class Options
{
    [JsonProperty(PropertyName = "Respawn timer (seconds)")]
    public int Respawn { get; set; }
    [JsonProperty(PropertyName = "Spawn spread distance from center of monument")]
    public float Spread { get; set; }
    [JsonProperty(PropertyName = "Maximum amount of animals to spawn")]
    public int Total { get; set; }
}

public class Monuments
{
    public MonumentSettings Airfield { get; set; }
    public MonumentSettings Dome { get; set; }
    public MonumentSettings Junkyard { get; set; }
    public MonumentSettings Lighthouse { get; set; }
    public MonumentSettings LargeHarbor { get; set; }
    public MonumentSettings GasStation { get; set; }
    public MonumentSettings Powerplant { get; set; }
    [JsonProperty(PropertyName = "Stone Quarry")]
    public MonumentSettings Quarry_Stone { get; set; }
    [JsonProperty(PropertyName = "Sulfur Quarry")]
    public MonumentSettings Quarry_Sulfur { get; set; }
    [JsonProperty(PropertyName = "HQM Quarry")]
    public MonumentSettings Quarry_HQM { get; set; }
    public MonumentSettings Radtown { get; set; }
    public MonumentSettings RocketFactory { get; set; }
    public MonumentSettings Satellite { get; set; }
    public MonumentSettings SmallHarbor { get; set; }
    public MonumentSettings Supermarket { get; set; }
    public MonumentSettings Trainyard { get; set; }
    public MonumentSettings Tunnels { get; set; }
    public MonumentSettings Warehouse { get; set; }
    public MonumentSettings WaterTreatment { get; set; }
    public class MonumentSettings
    {
        [JsonProperty(PropertyName = "Enable spawning at this monument")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Amount of animals to spawn at this monument")]
        public Hash<NPC, int> Counts { get; set; }
    }

}

public class MonumentSettings
{
    [JsonProperty(PropertyName = "Enable spawning at this monument")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Amount of animals to spawn at this monument")]
    public Hash<NPC, int> Counts { get; set; }
}


```

---

## RadTownLoot by KrunghCrow - Animals drop loot and have a static health and strength profile (random HP/Str)

```csharp
using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Facepunch;
using Rust;
using Rust.Ai.Gen2;

Oxide.Plugins
[Info("RadTownLoot", "Krungh Crow", "2.2.2")]
[Description("Return of Radanimals with animal settings")]
 class RadTownLoot : RustPlugin
{
    [PluginReference]
     Plugin Clans;
     Plugin Friends;
     string Admin_Perm;
     string Chat_Perm;
     string Command_Perm;
     string Loot_Perm;
     ulong chaticon;
     string prefix;
     string animalprefix;
     bool Debug;
     bool IgnoreAlpha;
     bool IgnoreOmega;
     int HealthMin;
     int HealthMax;
     int RandomHealth;
     int DamageMin;
     int DamageMax;
     int RandomDamage;
     float Speed;
     bool ShowConsole;
     bool ChangeValues;
     void Init();
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Main config")]
        public SettingsPlugin PlugCFG;
        [JsonProperty(PropertyName = "Animal config")]
        public SettingsAnimals Animals;
    }

     class SettingsPlugin
    {
        [JsonProperty(PropertyName = "Debug")]
        public bool Debug;
        [JsonProperty(PropertyName = "Chat Steam64ID")]
        public ulong Chaticon;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string Prefix;
        [JsonProperty(PropertyName = "Animal Type Prefix")]
        public string AnimalPrefix;
        [JsonProperty(PropertyName = "Use Random Skins")]
        public bool RandomSkins;
    }

     class SettingsAnimals
    {
        [JsonProperty(PropertyName = "Skip Alpha Animals")]
        public bool IgnoreAlpha;
        [JsonProperty(PropertyName = "Skip Omega Animals")]
        public bool IgnoreOmega;
        [JsonProperty(PropertyName = "Bear settings")]
        public Spawns BearSpawns;
        [JsonProperty(PropertyName = "Boar settings")]
        public Spawns BoarSpawns;
        [JsonProperty(PropertyName = "Chicken settings")]
        public Spawns ChickenSpawns;
        [JsonProperty(PropertyName = "Polarbear settings")]
        public Spawns PBearSpawns;
        [JsonProperty(PropertyName = "Stag settings")]
        public Spawns StagSpawns;
        [JsonProperty(PropertyName = "Wolf settings")]
        public Spawns WolfSpawns;
    }

     class Spawns
    {
        [JsonProperty(PropertyName = "Change stats on spawns")]
        public bool Change;
        [JsonProperty(PropertyName = "Show spawns in Console")]
        public bool ShowConsole;
        [JsonProperty(PropertyName = "Droprate 0-100")]
        public float ChanceOfCrate;
        [JsonProperty(PropertyName = "Minimum Health")]
        public int Healthmin;
        [JsonProperty(PropertyName = "Maximum Health")]
        public int Healthmax;
        [JsonProperty(PropertyName = "Minimum Strength (Att dmg)")]
        public int Damage;
        [JsonProperty(PropertyName = "Maximum Strength (Att dmg")]
        public int DamageMax;
        [JsonProperty(PropertyName = "Running Speed")]
        public float Speed;
        [JsonProperty(PropertyName = "Loot settings")]
        public LootSettings Loots;
    }

     class LootSettings
    {
        [JsonProperty(PropertyName = "Spawn Min Amount Items")]
        public int MinAmount;
        [JsonProperty(PropertyName = "Spawn Max Amount Items")]
        public int MaxAmount;
        [JsonProperty(PropertyName = "Loot Table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItems> Loot { get; set; }
    }

    private bool LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConf();
    protected override void LoadDefaultMessages();
    [ChatCommand("rad")]
    private void cmdRad(BasePlayer player, string command, string[] args);
    private string msg(string key, string id);
    private string info(string key, string id);
     void TIP(BasePlayer player, string message, float dur);
     void OnEntityDeath(BaseNPC2 animal, HitInfo info);
     void OnEntityDeath(BaseAnimalNPC animal, HitInfo info);
     void OnEntitySpawned(BaseNPC2 animal);
     void OnEntitySpawned(BaseAnimalNPC animal);
     object AnimalCount(string _animal);
     bool HasPerm(BasePlayer player, string perm);
    private Dictionary<string, List<ulong>> Skins { get; set; }
    private static List<LootItems> DefaultLoot { get; set; }
    public class LootItems
    {
        public string shortname { get; set; }
        public int amount { get; set; }
        public ulong skin { get; set; }
        public int amountMin { get; set; }
    }

    private void SpawnRadLoot(Vector3 pos, Quaternion rot, string AnimalType);
    private void SpawnLoot(ItemContainer container, List<LootItems> loot, string AnimalType);
    private List<ulong> GetItemSkins(ItemDefinition def);
    private List<ulong> ExtractItemSkins(ItemDefinition def, List<ulong> skins);
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Main config")]
    public SettingsPlugin PlugCFG;
    [JsonProperty(PropertyName = "Animal config")]
    public SettingsAnimals Animals;
}

 class SettingsPlugin
{
    [JsonProperty(PropertyName = "Debug")]
    public bool Debug;
    [JsonProperty(PropertyName = "Chat Steam64ID")]
    public ulong Chaticon;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string Prefix;
    [JsonProperty(PropertyName = "Animal Type Prefix")]
    public string AnimalPrefix;
    [JsonProperty(PropertyName = "Use Random Skins")]
    public bool RandomSkins;
}

 class SettingsAnimals
{
    [JsonProperty(PropertyName = "Skip Alpha Animals")]
    public bool IgnoreAlpha;
    [JsonProperty(PropertyName = "Skip Omega Animals")]
    public bool IgnoreOmega;
    [JsonProperty(PropertyName = "Bear settings")]
    public Spawns BearSpawns;
    [JsonProperty(PropertyName = "Boar settings")]
    public Spawns BoarSpawns;
    [JsonProperty(PropertyName = "Chicken settings")]
    public Spawns ChickenSpawns;
    [JsonProperty(PropertyName = "Polarbear settings")]
    public Spawns PBearSpawns;
    [JsonProperty(PropertyName = "Stag settings")]
    public Spawns StagSpawns;
    [JsonProperty(PropertyName = "Wolf settings")]
    public Spawns WolfSpawns;
}

 class Spawns
{
    [JsonProperty(PropertyName = "Change stats on spawns")]
    public bool Change;
    [JsonProperty(PropertyName = "Show spawns in Console")]
    public bool ShowConsole;
    [JsonProperty(PropertyName = "Droprate 0-100")]
    public float ChanceOfCrate;
    [JsonProperty(PropertyName = "Minimum Health")]
    public int Healthmin;
    [JsonProperty(PropertyName = "Maximum Health")]
    public int Healthmax;
    [JsonProperty(PropertyName = "Minimum Strength (Att dmg)")]
    public int Damage;
    [JsonProperty(PropertyName = "Maximum Strength (Att dmg")]
    public int DamageMax;
    [JsonProperty(PropertyName = "Running Speed")]
    public float Speed;
    [JsonProperty(PropertyName = "Loot settings")]
    public LootSettings Loots;
}

 class LootSettings
{
    [JsonProperty(PropertyName = "Spawn Min Amount Items")]
    public int MinAmount;
    [JsonProperty(PropertyName = "Spawn Max Amount Items")]
    public int MaxAmount;
    [JsonProperty(PropertyName = "Loot Table", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItems> Loot { get; set; }
}

public class LootItems
{
    public string shortname { get; set; }
    public int amount { get; set; }
    public ulong skin { get; set; }
    public int amountMin { get; set; }
}


```

---

## Ragnarok by VisEntities - Complete weather system involving meteors, tides, tornadoes, and sandstorms

```csharp
using System;
using UnityEngine;
using System.Linq;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using Oxide.Core;

Oxide.Plugins
[Info("Ragnarok", "BuzZ", "1.0.1")]
[Description("A barrage of meteors and crappy weather")]
 class Ragnarok : RustPlugin
{
     bool debug;
     bool RagnarokIsOn;
    private bool ConfigChanged;
    const string RagnarokHUD;
    const string RagnarokAdmin;
     string ONRagnarokHUD;
     Timer RagnaTimer;
     Timer RagnaEndTimer;
     Timer RagnaMeteorTimer;
     float MarkerRate;
     bool MarkersIsOn;
     float minLaunchAngle;
     float maxLaunchAngle;
     float minLaunchHeight;
     float maxLaunchHeight;
     float minLaunchVelocity;
     float maxLaunchVelocity;
     float meteorFrequency;
     int maxClusterMeteors;
     int minClusterRange;
     int maxClusterRange;
     float spawnResourcePercent;
     float spawnResourceNodePercent;
     float repeater;
     float duration;
     double cloud;
     double fog;
     void Init();
     void OnServerInitialized();
     void Unload();
    protected override void LoadDefaultConfig();
    private void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
     void LaunchDaRagnarokOnDaFace();
    [ChatCommand("ragna")]
    private void RagnarokEmptyChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("ragna_start")]
    private void StartThisRagnarokBabeChatCommand(BasePlayer player, string command, string[] args);
    [ConsoleCommand("ragna_start")]
    private void StartThisRagnarokBabeConsoleCommand(ConsoleSystem.Arg arg);
    [ChatCommand("ragna_timer")]
    private void GetThisRagnarokBabeOnTimerChatCommand(BasePlayer player, string command, string[] args);
    [ConsoleCommand("ragna_timer")]
    private void GetThisRagnarokBabeOnTimerConsoleCommand(ConsoleSystem.Arg arg);
    [ChatCommand("ragna_stop")]
    private void StopThisRagnarokBabeChatCommand(BasePlayer player, string command, string[] args);
    [ConsoleCommand("ragna_stop")]
    private void StopThisRagnarokBabeConsoleCommand(ConsoleSystem.Arg arg);
     void StopThisRagnarokBabe();
     void StartThisRagnarokBabe();
     void DisplayRagnarokHUD();
     void RemoveRagnarokHUD();
     void SpawnMeteor(Vector3 origin);
     void SpawnResource(Vector3 location);
     void SpawnResourceNode(Vector3 location);
     ItemDefinition GetBasicRocket();
     ItemDefinition GetFireRocket();
     ItemDefinition GetHighVelocityRocket();
     ItemDefinition GetSmokeRocket();
     Vector3 GetRandomMapPosition();
     float GetMapSize();
     void GenerateMarkers(Vector3 position);
}


```

---

## RaidableBases by nivex - Create fully automated raidable bases with NPCs

```csharp
using Facepunch;
using Facepunch.Extend;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;
using static Oxide.Plugins.RaidableBasesExtensionMethods.ExtensionMethods;

Oxide.Plugins
[Info("Raidable Bases", "nivex", "3.0.2")]
[Description("Create fully automated raidable bases with npcs.")]
public class RaidableBases : RustPlugin
{
    [PluginReference]
     Plugin AbandonedBases;
     Plugin DangerousTreasures;
     Plugin ZoneManager;
     Plugin BankSystem;
     Plugin IQEconomic;
     Plugin Economics;
     Plugin ServerRewards;
     Plugin GUIAnnouncements;
     Plugin AdvancedAlerts;
     Plugin Archery;
     Plugin Space;
     Plugin Sputnik;
     Plugin PocketDimensions;
     Plugin FauxAdmin;
     Plugin IQDronePatrol;
     Plugin Friends;
     Plugin Clans;
     Plugin Kits;
     Plugin TruePVE;
     Plugin SimplePVE;
     Plugin NightLantern;
     Plugin Wizardry;
     Plugin NextGenPVE;
     Plugin Imperium;
     Plugin Backpacks;
     Plugin BaseRepair;
     Plugin Notify;
     Plugin SkillTree;
     Plugin ShoppyStock;
     Plugin XPerience;
     Plugin XLevels;
    private new const string Name;
    private const int targetMask;
    private const int visibleMask;
    private const int targetMask2;
    private const int manualMask;
    private const int blockLayers;
    private const int queueLayers;
    private const int gridLayers;
    private const float M_RADIUS;
    private const float CELL_SIZE;
    private float OceanLevel;
    private bool wiped;
    private bool IsUnloading;
    private bool IsShuttingDown;
    private bool bypassRestarting;
    private bool DebugMode;
    private int despawnLimit;
    private SkinSettingsImportedWorkshop ImportedWorkshopSkins;
    private ProtectionProperties _elevatorProtection;
    private ProtectionProperties _turretProtection;
    private AutomatedController Automated;
    private StoredData data;
    public BuildingTables Buildings;
    public QueueController Queues;
    private SkinsPlugin skinsPlugin;
    private Coroutine setupCopyPasteObstructionRadius;
    private List<Coroutine> loadCoroutines;
    public List<RaidableBase> Raids;
    public Dictionary<ulong, DelaySettings> PvpDelay;
    public Dictionary<string, SkinInfo> Skins;
    private Dictionary<string, PasteData> _pasteData;
    private Dictionary<ulong, HumanoidBrain> HumanoidBrains;
    private Dictionary<NetworkableId, BMGELEVATOR> _elevators;
    private Dictionary<string, ItemDefinition> DeployableItems;
    private Dictionary<ItemDefinition, string> ItemDefinitions;
    private Dictionary<string, ItemDefinition> _itemModEntity;
    private Dictionary<ItemDefinition, ItemModConsume> _itemModConsume;
    private readonly List<string> ExcludedMounts;
    private readonly List<string> Blocks;
    private readonly List<string> TrueDamage;
    private readonly List<string> arguments;
    private readonly List<uint> CupboardPrefabIDs;
    private readonly IPlayer _consolePlayer;
    private readonly List<BaseEntity.Slot> _checkSlots;
    public class PasteData
    {
        public bool valid;
        public float radius;
        public List<Vector3> foundations;
        public List<string> invalid;
        public PasteData();
    }

    public static class RaidableMode
    {
        public const string Normal;
        public const string Random;
        public const string Points;
        public const string Disabled;
    }

    public class StoredData
    {
        public RotationCycle Cycle;
        public Dictionary<string, PlayerInfo> Players;
        public DateTime RaidTime;
        public int TotalEvents;
        public int protocol;
        public StoredData();
    }

    public class RandomBase
    {
        public float heightAdj;
        public float typeDistance;
        public float protectionRadius;
        public float safeRadius;
        public float ignoreRadius;
        public float buildRadius;
        public float baseHeight;
        public bool autoHeight;
        public bool stability;
        public bool checkTerrain;
        public bool Sorted;
        public bool Save;
        public string BaseName;
        public string username;
        public string id;
        public int attempts;
        public int errors;
        public ulong userid;
        public Vector3 Position;
        public IPlayer user;
        public RaidableType type;
        public BasePlayer owner;
        public PasteData pasteData;
        public BaseProfile Profile;
        public RaidableSpawns spawns;
        public RaidableBases Instance;
        public RaidableBase raid;
        public HashSet<ulong> members;
        public BuildingOptions options { get; set; }
        public bool HasSpawns();
    }

    public class BackpackData : Pool.IPooled
    {
        public BackpackData();
        public void EnterPool();
        public void LeavePool();
        public List<DroppedItemContainer> containers;
        public BasePlayer _player;
        public ulong userid;
        public bool IsEmpty { get; set; }
        public BasePlayer player { get; set; }
    }

    public class DelaySettings
    {
        public RaidableBase raid;
        public string mode;
        public Timer Timer;
        public float time;
        public void Destroy();
    }

    public class SkinInfo
    {
        public List<ulong> skins;
        public List<ulong> workshopSkins;
        public List<ulong> importedWorkshopSkins;
        public List<ulong> allSkins;
    }

    public class RankedRecord
    {
        public string Permission;
        public string Group;
        public string Mode;
        internal bool IsValid { get; set; }
        public RankedRecord(string permission, string group, string mode);
        public RankedRecord();
    }

    public class RaidableSpawnLocation : IEquatable<RaidableSpawnLocation>
    {
        public List<Vector3> Surroundings;
        public Vector3 Location;
        public MinMax LandLevel;
        public float WaterHeight;
        public float TerrainHeight;
        public float SpawnHeight;
        public float Radius;
        public float RailRadius;
        public bool AutoHeight;
        public RaidableSpawnLocation(Vector3 location);
        public bool Equals(RaidableSpawnLocation other);
        public override bool Equals(object obj);
        public override int GetHashCode();
    }

    public class ZoneInfo
    {
        internal string ZoneId;
        internal Vector3 Position;
        internal Vector3 Size;
        internal Vector3 extents;
        internal float Distance;
        internal bool IsBlocked;
        public ZoneInfo(string zoneID, Vector3 position, object radius, object size, bool isBlocked, float dist);
        public bool IsPositionInZone(Vector3 a);
    }

    public class BaseProfile
    {
        public BuildingOptions Options;
        public string ProfileName;
        private Dictionary<string, BaseProfile> Clones;
        public RaidableBases Instance;
        public BaseProfile(RaidableBases instance);
        public BaseProfile(RaidableBases instance, BuildingOptions options, string name);
        public static BaseProfile Clone(BaseProfile profile, string name);
    }

    public class BuildingTables
    {
        public Dictionary<string, List<LootItem>> DifficultyLootLists;
        public Dictionary<DayOfWeek, List<LootItem>> WeekdayLootLists;
        public Dictionary<string, BaseProfile> Profiles;
        public List<string> Removed;
        public bool IsConfigured(string baseName);
        public bool TryGetValue(string baseName, BaseProfile profile);
        public void Remove(string baseName);
    }

    public GridControllerManager GridController;
    public class GridControllerManager
    {
        internal RaidableBases Instance;
        internal Dictionary<RaidableType, RaidableSpawns> Spawns;
        internal Coroutine gridCoroutine;
        internal Coroutine fileCoroutine;
        internal float gridTime;
        public SpawnsControllerManager SpawnsController { get; set; }
        public StoredData data { get; set; }
        public Configuration config { get; set; }
        public double GetRaidTime();
        public void StartAutomation();
        private IEnumerator LoadFiles();
        public void SetupGrid();
        public void StopCoroutine();
        private void CriticalError(string text);
        public bool BadFrameRate;
        private IEnumerator GenerateGrid();
        public void LoadSpawns();
        public bool BlockAtSpawnsDatabase(Vector3 a);
        private void LoadSpawnsForType(RaidableType type, string spawnsFile, string key);
        public bool SpawnsFileValid(string spawnsFile);
        public HashSet<RaidableSpawnLocation> GetSpawnsLocations(string spawnsFile);
    }

    private class Spawnfile
    {
        public Dictionary<string, object> spawnPoints;
    }

    public class QueueController
    {
        internal YieldInstruction instruction0;
        internal YieldInstruction instruction1;
        internal Queue<RandomBase> queue;
        internal DebugMessages Messages;
        internal Coroutine _coroutine;
        internal int spawnChecks;
        internal bool Paused;
        internal RaidableBases Instance;
        internal const float REMOVE_RADIUS;
        internal Configuration config { get; set; }
        internal SpawnsControllerManager SpawnsController { get; set; }
        internal bool Any { get; set; }
        private void Message(BasePlayer player, string key, object[] args);
        private string mx(string key, string id, object[] args);
        public class DebugMessages
        {
            internal Dictionary<string, Info> _elements;
            internal RaidableBases _instance;
            internal bool _logToFile;
            internal IPlayer _user;
            public class Info
            {
                public int Amount;
                public List<string> Values;
                public override string ToString();
            }

            public string Add(string element, object obj);
            public void Clear();
            public bool Any();
            public void PrintAll(IPlayer user);
            private bool PrintInternal(IPlayer user, string message);
            public void Log(string baseName, string message);
            public bool Print(string message);
            public void Print(string message, object obj);
            public void Print(IPlayer user, string message, object obj);
            public void PrintLast(string id);
            public string GetLast(string id);
        }

        public QueueController(RaidableBases instance);
        public void RestartCoroutine();
        public void StopCoroutine();
        public void Add(RandomBase rb);
        private void Spawn(RandomBase rb, Vector3 position);
        private bool CanBypassPause(RandomBase rb);
        private IEnumerator FindEventPosition();
        private void CheckSpawner(RandomBase spq);
        internal bool IsObstructed(RandomBase spq, Vector3 v);
        private IEnumerator SetupCopyPasteRadius(RandomBase spq);
        internal bool IsAreaSafe(RandomBase spq, RaidableSpawnLocation rsl, Vector3 v);
        internal bool IsSubmerged(RandomBase spq, RaidableSpawnLocation rsl, Vector3 v);
        private bool CanSpawnCustom(RandomBase spq, RaidableType type, Vector3 v, bool ignore, float radius);
        private bool IsTooClose(RandomBase spq, Vector3 v);
        internal bool IsAreaManuallyBlocked(RandomBase spq, Vector3 v);
        private float GetAdjustedHeight(RandomBase spq, Vector3 v);
        private bool TopologyChecks(RandomBase spq, Vector3 v, float railRadius);
    }

    public class AutomatedController
    {
        internal YieldInstruction instruction0;
        internal YieldInstruction instruction1;
        internal YieldInstruction instruction5;
        internal YieldInstruction instruction15;
        internal Coroutine _maintainedCoroutine;
        internal Coroutine _scheduledCoroutine;
        internal bool IsMaintainedEnabled;
        internal bool IsScheduledEnabled;
        internal RaidableBases Instance;
        internal int _maxOnce;
        internal StoredData data { get; set; }
        internal Configuration config { get; set; }
        public AutomatedController(RaidableBases instance, bool a, bool b);
        public void DestroyMe();
        public void StopCoroutine(RaidableType type, IPlayer user);
        public void StartCoroutine(RaidableType type, IPlayer user);
        private IEnumerator MaintainCoroutine();
        private IEnumerator ScheduleCoroutine();
        private IEnumerator ProcessEvent(RaidableType type, float timeBetweenSpawns);
        private float ScheduleNextAutomatedEvent();
        private bool MaxOnce();
        private bool CanSpawn(RaidableType type, int onlinePlayers, int playerLimit, int playerLimitMax, int maxEvents, bool checkRaidTime);
    }

    public class BMGELEVATOR : FacepunchBehaviour
    {
        internal const string ElevatorPanelName;
        internal Elevator _elevator;
        internal RaycastHit hit;
        internal BaseEntity hitEntity;
        internal RaidableBase raid;
        internal BuildingOptionsElevators options;
        internal Dictionary<ulong, BasePlayer> _UI;
        internal bool HasButton;
        internal NetworkableId uid;
        internal int CurrentFloor;
        internal int returnDelay;
        internal float Floors;
        internal const float _LiftSpeedPerMetre;
        internal RaidableBases env;
        private void Awake();
        private void OnDestroy();
        private Vector3 GetWorldSpaceFloorPosition(int targetFloor);
        public void GoToFloor(Elevator.Direction Direction, bool FullTravel, int forcedFloor);
        private void Retry();
        private void ElevatorToGround();
        public void Init(RaidableBase raid);
        private void ShowHealthUI();
        public static void DestroyUi(BasePlayer player);
        private static void CleanElevatorKill(BaseEntity entity);
        public static PooledList<PooledList<BaseEntity>> SplitElevators(List<BaseEntity> source);
        public static void FixElevators(RaidableBase raid, Dictionary<Elevator, BMGELEVATOR> bmgs);
        public static BMGELEVATOR FixElevator(RaidableBases instance, List<BaseEntity> elevators);
        internal static bool GetElevatorLift(Elevator elevator, ElevatorLift lift);
        internal static void RemoveImmortality(ProtectionProperties baseProtection, float[] obj);
        private HashSet<ulong> _granted;
        public bool HasCardPermission(BasePlayer player);
        public bool HasBuildingPermission(BasePlayer player);
    }

    public class RaidableSpawns
    {
        public HashSet<RaidableSpawnLocation> Spawns;
        public HashSet<RaidableSpawnLocation> Garbage;
        public Dictionary<CacheType, HashSet<RaidableSpawnLocation>> Cached;
        private float lastTryTime;
        public bool IsCustomSpawn;
        public RaidableBases Instance;
        internal Configuration config { get; set; }
        public SpawnsControllerManager SpawnsController { get; set; }
        public HashSet<RaidableSpawnLocation> Inactive(CacheType cacheType);
        public RaidableSpawns(RaidableBases instance, HashSet<RaidableSpawnLocation> spawns);
        public RaidableSpawns(RaidableBases instance);
        public bool CanBuild(Vector3 buildPos, float radius);
        public bool Add(RaidableSpawnLocation rsl, CacheType cacheType, HashSet<RaidableSpawnLocation> cache, bool forced);
        public bool SetOceanLevel(RaidableSpawnLocation rsl);
        public void Check();
        public void TryAddRange(CacheType cacheType, bool forced);
        public RaidableSpawnLocation GetRandom(BuildingWaterOptions options);
        public HashSet<RaidableSpawnLocation> GetCache(CacheType cacheType);
        public void AddNear(Vector3 target, float radius, CacheType cacheType, float delayTime);
        public void Remove(RaidableSpawnLocation a, CacheType cacheType);
        public float RemoveNear(Vector3 target, float radius, CacheType cacheType, RaidableType type);
    }

    public class PlayerInfo
    {
        public int Raids;
        public int TotalRaids;
        public DateTime ExpiredDate;
        public bool IsExpired();
        public void ResetExpiredDate();
        public static PlayerInfo Get(StoredData data, string userid);
        public void ResetWipe();
        public void ResetLifetime();
        internal bool Any { get; set; }
    }

    public class RotationCycle
    {
        [JsonProperty(PropertyName = "Buildings")]
        public Dictionary<string, List<string>> _buildings;
        [JsonProperty(PropertyName = "Player Buildings")]
        public Dictionary<ulong, Dictionary<string, List<string>>> _playerBuildings;
        internal RaidableBases Instance;
        internal Configuration config { get; set; }
        public void Add(RaidableType type, string key, BasePlayer player, string mode);
        private Dictionary<string, List<string>> GetBuildingsDictionary(RaidableType type, BasePlayer player);
        public bool CanSpawn(RaidableType type, string mode, string key, BasePlayer player);
        public bool TryClear(RaidableType type, List<string> files);
    }

    public class PlayerInputEx : FacepunchBehaviour
    {
        private BasePlayer player;
        private Action queuedAction;
        private RaidableBases Instance;
        private RaidableBase raid;
        private Raider raider;
        private Transform t;
        private RaycastHit hit;
        private float deltaTimeTaken;
        private float nextConsumeTime;
        private bool AllowLadders;
        private bool AllowBarricades;
        public bool isDestroyed;
        public Configuration config { get; set; }
        public bool IsInvalid { get; set; }
        public void Setup(RaidableBase raid, Raider ri);
        public void Restart();
        private void Update();
        private bool IsFireButton { get; set; }
        private bool IsUseButton { get; set; }
        public bool TryPlace(ConstructionType constructionType);
        private void UseHeal(Item item, bool consume);
        private bool IsConstructionType(string shortname, ConstructionType constructionType);
        private bool IsConstructionNear(ConstructionType constructionType, Vector3 target);
    }

    public class HumanoidNPC : ScientistNPC
    {
        public new HumanoidBrain Brain;
        public RaidableBase raid { get; set; }
        public new Translate.Phrase LootPanelTitle { get; set; }
        public override string Categorize();
        public override bool ShouldDropActiveItem();
        public override string displayName { get; set; }
        public override void AttackerInfo(ProtoBuf.PlayerLifeStory.DeathInfo info);
        public override void OnDied(HitInfo info);
        private void TryRespawnNpc();
        public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide);
    }

    public class HumanoidBrain : ScientistBrain
    {
        public void DisableShouldThink();
        internal string displayName;
        internal Transform NpcTransform;
        internal IThinker thinker;
        internal HumanoidNPC npc;
        internal AttackEntity _attackEntity;
        internal FlameThrower flameThrower;
        internal BaseProjectile launcher;
        internal LiquidWeapon liquidWeapon;
        internal BaseMelee baseMelee;
        internal BaseProjectile baseProjectile;
        internal BasePlayer AttackTarget;
        internal Transform AttackTransform;
        internal RaidableBases Instance;
        internal RaidableBase raid;
        internal NpcSettings Settings;
        internal List<Vector3> RandomRoamPositions;
        internal List<Vector3> RandomNearPositions;
        internal Vector3 DestinationOverride;
        internal bool keepInventory;
        internal bool isKilled;
        internal bool isMurderer;
        internal float lastWarpTime;
        internal float ScientistChaseRange;
        internal float lastAttackTime;
        internal float nextAttackTime;
        internal float attackRange;
        internal float attackCooldown;
        internal float equipWeaponTime;
        internal float equipToolTime;
        internal float updateDeltaTime;
        internal AttackType attackType;
        internal BaseNavigator.NavigationSpeed CurrentSpeed;
        internal Configuration config { get; set; }
        internal Vector3 AttackPosition { get; set; }
        internal Vector3 ServerPosition { get; set; }
        public float SecondsSinceLastAttack { get; set; }
        internal List<AttackEntity> AttackWeapons;
        internal List<Item> MedicalTools;
        internal AttackEntity AttackEntity { get; set; }
        private void Update();
        private void EquipWeapon();
        public bool HasCorpseLoot();
        public void EnableMedicalTools();
        private void EquipMedicalTool();
        private IEnumerator Heal(Item medicalItem);
        public void UpdateWeapon(AttackEntity attackEntity, ItemId uid);
        internal void IdentifyWeapon();
        private void SetAttackRestrictions(AttackType attackType, float attackRange, float attackCooldown, float effectiveRange);
        public bool ValidTarget { get; set; }
        public override void OnDestroy();
        public override void InitializeAI();
        public void SetSleeping(bool state);
        public override void AddStates();
        public class AttackState : BaseAttackState
        {
            private new HumanoidBrain brain;
            private global::HumanNPC npc;
            private Transform NpcTransform;
            private IAIAttack attack { get; set; }
            public AttackState(HumanoidBrain humanoidBrain);
            public override void StateEnter(BaseAIBrain _brain, BaseEntity _entity);
            public override void StateLeave(BaseAIBrain _brain, BaseEntity _entity);
            private void StopAttacking();
            public override StateStatus StateThink(float delta, BaseAIBrain _brain, BaseEntity _entity);
            private bool InAttackRange();
            private void StartAttacking();
            private void RealisticShotTest();
        }

        private bool init;
        public void Init();
        private void Converge();
        public void Forget();
        public void SetRange(float range);
        private void RandomMove(float radius);
        private void RandomMove(Vector3 v, float radius);
        public void RandomMove(float radius, float margin, float maxAngle);
        public void SetupNavigator(BaseCombatEntity owner, BaseNavigator navigator, float distance);
        public Vector3 GetAimDirection();
        private void SetAimDirection();
        private void MovementUpdate();
        private void SetDestination();
        private void SetDestination(Vector3 destination);
        public bool SetTarget(BasePlayer player, bool converge);
        private bool TryReturnHome();
        private void TryToAttack();
        private void TryMurdererActions();
        private void TryScientistActions();
        public void SetupMovement(List<Vector3> positions);
        private void TryToRoam();
        public bool Warp();
        private void UseFlameThrower();
        private void UseWaterGun();
        private void UseChainsaw();
        private void EmulatedFire();
        private void MeleeAttack();
        public bool TryThrowWeapon();
        private bool CanConverge(HumanoidNPC other);
        private bool CanAnySeeTarget(BasePlayer target);
        private bool CanSeeTarget(BasePlayer target);
        public bool CanRoam(Vector3 destination);
        private bool CanShoot();
        private void TrySetKnown(BasePlayer player);
        public BasePlayer GetBestTarget();
        private bool IsAttackOnCooldown();
        private Vector3 GetRandomRoamPosition();
        private bool CanUseNavMesh();
        private bool IsInAttackRange(float range);
        private bool IsInEventRange(Vector3 destination);
        private bool IsInReachableRange();
        private bool IsInSenseRange(Vector3 destination);
        private bool IsInTargetRange(Vector3 destination);
        private bool IsInChaseRange(Vector3 destination);
        private bool IsInThrowRange();
        private bool ShouldForgetTarget(BasePlayer target);
    }

    public class Raider
    {
        public bool HasDestroyed;
        public bool IsAlly;
        public bool IsAllowed;
        public bool IsParticipant;
        public bool PreEnter;
        public bool eligible;
        public bool rewards;
        public float lastActiveTime;
        public float TotalDamage;
        public string id;
        public string displayName;
        public ulong userid;
        public PlayerInputEx Input;
        private BasePlayer _player;
        public Vector3 lastPosition;
        public BasePlayer player { get; set; }
        public Raider(ulong userid, string username);
        public Raider(BasePlayer target);
        public void DestroyInput();
        public void CheckInput(BasePlayer player, RaidableBase raid);
    }

    public class RaidableBase : FacepunchBehaviour
    {
        private const float Radius;
        public HashSet<ulong> alliance;
        public HashSet<ulong> cooldowns;
        public HashSet<ulong> intruders;
        public Dictionary<ulong, Raider> raiders;
        public Dictionary<ItemId, float> conditions;
        internal List<StorageContainer> fridges;
        internal HashSet<StorageContainer> _containers;
        internal HashSet<StorageContainer> _allcontainers;
        public List<HumanoidNPC> npcs;
        public List<WeaponRack> weaponRacks;
        public List<BackpackData> backpacks;
        public List<Vector3> compound;
        public List<Vector3> foundations;
        public List<Vector3> floors;
        public List<BaseEntity> locks;
        private List<BuildingBlock> blocks;
        private List<Vector3> _inside;
        private List<SphereEntity> spheres;
        private List<IOEntity> lights;
        private List<BaseOven> ovens;
        public List<AutoTurret> turrets;
        private List<Door> doors;
        public List<string> ids;
        private List<CustomDoorManipulator> doorControllers;
        private List<Locker> lockers;
        private Dictionary<string, Dictionary<SkinType, ulong>> _shortnameToSkin;
        private Dictionary<uint, ulong> _prefabToSkin;
        internal Dictionary<TriggerBase, BaseEntity> triggers;
        private List<SleepingBag> _beds;
        private Dictionary<SleepingBag, ulong> _bags;
        public List<SamSite> samsites;
        public List<VendingMachine> vms;
        public List<DamageMultiplier> PlayerDamageMultiplier;
        public List<ulong> HintCooldowns;
        public BuildingPrivlidge priv;
        public List<ulong> TeleportExceptions;
        private List<string> murdererKits;
        private List<string> scientistKits;
        private MapMarkerExplosion explosionMarker;
        private MapMarkerGenericRadius genericMarker;
        private VendingMachineMapMarker vendingMarker;
        public Coroutine setupRoutine;
        public Coroutine turretsCoroutine;
        private GameObject go;
        private bool IsPrivDestroyed;
        public bool IsDespawning;
        public Vector3 Location;
        public string ProfileName;
        public float BaseHeight;
        public string BaseName;
        public Color NoneColor;
        public bool ownerFlag;
        public string ID;
        public ulong ownerId;
        public string ownerName;
        public float loadTime;
        public DateTime spawnDateTime;
        public DateTime despawnDateTime;
        public float AddNearTime;
        public bool AllowPVP;
        public BuildingOptions Options;
        public bool IsAuthed;
        public bool IsOpened;
        public bool IsResetting;
        public int npcMaxAmountMurderers;
        public int npcMaxAmountScientists;
        private bool isInvokingMurdererRespawn;
        private bool isInvokingScientistRespawn;
        public RaidableType Type;
        public bool IsLoading;
        public bool InitiateTurretOnSpawn;
        private bool markerCreated;
        private int itemAmountSpawned;
        public bool privSpawned;
        public bool privHadLoot;
        public string markerName;
        public string NoMode;
        public bool isAuthorized;
        public bool IsEngaged;
        public int _undoLimit;
        private Dictionary<Elevator, BMGELEVATOR> Elevators;
        public HashSet<BaseEntity> Entities;
        public HashSet<BaseEntity> DespawnExceptions;
        public HashSet<BaseEntity> BuiltList;
        public RaidableSpawns spawns;
        public RandomBase rb;
        public float RemoveNearDistance;
        public bool IsAnyLooted;
        public bool IsDamaged;
        public bool IsEligible;
        public bool IsCompleted;
        public float ProtectionRadius;
        public float SqrProtectionRadius;
        public RaidableBases Instance;
        public bool stability;
        private int numLootRequired;
        public List<ulong> NotifiedNearby;
        public BasePlayer cached_attacker;
        public ulong cached_attacker_id;
        public float cached_attack_time;
        public float ProtectionRadiusSqr(float tolerance);
        public bool EjectBackpacksPVE { get; set; }
        public bool PlayersLootable { get; set; }
        public List<string> BlacklistedCommands { get; set; }
        public SpawnsControllerManager SpawnsController { get; set; }
        public StoredData data { get; set; }
        public Configuration config { get; set; }
        public bool IsUnloading { get; set; }
        public bool IsShuttingDown { get; set; }
        private float nextHookTime;
        private object[] _hookObjects;
        public object[] hookObjects { get; set; }
        public int DespawnMinutes { get; set; }
        public bool DespawnMinutesReset { get; set; }
        public int DespawnMinutesInactive { get; set; }
        public bool DespawnMinutesInactiveReset { get; set; }
        public bool EngageOnBaseDamage { get; set; }
        public bool EngageOnNpcDeath { get; set; }
        public string GetPercentCompleteMessage();
        public double GetPercentComplete();
        public int GetLootAmountRemaining();
        public bool Has(BaseEntity entity, bool checkList);
        public bool IsBox(BaseEntity entity, bool inherit);
        public string FormatGridReference(BasePlayer player, Vector3 v);
        private void OnDestroy();
        public bool CanDropRustBackpack(ulong userid);
        public bool CanDropBackpack(ulong userid);
        public Raider GetRaider(BasePlayer player);
        public bool CanHurtBox(BaseEntity entity);
        public void DestroyGroundCheck(BaseEntity entity);
        public void SetupEntity(BaseEntity entity, bool skipCheck);
        public void AddEntity(BaseEntity entity);
        public void ResetToPool();
        public void Message(BasePlayer player, string key, object[] args);
        public void TryMessage(BasePlayer player, string key, object[] args);
        public void QueueNotification(BasePlayer player, string key, object[] args);
        public string mx(string key, string id, object[] args);
        private void Start();
        public void SetupCollider();
        public HashSet<BaseEntity> enteredEntities;
        private void OnTriggerEnter(Collider collider);
        private void HandleDefaultEntity(BaseEntity entity, bool enabled);
        private void OnTriggerExit(Collider collider);
        public void HandlePlayerEntering(BasePlayer player);
        public void HandlePlayerExiting(BasePlayer player);
        private void HandleMountableEntering(BaseMountable m);
        private void HandleMountableExiting(BaseMountable m);
        private void HandleHotAirBalloonEntering(HotAirBalloon hab);
        private void HandleHotAirBalloonExiting(HotAirBalloon hab);
        public void RemoveMountedEntity(BaseEntity entity);
        public bool IsUnderground(Vector3 a);
        public bool CanRespawnAt(BasePlayer target);
        public bool WasConnected(BasePlayer target);
        public bool IsParticipant(BasePlayer target);
        public void HandleTurretSight(BasePlayer target);
        public DamageResult OnTurretTarget(AutoTurret turret);
        private void OnPreEnterRaid(BasePlayer target);
        public void OnEnterRaid(BasePlayer target, bool checkUnderground);
        public void HolsterWeapon(BasePlayer player);
        public void OnPlayerExit(BasePlayer target, bool skipDelay);
        public void OnPlayerExited(BasePlayer target);
        public void AddHintCooldown(BasePlayer target, float cooldown);
        public bool CanSetPVPDelay(BasePlayer target);
        public void TrySetPVPDelay(BasePlayer target, HitInfo info, bool skipDelay, string key);
        public void ExpireAllDelays();
        private object[] GetDelayHookObjects(BasePlayer target);
        public void SetPVPDelay(BasePlayer target, HitInfo info);
        public string GetAllowKey();
        private bool IsScavenging(BasePlayer player);
        private bool RemoveFauxAdmin(BasePlayer player);
        private bool IsBanned(BasePlayer player);
        private bool Teleported(BasePlayer player);
        public bool IsMounted(BasePlayer player);
        public bool IsMountable(BaseEntity entity);
        public bool IsHogging(BasePlayer player);
        public bool IsAllyHogging(BasePlayer player);
        private bool IsAllyHogging(BasePlayer player, RaidableBase raid);
        private void CheckBackpacks(bool bypass);
        private float RadiationProtection(BasePlayer player);
        private bool IsNullOrVoid(BaseEntity entity);
        public bool InRangeTolerance(Raider ri);
        private bool requiredLootPercentageMet;
        private void Protector();
        private void RejectPlayer(Raider ri);
        public void AddMember(ulong userid);
        public void FinalizeUi();
        public void StopSetupCoroutine();
        public void Despawn();
        public void LogEvent();
        public static void TryInvokeMethod(Action action);
        public void RemoveAllFromEvent();
        public void SendDronePatrol(RandomBase rb);
        private void CancellDrone(RandomBase rb);
        public void CheckSubscribe();
        public void DestroyElevators();
        public void DestroyEntities();
        public void SetPreventLooting();
        public void OnBuildingPrivilegeDestroyed();
        public bool IsOwnerConnected();
        public BasePlayer GetOwner();
        private List<BasePlayer> _intruders;
        public List<BasePlayer> GetIntruders();
        private List<BasePlayer> _raiders;
        public List<BasePlayer> GetRaiders(bool participantOnly);
        public int GetParticipantAmount();
        public bool AddLooter(BasePlayer looter, HitInfo info);
        public bool IsDamageBlocked(BaseEntity entity);
        public bool IsPickupBlacklisted(string name);
        private void FillAmmoTurret(AutoTurret turret);
        private void FillAmmoGunTrap(GunTrap gt);
        private ItemDefinition lowgradefuel;
        private void FillAmmoFogMachine(FogMachine fm);
        private void FillAmmoFlameTurret(FlameTurret ft);
        private void FillAmmoSamSite(SamSite ss);
        private bool IsAuthorized();
        private void OnWeaponItemPreRemove(Item item);
        public void TryToEnd();
        private void UnlockEverything();
        public bool GetInitiatorPlayer(HitInfo info, BaseCombatEntity entity, BasePlayer target);
        private List<string> fireAmmoTypes;
        public BasePlayer GetArsonist();
        public void SetAllowPVP(RandomBase rb);
        private bool CancelOnServerRestart();
        public void AwardRaiders();
        public bool RequiredLootPercentageMet(double requiredLootPercentage, double percentageMet);
        private void HandleAwards();
        private void AddGroupedPermission(string userid, string group, string perm);
        private bool CanAssignTo(ulong userid, ulong owner, bool only);
        public bool CanBypass(BasePlayer player);
        private bool Exceeds(BasePlayer player);
        public int GetParticipantsAmount();
        public string LangMode(string userid, bool strip);
        public string Mode(string userid, bool forceShowName);
        private void SetOwnerInternal(string username, ulong userid);
        public void SetOwner(BasePlayer owner);
        private float PlayerActivityTimeLeft(ulong userid);
        public bool IsPlayerActive(ulong userid);
        public void TrySetOwner(BasePlayer attacker, BaseEntity entity, HitInfo info);
        public void ResetRaiderRelations();
        public void ClearEnemies();
        public void CheckDespawn();
        public void CheckDespawn(HitInfo info);
        private float lastDespawnUpdateTime;
        public void UpdateDespawnDateTime(float time, HitInfo info);
        public bool EndWhenCupboardIsDestroyed();
        public bool CanUndo();
        private bool CanPlayerBeLooted(ulong looter, ulong target);
        private bool CanBeLooted(BasePlayer player, BaseEntity e);
        public bool IsProtectedWeapon(BaseEntity e, bool checkBuiltList);
        public bool IsWeapon(BaseEntity e);
        public bool IsFoundation(BaseEntity e);
        public bool IsCompound(BaseEntity e);
        public object CanLootEntityInternal(BasePlayer player, BaseEntity entity);
        public bool CanBuild(BasePlayer player);
        public static void ClearInventory(ItemContainer container);
        public void SetNoDrops();
        public void DestroyInputs();
        public void Init(RandomBase rb, List<BaseEntity> entities);
        private void SetupElevators();
        private List<string> setupBlockedPrefabs;
        private void AddEntities(List<BaseEntity> entities);
        private bool centerSetFromMultiplePoints;
        public void SetCenterFromMultiplePoints();
        private void CreateSpheres();
        private void SpawnSphere(string prefab);
        private void CreateZoneWalls();
        private List<TreeInfo> trees;
        public class TreeInfo
        {
            public Vector3 pos;
            public Quaternion rot;
            public string prefab;
            public BaseEntity tree;
            public TreeInfo(BaseEntity entity);
            public void Respawn();
        }

        private void RemoveClutter();
        private void RespawnTrees();
        private bool CanEjectMountable(BaseEntity m, PooledList<BasePlayer> players);
        private void DeployableItemHandler(BaseEntity e);
        public void ResetSleepingBags();
        private IEnumerator EntitySetup();
        private void TrySetupEntity(BaseEntity e, float invokeTime);
        private void SetupLights();
        public bool IsPasted;
        public void CheckPaste();
        private void SetupContainers();
        private void SetupWeaponRack(WeaponRack rack);
        private void SetupPickup(BaseCombatEntity e);
        private void AddContainer(StorageContainer container);
        private void RemoveContainer(StorageContainer container);
        public void TryEmptyContainer(StorageContainer container);
        private void SetupContainer(StorageContainer container);
        private void SetupIO(ContainerIOEntity io);
        private void SetupIO(IOEntity io);
        private void SetupLock(BaseEntity e, bool justCreated);
        private void SetupVendingMachine(VendingMachine vm);
        private void SetupLight(IOEntity light);
        private void SetupHBHFSensor(HBHFSensor sensor);
        private void SetupBattery(ElectricBattery eb);
        private void SetupGenerator(ElectricGenerator generator);
        private void SetupButton(PressButton button);
        private void SetupBuildingBlock(BuildingBlock block);
        private List<string> blockPrefabs;
        public bool HasSkin(BuildingBlock block, BuildingGrade.Enum grade, ulong skin);
        private void ChangeTier(BuildingBlock block);
        private Dictionary<BuildingGrade.Enum, ulong> skinWhole;
        private Dictionary<BuildingGrade.Enum, uint> skinColors;
        private void SetupTeslaCoil(TeslaCoil tc);
        private void SetupIgniter(Igniter igniter);
        public void PreSetupTurret(AutoTurret turret);
        private void SetupTurret(AutoTurret turret);
        private readonly Dictionary<NetworkableId, SphereCollider> _turretColliders;
        public void SetupSightRange(AutoTurret turret, float sightRange, int multi);
        private void SetupTurrets();
        private IEnumerator TurretsCoroutine();
        public bool UsableByTurret;
        private void EquipTurretWeapon(AutoTurret turret, PooledList<string> shortnames, bool setter);
        private bool CanAcceptItem(Item item, int targetPos);
        private void UpdateAttachedWeapon(AutoTurret turret);
        private void InitiateStartup(AutoTurret turret);
        private void Authorize(BasePlayer player);
        private bool CanBypassAuthorized(ulong userid);
        private void SetupGunTrap(GunTrap gt);
        private void SetupFogMachine(FogMachine fm);
        private void SetupSprinkler(Sprinkler sprinkler);
        private void SetupBurn(BaseEntity entity);
        private void SetupOven(BaseOven oven);
        private void SetupFlameTurret(FlameTurret ft);
        private void SetupSamSite(SamSite ss);
        private bool ChangeTier(Door door);
        private bool SetDoorType(Door door, string prefab);
        private void SetupDoor(Door door);
        private void SetupDoor(Door door, bool changed);
        private void SetupDoors();
        private void SetupDoorControllers();
        private void SetupPairedDoor(Door door);
        private void CreateLock(BaseEntity entity, bool createKeyLock, bool createCodeLock);
        private void CreateKeyLock(BaseEntity entity);
        private void CreateCodeLock(BaseEntity entity);
        private void SetupBuildingPriviledge(BuildingPrivlidge priv);
        private void SetupLocker(Locker locker);
        private void SetupSleepingBag(SleepingBag bag);
        private void SetupCollectible(CollectibleEntity ce);
        private void SetupSpookySpeaker(SpookySpeaker ss);
        private void SetupDecayEntity(DecayEntity e);
        private void SetupBoxSkin(StorageContainer container);
        private void SetupSkin(BaseEntity entity);
        private void Subscribe();
        private void Subscribe(string hook);
        private void MakeAnnouncements();
        public void ResetPublicOwner();
        public void ResetEventLock();
        public void SpawnDrops(ItemContainer[] containers, List<LootItem> lootList);
        private bool SetupLoot();
        private bool SetupLootContainers(List<StorageContainer> containers);
        public class LootProfile
        {
            public List<LootItem> Base;
            public List<LootItem> Difficulty;
            public List<LootItem> Default;
            public List<LootItem> Tables;
            public TreasureSettings Unique;
            public BuildingOptions Options;
            public RaidableBases Instance;
            public string BaseName;
            public bool AllowPVP;
            public ulong UserID;
            public int Amount;
            public int Count { get; set; }
        }

        private bool IsItemBlockedInto(LootItem lootItem, StorageContainer container);
        private LootItem GetLootItem(List<LootItem> lootList);
        private void DivideLoot(List<LootItem> lootList, int amount, List<StorageContainer> containers);
        private static void TakeLootFromBaseLoot(LootProfile loot);
        private static void TakeLootFromDifficultyLoot(LootProfile loot);
        private static void TakeLootFromWeekdayLoot(LootProfile loot);
        private static void TakeLootFromDefaultLoot(LootProfile loot);
        private static void TakeLootFrom(List<LootItem> lootList, List<LootItem> to, BuildingOptions Options, ulong UserID, bool AllowPVP);
        private static void TakeLootFromLootTables(LootProfile loot);
        private static bool AddToLoot(LootProfile loot, LootItem lootItem);
        private static int[] GetStacks(int amount, int maxStack);
        private List<string> BuildingMaterials;
        private Item CreateItem(LootItem ti, int amount);
        private void SetupSellOrders();
        private bool MoveFood(Item item);
        private bool MoveToRack(Item item);
        private bool MoveToBBQ(Item item);
        private bool MoveToCupboard(Item item);
        private bool IsCookable(ItemDefinition def);
        private bool MoveToOven(Item item);
        private bool SplitIntoFurnaces(List<BaseOven> ovens, Item item);
        private bool IsLockerItem(ItemDefinition def);
        private bool MoveToLocker(Item item);
        private bool MoveToLocker(Item item, Locker locker);
        private void CheckExpansionSettings();
        private bool ToggleNpcMinerHat(HumanoidNPC npc, bool state);
        public void ToggleLights();
        public void Undo();
        public bool Any(ulong userid, bool checkAllies);
        private static bool IsBlacklistedSkin(ItemDefinition def, int num);
        public ulong GetItemSkin(ItemDefinition def, SkinType type, ulong defaultSkin, bool stackable, bool nonstackable, bool random, bool workshop, bool importedworkshop, bool approved, int stacksize);
        public SkinInfo GetItemSkins(ItemDefinition def, bool approvedOnly);
        private bool IsApproved(ItemDefinition def, ulong skin);
        private List<ulong> GetItemSkins(SkinInfo si, bool random, bool workshop, bool importedworkshop);
        private bool SetItemSkin(List<ulong> skins, SkinInfo si, BaseEntity entity, bool unique);
        public bool IsAlly(ulong playerId, ulong targetId, AlliedType type);
        public bool IsAlly(BasePlayer player);
        public void StopUsingWeapon(BasePlayer player);
        public void StopUsingWeapon(BasePlayer player, string[] weapons);
        private void StopUsingWeapon(BasePlayer player, Item item);
        public BackpackData AddBackpack(DroppedItemContainer container, ulong playerSteamID, BasePlayer player);
        private void RemoveParentFromEntitiesOnElevators();
        public bool EjectBackpack(BackpackData backpack, bool bypass);
        private void EjectBackpackNotice(BasePlayer player, Vector3 position);
        private void EjectSleepers();
        public Vector3 GetEjectLocation(Vector3 a, float distance, Vector3 target, float radius, bool towardsZero, bool setHeight);
        public bool RemovePlayer(BasePlayer player, Vector3 a, float radius, RaidableType type, bool special);
        public void Teleport(BasePlayer player);
        public void DismountAllPlayers(BaseMountable m);
        public static PooledList<BasePlayer> GetMountedPlayers(HotAirBalloon m);
        public static PooledList<BasePlayer> GetMountedPlayers(BaseMountable m);
        public static bool AnyMounted(BaseMountable m);
        private bool CanEject(PooledList<BasePlayer> players);
        private bool CanEject(BasePlayer target);
        public bool CanEjectEnemy();
        private bool CannotEnter(BasePlayer target, bool justEntered);
        public bool IsControlledMount(BaseEntity m);
        private bool IsBlockingCampers(ModularCar car);
        private bool TryRemoveMountable(BaseEntity m, PooledList<BasePlayer> players);
        private bool ShouldEject(ManagementMountableSettings ms, BaseEntity m, bool jetpack, bool carpet);
        public static bool IsWearingJetpack(BasePlayer player);
        public static bool IsJetpack(BaseMountable m);
        public static bool IsInvisibleChair(BaseEntity m);
        public static void TryPushMountable(BaseVehicle vehicle, Vector3 target, float minDistance);
        private static void ApplyMassForce(BaseVehicle vehicle, Rigidbody body, Vector3 target);
        private static void ApplyModularCarForce(BaseVehicle vehicle, Rigidbody body, Vector3 target, float forceMultiplier);
        private static void ApplyHelicopterOrParachuteForce(BaseVehicle vehicle, Rigidbody body, Vector3 target, float forceMultiplier, bool b);
        private static void ApplyDefaultForce(BaseVehicle vehicle, Rigidbody body, float forceMultiplier);
        private static bool IsFlying(BasePlayer player);
        private void TryEjectMountable(BaseEntity e);
        private void EjectContainer(BaseEntity container, ulong playerSteamID, bool notice);
        private float habdist;
        public bool Eject(BaseEntity m, Vector3 position, float radius, bool groundLevel);
        public bool EjectMountable(BaseMountable m, PooledList<BasePlayer> players, Vector3 position, float radius, bool special);
        private static T GetParentEntity(T m);
        public bool CanSetupEntity(BaseEntity e);
        public void TryRespawnNpc(bool isMurderer);
        private void SetInvokingRespawnNpc(bool isMurderer, bool value);
        private void RespawnNpcNow(bool isMurderer);
        public void SpawnNpcs();
        public bool NearFoundation(Vector3 from, float range);
        public bool FindPointOnNavmesh(Vector3 a, float radius, Vector3 v);
        private bool IsAcceptableWaterDepth(Vector3 position);
        private bool TestInsideObject(Vector3 position);
        private bool TestClippedInside(Vector3 position, float radius, int mask);
        private bool TestInsideRock(Vector3 a);
        private bool IsInVerticalRange(Vector3 a, RaycastHit hit);
        private List<string> _prefabs;
        private bool IsRock(string name);
        private bool InstantiateEntity(List<Vector3> wander, Vector3 position, HumanoidBrain brain, HumanoidNPC npc);
        private List<Vector3> GetPositionsNearestTo(List<Vector3> wander, Vector3 a, float sqrSenseRange);
        private List<Vector3> GetWanderPositions(float radius);
        private float GetRoamRadius();
        private float GetSpawnRadius();
        private HumanoidNPC SpawnNpc(bool isMurderer);
        public class Loadout
        {
            public List<PlayerInventoryProperties.ItemAmountSkinned> belt;
            public List<PlayerInventoryProperties.ItemAmountSkinned> main;
            public List<PlayerInventoryProperties.ItemAmountSkinned> wear;
        }

        private PlayerInventoryProperties GetLoadout(HumanoidNPC npc, HumanoidBrain brain);
        private Loadout CreateLoadout(HumanoidNPC npc, HumanoidBrain brain);
        private void AddItemAmountSkinned(List<PlayerInventoryProperties.ItemAmountSkinned> source, List<string> shortnames);
        private readonly List<string> _murdererPrefabNames;
        private void SetupNpc(HumanoidNPC npc, HumanoidBrain brain, List<Vector3> positions);
        private void SetupAlternateLoot(HumanoidNPC npc, HumanoidBrain brain);
        private bool isKitted;
        private void GiveKit(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
        private void UpdateItems(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
        public void EquipWeapon(HumanoidNPC npc, HumanoidBrain brain);
        private bool IsNpcNearSpot(Vector3 position);
        private void SetupNpcKits();
        public string DespawnString { get; set; }
        public double DespawnTime { get; set; }
        public string MarkerName { get; set; }
        public void ForceUpdateMarker();
        public void UpdateMarker();
        private void CreateGenericMarker();
        private void DestroyMapNote(BasePlayer owner);
        private ProtoBuf.MapNote mapNote;
        private bool TryParseHtmlString(string value, Color color);
        private Color GetMarkerColor1();
        private Color GetMarkerColor2();
        private bool IsMarkerAllowed();
        public void DestroyLocks();
        public void DestroyNpcs();
        public void DestroySpheres();
        public void DestroyMapMarkers();
    }

    public SpawnsControllerManager SpawnsController;
    public class SpawnsControllerManager
    {
        internal YieldInstruction instruction0;
        internal List<ZoneInfo> managedZones;
        internal List<string> assets;
        internal List<string> AdditionalBlockedColliders;
        internal List<string> _materialNames;
        internal List<MonumentInfoEx> Monuments;
        public RaidableBases Instance;
        internal Configuration config { get; set; }
        public class MonumentInfoEx
        {
            public float radius;
            public string text;
            public Vector3 position;
            public MonumentInfoEx(string text, Vector3 position, float radius);
        }

        public void Initialize();
        private bool IsMonumentMarkerBlocked(string category);
        public IEnumerator SetupMonuments();
        public IEnumerator CalculateMonumentSize(Vector3 from, string text);
        public PooledList<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next, bool spawnHeight, bool shouldSkipSmallRock, float y);
        private bool IsValidMaterial(string materialName);
        private bool ShouldSkipSmallRock(RaycastHit hit, string colName);
        public float GetSpawnHeight(Vector3 target, bool max, bool skip, int mask);
        public bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position, float radius);
        public bool IsLocationBlocked(Vector3 v);
        public bool IsZoneBlocked(Vector3 v);
        private bool IsValidLocation(Vector3 v, float safeRadius, float minProtectionRadius, float railRadius);
        internal bool TopologyChecks(Vector3 v, float radius, float railRadius, string topology);
        private bool HasPointOnPathList(List<PathList> paths, Vector3 point, float radius);
        public bool IsBlockedByMapPrefab(List<(Vector3 pos, float dist)> prefabs, Vector3 position);
        public void ExtractLocation(RaidableSpawns spawns, Vector3 position, float maxLandLevel, float minProtectionRadius, float maxProtectionRadius, float railRadius, float maxWaterDepth);
        public bool IsSubmerged(BuildingWaterOptions options, RaidableSpawnLocation rsl);
        public bool IsSubmerged(BuildingWaterOptions options, RaidableSpawnLocation rsl, float radius);
        public bool IsMonumentPosition(Vector3 a, float extra);
        private List<(Vector3 position, float sqrDistance)> safeZones;
        private bool IsSafeZone(Vector3 a, float extra);
        public bool IsAssetBlocked(BaseEntity entity, string colName, string entityName);
        public bool IsAreaSafe(Vector3 area, float ignoreRadius, float protectionRadius, float cupboardRadius, float worldRadius, int layers, bool isCustomSpawn, CacheType cacheType, RaidableType type);
        public bool IsTutorialNetworkGroup(BaseEntity entity);
        public bool CanIgnoreDeployable();
        public MinMax GetLandLevel(Vector3 from, float radius, BasePlayer player);
        public bool IsFlatTerrain(Vector3 from, MinMax landLevel, float maxLandLevel);
        public bool InDeepWater(Vector3 v, bool seabed, float minDepth, float maxDepth);
        public void SetupZones(Plugin ZoneManager, bool message);
        public bool AddZone(Plugin ZoneManager, string zoneId);
        public bool IsObstructed(Vector3 a, float radius, float landLevel, float forcedHeight, BasePlayer player);
    }

    private void UnsubscribeHooks();
    private void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote note);
    private void OnNewSave(string filename);
    private void Init();
    private void OnServerShutdown();
    private void Unload();
    private void OnServerInitialized(bool isStartup);
    private void OnSunrise();
    private void OnSunset();
    private object OnLifeSupportSavingLife(BasePlayer player);
    private object CanDoubleJump(BasePlayer player);
    private object OnRestoreUponDeath(BasePlayer player);
    private object OnCustomLootNPC(NetworkableId networkableId);
    private object OnNpcKits(ulong targetId);
    private object OnReflectDamage(BasePlayer victim, BasePlayer attacker);
    private object CanBGrade(BasePlayer player, int playerGrade, BuildingBlock block, Planner planner);
    private object canRemove(BasePlayer player);
    private object canTeleport(BasePlayer player);
    private object CanTeleport(BasePlayer player, Vector3 to);
    private object OnBaseRepair(BuildingManager.Building building, BasePlayer player);
    private object STCanGainXP(BasePlayer player, double amount, string pluginName);
    private object OnRaidingUltimateTargetAcquire(BasePlayer player, Vector3 targetPoint);
    private void OnClanMemberJoined(ulong userid, string tag);
    private object OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer player);
    private object OnNeverWear(Item item, float amount);
    private void OnDeletedDynamicPVP(string zoneId, string eventName);
    private void OnCreatedDynamicPVP(string zoneId, string eventName, Vector3 position, float duration);
    private void OnLoseCondition(Item item, float amount);
    private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade, ulong skin);
    private void OnEntityBuilt(Planner planner, GameObject go);
    private void AddPlayerEntity(BaseEntity e, RaidableBase raid);
    private void OnElevatorButtonPress(ElevatorLift e, BasePlayer player, Elevator.Direction Direction, bool FullTravel);
    private void OnButtonPress(PressButton button, BasePlayer player);
    private bool IsProtectedScientist(BasePlayer player, BaseEntity entity);
    private object OnNpcDuck(HumanoidNPC npc);
    private object OnNpcDestinationSet(HumanoidNPC npc, Vector3 newDestination);
    private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem);
    private void OnPlayerSleepEnded(BasePlayer player);
    private object OnPlayerLand(BasePlayer player, float amount);
    private void OnPlayerDeath(BasePlayer player, HitInfo info);
    private object OnBackpackDrop(Item backpack, PlayerInventory inv);
    private void DropRustBackpack(PlayerCorpse corpse);
    private void DropRustBackpack(DroppedItemContainer backpack);
    private object OnPlayerDropActiveItem(BasePlayer player, Item item);
    private object OnPlayerCommand(BasePlayer player, string command, string[] args);
    private object OnServerCommand(ConsoleSystem.Arg arg);
    private void OnEntityDeath(BuildingPrivlidge priv, HitInfo info);
    private void OnEntityKill(StorageContainer container);
    private void OnEntityDeath(StorageContainer container, HitInfo info);
    private void OnEntityDeath(StabilityEntity entity, HitInfo info);
    private object OnEntityGroundMissing(StorageContainer container);
    private void OnEntityDeath(IOEntity io, HitInfo info);
    private void EntityHandler(StorageContainer container, HitInfo info);
    private static bool IsLootingWeapon(HitInfo info);
    private void OnCupboardAuthorize(BuildingPrivlidge priv, BasePlayer player);
    private object CanPickupEntity(BasePlayer player, BaseEntity entity);
    private void OnFireBallSpread(FireBall fire, BaseEntity spread);
    private void OnFireBallDamage(FireBall fire, BaseCombatEntity target, HitInfo info);
    private object CanMlrsTargetLocation(MLRS mlrs, BasePlayer player);
    private object OnMlrsFire(MLRS mlrs, BasePlayer player);
    private object OnInterferenceOthersUpdate(AutoTurret turret);
    private object OnInterferenceUpdate(AutoTurret turret);
    private void OnEntitySpawned(TimedExplosive te);
    private void OnEntitySpawnedMLRS(MLRSRocket rocket);
    private BeeSwarmMaster _lastSwarmMaster;
    private void OnEntitySpawned(BeeSwarmMaster swarm);
    private void OnEntitySpawned(BeeSwarmAI ai);
    private void OnEntitySpawned(FireBall fire);
    private void OnEntitySpawned(DroppedItemContainer backpack);
    private void OnEntitySpawned(BaseLock entity);
    private void OnEntitySpawned(PlayerCorpse corpse);
    private object CanBuild(Planner planner, Construction construction, Construction.Target target);
    [HookMethod("AddLootToDifficultyProfile")]
    public bool AddLootToDifficultyProfile(string mode, List<object[]> lootObjects);
    private void OnLootEntityEnd(BasePlayer player, StorageContainer container);
    private object CanLootDroppedItemContainer(BasePlayer player, BaseEntity entity);
    private object CanLootEntity(BasePlayer player, BaseEntity entity);
    private object CanBePenalized(BasePlayer player);
    private void CanOpenBackpack(BasePlayer looter, ulong backpackOwnerID);
    private bool CanDropPlayerBackpack(BasePlayer player, RaidableBase raid);
    private bool ShouldIgnoreFlyingPlayer(BasePlayer player);
    private static bool IsDangerousEvent(BaseEntity entity);
    private static bool IsSputnik(BaseEntity entity);
    private bool IsEventEntity(BaseEntity entity, float dist, float protectionRadius);
    private bool IsAbandonedEntity(BaseEntity entity);
    private bool IsArmoredTrain(BaseEntity entity);
    private bool IsSentryTargetingNpc(BasePlayer player, BaseEntity entity);
    private bool IgnorePlayer(BasePlayer player, BaseEntity entity);
    private bool IsPositionInSpace(Vector3 a, Vector3 b, float r);
    private object OnEntityEnter(TriggerBase trigger, Drone drone);
    private object OnEntityEnter(TriggerBase trigger, BasePlayer player);
    private object CanEntityBeTargeted(BasePlayer player, BaseEntity entity);
    private object CanEntityBeTargetedInternal(BasePlayer player, BaseEntity entity, bool earlyExit);
    private object CanEntityBeTargeted(BaseEntity entity, SamSite ss);
    private object OnSamSiteTargetScan(SamSite ss, List<SamSite.ISamSiteTarget> obj);
    private object OnTrapTrigger(BaseTrap trap, GameObject go);
    private object CanEntityTrapTrigger(BaseTrap trap, BasePlayer player);
    private void OnCupboardProtectionCalculated(BuildingPrivlidge priv, float cachedProtectedMinutes);
    private object CanEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    protected void UnsubscribeDamageHook();
    private void SubscribeDamageHook();
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private DamageResult HandlePlayerDamage(BasePlayer victim, HitInfo info, DamageType damageType, RaidableBase raid, BasePlayer attacker, bool isHuman);
    private DamageResult HandleTrueDamage(RaidableBase raid, HitInfo info, BaseEntity weapon, BasePlayer victim);
    private DamageResult HandleAttacker(BasePlayer attacker, BasePlayer victim, HitInfo info, DamageType damageType, RaidableBase raid, bool isHuman);
    private DamageResult HandleNpcVictim(RaidableBase raid, BasePlayer victim, BasePlayer attacker, HitInfo info);
    private DamageResult HandlePVPDamage(RaidableBase raid, BasePlayer victim, BasePlayer attacker, HitInfo info, DamageType damageType);
    private DamageResult HandleNpcAttacker(RaidableBase raid, BasePlayer victim, BasePlayer attacker, HitInfo info, DamageType damageType);
    private DamageResult HandleEntityDamage(BaseCombatEntity entity, HitInfo info, DamageType damageType, RaidableBase raid, BasePlayer attacker, bool isHuman);
    private bool ValidateEventTurretDamage(HitInfo info, RaidableBase raid, BaseCombatEntity entity);
    private void HandleHelicopterDamage(BaseCombatEntity entity, HitInfo info);
    private DamageResult HandleOwnerlessEntities(BaseCombatEntity entity, HitInfo info, RaidableBase raid, bool isHuman);
    private void ApplyMaxEffectiveRangeMultiplier(float maxEffectiveRange, float sqrProtectionRadius, Vector3 a, HitInfo info, HumanoidBrain brain);
    private void ApplyPlayerDamageMultipliers(HitInfo info, RaidableBase raid, DamageType damageType, bool isAttacker, bool isHuman);
    private void HandleSpecificEntities(BaseCombatEntity entity, HitInfo info, RaidableBase raid);
    private bool ShouldBlockDamage(BaseCombatEntity entity, HitInfo info, DamageType damageType, RaidableBase raid);
    private bool ShouldBlockDueToLoadingOrDecay(BaseCombatEntity entity, DamageType damageType, RaidableBase raid);
    private DamageResult HandleBuildingBlock(BuildingBlock block, RaidableBase raid);
    private DamageResult HandleMountable(BaseEntity entity, HitInfo info, RaidableBase raid, bool isHuman, BasePlayer attacker);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private bool ExcludedMountsExists(string prefabName);
    private void ScaleTorpedoDamage(HitInfo info, RaidableBase raid);
    private bool ValidateUnknownAttacker(HitInfo info, RaidableBase raid, BaseCombatEntity entity);
    private DamageResult HandleNonHumanAttacker(BaseCombatEntity entity, RaidableBase raid, BasePlayer attacker, HitInfo info, DamageType damageType);
    private void UpdateAttackerInfo(BaseCombatEntity entity, BasePlayer attacker, RaidableBase raid);
    private DamageResult HandleEcoAndMountDamage(RaidableBase raid, BasePlayer attacker, HitInfo info);
    public bool CanBlockOutsideDamage(RaidableBase raid, BaseEntity attacker);
    private DamageResult HandleRaidAndTurretConditions(BaseCombatEntity entity, RaidableBase raid, BasePlayer attacker, HitInfo info, DamageType damageType);
    private DamageResult FinalizeRaidChecks(BaseCombatEntity entity, HitInfo info, RaidableBase raid, BasePlayer attacker, DamageType damageType);
    private readonly Dictionary<ulong, List<PlayerExclusion>> playerDelayExclusions;
    private class PlayerExclusion : Pool.IPooled
    {
        public Plugin plugin;
        public float time;
        public bool IsExpired { get; set; }
        public void EnterPool();
        public void LeavePool();
    }

    private void ExcludePlayer(ulong userid, float maxDelayLength, Plugin plugin);
    private bool HasDelayExclusion(ulong userid);
    private static void Shuffle(IList<T> list);
    public RaidableBase OpenEvent(RandomBase rb);
    private float isSpawnerBusyTime;
    private bool isSpawnerBusy;
    private bool IsLoaderBusy { get; set; }
    private bool IsSpawnerBusy { get; set; }
    private bool IsGridLoading();
    private bool IsPasteAvailable();
    private bool IsBusy();
    private bool PasteBuilding(RandomBase rb);
    private void StopLoadCoroutines();
    private bool IsPrefabFoundation(Dictionary<string, object> entity);
    private bool IsPrefabExternalWall(Dictionary<string, object> entity);
    private bool IsPrefabFloor(Dictionary<string, object> entity);
    private IEnumerator SetupCopyPasteObstructionRadius();
    private IEnumerator SetupCopyPasteObstructionRadius(string baseName, float radius);
    private readonly Dictionary<string, object> _emptyProtocol;
    private IEnumerator LoadCopyPasteFile(RandomBase rb);
    private Action CreatePastedCallback(RaidableBase raid, RandomBase rb);
    private Action<BaseEntity> CreateSpawnCallback(RaidableBase raid);
    private IEnumerator ApplyStartPositionAdjustment(RandomBase rb, DynamicConfigFile data);
    private IEnumerator TryApplyAutoHeight(RandomBase rb, HashSet<Dictionary<string, object>> preloadData);
    private void TryApplyCustomAutoHeight(RandomBase rb);
    private void TryApplyMultiFoundationSupport(RandomBase rb);
    [HookMethod("GetSpawnHeight")]
    public float GetSpawnHeight(Vector3 a, bool flag, bool shouldSkipSmallRock);
    private void ParseListedOptions(RandomBase rb);
    private bool SpawnRandomBase(RaidableType type, string baseName, bool isAdmin, BasePlayer owner, IPlayer user, bool free);
    private bool AddSpawnToQueue(string key, BaseProfile profile, bool checkTerrain, RaidableType type, RaidableSpawns spawns, BasePlayer owner, IPlayer user, Vector3 point);
    private string GetDebugMessage(bool validProfile, bool isAdmin, string id, string baseName, BuildingOptions options);
    public RaidableSpawns GetSpawns(RaidableType type, BaseProfile profile, bool checkTerrain);
    public (string, BaseProfile) GetBuilding(RaidableType type, string mode, string baseName, BasePlayer player);
    private static bool IsProfileValid(string key, BaseProfile profile);
    private bool FileExists(string file);
    private void CommandReloadConfig(IPlayer user, string command, string[] args);
    private void Initialize();
    private void CommandBlockRaids(BasePlayer player, string command, string[] args);
    private void CommandRaidHunter(IPlayer user, string command, string[] args);
    private bool CanBypassLock(RaidableBase raid, BasePlayer player);
    private void CommandInvite(IPlayer user, BasePlayer player, string[] args);
    protected void DrawRaidLocations(BasePlayer player, bool hasPerm);
    protected void ShowNextScheduledEvent(IPlayer user);
    protected void ShowLadder(IPlayer user, string[] args);
    protected List<KeyValuePair<string, int>> GetLadder(string arg);
    private void NotifyPlayer(IPlayer user, int rank, KeyValuePair<string, int> kvp);
    private bool IsRaidableMode(string value);
    private bool Get(string baseName, (string, BaseProfile) val);
    protected void ShowGrid(BasePlayer player, bool showAll);
    private static void ShowSpawns(BasePlayer player, RaidableSpawns spawns, bool showAll, float distance);
    private void CommandRaidBase(IPlayer user, string command, string[] args);
    protected void ProcessEventCommand(IPlayer user, BasePlayer player, bool isAllowed, string[] args);
    protected void ProcessConsoleCommand(IPlayer user, BasePlayer player, bool isAllowed, string[] args);
    private bool CanCommandContinue(BasePlayer player, IPlayer user, bool isAllowed, string[] args);
    private bool HandledCommandArguments(BasePlayer player, IPlayer user, bool isAllowed, string[] args);
    private void DrawSpheres(BasePlayer player, bool isAllowed);
    private bool IsScheduledReload;
    private void CommandToggle(IPlayer user, string command, string[] args);
    private void CommandPopulate(IPlayer user, string command, string[] args);
    private void AddToList(string mode, List<LootItem> source);
    private void CommandToggleProfile(IPlayer user, string command, string[] args);
    private void CommandStability(IPlayer user, string command, string[] args);
    private void CommandConfig(IPlayer user, string command, string[] args);
    public void RemoveHeldEntities();
    public void DespawnAll(bool inactiveOnly);
    private void KillEntity(BaseEntity entity, UndoLoopSettings us);
    private DroppedItemContainer DropLoot(BaseEntity ent, ItemContainer container, bool buoyant);
    private UndoLoopSettings UndoSettings;
    private UndoLoopComparer UndoComparer;
    public class UndoLoopSettings
    {
        public bool LogToFile;
        public bool DespawnMounts;
        public bool KeepStructures;
        public bool KeepDeployables;
        public UndoLoopSettings();
        public UndoLoopSettings(ManagementSettings ms, bool logToFile);
    }

    public class UndoLoopComparer : IComparer<BaseNetworkable>
    {
        public Dictionary<string, ItemDefinition> DeployableItems;
        public Func<BaseEntity, bool, bool> IsBox;
        private int Evaluate(BaseNetworkable entity);
        public int Compare(BaseNetworkable x, BaseNetworkable y);
    }

    public void UndoLoop(List<BaseEntity> entities, int limit, object[] hookObjects);
    private IEnumerator UndoLoopCo(List<BaseEntity> entities, int limit, object[] hookObjects);
    private class CustomPatrol
    {
        public string pluginName;
        public Vector3 position;
        public PositionSetting settingPosition;
        public DroneSetting settingDrone;
        internal class DroneSetting
        {
            public int droneCountSpawned;
            public int droneAttackedCount;
            public Dictionary<string, int> keyDrones;
        }

        internal class PositionSetting
        {
            public int countSpawnPoint;
            public int radiusFindedPoints;
        }

    }

    public static PooledList<T> DisposableList();
    public static bool IsCustomEntity(BaseEntity m);
    private static void SafelyKill(BaseEntity entity);
    private void RegisterPermissions();
    public void LoadPlayerData();
    private void SaveData();
    public void SavePlayerData();
    private string GetPlayerData();
    internal void StartEntityCleanup();
    private void UnsetStatics();
    private bool CheckForWipe(bool revoke);
    private bool IsPocketDimensions(BasePlayer player, BaseEntity e);
    private static float GetObstructionRadius(BuildingOptionsProtectionRadius radii, RaidableType type);
    public PasteData GetPasteData(string baseName);
    private bool IsEventOwner(BasePlayer player, bool isLoading);
    private bool Has(NetworkableId networkableId);
    private bool Has(TriggerBase trigger);
    private bool Has(BasePlayer player);
    private bool Has(BaseEntity entity, bool checkList);
    public int Get(RaidableType type);
    private bool HasLimit(RaidableType type);
    public bool Get(ulong userID, HumanoidBrain brain);
    public bool Get(Vector3 target, RaidableBase raid, float f, bool b);
    public bool Get(BasePlayer victim, HitInfo info, RaidableBase raid);
    public bool Get(BaseEntity entity, ulong playerSteamID, RaidableBase raid);
    public bool Get(BaseEntity entity, RaidableBase raid);
    public bool IsTooClose(Vector3 target, float radius);
    private static void DrawText(BasePlayer player, float duration, Color color, Vector3 from, object text);
    private static void DrawLine(BasePlayer player, float duration, Color color, Vector3 from, Vector3 to);
    private static void DrawSphere(BasePlayer player, float duration, Color color, Vector3 from, float radius);
    private static bool IsKilled(StorageContainer container);
    private static bool IsKilled(Item item);
    private static bool IsKilled(BaseEntity entity);
    internal void DestroyProtection();
    internal ProtectionProperties GetElevatorProtection();
    internal ProtectionProperties GetTurretProtection();
    public void UpdateAllMarkers();
    private bool IsBusy(Vector3 pastedLocation);
    public static void TryInvokeMethod(Action action);
    private bool IsKillableEntity(BaseEntity entity);
    private static PooledList<T> FindEntitiesOfType(Vector3 a, float n, int m, QueryTriggerInteraction queryTrigger);
    private void CheckOceanLevel();
    private void SetOnSun(bool state, int retries);
    public void InitializeSkins();
    public static void AdminCommand(BasePlayer player, Action action);
    private HashSet<ulong> GetMembers(ulong userid);
    private uint heli_napalm;
    private uint oilfireballsmall;
    private uint rocket_heli;
    private uint rocket_heli_napalm;
    private void BuildPrefabIds();
    private bool IsHelicopter(HitInfo info, bool eventHeli);
    private Plugin CopyPaste { get; set; }
    public bool IsCopyPasteLoaded(string error);
    private bool PlayerInEvent(BasePlayer player);
    private bool PlayerInEventPVE(BasePlayer player);
    private bool PlayerInEventPVP(BasePlayer player);
    private float GetPVPDelay(ulong userid);
    private bool GetPVPDelay(ulong userid, bool check, DelaySettings ds);
    private float GetMaxPVPDelay();
    [HookMethod("HasPVPDelay")]
    public bool HasPVPDelay(ulong userid);
    private void RemovePVPDelay(ulong userid, DelaySettings ds);
    private bool IsBox(BaseEntity entity, bool inherit);
    public float GetDistance(RaidableType type);
    private bool IsPVE();
    [HookMethod("IsPremium")]
    public bool IsPremium();
    private static bool NullifyDamage(HitInfo info);
    public bool MustExclude(RaidableType type, bool allowPVP);
    private bool AnyNpcs();
    private string[] GetProfileFiles();
    private string[] GetCopyPasteFiles();
    private bool CheckAutoCorrect(IPlayer user, string file, string value);
    private static string GetFileNameWithoutExtension(string file);
    private void ConfigAddBase(IPlayer user, string[] args);
    private void ConfigRemoveBase(IPlayer user, string[] args);
    private void ConfigCheckFrames(IPlayer user);
    private void ConfigListBases(IPlayer user);
    private bool TryRemoveItems(BaseEntity entity);
    private void DropOrRemoveItems(StorageContainer container, RaidableBase raid, bool forced, bool kill);
    protected bool DespawnBase(BasePlayer player);
    private RaidableBase GetNearestBase(Vector3 target, float radius);
    private bool IsTrueDamage(BaseEntity entity, bool isProtectedWeapon);
    private Vector3 GetCenterLocation(Vector3 position);
    private bool HasEventEntity(BaseEntity entity);
    [HookMethod("GetAllEvents")]
    public List<(Vector3 pos, int mode, bool allowPVP, string a, float b, float c, float loadTime, ulong ownerId, BasePlayer owner, List<BasePlayer> raiders, List<BasePlayer> intruders, HashSet<BaseEntity> entities, string baseName, DateTime spawnDateTime, DateTime despawnDateTime, float radius, int lootRemaining)> GetAllEvents(Vector3 position, float x);
    [HookMethod("EventTerritory")]
    public bool EventTerritory(Vector3 position, float x);
    [HookMethod("EventTerritoryAny")]
    public bool EventTerritoryAny(Vector3[] positions, float x);
    [HookMethod("EventTerritoryAll")]
    public bool EventTerritoryAll(Vector3[] positions, float x);
    [HookMethod("GetPlayersFrom")]
    public List<BasePlayer> GetPlayersFrom(Vector3 position, float x, bool intruders);
    [HookMethod("GetOwnerFrom")]
    public BasePlayer GetOwnerFrom(Vector3 position, float x);
    public static bool InRange2D(Vector3 a, Vector3 b, float distance);
    public static bool InRange(Vector3 a, Vector3 b, float distance);
    private void RevokePermissionsAndGroups(IEnumerable<string> revokes);
    private bool AssignTreasureHunters();
    private bool IsNormalUser(string userid);
    private void AssignTreasureHunters(List<KeyValuePair<string, PlayerInfo>> players);
    private bool CanContinueAutomation();
    private static bool IsModeValid(string mode);
    public string PositionToGrid(Vector3 v);
    public string FormatGridReference(BasePlayer player, Vector3 v);
    private string GetDirection(BasePlayer player, Vector3 target);
    private string FormatTime(double seconds, string id);
    private List<string> profileErrors;
    private bool AnyCopyPasteFileExists;
    private Exception exConf;
    protected void SaveProfile(string key, BuildingOptions options);
    private void LoadTable(string mode, DisposableBuilder _sb, string file, List<LootItem> lootList);
    private List<string> BlacklistedItems;
    private bool GetTable(string file, List<LootItem> lootList);
    private bool isDefaultMessagesLoaded;
    protected override void LoadDefaultMessages();
    public void TryMessage(BasePlayer player, string key, object[] args);
    public void Message(BasePlayer player, string key, object[] args);
    public void Message(IPlayer user, string key, object[] args);
    private void CheckNotifications();
    private void QueueNotification(IPlayer user, string key, object[] args);
    private void QueueNotification(BasePlayer player, string key, object[] args);
    private void SendNotification(Notification notification);
    public string m(string key, string id, object[] args);
    public string mx(string key, string id, object[] args);
    public static Regex HtmlTagRegex;
    public static string rf(string source);
    public class Notification : Pool.IPooled
    {
        public BasePlayer player;
        public string messageEx;
        public void Reset();
        public void EnterPool();
        public void LeavePool();
    }

    private Dictionary<ulong, List<Notification>> _notifications;
    private List<ulong> waiting;
    protected static void Puts(Exception ex);
    protected new static void Puts(string format, object[] args);
    private bool ProfilesExists();
    private void CreateDefaultFiles();
    protected void VerifyProfiles();
    private IEnumerator ReloadProfiles(IPlayer user);
    protected IEnumerator LoadProfiles(DisposableBuilder _sb, IPlayer user);
    private bool BuoyantBox;
    private IEnumerator ReloadTables(IPlayer user);
    private void LoadImportedSkins();
    public class SkinsPlugin
    {
        [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<SkinItem> Skins;
    }

    public class SkinItem
    {
        [JsonProperty(PropertyName = "Item Shortname")]
        public string Shortname;
        [JsonProperty(PropertyName = "Permission")]
        public string Permission;
        [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> Skins;
    }

    protected IEnumerator LoadTables(DisposableBuilder _sb);
    public List<LootItem> BaseLootList;
    protected IEnumerator LoadBaseTables(DisposableBuilder _sb, IPlayer user);
    private void LoadTable(DisposableBuilder _sb, string file, List<LootItem> lootList);
    private List<LootItem> GetTable(string file);
    private Configuration config;
    private static Dictionary<string, List<ulong>> DefaultImportedSkins { get; set; }
    private static List<PasteOption> DefaultPasteOptions { get; set; }
    private static Dictionary<string, BuildingOptions> DefaultBuildingOptions { get; set; }
    private static List<LootItem> DefaultLoot { get; set; }
    public class Color1Settings
    {
        [JsonProperty(PropertyName = "Normal")]
        public string Normal;
        public string Get();
    }

    public class Color2Settings
    {
        [JsonProperty(PropertyName = "Normal")]
        public string Normal;
        public string Get();
    }

    public class ManagementMountableSettings
    {
        [JsonProperty(PropertyName = "All Controlled Mounts")]
        public bool ControlledMounts;
        [JsonProperty(PropertyName = "All Other Mounts")]
        public bool Other;
        [JsonProperty(PropertyName = "Attack Helicopters")]
        public bool AttackHelicopters;
        [JsonProperty(PropertyName = "Bikes")]
        public bool Bikes;
        [JsonProperty(PropertyName = "Boats")]
        public bool Boats;
        [JsonProperty(PropertyName = "Campers")]
        public bool Campers;
        [JsonProperty(PropertyName = "Cars (Basic)")]
        public bool BasicCars;
        [JsonProperty(PropertyName = "Cars (Modular)")]
        public bool ModularCars;
        [JsonProperty(PropertyName = "Chinook")]
        public bool CH47;
        [JsonProperty(PropertyName = "Flying Carpet")]
        public bool FlyingCarpet;
        [JsonProperty(PropertyName = "Horses")]
        public bool Horses;
        [JsonProperty(PropertyName = "HotAirBalloon")]
        public bool HotAirBalloon;
        [JsonProperty(PropertyName = "Invisible Chair")]
        public bool Invisible;
        [JsonProperty(PropertyName = "Jetpacks")]
        public bool Jetpacks;
        [JsonProperty(PropertyName = "MiniCopters")]
        public bool MiniCopters;
        [JsonProperty(PropertyName = "Parachutes")]
        public bool Parachutes;
        [JsonProperty(PropertyName = "Pianos")]
        public bool Pianos;
        [JsonProperty(PropertyName = "Scrap Transport Helicopters")]
        public bool Scrap;
        [JsonProperty(PropertyName = "Siege")]
        public bool Siege;
        [JsonProperty(PropertyName = "Snowmobiles")]
        public bool Snowmobile;
        [JsonProperty(PropertyName = "Tugboats")]
        public bool Tugboats;
    }

    public class BuildingOptionsSetupSettings
    {
        [JsonProperty(PropertyName = "Amount Of Entities To Spawn Per Batch")]
        public int SpawnLimit;
        [JsonProperty(PropertyName = "Amount Of Entities To Despawn Per Batch")]
        public int DespawnLimit;
        [JsonProperty(PropertyName = "Height Adjustment Applied To This Paste")]
        public float PasteHeightAdjustment;
        [JsonProperty(PropertyName = "Force All Bases To Spawn At Height Level (0 = Water)")]
        public float ForcedHeight;
        [JsonProperty(PropertyName = "Foundations Immune To Damage When Forced Height Is Applied")]
        public bool FoundationsImmuneForcedHeight;
        [JsonProperty(PropertyName = "Foundations Immune To Damage")]
        public bool FoundationsImmune;
        [JsonProperty(PropertyName = "Kill These Prefabs After Paste", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlockedPrefabs;
    }

    public class ManagementPlayerAmountsSettings
    {
        [JsonProperty(PropertyName = "Maintained Events")]
        public int Maintained;
        [JsonProperty(PropertyName = "Manual Events")]
        public int Manual;
        [JsonProperty(PropertyName = "Scheduled Events")]
        public int Scheduled;
        [JsonProperty(PropertyName = "Bypass For PVP Bases")]
        public bool BypassPVP;
        public int Get(RaidableType type);
    }

    public class ManagementDropSettings
    {
        [JsonProperty(PropertyName = "Auto Turrets")]
        public bool AutoTurret;
        [JsonProperty(PropertyName = "Flame Turret")]
        public bool FlameTurret;
        [JsonProperty(PropertyName = "Fog Machine")]
        public bool FogMachine;
        [JsonProperty(PropertyName = "Gun Trap")]
        public bool GunTrap;
        [JsonProperty(PropertyName = "SAM Site")]
        public bool SamSite;
    }

    public class ManagementSettingsLocations
    {
        [JsonProperty(PropertyName = "position")]
        public string _position;
        public float radius;
        public ManagementSettingsLocations();
        public ManagementSettingsLocations(Vector3 position, float radius);
        [JsonIgnore]
        public Vector3 position { get; set; }
    }

    public class ManagementSettings
    {
        [JsonProperty(PropertyName = "Grids To Block Spawns At", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlockedGrids;
        [JsonProperty(PropertyName = "Block Spawns At Positions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ManagementSettingsLocations> BlockedPositions;
        [JsonProperty(PropertyName = "Blocked Monument Markers (* = everything)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlockedMonumentMarkers;
        [JsonProperty(PropertyName = "Additional Map Prefabs To Block Spawns At", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, float> BlockedPrefabs;
        [JsonProperty(PropertyName = "Eject Mounts")]
        public ManagementMountableSettings Mounts;
        [JsonProperty(PropertyName = "Max Amount Of Players Allowed To Enter (0 = infinite, -1 = none)")]
        public ManagementPlayerAmountsSettings Players;
        [JsonProperty(PropertyName = "Additional Containers To Include As Boxes", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Inherit;
        [JsonProperty(PropertyName = "Difficulty Colors (Border)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Color1Settings Colors1;
        [JsonProperty(PropertyName = "Difficulty Colors (Inner)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Color2Settings Colors2;
        [JsonProperty(PropertyName = "Entities Allowed To Drop Loot")]
        public ManagementDropSettings DropLoot;
        [JsonProperty(PropertyName = "Additional Blocked Colliders", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> AdditionalBlockedColliders;
        [JsonProperty(PropertyName = "Allow Teleport")]
        public bool AllowTeleport;
        [JsonProperty(PropertyName = "Allow Teleport Ignores Respawning")]
        public bool AllowRespawn;
        [JsonProperty(PropertyName = "Allow Cupboard Loot To Drop")]
        public bool AllowCupboardLoot;
        [JsonProperty(PropertyName = "Allow Players To Build", NullValueHandling = NullValueHandling.Ignore)]
        public bool? _AllowBuilding;
        [JsonProperty(PropertyName = "Allow Players To Use Ladders")]
        public bool AllowLadders;
        [JsonProperty(PropertyName = "Allow Players To Upgrade Event Buildings")]
        public bool AllowUpgrade;
        [JsonProperty(PropertyName = "Allow Player Bags To Be Lootable At PVP Bases")]
        public bool PlayersLootableInPVP;
        [JsonProperty(PropertyName = "Allow Player Bags To Be Lootable At PVE Bases")]
        public bool PlayersLootableInPVE;
        [JsonProperty(PropertyName = "Allow Players To Loot Traps")]
        public bool LootableTraps;
        [JsonProperty(PropertyName = "Allow Npcs To Target Other Npcs")]
        public bool TargetNpcs;
        [JsonProperty(PropertyName = "Allow Raid Bases Inland")]
        public bool AllowInland;
        [JsonProperty(PropertyName = "Allow Raid Bases On Beaches")]
        public bool AllowOnBeach;
        [JsonProperty(PropertyName = "Allow Raid Bases On Ice Sheets")]
        public bool AllowOnIceSheets;
        [JsonProperty(PropertyName = "Allow Raid Bases On Roads")]
        public bool AllowOnRoads;
        [JsonProperty(PropertyName = "Allow Raid Bases On Rivers")]
        public bool AllowOnRivers;
        [JsonProperty(PropertyName = "Allow Raid Bases On Railroads")]
        public bool AllowOnRailroads;
        [JsonProperty(PropertyName = "Allow Raid Bases On Building Topology")]
        public bool AllowOnBuildingTopology;
        [JsonProperty(PropertyName = "Allow Raid Bases On Monument Topology")]
        public bool AllowOnMonumentTopology;
        [JsonProperty(PropertyName = "Amount Of Spawn Position Checks Per Frame (ADVANCED USERS ONLY)")]
        public int SpawnChecks;
        [JsonProperty(PropertyName = "Allow Vending Machines To Broadcast")]
        public bool AllowBroadcasting;
        [JsonProperty(PropertyName = "Backpacks Can Be Opened At PVE Bases")]
        public bool BackpacksOpenPVE;
        [JsonProperty(PropertyName = "Backpacks Can Be Opened At PVP Bases")]
        public bool BackpacksOpenPVP;
        [JsonProperty(PropertyName = "Rust Backpacks Drop At PVE Bases")]
        public bool RustBackpacksPVE;
        [JsonProperty(PropertyName = "Rust Backpacks Drop At PVP Bases")]
        public bool RustBackpacksPVP;
        [JsonProperty(PropertyName = "Backpacks Drop At PVE Bases")]
        public bool BackpacksPVE;
        [JsonProperty(PropertyName = "Backpacks Drop At PVP Bases")]
        public bool BackpacksPVP;
        [JsonProperty(PropertyName = "Block Custom Loot Plugin")]
        public bool BlockCustomLootNPC;
        [JsonProperty(PropertyName = "Block Npc Kits Plugin")]
        public bool BlockNpcKits;
        [JsonProperty(PropertyName = "Block Helicopter Damage To Bases")]
        public bool BlockHelicopterDamage;
        [JsonProperty(PropertyName = "Block Mounted Damage To Bases And Players")]
        public bool BlockMounts;
        [JsonProperty(PropertyName = "Block Mini Collision Damage")]
        public bool MiniCollision;
        [JsonProperty(PropertyName = "Block DoubleJump Plugin")]
        public bool NoDoubleJump;
        [JsonProperty(PropertyName = "Block RestoreUponDeath Plugin For PVP Bases")]
        public bool BlockRestorePVP;
        [JsonProperty(PropertyName = "Block RestoreUponDeath Plugin For PVE Bases")]
        public bool BlockRestorePVE;
        [JsonProperty(PropertyName = "Block LifeSupport Plugin")]
        public bool NoLifeSupport;
        [JsonProperty(PropertyName = "Block Rewards During Server Restart")]
        public bool Restart;
        [JsonProperty(PropertyName = "Bypass Lock Treasure To First Attacker For PVE Bases")]
        public bool BypassUseOwnersForPVE;
        [JsonProperty(PropertyName = "Bypass Lock Treasure To First Attacker For PVP Bases")]
        public bool BypassUseOwnersForPVP;
        [JsonProperty(PropertyName = "Despawn Spawned Mounts")]
        public bool DespawnMounts;
        [JsonProperty(PropertyName = "Do Not Destroy Player Built Deployables")]
        public bool KeepDeployables;
        [JsonProperty(PropertyName = "Do Not Destroy Player Built Structures")]
        public bool KeepStructures;
        [JsonProperty(PropertyName = "Distance To Spawn From Center Of Map")]
        public float Vector3ZeroDistance;
        [JsonProperty(PropertyName = "Divide Rewards Among All Raiders")]
        public bool DivideRewards;
        [JsonProperty(PropertyName = "Draw Corpse Time (Seconds)")]
        public float DrawTime;
        [JsonProperty(PropertyName = "Destroy Boxes Clipped Too Far Into Terrain")]
        public bool ClippedBoxes;
        [JsonProperty(PropertyName = "Destroy Turrets Clipped Too Far Into Terrain")]
        public bool ClippedTurrets;
        [JsonProperty(PropertyName = "Eject Sleepers Before Spawning Base")]
        public bool EjectSleepers;
        [JsonProperty(PropertyName = "Eject Scavengers When Raid Is Completed")]
        public bool EjectScavengers;
        [JsonProperty(PropertyName = "Eject Mountables Before Spawning A Base")]
        public bool EjectMountables;
        [JsonProperty(PropertyName = "Kill Deployables Before Spawning A Base")]
        public bool KillDeployables;
        [JsonProperty(PropertyName = "Eject Deployables Before Spawning A Base")]
        public bool EjectDeployables;
        [JsonProperty(PropertyName = "Extra Distance To Spawn From Monuments")]
        public float MonumentDistance;
        [JsonProperty(PropertyName = "Move Cookables Into Ovens")]
        public bool Cook;
        [JsonProperty(PropertyName = "Move Food Into BBQ Or Fridge")]
        public bool Food;
        [JsonProperty(PropertyName = "Blacklist For BBQ And Fridge", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public HashSet<string> Foods;
        [JsonProperty(PropertyName = "Move Weapons Onto Weapon Racks")]
        public bool Racks;
        [JsonProperty(PropertyName = "Move Resources Into Tool Cupboard")]
        public bool Cupboard;
        [JsonProperty(PropertyName = "Move Items Into Lockers")]
        public bool Lockers;
        [JsonProperty(PropertyName = "Divide Locker Loot When Enabled")]
        public bool DivideLockerLoot;
        [JsonProperty(PropertyName = "Lock Treasure To First Attacker")]
        public bool UseOwners;
        [JsonProperty(PropertyName = "Lock Treasure Max Inactive Time (Minutes)")]
        public float LockTime;
        [JsonProperty(PropertyName = "Lock Players To Raid Base After Entering Zone")]
        public bool LockToRaidOnEnter;
        [JsonProperty(PropertyName = "Only Award First Attacker and Allies")]
        public bool OnlyAwardAllies;
        [JsonProperty(PropertyName = "Only Award Owner Of Raid")]
        public bool OnlyAwardOwner;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Looting (min: 1)")]
        public int DespawnMinutes;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Looting Resets When Damaged")]
        public bool DespawnMinutesReset;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive (0 = disabled)")]
        public int DespawnMinutesInactive;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive Resets When Damaged")]
        public bool DespawnMinutesInactiveReset;
        [JsonProperty(PropertyName = "Mounts Can Take Damage From Players")]
        public bool MountDamageFromPlayers;
        [JsonProperty(PropertyName = "Player Cupboard Detection Radius")]
        public float CupboardDetectionRadius;
        [JsonProperty(PropertyName = "PVP Delay Triggers When Entity Destroyed From Outside Zone")]
        public bool PVPDelayTrigger;
        [JsonProperty(PropertyName = "Players With PVP Delay Can Damage Anything Inside Zone")]
        public bool PVPDelayDamageInside;
        [JsonProperty(PropertyName = "Players With PVP Delay Can Damage Other Players With PVP Delay Anywhere")]
        public bool PVPDelayAnywhere;
        [JsonProperty(PropertyName = "PVP Delay Between Zone Hopping")]
        public float PVPDelay;
        [JsonProperty(PropertyName = "PVP Delay Between Zone Hopping Persists After Despawn")]
        public bool PVPDelayPersists;
        [JsonProperty(PropertyName = "Prevent Fire From Spreading")]
        public bool PreventFireFromSpreading;
        [JsonProperty(PropertyName = "Prevent Players From Hogging Raids")]
        public bool PreventHogging;
        [JsonProperty(PropertyName = "Block Clans From Owning More Than One Raid")]
        public bool BlockClans;
        [JsonProperty(PropertyName = "Block Friends From Owning More Than One Raid")]
        public bool BlockFriends;
        [JsonProperty(PropertyName = "Block Teams From Owning More Than One Raid")]
        public bool BlockTeams;
        [JsonProperty(PropertyName = "Block Players From Joining A Clan/Team To Exploit Restrictions")]
        public bool AllyExploit;
        [JsonProperty(PropertyName = "Prevent Fall Damage When Base Despawns")]
        public bool PreventFallDamage;
        [JsonProperty(PropertyName = "Require Cupboard To Be Looted Before Despawning", NullValueHandling = NullValueHandling.Ignore)]
        public bool? _RequireCupboardLooted;
        [JsonProperty(PropertyName = "Require Cupboard To Be Looted Before Completion")]
        public bool RequireCupboardLooted;
        [JsonProperty(PropertyName = "Destroying The Cupboard Completes The Raid")]
        public bool EndWhenCupboardIsDestroyed;
        [JsonProperty(PropertyName = "Require All Bases To Spawn Before Respawning An Existing Base")]
        public bool RequireAllSpawned;
        [JsonProperty(PropertyName = "Turn Lights On At Night")]
        public bool Lights;
        [JsonProperty(PropertyName = "Turn Lights On Indefinitely")]
        public bool AlwaysLights;
        [JsonProperty(PropertyName = "Ignore List For Turn Lights On", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> IgnoredLights;
        [JsonProperty(PropertyName = "Traps And Turrets Ignore Users Using NOCLIP")]
        public bool IgnoreFlying;
        [JsonProperty(PropertyName = "Use Random Codes On Code Locks")]
        public bool RandomCodes;
        [JsonProperty(PropertyName = "Wait To Start Despawn Timer When Base Takes Damage From Player")]
        public bool Engaged;
        [JsonProperty(PropertyName = "Wait To Start Despawn Timer Until Npc Is Killed By Player")]
        public bool EngagedNpc;
        [JsonProperty(PropertyName = "Maximum Water Depth For All Npcs")]
        public float WaterDepth;
        public bool IsBlocking();
    }

    public class ProfileDespawnOptions
    {
        [JsonProperty(PropertyName = "Override Global Config With These Options For This Profile")]
        public bool OverrideConfig;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Looting (min: 1)")]
        public int DespawnMinutes;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Looting Resets When Damaged")]
        public bool DespawnMinutesReset;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive (0 = disabled)")]
        public int DespawnMinutesInactive;
        [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive Resets When Damaged")]
        public bool DespawnMinutesInactiveReset;
        [JsonProperty(PropertyName = "Wait To Start Despawn Timer When Base Takes Damage From Player")]
        public bool Engaged;
        [JsonProperty(PropertyName = "Wait To Start Despawn Timer Until Npc Is Killed By Player")]
        public bool EngagedNpc;
    }

    public class PluginSettingsMapMarkers
    {
        [JsonProperty(PropertyName = "Marker Name")]
        public string MarkerName;
        [JsonProperty(PropertyName = "Radius")]
        public float Radius;
        [JsonProperty(PropertyName = "Radius (Map Size 3600 Or Less)")]
        public float SubRadius;
        [JsonProperty(PropertyName = "Use Vending Map Marker")]
        public bool UseVendingMarker;
        [JsonProperty(PropertyName = "Show Owners Name on Map Marker")]
        public bool ShowOwnersName;
        [JsonProperty(PropertyName = "Use Explosion Map Marker")]
        public bool UseExplosionMarker;
        [JsonProperty(PropertyName = "Create Markers For Maintained Events")]
        public bool Maintained;
        [JsonProperty(PropertyName = "Create Markers For Scheduled Events")]
        public bool Scheduled;
        [JsonProperty(PropertyName = "Create Markers For Manual Events")]
        public bool Manual;
    }

    public class ExperimentalSettings
    {
        [JsonProperty(PropertyName = "Apply Custom Auto Height To", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> AutoHeight;
        [JsonProperty(PropertyName = "Bunker Bases Or Profiles", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Bunker;
        [JsonProperty(PropertyName = "Multi Foundation Bases Or Profiles", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> MultiFoundation;
        public bool Contains(Type type, RandomBase rb);
    }

    public class WipeSettings
    {
        [JsonProperty(PropertyName = "Wipe triggers when Rust protocol changes")]
        public bool Protocol;
        [JsonProperty(PropertyName = "Wipe triggers on detection of map wipe")]
        public bool Map;
        [JsonProperty(PropertyName = "Wipe includes current data")]
        public bool Current;
        [JsonProperty(PropertyName = "Wipe includes lifetime data (NOT recommended!)")]
        public bool Lifetime;
        [JsonProperty(PropertyName = "Manual wipe (command: rb wipe) revokes below permissions and groups from players")]
        public bool RemoveFromList;
        [JsonProperty(PropertyName = "Permissions and groups to revoke on wipe (command: rb revokepg)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Remove;
    }

    public class PluginSettings
    {
        [JsonProperty(PropertyName = "Wipe Management (/data/RaidableBases.json)")]
        public WipeSettings Wipe;
        [JsonProperty(PropertyName = "Experimental [* = everything]")]
        public ExperimentalSettings Experimental;
        [JsonProperty(PropertyName = "Raid Management")]
        public ManagementSettings Management;
        [JsonProperty(PropertyName = "Map Markers")]
        public PluginSettingsMapMarkers Markers;
        [JsonProperty(PropertyName = "Maintained Events")]
        public RaidableBaseSettingsMaintained Maintained;
        [JsonProperty(PropertyName = "Manual Events")]
        public RaidableBaseSettingsManual Manual;
        [JsonProperty(PropertyName = "Scheduled Events")]
        public RaidableBaseSettingsScheduled Schedule;
        [JsonProperty(PropertyName = "Allowed Zone Manager Zones", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Inclusions;
        [JsonProperty(PropertyName = "Use Grid Locations In Allowed Zone Manager Zones Only")]
        public bool UseZoneManagerOnly;
        [JsonProperty(PropertyName = "Extended Distance To Spawn Away From Zone Manager Zones")]
        public float ZoneDistance;
        [JsonProperty(PropertyName = "Blacklisted Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlacklistedCommands;
        [JsonProperty(PropertyName = "Automatically Teleport Admins To Their Map Marker Positions")]
        public bool TeleportMarker;
        [JsonProperty(PropertyName = "Automatically Destroy Markers That Admins Teleport To")]
        public bool DestroyMarker;
        [JsonProperty(PropertyName = "Block Archery Plugin At Events")]
        public bool NoArchery;
        [JsonProperty(PropertyName = "Block Wizardry Plugin At Events")]
        public bool NoWizardry;
        [JsonProperty(PropertyName = "Block Weapons From Use", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlockedWeapons;
        [JsonProperty(PropertyName = "Chat Steam64ID")]
        public ulong ChatID;
        [JsonProperty(PropertyName = "Expansion Mode (Dangerous Treasures)")]
        public bool ExpansionMode;
        [JsonProperty(PropertyName = "Remove Admins From Raiders List")]
        public bool RemoveAdminRaiders;
        [JsonProperty(PropertyName = "Show X Z Coordinates")]
        public bool ShowXZ;
        [JsonProperty(PropertyName = "Show Grid Coordinates")]
        public bool ShowGrid;
        [JsonProperty(PropertyName = "Show Direction To Coordinates")]
        public bool ShowDir;
        [JsonProperty(PropertyName = "Event Command")]
        public string EventCommand;
        [JsonProperty(PropertyName = "Hunter Command")]
        public string HunterCommand;
        [JsonProperty(PropertyName = "Server Console Command")]
        public string ConsoleCommand;
    }

    public class EventMessageRewardSettings
    {
        [JsonProperty(PropertyName = "Flying")]
        public bool Flying;
        [JsonProperty(PropertyName = "Vanished")]
        public bool Vanished;
        [JsonProperty(PropertyName = "Inactive")]
        public bool Inactive;
        [JsonProperty(PropertyName = "Not An Ally")]
        public bool NotAlly;
        [JsonProperty(PropertyName = "Not The Owner")]
        public bool NotOwner;
        [JsonProperty(PropertyName = "Not A Participant")]
        public bool NotParticipant;
        [JsonProperty(PropertyName = "Remove Admins From Raiders List")]
        public bool RemoveAdmin;
    }

    public class EventMessageSettings
    {
        [JsonProperty(PropertyName = "Show Message For Block Damage Outside Of The Dome To Players Inside")]
        public bool NoDamageFromOutsideToPlayersInside;
        [JsonProperty(PropertyName = "Ineligible For Rewards")]
        public EventMessageRewardSettings Rewards;
        [JsonProperty(PropertyName = "Announce Raid Unlocked")]
        public bool AnnounceRaidUnlock;
        [JsonProperty(PropertyName = "Announce Thief Message")]
        public bool AnnounceThief;
        [JsonProperty(PropertyName = "Announce PVE/PVP Enter/Exit Messages")]
        public bool AnnounceEnterExit;
        [JsonProperty(PropertyName = "Announce When Blocks Are Immune To Damage")]
        public bool BlocksImmune;
        [JsonProperty(PropertyName = "Show Destroy Warning")]
        public bool ShowWarning;
        [JsonProperty(PropertyName = "Show Opened Message For PVE Bases")]
        public bool OpenedPVE;
        [JsonProperty(PropertyName = "Show Opened Message For PVP Bases")]
        public bool OpenedPVP;
        [JsonProperty(PropertyName = "Show Prefix")]
        public bool Prefix;
        [JsonProperty(PropertyName = "Notify Plugin - Type (-1 = disabled)")]
        public int NotifyType;
        [JsonProperty(PropertyName = "Notification Interval")]
        public float Interval;
        [JsonProperty(PropertyName = "Send Messages To Player")]
        public bool Message;
        [JsonProperty(PropertyName = "Save Thieves To Log File")]
        public bool LogThieves;
    }

    public class GUIAnnouncementSettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Banner Tint Color")]
        public string TintColor;
        [JsonProperty(PropertyName = "Maximum Distance")]
        public float Distance;
        [JsonProperty(PropertyName = "Text Color")]
        public string TextColor;
    }

    public class NpcKitSettings
    {
        [JsonProperty(PropertyName = "Helm", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Helm;
        [JsonProperty(PropertyName = "Torso", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Torso;
        [JsonProperty(PropertyName = "Pants", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Pants;
        [JsonProperty(PropertyName = "Gloves", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Gloves;
        [JsonProperty(PropertyName = "Boots", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Boots;
        [JsonProperty(PropertyName = "Shirt", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Shirt;
        [JsonProperty(PropertyName = "Kilts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Kilts;
        [JsonProperty(PropertyName = "Weapon", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Weapon;
        public NpcKitSettings(bool isMurderer);
    }

    public class NpcMultiplierSettings
    {
        [JsonProperty(PropertyName = "Explosive Damage Multiplier")]
        public float ExplosiveDamageMultiplier;
        [JsonProperty(PropertyName = "Gun Damage Multiplier")]
        public float ProjectileDamageMultiplier;
        [JsonProperty(PropertyName = "Melee Damage Multiplier")]
        public float MeleeDamageMultiplier;
    }

    public class NpcSettingsAccuracyDifficulty
    {
        [JsonProperty(PropertyName = "AK47")]
        public double AK47;
        [JsonProperty(PropertyName = "AK47 ICE")]
        public double AK47ICE;
        [JsonProperty(PropertyName = "Bolt Rifle")]
        public double BOLT_RIFLE;
        [JsonProperty(PropertyName = "Compound Bow")]
        public double COMPOUND_BOW;
        [JsonProperty(PropertyName = "Crossbow")]
        public double CROSSBOW;
        [JsonProperty(PropertyName = "Double Barrel Shotgun")]
        public double DOUBLE_SHOTGUN;
        [JsonProperty(PropertyName = "Eoka")]
        public double EOKA;
        [JsonProperty(PropertyName = "Glock")]
        public double GLOCK;
        [JsonProperty(PropertyName = "HMLMG")]
        public double HMLMG;
        [JsonProperty(PropertyName = "L96")]
        public double L96;
        [JsonProperty(PropertyName = "LR300")]
        public double LR300;
        [JsonProperty(PropertyName = "M249")]
        public double M249;
        [JsonProperty(PropertyName = "M39")]
        public double M39;
        [JsonProperty(PropertyName = "M92")]
        public double M92;
        [JsonProperty(PropertyName = "MP5")]
        public double MP5;
        [JsonProperty(PropertyName = "Nailgun")]
        public double NAILGUN;
        [JsonProperty(PropertyName = "Pump Shotgun")]
        public double PUMP_SHOTGUN;
        [JsonProperty(PropertyName = "Python")]
        public double PYTHON;
        [JsonProperty(PropertyName = "Revolver")]
        public double REVOLVER;
        [JsonProperty(PropertyName = "Semi Auto Pistol")]
        public double SEMI_AUTO_PISTOL;
        [JsonProperty(PropertyName = "Semi Auto Rifle")]
        public double SEMI_AUTO_RIFLE;
        [JsonProperty(PropertyName = "Spas12")]
        public double SPAS12;
        [JsonProperty(PropertyName = "Speargun")]
        public double SPEARGUN;
        [JsonProperty(PropertyName = "SMG")]
        public double SMG;
        [JsonProperty(PropertyName = "Snowball Gun")]
        public double SNOWBALL_GUN;
        [JsonProperty(PropertyName = "Thompson")]
        public double THOMPSON;
        [JsonProperty(PropertyName = "Waterpipe Shotgun")]
        public double WATERPIPE_SHOTGUN;
        public NpcSettingsAccuracyDifficulty(double accuracy);
        public double Get(HumanoidBrain brain);
    }

    public class ScientistLootSettings
    {
        [JsonProperty(PropertyName = "Prefab ID List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> IDs;
        [JsonProperty(PropertyName = "Enabled", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public bool Enabled;
        [JsonProperty(PropertyName = "Disable All Prefab Loot Spawns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public bool None;
        public uint GetRandom(List<string> ids);
    }

    public class NpcSettings
    {
        public NpcSettings();
        public NpcSettings(double accuracy);
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Decrease Damage Linearly From Npcs With A Maximum Effective Range Of")]
        public float NpcMaxEffectiveRange;
        [JsonProperty(PropertyName = "Decrease Damage Linearly From Players With A Maximum Effective Range Of")]
        public float PlayerMaxEffectiveRange;
        [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
        public NpcSettingsAccuracyDifficulty Accuracy;
        [JsonProperty(PropertyName = "Damage Multipliers")]
        public NpcMultiplierSettings Multipliers;
        [JsonProperty(PropertyName = "Murderer Items Dropped On Death", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> MurdererDrops;
        [JsonProperty(PropertyName = "Scientist Items Dropped On Death", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> ScientistDrops;
        [JsonProperty(PropertyName = "Murderer (Items)")]
        public NpcKitSettings MurdererLoadout;
        [JsonProperty(PropertyName = "Scientist (Items)")]
        public NpcKitSettings ScientistLoadout;
        [JsonProperty(PropertyName = "Murderer Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> MurdererKits;
        [JsonProperty(PropertyName = "Scientist Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> ScientistKits;
        [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> RandomNames;
        [JsonProperty(PropertyName = "Spawn Alternate Default Scientist Loot")]
        public ScientistLootSettings AlternateScientistLoot;
        [JsonProperty(PropertyName = "Amount Of Murderers To Spawn")]
        public int SpawnAmountMurderers;
        [JsonProperty(PropertyName = "Minimum Amount Of Murderers To Spawn")]
        public int SpawnMinAmountMurderers;
        [JsonProperty(PropertyName = "Spawn Random Amount Of Murderers")]
        public bool SpawnRandomAmountMurderers;
        [JsonProperty(PropertyName = "Amount Of Scientists To Spawn")]
        public int SpawnAmountScientists;
        [JsonProperty(PropertyName = "Minimum Amount Of Scientists To Spawn")]
        public int SpawnMinAmountScientists;
        [JsonProperty(PropertyName = "Spawn Random Amount Of Scientists")]
        public bool SpawnRandomAmountScientists;
        [JsonProperty(PropertyName = "Allow Npcs To Leave Dome When Attacking")]
        public bool CanLeave;
        [JsonProperty(PropertyName = "Allow Npcs To Shoot Players Outside Of The Dome")]
        public bool CanShoot;
        [JsonProperty(PropertyName = "Aggression Range")]
        public float AggressionRange;
        [JsonProperty(PropertyName = "Block Damage Outside To Npcs When Not Allowed To Leave Dome")]
        public bool BlockOutsideDamageOnLeave;
        [JsonProperty(PropertyName = "Block Damage Outside Of The Dome To Npcs Inside")]
        public bool BlockOutsideDamageToNpcsInside;
        [JsonProperty(PropertyName = "Despawn Inventory On Death")]
        public bool DespawnInventory;
        [JsonProperty(PropertyName = "Health For Murderers (100 min, 5000 max)")]
        public float MurdererHealth;
        [JsonProperty(PropertyName = "Health For Scientists (100 min, 5000 max)")]
        public float ScientistHealth;
        [JsonProperty(PropertyName = "Kill Underwater Npcs")]
        public bool KillUnderwater;
        [JsonProperty(PropertyName = "Player Traps And Turrets Ignore Npcs")]
        public bool IgnorePlayerTrapsTurrets;
        [JsonProperty(PropertyName = "Event Traps And Turrets Ignore Npcs")]
        public bool IgnoreTrapsTurrets;
        [JsonProperty(PropertyName = "Use Dangerous Treasures NPCs")]
        public bool UseExpansionNpcs;
    }

    public class PasteOption
    {
        [JsonProperty(PropertyName = "Option")]
        public string Key;
        [JsonProperty(PropertyName = "Value")]
        public string Value;
    }

    public class BuildingLevels
    {
        [JsonProperty(PropertyName = "Level 2 - Final Death")]
        public bool Level2;
    }

    public class DoorTypes
    {
        [JsonProperty(PropertyName = "Wooden")]
        public bool Wooden;
        [JsonProperty(PropertyName = "Metal")]
        public bool Metal;
        [JsonProperty(PropertyName = "HQM")]
        public bool HQM;
        [JsonProperty(PropertyName = "Include Garage Doors")]
        public bool GarageDoor;
        public bool Any();
    }

    public class BuildingGradeLevels
    {
        [JsonProperty(PropertyName = "Wooden")]
        public bool Wooden;
        [JsonProperty(PropertyName = "Stone")]
        public bool Stone;
        [JsonProperty(PropertyName = "Metal")]
        public bool Metal;
        [JsonProperty(PropertyName = "HQM")]
        public bool HQM;
        public bool Any();
    }

    public class BuildingOptionsAutoTurrets
    {
        [JsonProperty(PropertyName = "Aim Cone")]
        public float AimCone;
        [JsonProperty(PropertyName = "Wait To Power On Until Event Starts")]
        public bool InitiateOnSpawn;
        [JsonProperty(PropertyName = "Minimum Damage Modifier")]
        public float Min;
        [JsonProperty(PropertyName = "Maximum Damage Modifier")]
        public float Max;
        [JsonProperty(PropertyName = "Start Health")]
        public float Health;
        [JsonProperty(PropertyName = "Sight Range")]
        public float SightRange;
        [JsonProperty(PropertyName = "Double Sight Range When Shot")]
        public bool AutoAdjust;
        [JsonProperty(PropertyName = "Set Hostile (False = Do Not Set Any Mode)")]
        public bool Hostile;
        [JsonProperty(PropertyName = "Requires Power Source")]
        public bool RequiresPower;
        [JsonProperty(PropertyName = "Remove Equipped Weapon")]
        public bool RemoveWeapon;
        [JsonProperty(PropertyName = "Random Weapons To Equip When Unequipped", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Shortnames;
    }

    public class BuildingOptionsProtectionRadius
    {
        [JsonProperty(PropertyName = "Maintained Events")]
        public float Maintained;
        [JsonProperty(PropertyName = "Manual Events")]
        public float Manual;
        [JsonProperty(PropertyName = "Scheduled Events")]
        public float Scheduled;
        [JsonProperty(PropertyName = "Obstruction Distance Check")]
        public float Obstruction;
        public void Set(float value);
        public float Get(RaidableType type);
        public float Max();
        public float Min();
    }

    public class BuildingWaterOptions
    {
        [JsonProperty(PropertyName = "Allow Bases To Float Above Water")]
        public bool AllowSubmerged;
        [JsonProperty(PropertyName = "Prevent Bases From Floating Above Water By Also Checking Surrounding Area")]
        public bool SubmergedAreaCheck;
        [JsonProperty(PropertyName = "Maximum Water Depth Level Used For Float Above Water Option")]
        public float WaterDepth;
        [JsonProperty(PropertyName = "Torpedo Damage Multiplier (Min)")]
        public float TorpedoMin;
        [JsonProperty(PropertyName = "Torpedo Damage Multiplier (Max)")]
        public float TorpedoMax;
        internal float OceanLevel;
    }

    public class IQDronePatrolSettings
    {
        [JsonProperty("Use drone support")]
        public bool UseDronePatrol;
        [JsonProperty("How many drones will be spawned near the base?")]
        public int droneCountSpawned;
        [JsonProperty("How many drones can attack simultaneously?")]
        public int droneAttackedCount;
        [JsonProperty("Drone presets configuration [Drone preset key from the drone config] - chance")]
        public Dictionary<String, int> keyDrones;
    }

    public class PlayerDamageMultiplier
    {
        [JsonProperty(PropertyName = "Type")]
        public string Type;
        [JsonProperty(PropertyName = "Min")]
        public float Min;
        [JsonProperty(PropertyName = "Max")]
        public float Max;
        internal float amount { get; set; }
        internal DamageType[] _damageTypes;
        internal DamageType index { get; set; }
        public PlayerDamageMultiplier();
        public PlayerDamageMultiplier(string type, float min, float max);
    }

    public class SiegeSettings
    {
        [JsonProperty(PropertyName = "Allow Siege Raiding Only")]
        public bool Only;
        [JsonProperty(PropertyName = "Damage Multiplier")]
        public float SiegeMultiplier;
        [JsonProperty(PropertyName = "Damage Multiplier (Ballista)")]
        public float BallistaMultiplier;
        [JsonProperty(PropertyName = "Damage Multiplier (Catapult)")]
        public float CatapultMultiplier;
        [JsonProperty(PropertyName = "Damage Multiplier (Ram)")]
        public float RamMultiplier;
        public void Scale(HitInfo info);
        public bool IsSiegeTool(BasePlayer attacker, HitInfo info);
        public SiegeSettings();
    }

    public class BuildingOptions
    {
        internal float GetLandLevel { get; set; }
        public BuildingOptions();
        public BuildingOptions(string[] bases);
        [JsonProperty(PropertyName = "Advanced Protection Radius")]
        public BuildingOptionsProtectionRadius ProtectionRadii;
        [JsonProperty(PropertyName = "Advanced Setup Settings")]
        public BuildingOptionsSetupSettings Setup;
        [JsonProperty(PropertyName = "Despawn Options Override")]
        public ProfileDespawnOptions DespawnOptions;
        [JsonProperty(PropertyName = "Elevators")]
        public BuildingOptionsElevators Elevators;
        [JsonProperty(PropertyName = "Entities Not Allowed To Be Picked Up", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlacklistedPickupItems;
        [JsonProperty(PropertyName = "Additional Bases For This Difficulty", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<PasteOption>> AdditionalBases;
        [JsonProperty(PropertyName = "Paste Options", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<PasteOption> PasteOptions;
        [JsonProperty(PropertyName = "Arena Walls")]
        public RaidableBaseWallOptions ArenaWalls;
        [JsonProperty(PropertyName = "NPC Levels")]
        public BuildingLevels Levels;
        [JsonProperty(PropertyName = "NPCs")]
        public NpcSettings NPC;
        [JsonProperty(PropertyName = "Rewards")]
        public RewardSettings Rewards;
        [JsonProperty(PropertyName = "Change Building Material Tier To")]
        public BuildingGradeLevels Blocks;
        [JsonProperty(PropertyName = "Change Door Type To")]
        public DoorTypes Doors;
        [JsonProperty(PropertyName = "Player Damage To Base Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<PlayerDamageMultiplier> PlayerDamageMultiplier;
        [JsonProperty(PropertyName = "Auto Turrets")]
        public BuildingOptionsAutoTurrets AutoTurret;
        [JsonProperty(PropertyName = "Player Building Restrictions")]
        public BuildingGradeLevels BuildingRestrictions;
        [JsonProperty(PropertyName = "Water Settings")]
        public BuildingWaterOptions Water;
        [JsonProperty(PropertyName = "IQDronePatrol : Setting up for spawn drones on raid bases")]
        public IQDronePatrolSettings DronePatrols;
        [JsonProperty(PropertyName = "Siege")]
        public SiegeSettings Siege;
        [JsonProperty(PropertyName = "Profile Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Maximum Land Level")]
        public float LandLevel;
        [JsonProperty(PropertyName = "Player Damage To Tool Cupboard Multiplier")]
        public float PlayerDamageMultiplierTC;
        [JsonProperty(PropertyName = "Allow Players To Use MLRS")]
        public bool MLRS;
        [JsonProperty(PropertyName = "Allow Third-Party Npc Explosive Damage To Bases")]
        public bool RaidingNpcs;
        [JsonProperty(PropertyName = "Add Code Lock To Unlocked Or KeyLocked Doors")]
        public bool CodeLockDoors;
        [JsonProperty(PropertyName = "Add Key Lock To Unlocked Or CodeLocked Doors")]
        public bool KeyLockDoors;
        [JsonProperty(PropertyName = "Add Code Lock To Tool Cupboards")]
        public bool CodeLockPrivilege;
        [JsonProperty(PropertyName = "Add Key Lock To Tool Cupboards")]
        public bool KeyLockPrivilege;
        [JsonProperty(PropertyName = "Add Code Lock To Boxes")]
        public bool CodeLockBoxes;
        [JsonProperty(PropertyName = "Add Key Lock To Boxes")]
        public bool KeyLockBoxes;
        [JsonProperty(PropertyName = "Add Code Lock To Lockers")]
        public bool CodeLockLockers;
        [JsonProperty(PropertyName = "Add Key Lock To Lockers")]
        public bool KeyLockLockers;
        [JsonProperty(PropertyName = "Close Open Doors With No Door Controller Installed")]
        public bool CloseOpenDoors;
        [JsonProperty(PropertyName = "Allow Duplicate Items")]
        public bool AllowDuplicates;
        [JsonProperty(PropertyName = "Allow Players To Pickup Deployables")]
        public bool AllowPickup;
        [JsonProperty(PropertyName = "Allow Players To Deploy A Cupboard")]
        public bool AllowBuildingPriviledges;
        [JsonProperty(PropertyName = "Allow Players To Build")]
        public bool AllowBuilding;
        [JsonProperty(PropertyName = "Allow Players To Build (Exclusions)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> AllowedBuildingBlockExceptions;
        [JsonProperty(PropertyName = "Allow Players To Deploy Barricades")]
        public bool AllowBarricades;
        [JsonProperty(PropertyName = "Allow PVP")]
        public bool AllowPVP;
        [JsonProperty(PropertyName = "Allow Self Damage")]
        public bool AllowSelfDamage;
        [JsonProperty(PropertyName = "Allow Friendly Fire (Teams)")]
        public bool AllowFriendlyFire;
        [JsonProperty(PropertyName = "Minimum Amount Of Items To Spawn (0 = Use Max Value)")]
        public int MinTreasure;
        [JsonProperty(PropertyName = "Amount Of Items To Spawn")]
        public int MaxTreasure;
        [JsonProperty(PropertyName = "Amount Of Items To Spawn Increased By Item Splits")]
        public bool Dynamic;
        [JsonProperty(PropertyName = "Check Lower Probability Once Per Loot Item")]
        public bool EnforceProbability;
        [JsonProperty(PropertyName = "Flame Turret Health")]
        public float FlameTurretHealth;
        [JsonProperty(PropertyName = "Briefly Holster Weapon To Prevent Camping The Entrance Of Events")]
        public bool Holster { get; set; }
        [JsonProperty(PropertyName = "Block Plugins Which Prevent Item Durability Loss")]
        public bool EnforceDurability;
        [JsonProperty(PropertyName = "Block Damage To Players From Player Turrets Deployed Outside Of The Dome")]
        public bool BlockOutsideTurrets;
        [JsonProperty(PropertyName = "Block Damage Outside Of The Dome To Players Inside")]
        public bool BlockOutsideDamageToPlayersInside;
        [JsonProperty(PropertyName = "Block Damage Outside Of The Dome To Bases Inside")]
        public bool BlockOutsideDamageToBaseInside;
        [JsonProperty(PropertyName = "Block Damage Inside From Npcs To Players Outside")]
        public bool BlockNpcDamageToPlayersOutside;
        [JsonProperty(PropertyName = "Building Blocks Are Immune To Damage")]
        public bool BlocksImmune;
        [JsonProperty(PropertyName = "Building Blocks Are Immune To Damage (Twig Only)")]
        public bool TwigImmune;
        [JsonProperty(PropertyName = "Turrets Can Hurt Event Twig")]
        public bool TurretsHurtTwig;
        [JsonProperty(PropertyName = "Boxes Are Invulnerable")]
        public bool Invulnerable;
        [JsonProperty(PropertyName = "Boxes Are Invulnerable Until Cupboard Is Destroyed")]
        public bool InvulnerableUntilCupboardIsDestroyed;
        [JsonProperty(PropertyName = "Spawn Silently (No Notifcation, No Dome, No Map Marker)")]
        public bool Silent;
        [JsonProperty(PropertyName = "Hide Despawn Time On Map Marker (PVP)")]
        public bool HideDespawnTimePVP;
        [JsonProperty(PropertyName = "Hide Despawn Time On Map Marker (PVE)")]
        public bool HideDespawnTimePVE;
        [JsonProperty(PropertyName = "Use Simple Messaging")]
        public bool Smart;
        [JsonProperty(PropertyName = "Despawn Dropped Loot Bags From Raid Boxes When Base Despawns")]
        public bool DespawnGreyBoxBags;
        [JsonProperty(PropertyName = "Despawn Dropped Loot Bags From Npc When Base Despawns")]
        public bool DespawnGreyNpcBags;
        [JsonProperty(PropertyName = "Protect Loot Bags From Raid Boxes For X Seconds After Base Despawns")]
        public float PreventLooting;
        [JsonProperty(PropertyName = "Divide Loot Into All Containers")]
        public bool DivideLoot;
        [JsonProperty(PropertyName = "Drop Tool Cupboard Loot After Raid Is Completed")]
        public bool DropPrivilegeLoot;
        [JsonProperty(PropertyName = "Drop Container Loot X Seconds After It Is Looted")]
        public float DropTimeAfterLooting;
        [JsonProperty(PropertyName = "Drop Container Loot Applies Only To Boxes And Cupboards")]
        public bool DropOnlyBoxesAndPrivileges;
        [JsonProperty(PropertyName = "Create Dome Around Event Using Spheres (0 = disabled, recommended = 5)")]
        public int SphereAmount;
        [JsonProperty(PropertyName = "Empty All Containers Before Spawning Loot")]
        public bool EmptyAll;
        [JsonProperty(PropertyName = "Empty All Containers (Exclusions)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> EmptyExemptions;
        [JsonProperty(PropertyName = "Eject Corpses From Enemy Raids (Advanced Users Only)")]
        public bool EjectBackpacks;
        [JsonProperty(PropertyName = "Eject Corpses From PVE Instantly (Advanced Users Only)")]
        public bool EjectBackpacksPVE;
        [JsonProperty(PropertyName = "Eject Enemies From Locked PVE Raids")]
        public bool EjectLockedPVE;
        [JsonProperty(PropertyName = "Eject Enemies From Locked PVP Raids")]
        public bool EjectLockedPVP;
        [JsonProperty(PropertyName = "Eject Tree Radius When Spawning Base")]
        public float TreeRadius;
        [JsonProperty(PropertyName = "Delete Tree Radius When Spawning Base")]
        public float DeleteRadius;
        [JsonProperty(PropertyName = "Respawn Deleted Trees When Despawning Base")]
        public bool RespawnTrees;
        [JsonProperty(PropertyName = "Explosion Damage Modifier (0-999)")]
        public float ExplosionModifier;
        [JsonProperty(PropertyName = "Force All Boxes To Have Same Skin")]
        public bool SetSkins;
        [JsonProperty(PropertyName = "Ignore Containers That Spawn With Loot Already")]
        public bool IgnoreContainedLoot;
        [JsonProperty(PropertyName = "Loot Amount Multiplier")]
        public float Multiplier;
        [JsonProperty(PropertyName = "Maximum Respawn Npc X Seconds After Death")]
        public float RespawnRateMax;
        [JsonProperty(PropertyName = "Minimum Respawn Npc X Seconds After Death")]
        public float RespawnRateMin;
        [JsonProperty(PropertyName = "No Item Input For Boxes And TC")]
        public bool NoItemInput;
        [JsonProperty(PropertyName = "Penalize Players On Death In PVE (ZLevels)")]
        public bool PenalizePVE;
        [JsonProperty(PropertyName = "Penalize Players On Death In PVP (ZLevels)")]
        public bool PenalizePVP;
        [JsonProperty(PropertyName = "Require Cupboard Access To Loot")]
        public bool RequiresCupboardAccess;
        [JsonProperty(PropertyName = "Require Cupboard Access To Place Ladders")]
        public bool RequiresCupboardAccessLadders;
        [JsonProperty(PropertyName = "Skip Treasure Loot And Use Loot In Base Only")]
        public bool SkipTreasureLoot;
        [JsonProperty(PropertyName = "Use Buoyant Boxex For Dropped Privilege Loot")]
        public bool BuoyantPrivilege;
        [JsonProperty(PropertyName = "Use Buoyant Boxex For Dropped Box Loot")]
        public bool BuoyantBox;
        [JsonProperty(PropertyName = "Rearm Bear Traps When Damaged")]
        public bool RearmBearTraps;
        [JsonProperty(PropertyName = "Bear Traps Are Immune To Timed Explosives")]
        public bool BearTrapsImmuneToExplosives;
        [JsonProperty(PropertyName = "Remove Locks When Event Is Completed")]
        public bool UnlockEverything;
        [JsonProperty(PropertyName = "Required Loot Percentage For Rewards")]
        public double RequiredLootPercentage;
        [JsonProperty(PropertyName = "Each Player Must Destroy An Entity For Reward Eligibility")]
        public bool RequiredDestroyEntity;
        [JsonProperty(PropertyName = "Always Spawn Base Loot Table")]
        public bool AlwaysSpawnBaseLoot;
        public BuildingOptions Clone();
        public float ProtectionRadius(RaidableType type);
        public int GetLootAmount(RaidableType type);
    }

    public class BuildingOptionsEco
    {
        [JsonProperty(PropertyName = "Allow Eco Raiding Only")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Allow Flame Throwers")]
        public bool FlameThrowers;
    }

    public class RaidableBaseSettingsEventTypeBase
    {
        [JsonProperty(PropertyName = "Convert PVE To PVP")]
        public bool ConvertPVE;
        [JsonProperty(PropertyName = "Convert PVP To PVE")]
        public bool ConvertPVP;
        [JsonProperty(PropertyName = "Ignore Safe Checks")]
        public bool Ignore;
        [JsonProperty(PropertyName = "Ignore Safe Checks In X Radius Only")]
        public float SafeRadius;
        [JsonProperty(PropertyName = "Ignore Player Entities At Custom Spawn Locations")]
        public bool Skip;
        [JsonProperty(PropertyName = "Spawn Bases X Distance Apart")]
        public float Distance;
        [JsonProperty(PropertyName = "Spawns Database File (Optional)")]
        public string SpawnsFile;
    }

    public class RaidableBaseSettingsEventTypeBaseExtended : RaidableBaseSettingsEventTypeBase
    {
        [JsonProperty(PropertyName = "Chance To Randomly Spawn PVP Bases (0 = Ignore Setting)")]
        public decimal Chance;
        [JsonProperty(PropertyName = "Include PVE Bases")]
        public bool IncludePVE;
        [JsonProperty(PropertyName = "Include PVP Bases")]
        public bool IncludePVP;
        [JsonProperty(PropertyName = "Minimum Required Players Online")]
        public int PlayerLimitMin;
        [JsonProperty(PropertyName = "Maximum Limit Of Players Online")]
        public int PlayerLimitMax;
        [JsonProperty(PropertyName = "Time To Wait Between Spawns")]
        public float Time;
        public int GetPlayerCount();
    }

    public class RaidableBaseSettingsScheduled : RaidableBaseSettingsEventTypeBaseExtended
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Every Min Seconds")]
        public double IntervalMin;
        [JsonProperty(PropertyName = "Every Max Seconds")]
        public double IntervalMax;
        [JsonProperty(PropertyName = "Max Scheduled Events")]
        public int Max;
        [JsonProperty(PropertyName = "Max To Spawn At Once (0 = Use Max Scheduled Events Amount)")]
        public int MaxOnce;
    }

    public class RaidableBaseSettingsMaintained : RaidableBaseSettingsEventTypeBaseExtended
    {
        [JsonProperty(PropertyName = "Always Maintain Max Events")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Max Maintained Events")]
        public int Max;
    }

    public class RaidableBaseSettingsManual
    {
        [JsonProperty(PropertyName = "Convert PVE To PVP")]
        public bool ConvertPVE;
        [JsonProperty(PropertyName = "Convert PVP To PVE")]
        public bool ConvertPVP;
        [JsonProperty(PropertyName = "Max Manual Events")]
        public int Max;
        [JsonProperty(PropertyName = "Spawns Database File (Optional)")]
        public string SpawnsFile;
    }

    public class RaidableBaseWallOptions
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Stacks")]
        public int Stacks;
        [JsonProperty(PropertyName = "Ignore Stack Limit When Clipping Terrain")]
        public bool IgnoreWhenClippingTerrain;
        [JsonProperty(PropertyName = "Ignore Forced Height Option")]
        public bool IgnoreForcedHeight;
        [JsonProperty(PropertyName = "Use Stone Walls")]
        public bool Stone;
        [JsonProperty(PropertyName = "Use Iced Walls")]
        public bool Ice;
        [JsonProperty(PropertyName = "Use Least Amount Of Walls")]
        public bool LeastAmount;
        [JsonProperty(PropertyName = "Use UFO Walls")]
        public bool UseUFOWalls;
        [JsonProperty(PropertyName = "Radius")]
        public float Radius;
    }

    public class RankedLadderSettings
    {
        [JsonProperty(PropertyName = "Award Top X Players On Wipe")]
        public int Amount;
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Show Top X Ladder")]
        public int Top;
    }

    public class RewardSettings
    {
        [JsonProperty(PropertyName = "Economics Money")]
        public double Money;
        [JsonProperty(PropertyName = "ServerRewards Points")]
        public int Points;
        [JsonProperty(PropertyName = "SkillTree XP")]
        public double XP;
    }

    public class SkinSettingsDefault
    {
        [JsonProperty(PropertyName = "Use Random Skin")]
        public bool Random;
        [JsonProperty(PropertyName = "Include Workshop Skins")]
        public bool Workshop;
        [JsonProperty(PropertyName = "Use Imported Workshop Skins File")]
        public bool Imported;
        [JsonProperty(PropertyName = "Use Approved Workshop Skins Only")]
        public bool ApprovedOnly;
        [JsonProperty(PropertyName = "Ignore If Skinned Already")]
        public bool IgnoreSkinned;
        [JsonProperty(PropertyName = "Use Identical Skins")]
        public bool Unique;
        [JsonProperty(PropertyName = "Preset Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> Skins;
    }

    public class SkinSettingsLoot
    {
        [JsonProperty(PropertyName = "Include Workshop Skins")]
        public bool Workshop;
        [JsonProperty(PropertyName = "Use Random Skin")]
        public bool Random;
        [JsonProperty(PropertyName = "Use Imported Workshop Skins File")]
        public bool Imported;
        [JsonProperty(PropertyName = "Use Identical Skins For Stackable Items")]
        public bool Stackable;
        [JsonProperty(PropertyName = "Use Identical Skins For Non-Stackable Items")]
        public bool NonStackable;
        [JsonProperty(PropertyName = "Use Approved Workshop Skins Only")]
        public bool ApprovedOnly;
    }

    public class SkinSettingsDeployables
    {
        [JsonProperty(PropertyName = "Partial Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Names;
        [JsonProperty(PropertyName = "Use Approved Workshop Skins Only")]
        public bool ApprovedOnly;
        [JsonProperty(PropertyName = "Use Imported Workshop Skins File")]
        public bool ImportedWorkshop;
        [JsonProperty(PropertyName = "Preset Door Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> Doors;
        [JsonProperty(PropertyName = "Include Workshop Skins")]
        public bool Workshop;
        [JsonProperty(PropertyName = "Use Random Skin")]
        public bool Random;
        [JsonProperty(PropertyName = "Skin Everything")]
        public bool Everything;
        [JsonProperty(PropertyName = "Ignore If Skinned Already")]
        public bool IgnoreSkinned;
        [JsonProperty(PropertyName = "Use Identical Skins")]
        public bool Unique;
    }

    public class SkinSettingsNpcs : SkinSettingsDefault
    {
        [JsonProperty(PropertyName = "Use Skins With Murderer Kits")]
        public bool MurdererKits;
        [JsonProperty(PropertyName = "Use Skins With Scientist Kits")]
        public bool ScientistKits;
        [JsonProperty(PropertyName = "Ignore Skinned Murderer Kits")]
        public bool IgnoreSkinnedMurderer;
        [JsonProperty(PropertyName = "Ignore Skinned Scientist Kits")]
        public bool IgnoreSkinnedScientist;
        internal bool CanSkinKit(ulong skin, bool isMurderer);
    }

    public class SkinSettings
    {
        [JsonProperty(PropertyName = "Boxes")]
        public SkinSettingsDefault Boxes;
        [JsonProperty(PropertyName = "Loot Items")]
        public SkinSettingsLoot Loot;
        [JsonProperty(PropertyName = "Npcs")]
        public SkinSettingsNpcs Npc;
        [JsonProperty(PropertyName = "Deployables")]
        public SkinSettingsDeployables Deployables;
        [JsonProperty(PropertyName = "Randomize Npc Item Skins")]
        public bool Npcs;
        [JsonProperty(PropertyName = "Use Identical Skins For All Npcs")]
        public bool UniqueNpcs;
        [JsonProperty(PropertyName = "Ignore If Skinned Already")]
        public bool IgnoreSkinned;
    }

    public class SkinSettingsImportedWorkshop
    {
        [JsonProperty(PropertyName = "Imported Workshop Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<ulong>> SkinList;
    }

    public class LootItem : IEquatable<LootItem>
    {
        [JsonProperty(PropertyName = "shortname")]
        public string shortname;
        [JsonProperty(PropertyName = "name")]
        public string name;
        [JsonProperty(PropertyName = "text")]
        public string text;
        [JsonProperty(PropertyName = "amount")]
        public int amount;
        [JsonProperty(PropertyName = "skin")]
        public ulong skin;
        [JsonProperty(PropertyName = "amountMin")]
        public int amountMin;
        [JsonProperty(PropertyName = "probability")]
        public float probability;
        [JsonProperty(PropertyName = "stacksize")]
        public int stacksize;
        public bool HasProbability();
        internal bool hasPriority;
        internal bool isSplit;
        internal ItemDefinition _def;
        [JsonIgnore]
        public ItemDefinition definition { get; set; }
        [JsonIgnore]
        public bool isBlueprint;
        [JsonIgnore]
        public bool isModified;
        public LootItem();
        public LootItem(string shortname, int amountMin, int amount, ulong skin, bool isBlueprint, float probability, int stacksize, string name, string text, bool isModified, bool hasPriority);
        public LootItem Clone();
        public bool Equals(LootItem other);
        public override bool Equals(object obj);
        public override int GetHashCode();
    }

    public class TreasureSettings
    {
        [JsonProperty(PropertyName = "Resources Not Moved To Cupboards", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> ExcludeFromCupboard;
        [JsonProperty(PropertyName = "Use Day Of Week Loot")]
        public bool UseDOWL;
        [JsonProperty(PropertyName = "Do Not Duplicate Base Loot")]
        public bool Base;
        [JsonProperty(PropertyName = "Do Not Duplicate Difficulty Loot")]
        public bool Difficulty;
        [JsonProperty(PropertyName = "Do Not Duplicate Default Loot")]
        public bool Default;
        [JsonProperty(PropertyName = "Use Stack Size Limit For Spawning Items")]
        public bool Stacks;
    }

    public class UIBaseSettings
    {
        [JsonProperty(PropertyName = "Enabled", Order = 1)]
        public bool Enabled;
        [JsonProperty(PropertyName = "Anchor Min", Order = 2)]
        public string AnchorMin;
        [JsonProperty(PropertyName = "Anchor Max", Order = 3)]
        public string AnchorMax;
        [JsonProperty(PropertyName = "Panel Alpha", NullValueHandling = NullValueHandling.Ignore, Order = 4)]
        public float? PanelAlpha;
        [JsonProperty(PropertyName = "Panel Color", NullValueHandling = NullValueHandling.Ignore, Order = 5)]
        public string PanelColor;
    }

    public class BuildingOptionsElevators : UIBaseSettings
    {
        public BuildingOptionsElevators();
        [JsonProperty(PropertyName = "Required Access Level", Order = 5)]
        public int RequiredAccessLevel;
        [JsonProperty(PropertyName = "Required Access Level Grants Permanent Use", Order = 6)]
        public bool RequiredAccessLevelOnce;
        [JsonProperty(PropertyName = "Required Keycard Skin ID", Order = 7)]
        public ulong SkinID;
        [JsonProperty(PropertyName = "Requires Building Permission", Order = 8)]
        public bool RequiresBuildingPermission;
        [JsonProperty(PropertyName = "Button Health", Order = 9)]
        public float ButtonHealth;
        [JsonProperty(PropertyName = "Elevator Health", Order = 10)]
        public float ElevatorHealth;
    }

    public class UIDelaySettings : UIBaseSettings
    {
        public UIDelaySettings();
        [JsonProperty(PropertyName = "Text Color", Order = 5)]
        public string Foreground;
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
    }

    public class Vector2Converter : JsonConverter
    {
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    public class UIStatusSettings : UIBaseSettings
    {
        public UIStatusSettings();
        [JsonProperty(PropertyName = "Offset Min", Order = 2, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(Vector2Converter))]
        public Vector2 OffsetMin;
        [JsonProperty(PropertyName = "Offset Max", Order = 3, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(Vector2Converter))]
        public Vector2 OffsetMax;
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "PVP Color")]
        public string ColorPVP;
        [JsonProperty(PropertyName = "PVE Color")]
        public string ColorPVE;
        [JsonProperty(PropertyName = "No Owner Color", Order = 7)]
        public string NoneColor;
        [JsonProperty(PropertyName = "Negative Color", Order = 7)]
        public string NegativeColor;
        [JsonProperty(PropertyName = "Positive Color", Order = 8)]
        public string PositiveColor;
        [JsonProperty(PropertyName = "Title Background Color", Order = 6)]
        public string TitlePanelColor;
        [JsonProperty(PropertyName = "Show Loot Left")]
        public bool ShowLootLeft;
    }

    public class UIAdvancedAlertSettings : UIBaseSettings
    {
        [JsonProperty(PropertyName = "Time Shown", Order = 5)]
        public float Time;
        public UIAdvancedAlertSettings();
    }

    public class UISettings
    {
        [JsonProperty(PropertyName = "Advanced Alerts UI")]
        public UIAdvancedAlertSettings AA;
        [JsonProperty(PropertyName = "Delay")]
        public UIDelaySettings Delay;
        [JsonProperty(PropertyName = "Status UI")]
        public UIStatusSettings Status;
    }

    public class WeaponTypeStateSettings
    {
        [JsonProperty(PropertyName = "AutoTurret")]
        public bool AutoTurret;
        [JsonProperty(PropertyName = "FlameTurret")]
        public bool FlameTurret;
        [JsonProperty(PropertyName = "FogMachine")]
        public bool FogMachine;
        [JsonProperty(PropertyName = "GunTrap")]
        public bool GunTrap;
        [JsonProperty(PropertyName = "SamSite")]
        public bool SamSite;
    }

    public class WeaponTypeAmountSettings
    {
        [JsonProperty(PropertyName = "AutoTurret")]
        public int AutoTurret;
        [JsonProperty(PropertyName = "FlameTurret")]
        public int FlameTurret;
        [JsonProperty(PropertyName = "FogMachine")]
        public int FogMachine;
        [JsonProperty(PropertyName = "GunTrap")]
        public int GunTrap;
        [JsonProperty(PropertyName = "SamSite")]
        public int SamSite;
    }

    public class WeaponSettingsTeslaCoil
    {
        [JsonProperty(PropertyName = "Requires A Power Source")]
        public bool RequiresPower;
        [JsonProperty(PropertyName = "Max Discharge Self Damage Seconds (0 = None, 120 = Rust default)")]
        public float MaxDischargeSelfDamageSeconds;
        [JsonProperty(PropertyName = "Max Damage Output")]
        public float MaxDamageOutput;
        [JsonProperty(PropertyName = "Health")]
        public float Health;
    }

    public class WeaponSettings
    {
        [JsonProperty(PropertyName = "No Fuel Source", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Burn;
        [JsonProperty(PropertyName = "Infinite Ammo")]
        public WeaponTypeStateSettings InfiniteAmmo;
        [JsonProperty(PropertyName = "Ammo")]
        public WeaponTypeAmountSettings Ammo;
        [JsonProperty(PropertyName = "Tesla Coil")]
        public WeaponSettingsTeslaCoil TeslaCoil;
        [JsonProperty(PropertyName = "Fog Machine Allows Motion Toggle")]
        public bool FogMotion;
        [JsonProperty(PropertyName = "Fog Machine Requires A Power Source")]
        public bool FogRequiresPower;
        [JsonProperty(PropertyName = "SamSite Repairs Every X Minutes (0.0 = disabled)")]
        public float SamSiteRepair;
        [JsonProperty(PropertyName = "SamSite Range (350.0 = Rust default)")]
        public float SamSiteRange;
        [JsonProperty(PropertyName = "SamSite Requires Power Source")]
        public bool SamSiteRequiresPower;
        [JsonProperty(PropertyName = "Spooky Speakers Requires Power Source")]
        public bool SpookySpeakersRequiresPower;
        [JsonProperty(PropertyName = "Sprinkler Requires A Power Source")]
        public bool SprinklerRequiresPower;
        [JsonProperty(PropertyName = "Test Generator Power")]
        public float TestGeneratorPower;
        [JsonProperty(PropertyName = "Furnace Starting Fuel")]
        public int Furnace;
    }

    public class Configuration
    {
        [JsonProperty(PropertyName = "Settings")]
        public PluginSettings Settings;
        [JsonProperty(PropertyName = "Event Messages")]
        public EventMessageSettings EventMessages;
        [JsonProperty(PropertyName = "GUIAnnouncements")]
        public GUIAnnouncementSettings GUIAnnouncement;
        [JsonProperty(PropertyName = "Ranked Ladder")]
        public RankedLadderSettings RankedLadder;
        [JsonProperty(PropertyName = "Skins")]
        public SkinSettings Skins;
        [JsonProperty(PropertyName = "Treasure")]
        public TreasureSettings Loot;
        [JsonProperty(PropertyName = "UI")]
        public UISettings UI;
        [JsonProperty(PropertyName = "Weapons")]
        public WeaponSettings Weapons;
        [JsonProperty(PropertyName = "Log Debug To File")]
        public bool LogToFile;
    }

    private bool canSaveConfig;
    private bool InstallationError;
    private bool? allowBuilding;
    private bool IsEnPremium();
    private bool IsRuPremium();
    protected override void LoadConfig();
    public List<LootItem> TreasureLoot { get; set; }
    public List<LootItem> WeekdayLoot { get; set; }
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    public class UI
    {
        public static void AddCuiPanel(CuiElementContainer container, string color, string amin, string amax, string omin, string omax, string parent, string name, bool cursor);
        public static void AddCuiButton(CuiElementContainer container, string buttonColor, string command, string text, string textColor, int fontSize, TextAnchor align, string amin, string amax, string omin, string omax, string parent, string name, string font);
        public static void AddCuiElement(CuiElementContainer container, string text, int fontSize, TextAnchor align, string textColor, string amin, string amax, string omin, string omax, string parent, string name, string font, string distance);
        public static double ParseHexComponent(string hex, int j, int k);
        public static string ConvertHexToRGBA(string hex, float a);
        public static void DestroyDelayUI(BasePlayer player);
        public static void DestroyStatusUI(BasePlayer player);
        public static void DestroyAll();
        private static void ShowDelayUI(RaidableBases Instance, BasePlayer player);
        private static void CreateDelayUI(Configuration config, BasePlayer player, string panelName, string text, string color, string panelColor, string aMin, string aMax);
        public static void UpdateDelayUI(RaidableBases Instance, BasePlayer player);
        private static void SetDelayUpdate(RaidableBases Instance, BasePlayer player);
        public static void DestroyDelayUpdate(BasePlayer player);
        public static bool ShowStatusUi(RaidableBases Instance, BasePlayer player);
        private static void SetOwner(RaidableBase raid, UIStatusSettings ui, BasePlayer player, string ownerName, string ownerColor);
        private static double GetMinutes(double value);
        public static void UpdateStatusUI(RaidableBase raid);
        public static void UpdateStatusUI(RaidableBases Instance, BasePlayer player);
        private static void SetStatusUpdate(RaidableBases Instance, BasePlayer player);
        public static void DestroyStatusUpdate(BasePlayer player);
        public const string DelayPanelName;
        public const string StatusPanelName;
        public static List<BasePlayer> Delay;
        public static List<BasePlayer> Players;
        public static Dictionary<ulong, Timers> InvokeTimers;
        public class Timers
        {
            public Timer Delay;
            public Timer Status;
            public Timer Lockout;
        }

    }

}

public class PasteData
{
    public bool valid;
    public float radius;
    public List<Vector3> foundations;
    public List<string> invalid;
    public PasteData();
}

public static class RaidableMode
{
    public const string Normal;
    public const string Random;
    public const string Points;
    public const string Disabled;
}

public class StoredData
{
    public RotationCycle Cycle;
    public Dictionary<string, PlayerInfo> Players;
    public DateTime RaidTime;
    public int TotalEvents;
    public int protocol;
    public StoredData();
}

public class RandomBase
{
    public float heightAdj;
    public float typeDistance;
    public float protectionRadius;
    public float safeRadius;
    public float ignoreRadius;
    public float buildRadius;
    public float baseHeight;
    public bool autoHeight;
    public bool stability;
    public bool checkTerrain;
    public bool Sorted;
    public bool Save;
    public string BaseName;
    public string username;
    public string id;
    public int attempts;
    public int errors;
    public ulong userid;
    public Vector3 Position;
    public IPlayer user;
    public RaidableType type;
    public BasePlayer owner;
    public PasteData pasteData;
    public BaseProfile Profile;
    public RaidableSpawns spawns;
    public RaidableBases Instance;
    public RaidableBase raid;
    public HashSet<ulong> members;
    public BuildingOptions options { get; set; }
    public bool HasSpawns();
}

public class BackpackData : Pool.IPooled
{
    public BackpackData();
    public void EnterPool();
    public void LeavePool();
    public List<DroppedItemContainer> containers;
    public BasePlayer _player;
    public ulong userid;
    public bool IsEmpty { get; set; }
    public BasePlayer player { get; set; }
}

public class DelaySettings
{
    public RaidableBase raid;
    public string mode;
    public Timer Timer;
    public float time;
    public void Destroy();
}

public class SkinInfo
{
    public List<ulong> skins;
    public List<ulong> workshopSkins;
    public List<ulong> importedWorkshopSkins;
    public List<ulong> allSkins;
}

public class RankedRecord
{
    public string Permission;
    public string Group;
    public string Mode;
    internal bool IsValid { get; set; }
    public RankedRecord(string permission, string group, string mode);
    public RankedRecord();
}

public class RaidableSpawnLocation : IEquatable<RaidableSpawnLocation>
{
    public List<Vector3> Surroundings;
    public Vector3 Location;
    public MinMax LandLevel;
    public float WaterHeight;
    public float TerrainHeight;
    public float SpawnHeight;
    public float Radius;
    public float RailRadius;
    public bool AutoHeight;
    public RaidableSpawnLocation(Vector3 location);
    public bool Equals(RaidableSpawnLocation other);
    public override bool Equals(object obj);
    public override int GetHashCode();
}

public class ZoneInfo
{
    internal string ZoneId;
    internal Vector3 Position;
    internal Vector3 Size;
    internal Vector3 extents;
    internal float Distance;
    internal bool IsBlocked;
    public ZoneInfo(string zoneID, Vector3 position, object radius, object size, bool isBlocked, float dist);
    public bool IsPositionInZone(Vector3 a);
}

public class BaseProfile
{
    public BuildingOptions Options;
    public string ProfileName;
    private Dictionary<string, BaseProfile> Clones;
    public RaidableBases Instance;
    public BaseProfile(RaidableBases instance);
    public BaseProfile(RaidableBases instance, BuildingOptions options, string name);
    public static BaseProfile Clone(BaseProfile profile, string name);
}

public class BuildingTables
{
    public Dictionary<string, List<LootItem>> DifficultyLootLists;
    public Dictionary<DayOfWeek, List<LootItem>> WeekdayLootLists;
    public Dictionary<string, BaseProfile> Profiles;
    public List<string> Removed;
    public bool IsConfigured(string baseName);
    public bool TryGetValue(string baseName, BaseProfile profile);
    public void Remove(string baseName);
}

public class GridControllerManager
{
    internal RaidableBases Instance;
    internal Dictionary<RaidableType, RaidableSpawns> Spawns;
    internal Coroutine gridCoroutine;
    internal Coroutine fileCoroutine;
    internal float gridTime;
    public SpawnsControllerManager SpawnsController { get; set; }
    public StoredData data { get; set; }
    public Configuration config { get; set; }
    public double GetRaidTime();
    public void StartAutomation();
    private IEnumerator LoadFiles();
    public void SetupGrid();
    public void StopCoroutine();
    private void CriticalError(string text);
    public bool BadFrameRate;
    private IEnumerator GenerateGrid();
    public void LoadSpawns();
    public bool BlockAtSpawnsDatabase(Vector3 a);
    private void LoadSpawnsForType(RaidableType type, string spawnsFile, string key);
    public bool SpawnsFileValid(string spawnsFile);
    public HashSet<RaidableSpawnLocation> GetSpawnsLocations(string spawnsFile);
}

private class Spawnfile
{
    public Dictionary<string, object> spawnPoints;
}

public class QueueController
{
    internal YieldInstruction instruction0;
    internal YieldInstruction instruction1;
    internal Queue<RandomBase> queue;
    internal DebugMessages Messages;
    internal Coroutine _coroutine;
    internal int spawnChecks;
    internal bool Paused;
    internal RaidableBases Instance;
    internal const float REMOVE_RADIUS;
    internal Configuration config { get; set; }
    internal SpawnsControllerManager SpawnsController { get; set; }
    internal bool Any { get; set; }
    private void Message(BasePlayer player, string key, object[] args);
    private string mx(string key, string id, object[] args);
    public class DebugMessages
    {
        internal Dictionary<string, Info> _elements;
        internal RaidableBases _instance;
        internal bool _logToFile;
        internal IPlayer _user;
        public class Info
        {
            public int Amount;
            public List<string> Values;
            public override string ToString();
        }

        public string Add(string element, object obj);
        public void Clear();
        public bool Any();
        public void PrintAll(IPlayer user);
        private bool PrintInternal(IPlayer user, string message);
        public void Log(string baseName, string message);
        public bool Print(string message);
        public void Print(string message, object obj);
        public void Print(IPlayer user, string message, object obj);
        public void PrintLast(string id);
        public string GetLast(string id);
    }

    public QueueController(RaidableBases instance);
    public void RestartCoroutine();
    public void StopCoroutine();
    public void Add(RandomBase rb);
    private void Spawn(RandomBase rb, Vector3 position);
    private bool CanBypassPause(RandomBase rb);
    private IEnumerator FindEventPosition();
    private void CheckSpawner(RandomBase spq);
    internal bool IsObstructed(RandomBase spq, Vector3 v);
    private IEnumerator SetupCopyPasteRadius(RandomBase spq);
    internal bool IsAreaSafe(RandomBase spq, RaidableSpawnLocation rsl, Vector3 v);
    internal bool IsSubmerged(RandomBase spq, RaidableSpawnLocation rsl, Vector3 v);
    private bool CanSpawnCustom(RandomBase spq, RaidableType type, Vector3 v, bool ignore, float radius);
    private bool IsTooClose(RandomBase spq, Vector3 v);
    internal bool IsAreaManuallyBlocked(RandomBase spq, Vector3 v);
    private float GetAdjustedHeight(RandomBase spq, Vector3 v);
    private bool TopologyChecks(RandomBase spq, Vector3 v, float railRadius);
}

public class DebugMessages
{
    internal Dictionary<string, Info> _elements;
    internal RaidableBases _instance;
    internal bool _logToFile;
    internal IPlayer _user;
    public class Info
    {
        public int Amount;
        public List<string> Values;
        public override string ToString();
    }

    public string Add(string element, object obj);
    public void Clear();
    public bool Any();
    public void PrintAll(IPlayer user);
    private bool PrintInternal(IPlayer user, string message);
    public void Log(string baseName, string message);
    public bool Print(string message);
    public void Print(string message, object obj);
    public void Print(IPlayer user, string message, object obj);
    public void PrintLast(string id);
    public string GetLast(string id);
}

public class Info
{
    public int Amount;
    public List<string> Values;
    public override string ToString();
}

public class AutomatedController
{
    internal YieldInstruction instruction0;
    internal YieldInstruction instruction1;
    internal YieldInstruction instruction5;
    internal YieldInstruction instruction15;
    internal Coroutine _maintainedCoroutine;
    internal Coroutine _scheduledCoroutine;
    internal bool IsMaintainedEnabled;
    internal bool IsScheduledEnabled;
    internal RaidableBases Instance;
    internal int _maxOnce;
    internal StoredData data { get; set; }
    internal Configuration config { get; set; }
    public AutomatedController(RaidableBases instance, bool a, bool b);
    public void DestroyMe();
    public void StopCoroutine(RaidableType type, IPlayer user);
    public void StartCoroutine(RaidableType type, IPlayer user);
    private IEnumerator MaintainCoroutine();
    private IEnumerator ScheduleCoroutine();
    private IEnumerator ProcessEvent(RaidableType type, float timeBetweenSpawns);
    private float ScheduleNextAutomatedEvent();
    private bool MaxOnce();
    private bool CanSpawn(RaidableType type, int onlinePlayers, int playerLimit, int playerLimitMax, int maxEvents, bool checkRaidTime);
}

public class BMGELEVATOR : FacepunchBehaviour
{
    internal const string ElevatorPanelName;
    internal Elevator _elevator;
    internal RaycastHit hit;
    internal BaseEntity hitEntity;
    internal RaidableBase raid;
    internal BuildingOptionsElevators options;
    internal Dictionary<ulong, BasePlayer> _UI;
    internal bool HasButton;
    internal NetworkableId uid;
    internal int CurrentFloor;
    internal int returnDelay;
    internal float Floors;
    internal const float _LiftSpeedPerMetre;
    internal RaidableBases env;
    private void Awake();
    private void OnDestroy();
    private Vector3 GetWorldSpaceFloorPosition(int targetFloor);
    public void GoToFloor(Elevator.Direction Direction, bool FullTravel, int forcedFloor);
    private void Retry();
    private void ElevatorToGround();
    public void Init(RaidableBase raid);
    private void ShowHealthUI();
    public static void DestroyUi(BasePlayer player);
    private static void CleanElevatorKill(BaseEntity entity);
    public static PooledList<PooledList<BaseEntity>> SplitElevators(List<BaseEntity> source);
    public static void FixElevators(RaidableBase raid, Dictionary<Elevator, BMGELEVATOR> bmgs);
    public static BMGELEVATOR FixElevator(RaidableBases instance, List<BaseEntity> elevators);
    internal static bool GetElevatorLift(Elevator elevator, ElevatorLift lift);
    internal static void RemoveImmortality(ProtectionProperties baseProtection, float[] obj);
    private HashSet<ulong> _granted;
    public bool HasCardPermission(BasePlayer player);
    public bool HasBuildingPermission(BasePlayer player);
}

public class RaidableSpawns
{
    public HashSet<RaidableSpawnLocation> Spawns;
    public HashSet<RaidableSpawnLocation> Garbage;
    public Dictionary<CacheType, HashSet<RaidableSpawnLocation>> Cached;
    private float lastTryTime;
    public bool IsCustomSpawn;
    public RaidableBases Instance;
    internal Configuration config { get; set; }
    public SpawnsControllerManager SpawnsController { get; set; }
    public HashSet<RaidableSpawnLocation> Inactive(CacheType cacheType);
    public RaidableSpawns(RaidableBases instance, HashSet<RaidableSpawnLocation> spawns);
    public RaidableSpawns(RaidableBases instance);
    public bool CanBuild(Vector3 buildPos, float radius);
    public bool Add(RaidableSpawnLocation rsl, CacheType cacheType, HashSet<RaidableSpawnLocation> cache, bool forced);
    public bool SetOceanLevel(RaidableSpawnLocation rsl);
    public void Check();
    public void TryAddRange(CacheType cacheType, bool forced);
    public RaidableSpawnLocation GetRandom(BuildingWaterOptions options);
    public HashSet<RaidableSpawnLocation> GetCache(CacheType cacheType);
    public void AddNear(Vector3 target, float radius, CacheType cacheType, float delayTime);
    public void Remove(RaidableSpawnLocation a, CacheType cacheType);
    public float RemoveNear(Vector3 target, float radius, CacheType cacheType, RaidableType type);
}

public class PlayerInfo
{
    public int Raids;
    public int TotalRaids;
    public DateTime ExpiredDate;
    public bool IsExpired();
    public void ResetExpiredDate();
    public static PlayerInfo Get(StoredData data, string userid);
    public void ResetWipe();
    public void ResetLifetime();
    internal bool Any { get; set; }
}

public class RotationCycle
{
    [JsonProperty(PropertyName = "Buildings")]
    public Dictionary<string, List<string>> _buildings;
    [JsonProperty(PropertyName = "Player Buildings")]
    public Dictionary<ulong, Dictionary<string, List<string>>> _playerBuildings;
    internal RaidableBases Instance;
    internal Configuration config { get; set; }
    public void Add(RaidableType type, string key, BasePlayer player, string mode);
    private Dictionary<string, List<string>> GetBuildingsDictionary(RaidableType type, BasePlayer player);
    public bool CanSpawn(RaidableType type, string mode, string key, BasePlayer player);
    public bool TryClear(RaidableType type, List<string> files);
}

public class PlayerInputEx : FacepunchBehaviour
{
    private BasePlayer player;
    private Action queuedAction;
    private RaidableBases Instance;
    private RaidableBase raid;
    private Raider raider;
    private Transform t;
    private RaycastHit hit;
    private float deltaTimeTaken;
    private float nextConsumeTime;
    private bool AllowLadders;
    private bool AllowBarricades;
    public bool isDestroyed;
    public Configuration config { get; set; }
    public bool IsInvalid { get; set; }
    public void Setup(RaidableBase raid, Raider ri);
    public void Restart();
    private void Update();
    private bool IsFireButton { get; set; }
    private bool IsUseButton { get; set; }
    public bool TryPlace(ConstructionType constructionType);
    private void UseHeal(Item item, bool consume);
    private bool IsConstructionType(string shortname, ConstructionType constructionType);
    private bool IsConstructionNear(ConstructionType constructionType, Vector3 target);
}

public class HumanoidNPC : ScientistNPC
{
    public new HumanoidBrain Brain;
    public RaidableBase raid { get; set; }
    public new Translate.Phrase LootPanelTitle { get; set; }
    public override string Categorize();
    public override bool ShouldDropActiveItem();
    public override string displayName { get; set; }
    public override void AttackerInfo(ProtoBuf.PlayerLifeStory.DeathInfo info);
    public override void OnDied(HitInfo info);
    private void TryRespawnNpc();
    public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide);
}

public class HumanoidBrain : ScientistBrain
{
    public void DisableShouldThink();
    internal string displayName;
    internal Transform NpcTransform;
    internal IThinker thinker;
    internal HumanoidNPC npc;
    internal AttackEntity _attackEntity;
    internal FlameThrower flameThrower;
    internal BaseProjectile launcher;
    internal LiquidWeapon liquidWeapon;
    internal BaseMelee baseMelee;
    internal BaseProjectile baseProjectile;
    internal BasePlayer AttackTarget;
    internal Transform AttackTransform;
    internal RaidableBases Instance;
    internal RaidableBase raid;
    internal NpcSettings Settings;
    internal List<Vector3> RandomRoamPositions;
    internal List<Vector3> RandomNearPositions;
    internal Vector3 DestinationOverride;
    internal bool keepInventory;
    internal bool isKilled;
    internal bool isMurderer;
    internal float lastWarpTime;
    internal float ScientistChaseRange;
    internal float lastAttackTime;
    internal float nextAttackTime;
    internal float attackRange;
    internal float attackCooldown;
    internal float equipWeaponTime;
    internal float equipToolTime;
    internal float updateDeltaTime;
    internal AttackType attackType;
    internal BaseNavigator.NavigationSpeed CurrentSpeed;
    internal Configuration config { get; set; }
    internal Vector3 AttackPosition { get; set; }
    internal Vector3 ServerPosition { get; set; }
    public float SecondsSinceLastAttack { get; set; }
    internal List<AttackEntity> AttackWeapons;
    internal List<Item> MedicalTools;
    internal AttackEntity AttackEntity { get; set; }
    private void Update();
    private void EquipWeapon();
    public bool HasCorpseLoot();
    public void EnableMedicalTools();
    private void EquipMedicalTool();
    private IEnumerator Heal(Item medicalItem);
    public void UpdateWeapon(AttackEntity attackEntity, ItemId uid);
    internal void IdentifyWeapon();
    private void SetAttackRestrictions(AttackType attackType, float attackRange, float attackCooldown, float effectiveRange);
    public bool ValidTarget { get; set; }
    public override void OnDestroy();
    public override void InitializeAI();
    public void SetSleeping(bool state);
    public override void AddStates();
    public class AttackState : BaseAttackState
    {
        private new HumanoidBrain brain;
        private global::HumanNPC npc;
        private Transform NpcTransform;
        private IAIAttack attack { get; set; }
        public AttackState(HumanoidBrain humanoidBrain);
        public override void StateEnter(BaseAIBrain _brain, BaseEntity _entity);
        public override void StateLeave(BaseAIBrain _brain, BaseEntity _entity);
        private void StopAttacking();
        public override StateStatus StateThink(float delta, BaseAIBrain _brain, BaseEntity _entity);
        private bool InAttackRange();
        private void StartAttacking();
        private void RealisticShotTest();
    }

    private bool init;
    public void Init();
    private void Converge();
    public void Forget();
    public void SetRange(float range);
    private void RandomMove(float radius);
    private void RandomMove(Vector3 v, float radius);
    public void RandomMove(float radius, float margin, float maxAngle);
    public void SetupNavigator(BaseCombatEntity owner, BaseNavigator navigator, float distance);
    public Vector3 GetAimDirection();
    private void SetAimDirection();
    private void MovementUpdate();
    private void SetDestination();
    private void SetDestination(Vector3 destination);
    public bool SetTarget(BasePlayer player, bool converge);
    private bool TryReturnHome();
    private void TryToAttack();
    private void TryMurdererActions();
    private void TryScientistActions();
    public void SetupMovement(List<Vector3> positions);
    private void TryToRoam();
    public bool Warp();
    private void UseFlameThrower();
    private void UseWaterGun();
    private void UseChainsaw();
    private void EmulatedFire();
    private void MeleeAttack();
    public bool TryThrowWeapon();
    private bool CanConverge(HumanoidNPC other);
    private bool CanAnySeeTarget(BasePlayer target);
    private bool CanSeeTarget(BasePlayer target);
    public bool CanRoam(Vector3 destination);
    private bool CanShoot();
    private void TrySetKnown(BasePlayer player);
    public BasePlayer GetBestTarget();
    private bool IsAttackOnCooldown();
    private Vector3 GetRandomRoamPosition();
    private bool CanUseNavMesh();
    private bool IsInAttackRange(float range);
    private bool IsInEventRange(Vector3 destination);
    private bool IsInReachableRange();
    private bool IsInSenseRange(Vector3 destination);
    private bool IsInTargetRange(Vector3 destination);
    private bool IsInChaseRange(Vector3 destination);
    private bool IsInThrowRange();
    private bool ShouldForgetTarget(BasePlayer target);
}

public class AttackState : BaseAttackState
{
    private new HumanoidBrain brain;
    private global::HumanNPC npc;
    private Transform NpcTransform;
    private IAIAttack attack { get; set; }
    public AttackState(HumanoidBrain humanoidBrain);
    public override void StateEnter(BaseAIBrain _brain, BaseEntity _entity);
    public override void StateLeave(BaseAIBrain _brain, BaseEntity _entity);
    private void StopAttacking();
    public override StateStatus StateThink(float delta, BaseAIBrain _brain, BaseEntity _entity);
    private bool InAttackRange();
    private void StartAttacking();
    private void RealisticShotTest();
}

public class Raider
{
    public bool HasDestroyed;
    public bool IsAlly;
    public bool IsAllowed;
    public bool IsParticipant;
    public bool PreEnter;
    public bool eligible;
    public bool rewards;
    public float lastActiveTime;
    public float TotalDamage;
    public string id;
    public string displayName;
    public ulong userid;
    public PlayerInputEx Input;
    private BasePlayer _player;
    public Vector3 lastPosition;
    public BasePlayer player { get; set; }
    public Raider(ulong userid, string username);
    public Raider(BasePlayer target);
    public void DestroyInput();
    public void CheckInput(BasePlayer player, RaidableBase raid);
}

public class RaidableBase : FacepunchBehaviour
{
    private const float Radius;
    public HashSet<ulong> alliance;
    public HashSet<ulong> cooldowns;
    public HashSet<ulong> intruders;
    public Dictionary<ulong, Raider> raiders;
    public Dictionary<ItemId, float> conditions;
    internal List<StorageContainer> fridges;
    internal HashSet<StorageContainer> _containers;
    internal HashSet<StorageContainer> _allcontainers;
    public List<HumanoidNPC> npcs;
    public List<WeaponRack> weaponRacks;
    public List<BackpackData> backpacks;
    public List<Vector3> compound;
    public List<Vector3> foundations;
    public List<Vector3> floors;
    public List<BaseEntity> locks;
    private List<BuildingBlock> blocks;
    private List<Vector3> _inside;
    private List<SphereEntity> spheres;
    private List<IOEntity> lights;
    private List<BaseOven> ovens;
    public List<AutoTurret> turrets;
    private List<Door> doors;
    public List<string> ids;
    private List<CustomDoorManipulator> doorControllers;
    private List<Locker> lockers;
    private Dictionary<string, Dictionary<SkinType, ulong>> _shortnameToSkin;
    private Dictionary<uint, ulong> _prefabToSkin;
    internal Dictionary<TriggerBase, BaseEntity> triggers;
    private List<SleepingBag> _beds;
    private Dictionary<SleepingBag, ulong> _bags;
    public List<SamSite> samsites;
    public List<VendingMachine> vms;
    public List<DamageMultiplier> PlayerDamageMultiplier;
    public List<ulong> HintCooldowns;
    public BuildingPrivlidge priv;
    public List<ulong> TeleportExceptions;
    private List<string> murdererKits;
    private List<string> scientistKits;
    private MapMarkerExplosion explosionMarker;
    private MapMarkerGenericRadius genericMarker;
    private VendingMachineMapMarker vendingMarker;
    public Coroutine setupRoutine;
    public Coroutine turretsCoroutine;
    private GameObject go;
    private bool IsPrivDestroyed;
    public bool IsDespawning;
    public Vector3 Location;
    public string ProfileName;
    public float BaseHeight;
    public string BaseName;
    public Color NoneColor;
    public bool ownerFlag;
    public string ID;
    public ulong ownerId;
    public string ownerName;
    public float loadTime;
    public DateTime spawnDateTime;
    public DateTime despawnDateTime;
    public float AddNearTime;
    public bool AllowPVP;
    public BuildingOptions Options;
    public bool IsAuthed;
    public bool IsOpened;
    public bool IsResetting;
    public int npcMaxAmountMurderers;
    public int npcMaxAmountScientists;
    private bool isInvokingMurdererRespawn;
    private bool isInvokingScientistRespawn;
    public RaidableType Type;
    public bool IsLoading;
    public bool InitiateTurretOnSpawn;
    private bool markerCreated;
    private int itemAmountSpawned;
    public bool privSpawned;
    public bool privHadLoot;
    public string markerName;
    public string NoMode;
    public bool isAuthorized;
    public bool IsEngaged;
    public int _undoLimit;
    private Dictionary<Elevator, BMGELEVATOR> Elevators;
    public HashSet<BaseEntity> Entities;
    public HashSet<BaseEntity> DespawnExceptions;
    public HashSet<BaseEntity> BuiltList;
    public RaidableSpawns spawns;
    public RandomBase rb;
    public float RemoveNearDistance;
    public bool IsAnyLooted;
    public bool IsDamaged;
    public bool IsEligible;
    public bool IsCompleted;
    public float ProtectionRadius;
    public float SqrProtectionRadius;
    public RaidableBases Instance;
    public bool stability;
    private int numLootRequired;
    public List<ulong> NotifiedNearby;
    public BasePlayer cached_attacker;
    public ulong cached_attacker_id;
    public float cached_attack_time;
    public float ProtectionRadiusSqr(float tolerance);
    public bool EjectBackpacksPVE { get; set; }
    public bool PlayersLootable { get; set; }
    public List<string> BlacklistedCommands { get; set; }
    public SpawnsControllerManager SpawnsController { get; set; }
    public StoredData data { get; set; }
    public Configuration config { get; set; }
    public bool IsUnloading { get; set; }
    public bool IsShuttingDown { get; set; }
    private float nextHookTime;
    private object[] _hookObjects;
    public object[] hookObjects { get; set; }
    public int DespawnMinutes { get; set; }
    public bool DespawnMinutesReset { get; set; }
    public int DespawnMinutesInactive { get; set; }
    public bool DespawnMinutesInactiveReset { get; set; }
    public bool EngageOnBaseDamage { get; set; }
    public bool EngageOnNpcDeath { get; set; }
    public string GetPercentCompleteMessage();
    public double GetPercentComplete();
    public int GetLootAmountRemaining();
    public bool Has(BaseEntity entity, bool checkList);
    public bool IsBox(BaseEntity entity, bool inherit);
    public string FormatGridReference(BasePlayer player, Vector3 v);
    private void OnDestroy();
    public bool CanDropRustBackpack(ulong userid);
    public bool CanDropBackpack(ulong userid);
    public Raider GetRaider(BasePlayer player);
    public bool CanHurtBox(BaseEntity entity);
    public void DestroyGroundCheck(BaseEntity entity);
    public void SetupEntity(BaseEntity entity, bool skipCheck);
    public void AddEntity(BaseEntity entity);
    public void ResetToPool();
    public void Message(BasePlayer player, string key, object[] args);
    public void TryMessage(BasePlayer player, string key, object[] args);
    public void QueueNotification(BasePlayer player, string key, object[] args);
    public string mx(string key, string id, object[] args);
    private void Start();
    public void SetupCollider();
    public HashSet<BaseEntity> enteredEntities;
    private void OnTriggerEnter(Collider collider);
    private void HandleDefaultEntity(BaseEntity entity, bool enabled);
    private void OnTriggerExit(Collider collider);
    public void HandlePlayerEntering(BasePlayer player);
    public void HandlePlayerExiting(BasePlayer player);
    private void HandleMountableEntering(BaseMountable m);
    private void HandleMountableExiting(BaseMountable m);
    private void HandleHotAirBalloonEntering(HotAirBalloon hab);
    private void HandleHotAirBalloonExiting(HotAirBalloon hab);
    public void RemoveMountedEntity(BaseEntity entity);
    public bool IsUnderground(Vector3 a);
    public bool CanRespawnAt(BasePlayer target);
    public bool WasConnected(BasePlayer target);
    public bool IsParticipant(BasePlayer target);
    public void HandleTurretSight(BasePlayer target);
    public DamageResult OnTurretTarget(AutoTurret turret);
    private void OnPreEnterRaid(BasePlayer target);
    public void OnEnterRaid(BasePlayer target, bool checkUnderground);
    public void HolsterWeapon(BasePlayer player);
    public void OnPlayerExit(BasePlayer target, bool skipDelay);
    public void OnPlayerExited(BasePlayer target);
    public void AddHintCooldown(BasePlayer target, float cooldown);
    public bool CanSetPVPDelay(BasePlayer target);
    public void TrySetPVPDelay(BasePlayer target, HitInfo info, bool skipDelay, string key);
    public void ExpireAllDelays();
    private object[] GetDelayHookObjects(BasePlayer target);
    public void SetPVPDelay(BasePlayer target, HitInfo info);
    public string GetAllowKey();
    private bool IsScavenging(BasePlayer player);
    private bool RemoveFauxAdmin(BasePlayer player);
    private bool IsBanned(BasePlayer player);
    private bool Teleported(BasePlayer player);
    public bool IsMounted(BasePlayer player);
    public bool IsMountable(BaseEntity entity);
    public bool IsHogging(BasePlayer player);
    public bool IsAllyHogging(BasePlayer player);
    private bool IsAllyHogging(BasePlayer player, RaidableBase raid);
    private void CheckBackpacks(bool bypass);
    private float RadiationProtection(BasePlayer player);
    private bool IsNullOrVoid(BaseEntity entity);
    public bool InRangeTolerance(Raider ri);
    private bool requiredLootPercentageMet;
    private void Protector();
    private void RejectPlayer(Raider ri);
    public void AddMember(ulong userid);
    public void FinalizeUi();
    public void StopSetupCoroutine();
    public void Despawn();
    public void LogEvent();
    public static void TryInvokeMethod(Action action);
    public void RemoveAllFromEvent();
    public void SendDronePatrol(RandomBase rb);
    private void CancellDrone(RandomBase rb);
    public void CheckSubscribe();
    public void DestroyElevators();
    public void DestroyEntities();
    public void SetPreventLooting();
    public void OnBuildingPrivilegeDestroyed();
    public bool IsOwnerConnected();
    public BasePlayer GetOwner();
    private List<BasePlayer> _intruders;
    public List<BasePlayer> GetIntruders();
    private List<BasePlayer> _raiders;
    public List<BasePlayer> GetRaiders(bool participantOnly);
    public int GetParticipantAmount();
    public bool AddLooter(BasePlayer looter, HitInfo info);
    public bool IsDamageBlocked(BaseEntity entity);
    public bool IsPickupBlacklisted(string name);
    private void FillAmmoTurret(AutoTurret turret);
    private void FillAmmoGunTrap(GunTrap gt);
    private ItemDefinition lowgradefuel;
    private void FillAmmoFogMachine(FogMachine fm);
    private void FillAmmoFlameTurret(FlameTurret ft);
    private void FillAmmoSamSite(SamSite ss);
    private bool IsAuthorized();
    private void OnWeaponItemPreRemove(Item item);
    public void TryToEnd();
    private void UnlockEverything();
    public bool GetInitiatorPlayer(HitInfo info, BaseCombatEntity entity, BasePlayer target);
    private List<string> fireAmmoTypes;
    public BasePlayer GetArsonist();
    public void SetAllowPVP(RandomBase rb);
    private bool CancelOnServerRestart();
    public void AwardRaiders();
    public bool RequiredLootPercentageMet(double requiredLootPercentage, double percentageMet);
    private void HandleAwards();
    private void AddGroupedPermission(string userid, string group, string perm);
    private bool CanAssignTo(ulong userid, ulong owner, bool only);
    public bool CanBypass(BasePlayer player);
    private bool Exceeds(BasePlayer player);
    public int GetParticipantsAmount();
    public string LangMode(string userid, bool strip);
    public string Mode(string userid, bool forceShowName);
    private void SetOwnerInternal(string username, ulong userid);
    public void SetOwner(BasePlayer owner);
    private float PlayerActivityTimeLeft(ulong userid);
    public bool IsPlayerActive(ulong userid);
    public void TrySetOwner(BasePlayer attacker, BaseEntity entity, HitInfo info);
    public void ResetRaiderRelations();
    public void ClearEnemies();
    public void CheckDespawn();
    public void CheckDespawn(HitInfo info);
    private float lastDespawnUpdateTime;
    public void UpdateDespawnDateTime(float time, HitInfo info);
    public bool EndWhenCupboardIsDestroyed();
    public bool CanUndo();
    private bool CanPlayerBeLooted(ulong looter, ulong target);
    private bool CanBeLooted(BasePlayer player, BaseEntity e);
    public bool IsProtectedWeapon(BaseEntity e, bool checkBuiltList);
    public bool IsWeapon(BaseEntity e);
    public bool IsFoundation(BaseEntity e);
    public bool IsCompound(BaseEntity e);
    public object CanLootEntityInternal(BasePlayer player, BaseEntity entity);
    public bool CanBuild(BasePlayer player);
    public static void ClearInventory(ItemContainer container);
    public void SetNoDrops();
    public void DestroyInputs();
    public void Init(RandomBase rb, List<BaseEntity> entities);
    private void SetupElevators();
    private List<string> setupBlockedPrefabs;
    private void AddEntities(List<BaseEntity> entities);
    private bool centerSetFromMultiplePoints;
    public void SetCenterFromMultiplePoints();
    private void CreateSpheres();
    private void SpawnSphere(string prefab);
    private void CreateZoneWalls();
    private List<TreeInfo> trees;
    public class TreeInfo
    {
        public Vector3 pos;
        public Quaternion rot;
        public string prefab;
        public BaseEntity tree;
        public TreeInfo(BaseEntity entity);
        public void Respawn();
    }

    private void RemoveClutter();
    private void RespawnTrees();
    private bool CanEjectMountable(BaseEntity m, PooledList<BasePlayer> players);
    private void DeployableItemHandler(BaseEntity e);
    public void ResetSleepingBags();
    private IEnumerator EntitySetup();
    private void TrySetupEntity(BaseEntity e, float invokeTime);
    private void SetupLights();
    public bool IsPasted;
    public void CheckPaste();
    private void SetupContainers();
    private void SetupWeaponRack(WeaponRack rack);
    private void SetupPickup(BaseCombatEntity e);
    private void AddContainer(StorageContainer container);
    private void RemoveContainer(StorageContainer container);
    public void TryEmptyContainer(StorageContainer container);
    private void SetupContainer(StorageContainer container);
    private void SetupIO(ContainerIOEntity io);
    private void SetupIO(IOEntity io);
    private void SetupLock(BaseEntity e, bool justCreated);
    private void SetupVendingMachine(VendingMachine vm);
    private void SetupLight(IOEntity light);
    private void SetupHBHFSensor(HBHFSensor sensor);
    private void SetupBattery(ElectricBattery eb);
    private void SetupGenerator(ElectricGenerator generator);
    private void SetupButton(PressButton button);
    private void SetupBuildingBlock(BuildingBlock block);
    private List<string> blockPrefabs;
    public bool HasSkin(BuildingBlock block, BuildingGrade.Enum grade, ulong skin);
    private void ChangeTier(BuildingBlock block);
    private Dictionary<BuildingGrade.Enum, ulong> skinWhole;
    private Dictionary<BuildingGrade.Enum, uint> skinColors;
    private void SetupTeslaCoil(TeslaCoil tc);
    private void SetupIgniter(Igniter igniter);
    public void PreSetupTurret(AutoTurret turret);
    private void SetupTurret(AutoTurret turret);
    private readonly Dictionary<NetworkableId, SphereCollider> _turretColliders;
    public void SetupSightRange(AutoTurret turret, float sightRange, int multi);
    private void SetupTurrets();
    private IEnumerator TurretsCoroutine();
    public bool UsableByTurret;
    private void EquipTurretWeapon(AutoTurret turret, PooledList<string> shortnames, bool setter);
    private bool CanAcceptItem(Item item, int targetPos);
    private void UpdateAttachedWeapon(AutoTurret turret);
    private void InitiateStartup(AutoTurret turret);
    private void Authorize(BasePlayer player);
    private bool CanBypassAuthorized(ulong userid);
    private void SetupGunTrap(GunTrap gt);
    private void SetupFogMachine(FogMachine fm);
    private void SetupSprinkler(Sprinkler sprinkler);
    private void SetupBurn(BaseEntity entity);
    private void SetupOven(BaseOven oven);
    private void SetupFlameTurret(FlameTurret ft);
    private void SetupSamSite(SamSite ss);
    private bool ChangeTier(Door door);
    private bool SetDoorType(Door door, string prefab);
    private void SetupDoor(Door door);
    private void SetupDoor(Door door, bool changed);
    private void SetupDoors();
    private void SetupDoorControllers();
    private void SetupPairedDoor(Door door);
    private void CreateLock(BaseEntity entity, bool createKeyLock, bool createCodeLock);
    private void CreateKeyLock(BaseEntity entity);
    private void CreateCodeLock(BaseEntity entity);
    private void SetupBuildingPriviledge(BuildingPrivlidge priv);
    private void SetupLocker(Locker locker);
    private void SetupSleepingBag(SleepingBag bag);
    private void SetupCollectible(CollectibleEntity ce);
    private void SetupSpookySpeaker(SpookySpeaker ss);
    private void SetupDecayEntity(DecayEntity e);
    private void SetupBoxSkin(StorageContainer container);
    private void SetupSkin(BaseEntity entity);
    private void Subscribe();
    private void Subscribe(string hook);
    private void MakeAnnouncements();
    public void ResetPublicOwner();
    public void ResetEventLock();
    public void SpawnDrops(ItemContainer[] containers, List<LootItem> lootList);
    private bool SetupLoot();
    private bool SetupLootContainers(List<StorageContainer> containers);
    public class LootProfile
    {
        public List<LootItem> Base;
        public List<LootItem> Difficulty;
        public List<LootItem> Default;
        public List<LootItem> Tables;
        public TreasureSettings Unique;
        public BuildingOptions Options;
        public RaidableBases Instance;
        public string BaseName;
        public bool AllowPVP;
        public ulong UserID;
        public int Amount;
        public int Count { get; set; }
    }

    private bool IsItemBlockedInto(LootItem lootItem, StorageContainer container);
    private LootItem GetLootItem(List<LootItem> lootList);
    private void DivideLoot(List<LootItem> lootList, int amount, List<StorageContainer> containers);
    private static void TakeLootFromBaseLoot(LootProfile loot);
    private static void TakeLootFromDifficultyLoot(LootProfile loot);
    private static void TakeLootFromWeekdayLoot(LootProfile loot);
    private static void TakeLootFromDefaultLoot(LootProfile loot);
    private static void TakeLootFrom(List<LootItem> lootList, List<LootItem> to, BuildingOptions Options, ulong UserID, bool AllowPVP);
    private static void TakeLootFromLootTables(LootProfile loot);
    private static bool AddToLoot(LootProfile loot, LootItem lootItem);
    private static int[] GetStacks(int amount, int maxStack);
    private List<string> BuildingMaterials;
    private Item CreateItem(LootItem ti, int amount);
    private void SetupSellOrders();
    private bool MoveFood(Item item);
    private bool MoveToRack(Item item);
    private bool MoveToBBQ(Item item);
    private bool MoveToCupboard(Item item);
    private bool IsCookable(ItemDefinition def);
    private bool MoveToOven(Item item);
    private bool SplitIntoFurnaces(List<BaseOven> ovens, Item item);
    private bool IsLockerItem(ItemDefinition def);
    private bool MoveToLocker(Item item);
    private bool MoveToLocker(Item item, Locker locker);
    private void CheckExpansionSettings();
    private bool ToggleNpcMinerHat(HumanoidNPC npc, bool state);
    public void ToggleLights();
    public void Undo();
    public bool Any(ulong userid, bool checkAllies);
    private static bool IsBlacklistedSkin(ItemDefinition def, int num);
    public ulong GetItemSkin(ItemDefinition def, SkinType type, ulong defaultSkin, bool stackable, bool nonstackable, bool random, bool workshop, bool importedworkshop, bool approved, int stacksize);
    public SkinInfo GetItemSkins(ItemDefinition def, bool approvedOnly);
    private bool IsApproved(ItemDefinition def, ulong skin);
    private List<ulong> GetItemSkins(SkinInfo si, bool random, bool workshop, bool importedworkshop);
    private bool SetItemSkin(List<ulong> skins, SkinInfo si, BaseEntity entity, bool unique);
    public bool IsAlly(ulong playerId, ulong targetId, AlliedType type);
    public bool IsAlly(BasePlayer player);
    public void StopUsingWeapon(BasePlayer player);
    public void StopUsingWeapon(BasePlayer player, string[] weapons);
    private void StopUsingWeapon(BasePlayer player, Item item);
    public BackpackData AddBackpack(DroppedItemContainer container, ulong playerSteamID, BasePlayer player);
    private void RemoveParentFromEntitiesOnElevators();
    public bool EjectBackpack(BackpackData backpack, bool bypass);
    private void EjectBackpackNotice(BasePlayer player, Vector3 position);
    private void EjectSleepers();
    public Vector3 GetEjectLocation(Vector3 a, float distance, Vector3 target, float radius, bool towardsZero, bool setHeight);
    public bool RemovePlayer(BasePlayer player, Vector3 a, float radius, RaidableType type, bool special);
    public void Teleport(BasePlayer player);
    public void DismountAllPlayers(BaseMountable m);
    public static PooledList<BasePlayer> GetMountedPlayers(HotAirBalloon m);
    public static PooledList<BasePlayer> GetMountedPlayers(BaseMountable m);
    public static bool AnyMounted(BaseMountable m);
    private bool CanEject(PooledList<BasePlayer> players);
    private bool CanEject(BasePlayer target);
    public bool CanEjectEnemy();
    private bool CannotEnter(BasePlayer target, bool justEntered);
    public bool IsControlledMount(BaseEntity m);
    private bool IsBlockingCampers(ModularCar car);
    private bool TryRemoveMountable(BaseEntity m, PooledList<BasePlayer> players);
    private bool ShouldEject(ManagementMountableSettings ms, BaseEntity m, bool jetpack, bool carpet);
    public static bool IsWearingJetpack(BasePlayer player);
    public static bool IsJetpack(BaseMountable m);
    public static bool IsInvisibleChair(BaseEntity m);
    public static void TryPushMountable(BaseVehicle vehicle, Vector3 target, float minDistance);
    private static void ApplyMassForce(BaseVehicle vehicle, Rigidbody body, Vector3 target);
    private static void ApplyModularCarForce(BaseVehicle vehicle, Rigidbody body, Vector3 target, float forceMultiplier);
    private static void ApplyHelicopterOrParachuteForce(BaseVehicle vehicle, Rigidbody body, Vector3 target, float forceMultiplier, bool b);
    private static void ApplyDefaultForce(BaseVehicle vehicle, Rigidbody body, float forceMultiplier);
    private static bool IsFlying(BasePlayer player);
    private void TryEjectMountable(BaseEntity e);
    private void EjectContainer(BaseEntity container, ulong playerSteamID, bool notice);
    private float habdist;
    public bool Eject(BaseEntity m, Vector3 position, float radius, bool groundLevel);
    public bool EjectMountable(BaseMountable m, PooledList<BasePlayer> players, Vector3 position, float radius, bool special);
    private static T GetParentEntity(T m);
    public bool CanSetupEntity(BaseEntity e);
    public void TryRespawnNpc(bool isMurderer);
    private void SetInvokingRespawnNpc(bool isMurderer, bool value);
    private void RespawnNpcNow(bool isMurderer);
    public void SpawnNpcs();
    public bool NearFoundation(Vector3 from, float range);
    public bool FindPointOnNavmesh(Vector3 a, float radius, Vector3 v);
    private bool IsAcceptableWaterDepth(Vector3 position);
    private bool TestInsideObject(Vector3 position);
    private bool TestClippedInside(Vector3 position, float radius, int mask);
    private bool TestInsideRock(Vector3 a);
    private bool IsInVerticalRange(Vector3 a, RaycastHit hit);
    private List<string> _prefabs;
    private bool IsRock(string name);
    private bool InstantiateEntity(List<Vector3> wander, Vector3 position, HumanoidBrain brain, HumanoidNPC npc);
    private List<Vector3> GetPositionsNearestTo(List<Vector3> wander, Vector3 a, float sqrSenseRange);
    private List<Vector3> GetWanderPositions(float radius);
    private float GetRoamRadius();
    private float GetSpawnRadius();
    private HumanoidNPC SpawnNpc(bool isMurderer);
    public class Loadout
    {
        public List<PlayerInventoryProperties.ItemAmountSkinned> belt;
        public List<PlayerInventoryProperties.ItemAmountSkinned> main;
        public List<PlayerInventoryProperties.ItemAmountSkinned> wear;
    }

    private PlayerInventoryProperties GetLoadout(HumanoidNPC npc, HumanoidBrain brain);
    private Loadout CreateLoadout(HumanoidNPC npc, HumanoidBrain brain);
    private void AddItemAmountSkinned(List<PlayerInventoryProperties.ItemAmountSkinned> source, List<string> shortnames);
    private readonly List<string> _murdererPrefabNames;
    private void SetupNpc(HumanoidNPC npc, HumanoidBrain brain, List<Vector3> positions);
    private void SetupAlternateLoot(HumanoidNPC npc, HumanoidBrain brain);
    private bool isKitted;
    private void GiveKit(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
    private void UpdateItems(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
    public void EquipWeapon(HumanoidNPC npc, HumanoidBrain brain);
    private bool IsNpcNearSpot(Vector3 position);
    private void SetupNpcKits();
    public string DespawnString { get; set; }
    public double DespawnTime { get; set; }
    public string MarkerName { get; set; }
    public void ForceUpdateMarker();
    public void UpdateMarker();
    private void CreateGenericMarker();
    private void DestroyMapNote(BasePlayer owner);
    private ProtoBuf.MapNote mapNote;
    private bool TryParseHtmlString(string value, Color color);
    private Color GetMarkerColor1();
    private Color GetMarkerColor2();
    private bool IsMarkerAllowed();
    public void DestroyLocks();
    public void DestroyNpcs();
    public void DestroySpheres();
    public void DestroyMapMarkers();
}

public class TreeInfo
{
    public Vector3 pos;
    public Quaternion rot;
    public string prefab;
    public BaseEntity tree;
    public TreeInfo(BaseEntity entity);
    public void Respawn();
}

public class LootProfile
{
    public List<LootItem> Base;
    public List<LootItem> Difficulty;
    public List<LootItem> Default;
    public List<LootItem> Tables;
    public TreasureSettings Unique;
    public BuildingOptions Options;
    public RaidableBases Instance;
    public string BaseName;
    public bool AllowPVP;
    public ulong UserID;
    public int Amount;
    public int Count { get; set; }
}

public class Loadout
{
    public List<PlayerInventoryProperties.ItemAmountSkinned> belt;
    public List<PlayerInventoryProperties.ItemAmountSkinned> main;
    public List<PlayerInventoryProperties.ItemAmountSkinned> wear;
}

public class SpawnsControllerManager
{
    internal YieldInstruction instruction0;
    internal List<ZoneInfo> managedZones;
    internal List<string> assets;
    internal List<string> AdditionalBlockedColliders;
    internal List<string> _materialNames;
    internal List<MonumentInfoEx> Monuments;
    public RaidableBases Instance;
    internal Configuration config { get; set; }
    public class MonumentInfoEx
    {
        public float radius;
        public string text;
        public Vector3 position;
        public MonumentInfoEx(string text, Vector3 position, float radius);
    }

    public void Initialize();
    private bool IsMonumentMarkerBlocked(string category);
    public IEnumerator SetupMonuments();
    public IEnumerator CalculateMonumentSize(Vector3 from, string text);
    public PooledList<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next, bool spawnHeight, bool shouldSkipSmallRock, float y);
    private bool IsValidMaterial(string materialName);
    private bool ShouldSkipSmallRock(RaycastHit hit, string colName);
    public float GetSpawnHeight(Vector3 target, bool max, bool skip, int mask);
    public bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position, float radius);
    public bool IsLocationBlocked(Vector3 v);
    public bool IsZoneBlocked(Vector3 v);
    private bool IsValidLocation(Vector3 v, float safeRadius, float minProtectionRadius, float railRadius);
    internal bool TopologyChecks(Vector3 v, float radius, float railRadius, string topology);
    private bool HasPointOnPathList(List<PathList> paths, Vector3 point, float radius);
    public bool IsBlockedByMapPrefab(List<(Vector3 pos, float dist)> prefabs, Vector3 position);
    public void ExtractLocation(RaidableSpawns spawns, Vector3 position, float maxLandLevel, float minProtectionRadius, float maxProtectionRadius, float railRadius, float maxWaterDepth);
    public bool IsSubmerged(BuildingWaterOptions options, RaidableSpawnLocation rsl);
    public bool IsSubmerged(BuildingWaterOptions options, RaidableSpawnLocation rsl, float radius);
    public bool IsMonumentPosition(Vector3 a, float extra);
    private List<(Vector3 position, float sqrDistance)> safeZones;
    private bool IsSafeZone(Vector3 a, float extra);
    public bool IsAssetBlocked(BaseEntity entity, string colName, string entityName);
    public bool IsAreaSafe(Vector3 area, float ignoreRadius, float protectionRadius, float cupboardRadius, float worldRadius, int layers, bool isCustomSpawn, CacheType cacheType, RaidableType type);
    public bool IsTutorialNetworkGroup(BaseEntity entity);
    public bool CanIgnoreDeployable();
    public MinMax GetLandLevel(Vector3 from, float radius, BasePlayer player);
    public bool IsFlatTerrain(Vector3 from, MinMax landLevel, float maxLandLevel);
    public bool InDeepWater(Vector3 v, bool seabed, float minDepth, float maxDepth);
    public void SetupZones(Plugin ZoneManager, bool message);
    public bool AddZone(Plugin ZoneManager, string zoneId);
    public bool IsObstructed(Vector3 a, float radius, float landLevel, float forcedHeight, BasePlayer player);
}

public class MonumentInfoEx
{
    public float radius;
    public string text;
    public Vector3 position;
    public MonumentInfoEx(string text, Vector3 position, float radius);
}

private class PlayerExclusion : Pool.IPooled
{
    public Plugin plugin;
    public float time;
    public bool IsExpired { get; set; }
    public void EnterPool();
    public void LeavePool();
}

public class UndoLoopSettings
{
    public bool LogToFile;
    public bool DespawnMounts;
    public bool KeepStructures;
    public bool KeepDeployables;
    public UndoLoopSettings();
    public UndoLoopSettings(ManagementSettings ms, bool logToFile);
}

public class UndoLoopComparer : IComparer<BaseNetworkable>
{
    public Dictionary<string, ItemDefinition> DeployableItems;
    public Func<BaseEntity, bool, bool> IsBox;
    private int Evaluate(BaseNetworkable entity);
    public int Compare(BaseNetworkable x, BaseNetworkable y);
}

private class CustomPatrol
{
    public string pluginName;
    public Vector3 position;
    public PositionSetting settingPosition;
    public DroneSetting settingDrone;
    internal class DroneSetting
    {
        public int droneCountSpawned;
        public int droneAttackedCount;
        public Dictionary<string, int> keyDrones;
    }

    internal class PositionSetting
    {
        public int countSpawnPoint;
        public int radiusFindedPoints;
    }

}

internal class DroneSetting
{
    public int droneCountSpawned;
    public int droneAttackedCount;
    public Dictionary<string, int> keyDrones;
}

internal class PositionSetting
{
    public int countSpawnPoint;
    public int radiusFindedPoints;
}

public class Notification : Pool.IPooled
{
    public BasePlayer player;
    public string messageEx;
    public void Reset();
    public void EnterPool();
    public void LeavePool();
}

public class SkinsPlugin
{
    [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<SkinItem> Skins;
}

public class SkinItem
{
    [JsonProperty(PropertyName = "Item Shortname")]
    public string Shortname;
    [JsonProperty(PropertyName = "Permission")]
    public string Permission;
    [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> Skins;
}

public class Color1Settings
{
    [JsonProperty(PropertyName = "Normal")]
    public string Normal;
    public string Get();
}

public class Color2Settings
{
    [JsonProperty(PropertyName = "Normal")]
    public string Normal;
    public string Get();
}

public class ManagementMountableSettings
{
    [JsonProperty(PropertyName = "All Controlled Mounts")]
    public bool ControlledMounts;
    [JsonProperty(PropertyName = "All Other Mounts")]
    public bool Other;
    [JsonProperty(PropertyName = "Attack Helicopters")]
    public bool AttackHelicopters;
    [JsonProperty(PropertyName = "Bikes")]
    public bool Bikes;
    [JsonProperty(PropertyName = "Boats")]
    public bool Boats;
    [JsonProperty(PropertyName = "Campers")]
    public bool Campers;
    [JsonProperty(PropertyName = "Cars (Basic)")]
    public bool BasicCars;
    [JsonProperty(PropertyName = "Cars (Modular)")]
    public bool ModularCars;
    [JsonProperty(PropertyName = "Chinook")]
    public bool CH47;
    [JsonProperty(PropertyName = "Flying Carpet")]
    public bool FlyingCarpet;
    [JsonProperty(PropertyName = "Horses")]
    public bool Horses;
    [JsonProperty(PropertyName = "HotAirBalloon")]
    public bool HotAirBalloon;
    [JsonProperty(PropertyName = "Invisible Chair")]
    public bool Invisible;
    [JsonProperty(PropertyName = "Jetpacks")]
    public bool Jetpacks;
    [JsonProperty(PropertyName = "MiniCopters")]
    public bool MiniCopters;
    [JsonProperty(PropertyName = "Parachutes")]
    public bool Parachutes;
    [JsonProperty(PropertyName = "Pianos")]
    public bool Pianos;
    [JsonProperty(PropertyName = "Scrap Transport Helicopters")]
    public bool Scrap;
    [JsonProperty(PropertyName = "Siege")]
    public bool Siege;
    [JsonProperty(PropertyName = "Snowmobiles")]
    public bool Snowmobile;
    [JsonProperty(PropertyName = "Tugboats")]
    public bool Tugboats;
}

public class BuildingOptionsSetupSettings
{
    [JsonProperty(PropertyName = "Amount Of Entities To Spawn Per Batch")]
    public int SpawnLimit;
    [JsonProperty(PropertyName = "Amount Of Entities To Despawn Per Batch")]
    public int DespawnLimit;
    [JsonProperty(PropertyName = "Height Adjustment Applied To This Paste")]
    public float PasteHeightAdjustment;
    [JsonProperty(PropertyName = "Force All Bases To Spawn At Height Level (0 = Water)")]
    public float ForcedHeight;
    [JsonProperty(PropertyName = "Foundations Immune To Damage When Forced Height Is Applied")]
    public bool FoundationsImmuneForcedHeight;
    [JsonProperty(PropertyName = "Foundations Immune To Damage")]
    public bool FoundationsImmune;
    [JsonProperty(PropertyName = "Kill These Prefabs After Paste", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlockedPrefabs;
}

public class ManagementPlayerAmountsSettings
{
    [JsonProperty(PropertyName = "Maintained Events")]
    public int Maintained;
    [JsonProperty(PropertyName = "Manual Events")]
    public int Manual;
    [JsonProperty(PropertyName = "Scheduled Events")]
    public int Scheduled;
    [JsonProperty(PropertyName = "Bypass For PVP Bases")]
    public bool BypassPVP;
    public int Get(RaidableType type);
}

public class ManagementDropSettings
{
    [JsonProperty(PropertyName = "Auto Turrets")]
    public bool AutoTurret;
    [JsonProperty(PropertyName = "Flame Turret")]
    public bool FlameTurret;
    [JsonProperty(PropertyName = "Fog Machine")]
    public bool FogMachine;
    [JsonProperty(PropertyName = "Gun Trap")]
    public bool GunTrap;
    [JsonProperty(PropertyName = "SAM Site")]
    public bool SamSite;
}

public class ManagementSettingsLocations
{
    [JsonProperty(PropertyName = "position")]
    public string _position;
    public float radius;
    public ManagementSettingsLocations();
    public ManagementSettingsLocations(Vector3 position, float radius);
    [JsonIgnore]
    public Vector3 position { get; set; }
}

public class ManagementSettings
{
    [JsonProperty(PropertyName = "Grids To Block Spawns At", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlockedGrids;
    [JsonProperty(PropertyName = "Block Spawns At Positions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ManagementSettingsLocations> BlockedPositions;
    [JsonProperty(PropertyName = "Blocked Monument Markers (* = everything)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlockedMonumentMarkers;
    [JsonProperty(PropertyName = "Additional Map Prefabs To Block Spawns At", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, float> BlockedPrefabs;
    [JsonProperty(PropertyName = "Eject Mounts")]
    public ManagementMountableSettings Mounts;
    [JsonProperty(PropertyName = "Max Amount Of Players Allowed To Enter (0 = infinite, -1 = none)")]
    public ManagementPlayerAmountsSettings Players;
    [JsonProperty(PropertyName = "Additional Containers To Include As Boxes", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Inherit;
    [JsonProperty(PropertyName = "Difficulty Colors (Border)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Color1Settings Colors1;
    [JsonProperty(PropertyName = "Difficulty Colors (Inner)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Color2Settings Colors2;
    [JsonProperty(PropertyName = "Entities Allowed To Drop Loot")]
    public ManagementDropSettings DropLoot;
    [JsonProperty(PropertyName = "Additional Blocked Colliders", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> AdditionalBlockedColliders;
    [JsonProperty(PropertyName = "Allow Teleport")]
    public bool AllowTeleport;
    [JsonProperty(PropertyName = "Allow Teleport Ignores Respawning")]
    public bool AllowRespawn;
    [JsonProperty(PropertyName = "Allow Cupboard Loot To Drop")]
    public bool AllowCupboardLoot;
    [JsonProperty(PropertyName = "Allow Players To Build", NullValueHandling = NullValueHandling.Ignore)]
    public bool? _AllowBuilding;
    [JsonProperty(PropertyName = "Allow Players To Use Ladders")]
    public bool AllowLadders;
    [JsonProperty(PropertyName = "Allow Players To Upgrade Event Buildings")]
    public bool AllowUpgrade;
    [JsonProperty(PropertyName = "Allow Player Bags To Be Lootable At PVP Bases")]
    public bool PlayersLootableInPVP;
    [JsonProperty(PropertyName = "Allow Player Bags To Be Lootable At PVE Bases")]
    public bool PlayersLootableInPVE;
    [JsonProperty(PropertyName = "Allow Players To Loot Traps")]
    public bool LootableTraps;
    [JsonProperty(PropertyName = "Allow Npcs To Target Other Npcs")]
    public bool TargetNpcs;
    [JsonProperty(PropertyName = "Allow Raid Bases Inland")]
    public bool AllowInland;
    [JsonProperty(PropertyName = "Allow Raid Bases On Beaches")]
    public bool AllowOnBeach;
    [JsonProperty(PropertyName = "Allow Raid Bases On Ice Sheets")]
    public bool AllowOnIceSheets;
    [JsonProperty(PropertyName = "Allow Raid Bases On Roads")]
    public bool AllowOnRoads;
    [JsonProperty(PropertyName = "Allow Raid Bases On Rivers")]
    public bool AllowOnRivers;
    [JsonProperty(PropertyName = "Allow Raid Bases On Railroads")]
    public bool AllowOnRailroads;
    [JsonProperty(PropertyName = "Allow Raid Bases On Building Topology")]
    public bool AllowOnBuildingTopology;
    [JsonProperty(PropertyName = "Allow Raid Bases On Monument Topology")]
    public bool AllowOnMonumentTopology;
    [JsonProperty(PropertyName = "Amount Of Spawn Position Checks Per Frame (ADVANCED USERS ONLY)")]
    public int SpawnChecks;
    [JsonProperty(PropertyName = "Allow Vending Machines To Broadcast")]
    public bool AllowBroadcasting;
    [JsonProperty(PropertyName = "Backpacks Can Be Opened At PVE Bases")]
    public bool BackpacksOpenPVE;
    [JsonProperty(PropertyName = "Backpacks Can Be Opened At PVP Bases")]
    public bool BackpacksOpenPVP;
    [JsonProperty(PropertyName = "Rust Backpacks Drop At PVE Bases")]
    public bool RustBackpacksPVE;
    [JsonProperty(PropertyName = "Rust Backpacks Drop At PVP Bases")]
    public bool RustBackpacksPVP;
    [JsonProperty(PropertyName = "Backpacks Drop At PVE Bases")]
    public bool BackpacksPVE;
    [JsonProperty(PropertyName = "Backpacks Drop At PVP Bases")]
    public bool BackpacksPVP;
    [JsonProperty(PropertyName = "Block Custom Loot Plugin")]
    public bool BlockCustomLootNPC;
    [JsonProperty(PropertyName = "Block Npc Kits Plugin")]
    public bool BlockNpcKits;
    [JsonProperty(PropertyName = "Block Helicopter Damage To Bases")]
    public bool BlockHelicopterDamage;
    [JsonProperty(PropertyName = "Block Mounted Damage To Bases And Players")]
    public bool BlockMounts;
    [JsonProperty(PropertyName = "Block Mini Collision Damage")]
    public bool MiniCollision;
    [JsonProperty(PropertyName = "Block DoubleJump Plugin")]
    public bool NoDoubleJump;
    [JsonProperty(PropertyName = "Block RestoreUponDeath Plugin For PVP Bases")]
    public bool BlockRestorePVP;
    [JsonProperty(PropertyName = "Block RestoreUponDeath Plugin For PVE Bases")]
    public bool BlockRestorePVE;
    [JsonProperty(PropertyName = "Block LifeSupport Plugin")]
    public bool NoLifeSupport;
    [JsonProperty(PropertyName = "Block Rewards During Server Restart")]
    public bool Restart;
    [JsonProperty(PropertyName = "Bypass Lock Treasure To First Attacker For PVE Bases")]
    public bool BypassUseOwnersForPVE;
    [JsonProperty(PropertyName = "Bypass Lock Treasure To First Attacker For PVP Bases")]
    public bool BypassUseOwnersForPVP;
    [JsonProperty(PropertyName = "Despawn Spawned Mounts")]
    public bool DespawnMounts;
    [JsonProperty(PropertyName = "Do Not Destroy Player Built Deployables")]
    public bool KeepDeployables;
    [JsonProperty(PropertyName = "Do Not Destroy Player Built Structures")]
    public bool KeepStructures;
    [JsonProperty(PropertyName = "Distance To Spawn From Center Of Map")]
    public float Vector3ZeroDistance;
    [JsonProperty(PropertyName = "Divide Rewards Among All Raiders")]
    public bool DivideRewards;
    [JsonProperty(PropertyName = "Draw Corpse Time (Seconds)")]
    public float DrawTime;
    [JsonProperty(PropertyName = "Destroy Boxes Clipped Too Far Into Terrain")]
    public bool ClippedBoxes;
    [JsonProperty(PropertyName = "Destroy Turrets Clipped Too Far Into Terrain")]
    public bool ClippedTurrets;
    [JsonProperty(PropertyName = "Eject Sleepers Before Spawning Base")]
    public bool EjectSleepers;
    [JsonProperty(PropertyName = "Eject Scavengers When Raid Is Completed")]
    public bool EjectScavengers;
    [JsonProperty(PropertyName = "Eject Mountables Before Spawning A Base")]
    public bool EjectMountables;
    [JsonProperty(PropertyName = "Kill Deployables Before Spawning A Base")]
    public bool KillDeployables;
    [JsonProperty(PropertyName = "Eject Deployables Before Spawning A Base")]
    public bool EjectDeployables;
    [JsonProperty(PropertyName = "Extra Distance To Spawn From Monuments")]
    public float MonumentDistance;
    [JsonProperty(PropertyName = "Move Cookables Into Ovens")]
    public bool Cook;
    [JsonProperty(PropertyName = "Move Food Into BBQ Or Fridge")]
    public bool Food;
    [JsonProperty(PropertyName = "Blacklist For BBQ And Fridge", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public HashSet<string> Foods;
    [JsonProperty(PropertyName = "Move Weapons Onto Weapon Racks")]
    public bool Racks;
    [JsonProperty(PropertyName = "Move Resources Into Tool Cupboard")]
    public bool Cupboard;
    [JsonProperty(PropertyName = "Move Items Into Lockers")]
    public bool Lockers;
    [JsonProperty(PropertyName = "Divide Locker Loot When Enabled")]
    public bool DivideLockerLoot;
    [JsonProperty(PropertyName = "Lock Treasure To First Attacker")]
    public bool UseOwners;
    [JsonProperty(PropertyName = "Lock Treasure Max Inactive Time (Minutes)")]
    public float LockTime;
    [JsonProperty(PropertyName = "Lock Players To Raid Base After Entering Zone")]
    public bool LockToRaidOnEnter;
    [JsonProperty(PropertyName = "Only Award First Attacker and Allies")]
    public bool OnlyAwardAllies;
    [JsonProperty(PropertyName = "Only Award Owner Of Raid")]
    public bool OnlyAwardOwner;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Looting (min: 1)")]
    public int DespawnMinutes;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Looting Resets When Damaged")]
    public bool DespawnMinutesReset;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive (0 = disabled)")]
    public int DespawnMinutesInactive;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive Resets When Damaged")]
    public bool DespawnMinutesInactiveReset;
    [JsonProperty(PropertyName = "Mounts Can Take Damage From Players")]
    public bool MountDamageFromPlayers;
    [JsonProperty(PropertyName = "Player Cupboard Detection Radius")]
    public float CupboardDetectionRadius;
    [JsonProperty(PropertyName = "PVP Delay Triggers When Entity Destroyed From Outside Zone")]
    public bool PVPDelayTrigger;
    [JsonProperty(PropertyName = "Players With PVP Delay Can Damage Anything Inside Zone")]
    public bool PVPDelayDamageInside;
    [JsonProperty(PropertyName = "Players With PVP Delay Can Damage Other Players With PVP Delay Anywhere")]
    public bool PVPDelayAnywhere;
    [JsonProperty(PropertyName = "PVP Delay Between Zone Hopping")]
    public float PVPDelay;
    [JsonProperty(PropertyName = "PVP Delay Between Zone Hopping Persists After Despawn")]
    public bool PVPDelayPersists;
    [JsonProperty(PropertyName = "Prevent Fire From Spreading")]
    public bool PreventFireFromSpreading;
    [JsonProperty(PropertyName = "Prevent Players From Hogging Raids")]
    public bool PreventHogging;
    [JsonProperty(PropertyName = "Block Clans From Owning More Than One Raid")]
    public bool BlockClans;
    [JsonProperty(PropertyName = "Block Friends From Owning More Than One Raid")]
    public bool BlockFriends;
    [JsonProperty(PropertyName = "Block Teams From Owning More Than One Raid")]
    public bool BlockTeams;
    [JsonProperty(PropertyName = "Block Players From Joining A Clan/Team To Exploit Restrictions")]
    public bool AllyExploit;
    [JsonProperty(PropertyName = "Prevent Fall Damage When Base Despawns")]
    public bool PreventFallDamage;
    [JsonProperty(PropertyName = "Require Cupboard To Be Looted Before Despawning", NullValueHandling = NullValueHandling.Ignore)]
    public bool? _RequireCupboardLooted;
    [JsonProperty(PropertyName = "Require Cupboard To Be Looted Before Completion")]
    public bool RequireCupboardLooted;
    [JsonProperty(PropertyName = "Destroying The Cupboard Completes The Raid")]
    public bool EndWhenCupboardIsDestroyed;
    [JsonProperty(PropertyName = "Require All Bases To Spawn Before Respawning An Existing Base")]
    public bool RequireAllSpawned;
    [JsonProperty(PropertyName = "Turn Lights On At Night")]
    public bool Lights;
    [JsonProperty(PropertyName = "Turn Lights On Indefinitely")]
    public bool AlwaysLights;
    [JsonProperty(PropertyName = "Ignore List For Turn Lights On", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> IgnoredLights;
    [JsonProperty(PropertyName = "Traps And Turrets Ignore Users Using NOCLIP")]
    public bool IgnoreFlying;
    [JsonProperty(PropertyName = "Use Random Codes On Code Locks")]
    public bool RandomCodes;
    [JsonProperty(PropertyName = "Wait To Start Despawn Timer When Base Takes Damage From Player")]
    public bool Engaged;
    [JsonProperty(PropertyName = "Wait To Start Despawn Timer Until Npc Is Killed By Player")]
    public bool EngagedNpc;
    [JsonProperty(PropertyName = "Maximum Water Depth For All Npcs")]
    public float WaterDepth;
    public bool IsBlocking();
}

public class ProfileDespawnOptions
{
    [JsonProperty(PropertyName = "Override Global Config With These Options For This Profile")]
    public bool OverrideConfig;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Looting (min: 1)")]
    public int DespawnMinutes;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Looting Resets When Damaged")]
    public bool DespawnMinutesReset;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive (0 = disabled)")]
    public int DespawnMinutesInactive;
    [JsonProperty(PropertyName = "Minutes Until Despawn After Inactive Resets When Damaged")]
    public bool DespawnMinutesInactiveReset;
    [JsonProperty(PropertyName = "Wait To Start Despawn Timer When Base Takes Damage From Player")]
    public bool Engaged;
    [JsonProperty(PropertyName = "Wait To Start Despawn Timer Until Npc Is Killed By Player")]
    public bool EngagedNpc;
}

public class PluginSettingsMapMarkers
{
    [JsonProperty(PropertyName = "Marker Name")]
    public string MarkerName;
    [JsonProperty(PropertyName = "Radius")]
    public float Radius;
    [JsonProperty(PropertyName = "Radius (Map Size 3600 Or Less)")]
    public float SubRadius;
    [JsonProperty(PropertyName = "Use Vending Map Marker")]
    public bool UseVendingMarker;
    [JsonProperty(PropertyName = "Show Owners Name on Map Marker")]
    public bool ShowOwnersName;
    [JsonProperty(PropertyName = "Use Explosion Map Marker")]
    public bool UseExplosionMarker;
    [JsonProperty(PropertyName = "Create Markers For Maintained Events")]
    public bool Maintained;
    [JsonProperty(PropertyName = "Create Markers For Scheduled Events")]
    public bool Scheduled;
    [JsonProperty(PropertyName = "Create Markers For Manual Events")]
    public bool Manual;
}

public class ExperimentalSettings
{
    [JsonProperty(PropertyName = "Apply Custom Auto Height To", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> AutoHeight;
    [JsonProperty(PropertyName = "Bunker Bases Or Profiles", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Bunker;
    [JsonProperty(PropertyName = "Multi Foundation Bases Or Profiles", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> MultiFoundation;
    public bool Contains(Type type, RandomBase rb);
}

public class WipeSettings
{
    [JsonProperty(PropertyName = "Wipe triggers when Rust protocol changes")]
    public bool Protocol;
    [JsonProperty(PropertyName = "Wipe triggers on detection of map wipe")]
    public bool Map;
    [JsonProperty(PropertyName = "Wipe includes current data")]
    public bool Current;
    [JsonProperty(PropertyName = "Wipe includes lifetime data (NOT recommended!)")]
    public bool Lifetime;
    [JsonProperty(PropertyName = "Manual wipe (command: rb wipe) revokes below permissions and groups from players")]
    public bool RemoveFromList;
    [JsonProperty(PropertyName = "Permissions and groups to revoke on wipe (command: rb revokepg)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Remove;
}

public class PluginSettings
{
    [JsonProperty(PropertyName = "Wipe Management (/data/RaidableBases.json)")]
    public WipeSettings Wipe;
    [JsonProperty(PropertyName = "Experimental [* = everything]")]
    public ExperimentalSettings Experimental;
    [JsonProperty(PropertyName = "Raid Management")]
    public ManagementSettings Management;
    [JsonProperty(PropertyName = "Map Markers")]
    public PluginSettingsMapMarkers Markers;
    [JsonProperty(PropertyName = "Maintained Events")]
    public RaidableBaseSettingsMaintained Maintained;
    [JsonProperty(PropertyName = "Manual Events")]
    public RaidableBaseSettingsManual Manual;
    [JsonProperty(PropertyName = "Scheduled Events")]
    public RaidableBaseSettingsScheduled Schedule;
    [JsonProperty(PropertyName = "Allowed Zone Manager Zones", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Inclusions;
    [JsonProperty(PropertyName = "Use Grid Locations In Allowed Zone Manager Zones Only")]
    public bool UseZoneManagerOnly;
    [JsonProperty(PropertyName = "Extended Distance To Spawn Away From Zone Manager Zones")]
    public float ZoneDistance;
    [JsonProperty(PropertyName = "Blacklisted Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlacklistedCommands;
    [JsonProperty(PropertyName = "Automatically Teleport Admins To Their Map Marker Positions")]
    public bool TeleportMarker;
    [JsonProperty(PropertyName = "Automatically Destroy Markers That Admins Teleport To")]
    public bool DestroyMarker;
    [JsonProperty(PropertyName = "Block Archery Plugin At Events")]
    public bool NoArchery;
    [JsonProperty(PropertyName = "Block Wizardry Plugin At Events")]
    public bool NoWizardry;
    [JsonProperty(PropertyName = "Block Weapons From Use", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlockedWeapons;
    [JsonProperty(PropertyName = "Chat Steam64ID")]
    public ulong ChatID;
    [JsonProperty(PropertyName = "Expansion Mode (Dangerous Treasures)")]
    public bool ExpansionMode;
    [JsonProperty(PropertyName = "Remove Admins From Raiders List")]
    public bool RemoveAdminRaiders;
    [JsonProperty(PropertyName = "Show X Z Coordinates")]
    public bool ShowXZ;
    [JsonProperty(PropertyName = "Show Grid Coordinates")]
    public bool ShowGrid;
    [JsonProperty(PropertyName = "Show Direction To Coordinates")]
    public bool ShowDir;
    [JsonProperty(PropertyName = "Event Command")]
    public string EventCommand;
    [JsonProperty(PropertyName = "Hunter Command")]
    public string HunterCommand;
    [JsonProperty(PropertyName = "Server Console Command")]
    public string ConsoleCommand;
}

public class EventMessageRewardSettings
{
    [JsonProperty(PropertyName = "Flying")]
    public bool Flying;
    [JsonProperty(PropertyName = "Vanished")]
    public bool Vanished;
    [JsonProperty(PropertyName = "Inactive")]
    public bool Inactive;
    [JsonProperty(PropertyName = "Not An Ally")]
    public bool NotAlly;
    [JsonProperty(PropertyName = "Not The Owner")]
    public bool NotOwner;
    [JsonProperty(PropertyName = "Not A Participant")]
    public bool NotParticipant;
    [JsonProperty(PropertyName = "Remove Admins From Raiders List")]
    public bool RemoveAdmin;
}

public class EventMessageSettings
{
    [JsonProperty(PropertyName = "Show Message For Block Damage Outside Of The Dome To Players Inside")]
    public bool NoDamageFromOutsideToPlayersInside;
    [JsonProperty(PropertyName = "Ineligible For Rewards")]
    public EventMessageRewardSettings Rewards;
    [JsonProperty(PropertyName = "Announce Raid Unlocked")]
    public bool AnnounceRaidUnlock;
    [JsonProperty(PropertyName = "Announce Thief Message")]
    public bool AnnounceThief;
    [JsonProperty(PropertyName = "Announce PVE/PVP Enter/Exit Messages")]
    public bool AnnounceEnterExit;
    [JsonProperty(PropertyName = "Announce When Blocks Are Immune To Damage")]
    public bool BlocksImmune;
    [JsonProperty(PropertyName = "Show Destroy Warning")]
    public bool ShowWarning;
    [JsonProperty(PropertyName = "Show Opened Message For PVE Bases")]
    public bool OpenedPVE;
    [JsonProperty(PropertyName = "Show Opened Message For PVP Bases")]
    public bool OpenedPVP;
    [JsonProperty(PropertyName = "Show Prefix")]
    public bool Prefix;
    [JsonProperty(PropertyName = "Notify Plugin - Type (-1 = disabled)")]
    public int NotifyType;
    [JsonProperty(PropertyName = "Notification Interval")]
    public float Interval;
    [JsonProperty(PropertyName = "Send Messages To Player")]
    public bool Message;
    [JsonProperty(PropertyName = "Save Thieves To Log File")]
    public bool LogThieves;
}

public class GUIAnnouncementSettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Banner Tint Color")]
    public string TintColor;
    [JsonProperty(PropertyName = "Maximum Distance")]
    public float Distance;
    [JsonProperty(PropertyName = "Text Color")]
    public string TextColor;
}

public class NpcKitSettings
{
    [JsonProperty(PropertyName = "Helm", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Helm;
    [JsonProperty(PropertyName = "Torso", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Torso;
    [JsonProperty(PropertyName = "Pants", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Pants;
    [JsonProperty(PropertyName = "Gloves", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Gloves;
    [JsonProperty(PropertyName = "Boots", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Boots;
    [JsonProperty(PropertyName = "Shirt", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Shirt;
    [JsonProperty(PropertyName = "Kilts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Kilts;
    [JsonProperty(PropertyName = "Weapon", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Weapon;
    public NpcKitSettings(bool isMurderer);
}

public class NpcMultiplierSettings
{
    [JsonProperty(PropertyName = "Explosive Damage Multiplier")]
    public float ExplosiveDamageMultiplier;
    [JsonProperty(PropertyName = "Gun Damage Multiplier")]
    public float ProjectileDamageMultiplier;
    [JsonProperty(PropertyName = "Melee Damage Multiplier")]
    public float MeleeDamageMultiplier;
}

public class NpcSettingsAccuracyDifficulty
{
    [JsonProperty(PropertyName = "AK47")]
    public double AK47;
    [JsonProperty(PropertyName = "AK47 ICE")]
    public double AK47ICE;
    [JsonProperty(PropertyName = "Bolt Rifle")]
    public double BOLT_RIFLE;
    [JsonProperty(PropertyName = "Compound Bow")]
    public double COMPOUND_BOW;
    [JsonProperty(PropertyName = "Crossbow")]
    public double CROSSBOW;
    [JsonProperty(PropertyName = "Double Barrel Shotgun")]
    public double DOUBLE_SHOTGUN;
    [JsonProperty(PropertyName = "Eoka")]
    public double EOKA;
    [JsonProperty(PropertyName = "Glock")]
    public double GLOCK;
    [JsonProperty(PropertyName = "HMLMG")]
    public double HMLMG;
    [JsonProperty(PropertyName = "L96")]
    public double L96;
    [JsonProperty(PropertyName = "LR300")]
    public double LR300;
    [JsonProperty(PropertyName = "M249")]
    public double M249;
    [JsonProperty(PropertyName = "M39")]
    public double M39;
    [JsonProperty(PropertyName = "M92")]
    public double M92;
    [JsonProperty(PropertyName = "MP5")]
    public double MP5;
    [JsonProperty(PropertyName = "Nailgun")]
    public double NAILGUN;
    [JsonProperty(PropertyName = "Pump Shotgun")]
    public double PUMP_SHOTGUN;
    [JsonProperty(PropertyName = "Python")]
    public double PYTHON;
    [JsonProperty(PropertyName = "Revolver")]
    public double REVOLVER;
    [JsonProperty(PropertyName = "Semi Auto Pistol")]
    public double SEMI_AUTO_PISTOL;
    [JsonProperty(PropertyName = "Semi Auto Rifle")]
    public double SEMI_AUTO_RIFLE;
    [JsonProperty(PropertyName = "Spas12")]
    public double SPAS12;
    [JsonProperty(PropertyName = "Speargun")]
    public double SPEARGUN;
    [JsonProperty(PropertyName = "SMG")]
    public double SMG;
    [JsonProperty(PropertyName = "Snowball Gun")]
    public double SNOWBALL_GUN;
    [JsonProperty(PropertyName = "Thompson")]
    public double THOMPSON;
    [JsonProperty(PropertyName = "Waterpipe Shotgun")]
    public double WATERPIPE_SHOTGUN;
    public NpcSettingsAccuracyDifficulty(double accuracy);
    public double Get(HumanoidBrain brain);
}

public class ScientistLootSettings
{
    [JsonProperty(PropertyName = "Prefab ID List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> IDs;
    [JsonProperty(PropertyName = "Enabled", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public bool Enabled;
    [JsonProperty(PropertyName = "Disable All Prefab Loot Spawns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public bool None;
    public uint GetRandom(List<string> ids);
}

public class NpcSettings
{
    public NpcSettings();
    public NpcSettings(double accuracy);
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Decrease Damage Linearly From Npcs With A Maximum Effective Range Of")]
    public float NpcMaxEffectiveRange;
    [JsonProperty(PropertyName = "Decrease Damage Linearly From Players With A Maximum Effective Range Of")]
    public float PlayerMaxEffectiveRange;
    [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
    public NpcSettingsAccuracyDifficulty Accuracy;
    [JsonProperty(PropertyName = "Damage Multipliers")]
    public NpcMultiplierSettings Multipliers;
    [JsonProperty(PropertyName = "Murderer Items Dropped On Death", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> MurdererDrops;
    [JsonProperty(PropertyName = "Scientist Items Dropped On Death", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> ScientistDrops;
    [JsonProperty(PropertyName = "Murderer (Items)")]
    public NpcKitSettings MurdererLoadout;
    [JsonProperty(PropertyName = "Scientist (Items)")]
    public NpcKitSettings ScientistLoadout;
    [JsonProperty(PropertyName = "Murderer Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> MurdererKits;
    [JsonProperty(PropertyName = "Scientist Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> ScientistKits;
    [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> RandomNames;
    [JsonProperty(PropertyName = "Spawn Alternate Default Scientist Loot")]
    public ScientistLootSettings AlternateScientistLoot;
    [JsonProperty(PropertyName = "Amount Of Murderers To Spawn")]
    public int SpawnAmountMurderers;
    [JsonProperty(PropertyName = "Minimum Amount Of Murderers To Spawn")]
    public int SpawnMinAmountMurderers;
    [JsonProperty(PropertyName = "Spawn Random Amount Of Murderers")]
    public bool SpawnRandomAmountMurderers;
    [JsonProperty(PropertyName = "Amount Of Scientists To Spawn")]
    public int SpawnAmountScientists;
    [JsonProperty(PropertyName = "Minimum Amount Of Scientists To Spawn")]
    public int SpawnMinAmountScientists;
    [JsonProperty(PropertyName = "Spawn Random Amount Of Scientists")]
    public bool SpawnRandomAmountScientists;
    [JsonProperty(PropertyName = "Allow Npcs To Leave Dome When Attacking")]
    public bool CanLeave;
    [JsonProperty(PropertyName = "Allow Npcs To Shoot Players Outside Of The Dome")]
    public bool CanShoot;
    [JsonProperty(PropertyName = "Aggression Range")]
    public float AggressionRange;
    [JsonProperty(PropertyName = "Block Damage Outside To Npcs When Not Allowed To Leave Dome")]
    public bool BlockOutsideDamageOnLeave;
    [JsonProperty(PropertyName = "Block Damage Outside Of The Dome To Npcs Inside")]
    public bool BlockOutsideDamageToNpcsInside;
    [JsonProperty(PropertyName = "Despawn Inventory On Death")]
    public bool DespawnInventory;
    [JsonProperty(PropertyName = "Health For Murderers (100 min, 5000 max)")]
    public float MurdererHealth;
    [JsonProperty(PropertyName = "Health For Scientists (100 min, 5000 max)")]
    public float ScientistHealth;
    [JsonProperty(PropertyName = "Kill Underwater Npcs")]
    public bool KillUnderwater;
    [JsonProperty(PropertyName = "Player Traps And Turrets Ignore Npcs")]
    public bool IgnorePlayerTrapsTurrets;
    [JsonProperty(PropertyName = "Event Traps And Turrets Ignore Npcs")]
    public bool IgnoreTrapsTurrets;
    [JsonProperty(PropertyName = "Use Dangerous Treasures NPCs")]
    public bool UseExpansionNpcs;
}

public class PasteOption
{
    [JsonProperty(PropertyName = "Option")]
    public string Key;
    [JsonProperty(PropertyName = "Value")]
    public string Value;
}

public class BuildingLevels
{
    [JsonProperty(PropertyName = "Level 2 - Final Death")]
    public bool Level2;
}

public class DoorTypes
{
    [JsonProperty(PropertyName = "Wooden")]
    public bool Wooden;
    [JsonProperty(PropertyName = "Metal")]
    public bool Metal;
    [JsonProperty(PropertyName = "HQM")]
    public bool HQM;
    [JsonProperty(PropertyName = "Include Garage Doors")]
    public bool GarageDoor;
    public bool Any();
}

public class BuildingGradeLevels
{
    [JsonProperty(PropertyName = "Wooden")]
    public bool Wooden;
    [JsonProperty(PropertyName = "Stone")]
    public bool Stone;
    [JsonProperty(PropertyName = "Metal")]
    public bool Metal;
    [JsonProperty(PropertyName = "HQM")]
    public bool HQM;
    public bool Any();
}

public class BuildingOptionsAutoTurrets
{
    [JsonProperty(PropertyName = "Aim Cone")]
    public float AimCone;
    [JsonProperty(PropertyName = "Wait To Power On Until Event Starts")]
    public bool InitiateOnSpawn;
    [JsonProperty(PropertyName = "Minimum Damage Modifier")]
    public float Min;
    [JsonProperty(PropertyName = "Maximum Damage Modifier")]
    public float Max;
    [JsonProperty(PropertyName = "Start Health")]
    public float Health;
    [JsonProperty(PropertyName = "Sight Range")]
    public float SightRange;
    [JsonProperty(PropertyName = "Double Sight Range When Shot")]
    public bool AutoAdjust;
    [JsonProperty(PropertyName = "Set Hostile (False = Do Not Set Any Mode)")]
    public bool Hostile;
    [JsonProperty(PropertyName = "Requires Power Source")]
    public bool RequiresPower;
    [JsonProperty(PropertyName = "Remove Equipped Weapon")]
    public bool RemoveWeapon;
    [JsonProperty(PropertyName = "Random Weapons To Equip When Unequipped", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Shortnames;
}

public class BuildingOptionsProtectionRadius
{
    [JsonProperty(PropertyName = "Maintained Events")]
    public float Maintained;
    [JsonProperty(PropertyName = "Manual Events")]
    public float Manual;
    [JsonProperty(PropertyName = "Scheduled Events")]
    public float Scheduled;
    [JsonProperty(PropertyName = "Obstruction Distance Check")]
    public float Obstruction;
    public void Set(float value);
    public float Get(RaidableType type);
    public float Max();
    public float Min();
}

public class BuildingWaterOptions
{
    [JsonProperty(PropertyName = "Allow Bases To Float Above Water")]
    public bool AllowSubmerged;
    [JsonProperty(PropertyName = "Prevent Bases From Floating Above Water By Also Checking Surrounding Area")]
    public bool SubmergedAreaCheck;
    [JsonProperty(PropertyName = "Maximum Water Depth Level Used For Float Above Water Option")]
    public float WaterDepth;
    [JsonProperty(PropertyName = "Torpedo Damage Multiplier (Min)")]
    public float TorpedoMin;
    [JsonProperty(PropertyName = "Torpedo Damage Multiplier (Max)")]
    public float TorpedoMax;
    internal float OceanLevel;
}

public class IQDronePatrolSettings
{
    [JsonProperty("Use drone support")]
    public bool UseDronePatrol;
    [JsonProperty("How many drones will be spawned near the base?")]
    public int droneCountSpawned;
    [JsonProperty("How many drones can attack simultaneously?")]
    public int droneAttackedCount;
    [JsonProperty("Drone presets configuration [Drone preset key from the drone config] - chance")]
    public Dictionary<String, int> keyDrones;
}

public class PlayerDamageMultiplier
{
    [JsonProperty(PropertyName = "Type")]
    public string Type;
    [JsonProperty(PropertyName = "Min")]
    public float Min;
    [JsonProperty(PropertyName = "Max")]
    public float Max;
    internal float amount { get; set; }
    internal DamageType[] _damageTypes;
    internal DamageType index { get; set; }
    public PlayerDamageMultiplier();
    public PlayerDamageMultiplier(string type, float min, float max);
}

public class SiegeSettings
{
    [JsonProperty(PropertyName = "Allow Siege Raiding Only")]
    public bool Only;
    [JsonProperty(PropertyName = "Damage Multiplier")]
    public float SiegeMultiplier;
    [JsonProperty(PropertyName = "Damage Multiplier (Ballista)")]
    public float BallistaMultiplier;
    [JsonProperty(PropertyName = "Damage Multiplier (Catapult)")]
    public float CatapultMultiplier;
    [JsonProperty(PropertyName = "Damage Multiplier (Ram)")]
    public float RamMultiplier;
    public void Scale(HitInfo info);
    public bool IsSiegeTool(BasePlayer attacker, HitInfo info);
    public SiegeSettings();
}

public class BuildingOptions
{
    internal float GetLandLevel { get; set; }
    public BuildingOptions();
    public BuildingOptions(string[] bases);
    [JsonProperty(PropertyName = "Advanced Protection Radius")]
    public BuildingOptionsProtectionRadius ProtectionRadii;
    [JsonProperty(PropertyName = "Advanced Setup Settings")]
    public BuildingOptionsSetupSettings Setup;
    [JsonProperty(PropertyName = "Despawn Options Override")]
    public ProfileDespawnOptions DespawnOptions;
    [JsonProperty(PropertyName = "Elevators")]
    public BuildingOptionsElevators Elevators;
    [JsonProperty(PropertyName = "Entities Not Allowed To Be Picked Up", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlacklistedPickupItems;
    [JsonProperty(PropertyName = "Additional Bases For This Difficulty", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<PasteOption>> AdditionalBases;
    [JsonProperty(PropertyName = "Paste Options", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<PasteOption> PasteOptions;
    [JsonProperty(PropertyName = "Arena Walls")]
    public RaidableBaseWallOptions ArenaWalls;
    [JsonProperty(PropertyName = "NPC Levels")]
    public BuildingLevels Levels;
    [JsonProperty(PropertyName = "NPCs")]
    public NpcSettings NPC;
    [JsonProperty(PropertyName = "Rewards")]
    public RewardSettings Rewards;
    [JsonProperty(PropertyName = "Change Building Material Tier To")]
    public BuildingGradeLevels Blocks;
    [JsonProperty(PropertyName = "Change Door Type To")]
    public DoorTypes Doors;
    [JsonProperty(PropertyName = "Player Damage To Base Multipliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<PlayerDamageMultiplier> PlayerDamageMultiplier;
    [JsonProperty(PropertyName = "Auto Turrets")]
    public BuildingOptionsAutoTurrets AutoTurret;
    [JsonProperty(PropertyName = "Player Building Restrictions")]
    public BuildingGradeLevels BuildingRestrictions;
    [JsonProperty(PropertyName = "Water Settings")]
    public BuildingWaterOptions Water;
    [JsonProperty(PropertyName = "IQDronePatrol : Setting up for spawn drones on raid bases")]
    public IQDronePatrolSettings DronePatrols;
    [JsonProperty(PropertyName = "Siege")]
    public SiegeSettings Siege;
    [JsonProperty(PropertyName = "Profile Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Maximum Land Level")]
    public float LandLevel;
    [JsonProperty(PropertyName = "Player Damage To Tool Cupboard Multiplier")]
    public float PlayerDamageMultiplierTC;
    [JsonProperty(PropertyName = "Allow Players To Use MLRS")]
    public bool MLRS;
    [JsonProperty(PropertyName = "Allow Third-Party Npc Explosive Damage To Bases")]
    public bool RaidingNpcs;
    [JsonProperty(PropertyName = "Add Code Lock To Unlocked Or KeyLocked Doors")]
    public bool CodeLockDoors;
    [JsonProperty(PropertyName = "Add Key Lock To Unlocked Or CodeLocked Doors")]
    public bool KeyLockDoors;
    [JsonProperty(PropertyName = "Add Code Lock To Tool Cupboards")]
    public bool CodeLockPrivilege;
    [JsonProperty(PropertyName = "Add Key Lock To Tool Cupboards")]
    public bool KeyLockPrivilege;
    [JsonProperty(PropertyName = "Add Code Lock To Boxes")]
    public bool CodeLockBoxes;
    [JsonProperty(PropertyName = "Add Key Lock To Boxes")]
    public bool KeyLockBoxes;
    [JsonProperty(PropertyName = "Add Code Lock To Lockers")]
    public bool CodeLockLockers;
    [JsonProperty(PropertyName = "Add Key Lock To Lockers")]
    public bool KeyLockLockers;
    [JsonProperty(PropertyName = "Close Open Doors With No Door Controller Installed")]
    public bool CloseOpenDoors;
    [JsonProperty(PropertyName = "Allow Duplicate Items")]
    public bool AllowDuplicates;
    [JsonProperty(PropertyName = "Allow Players To Pickup Deployables")]
    public bool AllowPickup;
    [JsonProperty(PropertyName = "Allow Players To Deploy A Cupboard")]
    public bool AllowBuildingPriviledges;
    [JsonProperty(PropertyName = "Allow Players To Build")]
    public bool AllowBuilding;
    [JsonProperty(PropertyName = "Allow Players To Build (Exclusions)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> AllowedBuildingBlockExceptions;
    [JsonProperty(PropertyName = "Allow Players To Deploy Barricades")]
    public bool AllowBarricades;
    [JsonProperty(PropertyName = "Allow PVP")]
    public bool AllowPVP;
    [JsonProperty(PropertyName = "Allow Self Damage")]
    public bool AllowSelfDamage;
    [JsonProperty(PropertyName = "Allow Friendly Fire (Teams)")]
    public bool AllowFriendlyFire;
    [JsonProperty(PropertyName = "Minimum Amount Of Items To Spawn (0 = Use Max Value)")]
    public int MinTreasure;
    [JsonProperty(PropertyName = "Amount Of Items To Spawn")]
    public int MaxTreasure;
    [JsonProperty(PropertyName = "Amount Of Items To Spawn Increased By Item Splits")]
    public bool Dynamic;
    [JsonProperty(PropertyName = "Check Lower Probability Once Per Loot Item")]
    public bool EnforceProbability;
    [JsonProperty(PropertyName = "Flame Turret Health")]
    public float FlameTurretHealth;
    [JsonProperty(PropertyName = "Briefly Holster Weapon To Prevent Camping The Entrance Of Events")]
    public bool Holster { get; set; }
    [JsonProperty(PropertyName = "Block Plugins Which Prevent Item Durability Loss")]
    public bool EnforceDurability;
    [JsonProperty(PropertyName = "Block Damage To Players From Player Turrets Deployed Outside Of The Dome")]
    public bool BlockOutsideTurrets;
    [JsonProperty(PropertyName = "Block Damage Outside Of The Dome To Players Inside")]
    public bool BlockOutsideDamageToPlayersInside;
    [JsonProperty(PropertyName = "Block Damage Outside Of The Dome To Bases Inside")]
    public bool BlockOutsideDamageToBaseInside;
    [JsonProperty(PropertyName = "Block Damage Inside From Npcs To Players Outside")]
    public bool BlockNpcDamageToPlayersOutside;
    [JsonProperty(PropertyName = "Building Blocks Are Immune To Damage")]
    public bool BlocksImmune;
    [JsonProperty(PropertyName = "Building Blocks Are Immune To Damage (Twig Only)")]
    public bool TwigImmune;
    [JsonProperty(PropertyName = "Turrets Can Hurt Event Twig")]
    public bool TurretsHurtTwig;
    [JsonProperty(PropertyName = "Boxes Are Invulnerable")]
    public bool Invulnerable;
    [JsonProperty(PropertyName = "Boxes Are Invulnerable Until Cupboard Is Destroyed")]
    public bool InvulnerableUntilCupboardIsDestroyed;
    [JsonProperty(PropertyName = "Spawn Silently (No Notifcation, No Dome, No Map Marker)")]
    public bool Silent;
    [JsonProperty(PropertyName = "Hide Despawn Time On Map Marker (PVP)")]
    public bool HideDespawnTimePVP;
    [JsonProperty(PropertyName = "Hide Despawn Time On Map Marker (PVE)")]
    public bool HideDespawnTimePVE;
    [JsonProperty(PropertyName = "Use Simple Messaging")]
    public bool Smart;
    [JsonProperty(PropertyName = "Despawn Dropped Loot Bags From Raid Boxes When Base Despawns")]
    public bool DespawnGreyBoxBags;
    [JsonProperty(PropertyName = "Despawn Dropped Loot Bags From Npc When Base Despawns")]
    public bool DespawnGreyNpcBags;
    [JsonProperty(PropertyName = "Protect Loot Bags From Raid Boxes For X Seconds After Base Despawns")]
    public float PreventLooting;
    [JsonProperty(PropertyName = "Divide Loot Into All Containers")]
    public bool DivideLoot;
    [JsonProperty(PropertyName = "Drop Tool Cupboard Loot After Raid Is Completed")]
    public bool DropPrivilegeLoot;
    [JsonProperty(PropertyName = "Drop Container Loot X Seconds After It Is Looted")]
    public float DropTimeAfterLooting;
    [JsonProperty(PropertyName = "Drop Container Loot Applies Only To Boxes And Cupboards")]
    public bool DropOnlyBoxesAndPrivileges;
    [JsonProperty(PropertyName = "Create Dome Around Event Using Spheres (0 = disabled, recommended = 5)")]
    public int SphereAmount;
    [JsonProperty(PropertyName = "Empty All Containers Before Spawning Loot")]
    public bool EmptyAll;
    [JsonProperty(PropertyName = "Empty All Containers (Exclusions)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> EmptyExemptions;
    [JsonProperty(PropertyName = "Eject Corpses From Enemy Raids (Advanced Users Only)")]
    public bool EjectBackpacks;
    [JsonProperty(PropertyName = "Eject Corpses From PVE Instantly (Advanced Users Only)")]
    public bool EjectBackpacksPVE;
    [JsonProperty(PropertyName = "Eject Enemies From Locked PVE Raids")]
    public bool EjectLockedPVE;
    [JsonProperty(PropertyName = "Eject Enemies From Locked PVP Raids")]
    public bool EjectLockedPVP;
    [JsonProperty(PropertyName = "Eject Tree Radius When Spawning Base")]
    public float TreeRadius;
    [JsonProperty(PropertyName = "Delete Tree Radius When Spawning Base")]
    public float DeleteRadius;
    [JsonProperty(PropertyName = "Respawn Deleted Trees When Despawning Base")]
    public bool RespawnTrees;
    [JsonProperty(PropertyName = "Explosion Damage Modifier (0-999)")]
    public float ExplosionModifier;
    [JsonProperty(PropertyName = "Force All Boxes To Have Same Skin")]
    public bool SetSkins;
    [JsonProperty(PropertyName = "Ignore Containers That Spawn With Loot Already")]
    public bool IgnoreContainedLoot;
    [JsonProperty(PropertyName = "Loot Amount Multiplier")]
    public float Multiplier;
    [JsonProperty(PropertyName = "Maximum Respawn Npc X Seconds After Death")]
    public float RespawnRateMax;
    [JsonProperty(PropertyName = "Minimum Respawn Npc X Seconds After Death")]
    public float RespawnRateMin;
    [JsonProperty(PropertyName = "No Item Input For Boxes And TC")]
    public bool NoItemInput;
    [JsonProperty(PropertyName = "Penalize Players On Death In PVE (ZLevels)")]
    public bool PenalizePVE;
    [JsonProperty(PropertyName = "Penalize Players On Death In PVP (ZLevels)")]
    public bool PenalizePVP;
    [JsonProperty(PropertyName = "Require Cupboard Access To Loot")]
    public bool RequiresCupboardAccess;
    [JsonProperty(PropertyName = "Require Cupboard Access To Place Ladders")]
    public bool RequiresCupboardAccessLadders;
    [JsonProperty(PropertyName = "Skip Treasure Loot And Use Loot In Base Only")]
    public bool SkipTreasureLoot;
    [JsonProperty(PropertyName = "Use Buoyant Boxex For Dropped Privilege Loot")]
    public bool BuoyantPrivilege;
    [JsonProperty(PropertyName = "Use Buoyant Boxex For Dropped Box Loot")]
    public bool BuoyantBox;
    [JsonProperty(PropertyName = "Rearm Bear Traps When Damaged")]
    public bool RearmBearTraps;
    [JsonProperty(PropertyName = "Bear Traps Are Immune To Timed Explosives")]
    public bool BearTrapsImmuneToExplosives;
    [JsonProperty(PropertyName = "Remove Locks When Event Is Completed")]
    public bool UnlockEverything;
    [JsonProperty(PropertyName = "Required Loot Percentage For Rewards")]
    public double RequiredLootPercentage;
    [JsonProperty(PropertyName = "Each Player Must Destroy An Entity For Reward Eligibility")]
    public bool RequiredDestroyEntity;
    [JsonProperty(PropertyName = "Always Spawn Base Loot Table")]
    public bool AlwaysSpawnBaseLoot;
    public BuildingOptions Clone();
    public float ProtectionRadius(RaidableType type);
    public int GetLootAmount(RaidableType type);
}

public class BuildingOptionsEco
{
    [JsonProperty(PropertyName = "Allow Eco Raiding Only")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Allow Flame Throwers")]
    public bool FlameThrowers;
}

public class RaidableBaseSettingsEventTypeBase
{
    [JsonProperty(PropertyName = "Convert PVE To PVP")]
    public bool ConvertPVE;
    [JsonProperty(PropertyName = "Convert PVP To PVE")]
    public bool ConvertPVP;
    [JsonProperty(PropertyName = "Ignore Safe Checks")]
    public bool Ignore;
    [JsonProperty(PropertyName = "Ignore Safe Checks In X Radius Only")]
    public float SafeRadius;
    [JsonProperty(PropertyName = "Ignore Player Entities At Custom Spawn Locations")]
    public bool Skip;
    [JsonProperty(PropertyName = "Spawn Bases X Distance Apart")]
    public float Distance;
    [JsonProperty(PropertyName = "Spawns Database File (Optional)")]
    public string SpawnsFile;
}

public class RaidableBaseSettingsEventTypeBaseExtended : RaidableBaseSettingsEventTypeBase
{
    [JsonProperty(PropertyName = "Chance To Randomly Spawn PVP Bases (0 = Ignore Setting)")]
    public decimal Chance;
    [JsonProperty(PropertyName = "Include PVE Bases")]
    public bool IncludePVE;
    [JsonProperty(PropertyName = "Include PVP Bases")]
    public bool IncludePVP;
    [JsonProperty(PropertyName = "Minimum Required Players Online")]
    public int PlayerLimitMin;
    [JsonProperty(PropertyName = "Maximum Limit Of Players Online")]
    public int PlayerLimitMax;
    [JsonProperty(PropertyName = "Time To Wait Between Spawns")]
    public float Time;
    public int GetPlayerCount();
}

public class RaidableBaseSettingsScheduled : RaidableBaseSettingsEventTypeBaseExtended
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Every Min Seconds")]
    public double IntervalMin;
    [JsonProperty(PropertyName = "Every Max Seconds")]
    public double IntervalMax;
    [JsonProperty(PropertyName = "Max Scheduled Events")]
    public int Max;
    [JsonProperty(PropertyName = "Max To Spawn At Once (0 = Use Max Scheduled Events Amount)")]
    public int MaxOnce;
}

public class RaidableBaseSettingsMaintained : RaidableBaseSettingsEventTypeBaseExtended
{
    [JsonProperty(PropertyName = "Always Maintain Max Events")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Max Maintained Events")]
    public int Max;
}

public class RaidableBaseSettingsManual
{
    [JsonProperty(PropertyName = "Convert PVE To PVP")]
    public bool ConvertPVE;
    [JsonProperty(PropertyName = "Convert PVP To PVE")]
    public bool ConvertPVP;
    [JsonProperty(PropertyName = "Max Manual Events")]
    public int Max;
    [JsonProperty(PropertyName = "Spawns Database File (Optional)")]
    public string SpawnsFile;
}

public class RaidableBaseWallOptions
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Stacks")]
    public int Stacks;
    [JsonProperty(PropertyName = "Ignore Stack Limit When Clipping Terrain")]
    public bool IgnoreWhenClippingTerrain;
    [JsonProperty(PropertyName = "Ignore Forced Height Option")]
    public bool IgnoreForcedHeight;
    [JsonProperty(PropertyName = "Use Stone Walls")]
    public bool Stone;
    [JsonProperty(PropertyName = "Use Iced Walls")]
    public bool Ice;
    [JsonProperty(PropertyName = "Use Least Amount Of Walls")]
    public bool LeastAmount;
    [JsonProperty(PropertyName = "Use UFO Walls")]
    public bool UseUFOWalls;
    [JsonProperty(PropertyName = "Radius")]
    public float Radius;
}

public class RankedLadderSettings
{
    [JsonProperty(PropertyName = "Award Top X Players On Wipe")]
    public int Amount;
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Show Top X Ladder")]
    public int Top;
}

public class RewardSettings
{
    [JsonProperty(PropertyName = "Economics Money")]
    public double Money;
    [JsonProperty(PropertyName = "ServerRewards Points")]
    public int Points;
    [JsonProperty(PropertyName = "SkillTree XP")]
    public double XP;
}

public class SkinSettingsDefault
{
    [JsonProperty(PropertyName = "Use Random Skin")]
    public bool Random;
    [JsonProperty(PropertyName = "Include Workshop Skins")]
    public bool Workshop;
    [JsonProperty(PropertyName = "Use Imported Workshop Skins File")]
    public bool Imported;
    [JsonProperty(PropertyName = "Use Approved Workshop Skins Only")]
    public bool ApprovedOnly;
    [JsonProperty(PropertyName = "Ignore If Skinned Already")]
    public bool IgnoreSkinned;
    [JsonProperty(PropertyName = "Use Identical Skins")]
    public bool Unique;
    [JsonProperty(PropertyName = "Preset Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> Skins;
}

public class SkinSettingsLoot
{
    [JsonProperty(PropertyName = "Include Workshop Skins")]
    public bool Workshop;
    [JsonProperty(PropertyName = "Use Random Skin")]
    public bool Random;
    [JsonProperty(PropertyName = "Use Imported Workshop Skins File")]
    public bool Imported;
    [JsonProperty(PropertyName = "Use Identical Skins For Stackable Items")]
    public bool Stackable;
    [JsonProperty(PropertyName = "Use Identical Skins For Non-Stackable Items")]
    public bool NonStackable;
    [JsonProperty(PropertyName = "Use Approved Workshop Skins Only")]
    public bool ApprovedOnly;
}

public class SkinSettingsDeployables
{
    [JsonProperty(PropertyName = "Partial Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Names;
    [JsonProperty(PropertyName = "Use Approved Workshop Skins Only")]
    public bool ApprovedOnly;
    [JsonProperty(PropertyName = "Use Imported Workshop Skins File")]
    public bool ImportedWorkshop;
    [JsonProperty(PropertyName = "Preset Door Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> Doors;
    [JsonProperty(PropertyName = "Include Workshop Skins")]
    public bool Workshop;
    [JsonProperty(PropertyName = "Use Random Skin")]
    public bool Random;
    [JsonProperty(PropertyName = "Skin Everything")]
    public bool Everything;
    [JsonProperty(PropertyName = "Ignore If Skinned Already")]
    public bool IgnoreSkinned;
    [JsonProperty(PropertyName = "Use Identical Skins")]
    public bool Unique;
}

public class SkinSettingsNpcs : SkinSettingsDefault
{
    [JsonProperty(PropertyName = "Use Skins With Murderer Kits")]
    public bool MurdererKits;
    [JsonProperty(PropertyName = "Use Skins With Scientist Kits")]
    public bool ScientistKits;
    [JsonProperty(PropertyName = "Ignore Skinned Murderer Kits")]
    public bool IgnoreSkinnedMurderer;
    [JsonProperty(PropertyName = "Ignore Skinned Scientist Kits")]
    public bool IgnoreSkinnedScientist;
    internal bool CanSkinKit(ulong skin, bool isMurderer);
}

public class SkinSettings
{
    [JsonProperty(PropertyName = "Boxes")]
    public SkinSettingsDefault Boxes;
    [JsonProperty(PropertyName = "Loot Items")]
    public SkinSettingsLoot Loot;
    [JsonProperty(PropertyName = "Npcs")]
    public SkinSettingsNpcs Npc;
    [JsonProperty(PropertyName = "Deployables")]
    public SkinSettingsDeployables Deployables;
    [JsonProperty(PropertyName = "Randomize Npc Item Skins")]
    public bool Npcs;
    [JsonProperty(PropertyName = "Use Identical Skins For All Npcs")]
    public bool UniqueNpcs;
    [JsonProperty(PropertyName = "Ignore If Skinned Already")]
    public bool IgnoreSkinned;
}

public class SkinSettingsImportedWorkshop
{
    [JsonProperty(PropertyName = "Imported Workshop Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<ulong>> SkinList;
}

public class LootItem : IEquatable<LootItem>
{
    [JsonProperty(PropertyName = "shortname")]
    public string shortname;
    [JsonProperty(PropertyName = "name")]
    public string name;
    [JsonProperty(PropertyName = "text")]
    public string text;
    [JsonProperty(PropertyName = "amount")]
    public int amount;
    [JsonProperty(PropertyName = "skin")]
    public ulong skin;
    [JsonProperty(PropertyName = "amountMin")]
    public int amountMin;
    [JsonProperty(PropertyName = "probability")]
    public float probability;
    [JsonProperty(PropertyName = "stacksize")]
    public int stacksize;
    public bool HasProbability();
    internal bool hasPriority;
    internal bool isSplit;
    internal ItemDefinition _def;
    [JsonIgnore]
    public ItemDefinition definition { get; set; }
    [JsonIgnore]
    public bool isBlueprint;
    [JsonIgnore]
    public bool isModified;
    public LootItem();
    public LootItem(string shortname, int amountMin, int amount, ulong skin, bool isBlueprint, float probability, int stacksize, string name, string text, bool isModified, bool hasPriority);
    public LootItem Clone();
    public bool Equals(LootItem other);
    public override bool Equals(object obj);
    public override int GetHashCode();
}

public class TreasureSettings
{
    [JsonProperty(PropertyName = "Resources Not Moved To Cupboards", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> ExcludeFromCupboard;
    [JsonProperty(PropertyName = "Use Day Of Week Loot")]
    public bool UseDOWL;
    [JsonProperty(PropertyName = "Do Not Duplicate Base Loot")]
    public bool Base;
    [JsonProperty(PropertyName = "Do Not Duplicate Difficulty Loot")]
    public bool Difficulty;
    [JsonProperty(PropertyName = "Do Not Duplicate Default Loot")]
    public bool Default;
    [JsonProperty(PropertyName = "Use Stack Size Limit For Spawning Items")]
    public bool Stacks;
}

public class UIBaseSettings
{
    [JsonProperty(PropertyName = "Enabled", Order = 1)]
    public bool Enabled;
    [JsonProperty(PropertyName = "Anchor Min", Order = 2)]
    public string AnchorMin;
    [JsonProperty(PropertyName = "Anchor Max", Order = 3)]
    public string AnchorMax;
    [JsonProperty(PropertyName = "Panel Alpha", NullValueHandling = NullValueHandling.Ignore, Order = 4)]
    public float? PanelAlpha;
    [JsonProperty(PropertyName = "Panel Color", NullValueHandling = NullValueHandling.Ignore, Order = 5)]
    public string PanelColor;
}

public class BuildingOptionsElevators : UIBaseSettings
{
    public BuildingOptionsElevators();
    [JsonProperty(PropertyName = "Required Access Level", Order = 5)]
    public int RequiredAccessLevel;
    [JsonProperty(PropertyName = "Required Access Level Grants Permanent Use", Order = 6)]
    public bool RequiredAccessLevelOnce;
    [JsonProperty(PropertyName = "Required Keycard Skin ID", Order = 7)]
    public ulong SkinID;
    [JsonProperty(PropertyName = "Requires Building Permission", Order = 8)]
    public bool RequiresBuildingPermission;
    [JsonProperty(PropertyName = "Button Health", Order = 9)]
    public float ButtonHealth;
    [JsonProperty(PropertyName = "Elevator Health", Order = 10)]
    public float ElevatorHealth;
}

public class UIDelaySettings : UIBaseSettings
{
    public UIDelaySettings();
    [JsonProperty(PropertyName = "Text Color", Order = 5)]
    public string Foreground;
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
}

public class Vector2Converter : JsonConverter
{
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

public class UIStatusSettings : UIBaseSettings
{
    public UIStatusSettings();
    [JsonProperty(PropertyName = "Offset Min", Order = 2, NullValueHandling = NullValueHandling.Ignore)]
    [JsonConverter(typeof(Vector2Converter))]
    public Vector2 OffsetMin;
    [JsonProperty(PropertyName = "Offset Max", Order = 3, NullValueHandling = NullValueHandling.Ignore)]
    [JsonConverter(typeof(Vector2Converter))]
    public Vector2 OffsetMax;
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "PVP Color")]
    public string ColorPVP;
    [JsonProperty(PropertyName = "PVE Color")]
    public string ColorPVE;
    [JsonProperty(PropertyName = "No Owner Color", Order = 7)]
    public string NoneColor;
    [JsonProperty(PropertyName = "Negative Color", Order = 7)]
    public string NegativeColor;
    [JsonProperty(PropertyName = "Positive Color", Order = 8)]
    public string PositiveColor;
    [JsonProperty(PropertyName = "Title Background Color", Order = 6)]
    public string TitlePanelColor;
    [JsonProperty(PropertyName = "Show Loot Left")]
    public bool ShowLootLeft;
}

public class UIAdvancedAlertSettings : UIBaseSettings
{
    [JsonProperty(PropertyName = "Time Shown", Order = 5)]
    public float Time;
    public UIAdvancedAlertSettings();
}

public class UISettings
{
    [JsonProperty(PropertyName = "Advanced Alerts UI")]
    public UIAdvancedAlertSettings AA;
    [JsonProperty(PropertyName = "Delay")]
    public UIDelaySettings Delay;
    [JsonProperty(PropertyName = "Status UI")]
    public UIStatusSettings Status;
}

public class WeaponTypeStateSettings
{
    [JsonProperty(PropertyName = "AutoTurret")]
    public bool AutoTurret;
    [JsonProperty(PropertyName = "FlameTurret")]
    public bool FlameTurret;
    [JsonProperty(PropertyName = "FogMachine")]
    public bool FogMachine;
    [JsonProperty(PropertyName = "GunTrap")]
    public bool GunTrap;
    [JsonProperty(PropertyName = "SamSite")]
    public bool SamSite;
}

public class WeaponTypeAmountSettings
{
    [JsonProperty(PropertyName = "AutoTurret")]
    public int AutoTurret;
    [JsonProperty(PropertyName = "FlameTurret")]
    public int FlameTurret;
    [JsonProperty(PropertyName = "FogMachine")]
    public int FogMachine;
    [JsonProperty(PropertyName = "GunTrap")]
    public int GunTrap;
    [JsonProperty(PropertyName = "SamSite")]
    public int SamSite;
}

public class WeaponSettingsTeslaCoil
{
    [JsonProperty(PropertyName = "Requires A Power Source")]
    public bool RequiresPower;
    [JsonProperty(PropertyName = "Max Discharge Self Damage Seconds (0 = None, 120 = Rust default)")]
    public float MaxDischargeSelfDamageSeconds;
    [JsonProperty(PropertyName = "Max Damage Output")]
    public float MaxDamageOutput;
    [JsonProperty(PropertyName = "Health")]
    public float Health;
}

public class WeaponSettings
{
    [JsonProperty(PropertyName = "No Fuel Source", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Burn;
    [JsonProperty(PropertyName = "Infinite Ammo")]
    public WeaponTypeStateSettings InfiniteAmmo;
    [JsonProperty(PropertyName = "Ammo")]
    public WeaponTypeAmountSettings Ammo;
    [JsonProperty(PropertyName = "Tesla Coil")]
    public WeaponSettingsTeslaCoil TeslaCoil;
    [JsonProperty(PropertyName = "Fog Machine Allows Motion Toggle")]
    public bool FogMotion;
    [JsonProperty(PropertyName = "Fog Machine Requires A Power Source")]
    public bool FogRequiresPower;
    [JsonProperty(PropertyName = "SamSite Repairs Every X Minutes (0.0 = disabled)")]
    public float SamSiteRepair;
    [JsonProperty(PropertyName = "SamSite Range (350.0 = Rust default)")]
    public float SamSiteRange;
    [JsonProperty(PropertyName = "SamSite Requires Power Source")]
    public bool SamSiteRequiresPower;
    [JsonProperty(PropertyName = "Spooky Speakers Requires Power Source")]
    public bool SpookySpeakersRequiresPower;
    [JsonProperty(PropertyName = "Sprinkler Requires A Power Source")]
    public bool SprinklerRequiresPower;
    [JsonProperty(PropertyName = "Test Generator Power")]
    public float TestGeneratorPower;
    [JsonProperty(PropertyName = "Furnace Starting Fuel")]
    public int Furnace;
}

public class Configuration
{
    [JsonProperty(PropertyName = "Settings")]
    public PluginSettings Settings;
    [JsonProperty(PropertyName = "Event Messages")]
    public EventMessageSettings EventMessages;
    [JsonProperty(PropertyName = "GUIAnnouncements")]
    public GUIAnnouncementSettings GUIAnnouncement;
    [JsonProperty(PropertyName = "Ranked Ladder")]
    public RankedLadderSettings RankedLadder;
    [JsonProperty(PropertyName = "Skins")]
    public SkinSettings Skins;
    [JsonProperty(PropertyName = "Treasure")]
    public TreasureSettings Loot;
    [JsonProperty(PropertyName = "UI")]
    public UISettings UI;
    [JsonProperty(PropertyName = "Weapons")]
    public WeaponSettings Weapons;
    [JsonProperty(PropertyName = "Log Debug To File")]
    public bool LogToFile;
}

public class UI
{
    public static void AddCuiPanel(CuiElementContainer container, string color, string amin, string amax, string omin, string omax, string parent, string name, bool cursor);
    public static void AddCuiButton(CuiElementContainer container, string buttonColor, string command, string text, string textColor, int fontSize, TextAnchor align, string amin, string amax, string omin, string omax, string parent, string name, string font);
    public static void AddCuiElement(CuiElementContainer container, string text, int fontSize, TextAnchor align, string textColor, string amin, string amax, string omin, string omax, string parent, string name, string font, string distance);
    public static double ParseHexComponent(string hex, int j, int k);
    public static string ConvertHexToRGBA(string hex, float a);
    public static void DestroyDelayUI(BasePlayer player);
    public static void DestroyStatusUI(BasePlayer player);
    public static void DestroyAll();
    private static void ShowDelayUI(RaidableBases Instance, BasePlayer player);
    private static void CreateDelayUI(Configuration config, BasePlayer player, string panelName, string text, string color, string panelColor, string aMin, string aMax);
    public static void UpdateDelayUI(RaidableBases Instance, BasePlayer player);
    private static void SetDelayUpdate(RaidableBases Instance, BasePlayer player);
    public static void DestroyDelayUpdate(BasePlayer player);
    public static bool ShowStatusUi(RaidableBases Instance, BasePlayer player);
    private static void SetOwner(RaidableBase raid, UIStatusSettings ui, BasePlayer player, string ownerName, string ownerColor);
    private static double GetMinutes(double value);
    public static void UpdateStatusUI(RaidableBase raid);
    public static void UpdateStatusUI(RaidableBases Instance, BasePlayer player);
    private static void SetStatusUpdate(RaidableBases Instance, BasePlayer player);
    public static void DestroyStatusUpdate(BasePlayer player);
    public const string DelayPanelName;
    public const string StatusPanelName;
    public static List<BasePlayer> Delay;
    public static List<BasePlayer> Players;
    public static Dictionary<ulong, Timers> InvokeTimers;
    public class Timers
    {
        public Timer Delay;
        public Timer Status;
        public Timer Lockout;
    }

}

public class Timers
{
    public Timer Delay;
    public Timer Status;
    public Timer Lockout;
}

Oxide.Plugins.RaidableBasesExtensionMethods
public static class ExtensionMethods
{
    internal static Core.Libraries.Permission _permission;
    public class DisposableBuilder : IDisposable, Pool.IPooled
    {
        private StringBuilder _builder;
        public DisposableBuilder();
        public void LeavePool();
        public void EnterPool();
        public void Dispose();
        public static DisposableBuilder Get();
        public DisposableBuilder Append(DisposableBuilder obj);
        public DisposableBuilder Append(string value);
        public DisposableBuilder AppendLine(string value);
        public DisposableBuilder Clear();
        public override string ToString();
        public int Length { get; set; }
    }

    public static PooledList<T> ToPooledList(IEnumerable<T> a);
    public static PooledList<T> TakePooledList(IEnumerable<T> a, int n);
    public static PooledList<Item> GetAllItems(BasePlayer a);
    public static KeyValuePair<K, V> GetRandom(IDictionary<K, V> a);
    public static bool All(IEnumerable<T> a, Func<T, bool> b);
    public static int Average(IList<int> a);
    public static T ElementAt(IEnumerable<T> a, int b);
    public static bool Exists(HashSet<T> a);
    public static bool Exists(IEnumerable<T> a, Func<T, bool> b);
    public static T FirstOrDefault(IEnumerable<T> a, Func<T, bool> b);
    public static void ForEach(IEnumerable<T> a, Action<T> action);
    public static int RemoveAll(IDictionary<TKey, TValue> c, Func<TKey, TValue, bool> d);
    public static IEnumerable<V> Select(IEnumerable<T> a, Func<T, V> b);
    public static string[] Skip(string[] a, int b);
    public static Dictionary<T, V> ToDictionary(IEnumerable<S> a, Func<S, T> b, Func<S, V> c);
    public static List<T> ToList(IEnumerable<T> a);
    public static List<T> Where(IEnumerable<T> a, Func<T, bool> b);
    public static List<T> OrderByAscending(IEnumerable<T> a, Func<T, TKey> s);
    public static int Sum(IEnumerable<T> a, Func<T, int> b);
    public static int Count(IEnumerable<T> a, Func<T, bool> b);
    public static IEnumerable<T> Union(IEnumerable<T> a, IEnumerable<T> b, IEqualityComparer<T> c);
    public static bool HasPermission(string a, string b);
    public static bool HasPermission(BasePlayer a, string b);
    public static bool HasPermission(ulong a, string b);
    public static bool BelongsToGroup(string a, string b);
    public static bool BelongsToGroup(ulong a, string b);
    public static bool BelongsToGroup(BasePlayer a, string b);
    public static bool IsOnline(BasePlayer a);
    public static bool IsKilled(BaseNetworkable a);
    public static bool IsNull(BaseNetworkable a);
    public static bool IsNetworked(BaseNetworkable a);
    public static void SafelyKill(BaseNetworkable a);
    public static void DelayedSafeKill(BaseNetworkable a);
    public static bool CanCall(Plugin o);
    public static bool IsHuman(BasePlayer a);
    public static bool IsCheating(BasePlayer a);
    public static void SetAiming(BasePlayer a, bool f);
    public static void SetNoTarget(AutoTurret a);
    public static void SafelyStrip(PlayerInventory inv);
    public static void SafelyRemove(ItemContainer inv, string shortname);
    public static BasePlayer Player(IPlayer user);
    public static string MaterialName(Collider collider);
    public static string ObjectName(Collider collider);
    public static string ColliderName(Collider collider);
    public static Vector3 GetPosition(Collider collider);
    public static string ObjectName(BaseEntity entity);
    public static T GetRandom(HashSet<T> h);
    public static float Distance(Vector3 a, Vector3 b);
    public static float Distance2D(Vector3 a, Vector3 b);
    public static bool IsMajorityDamage(HitInfo info, DamageType damageType);
    public static void ResetToPool(Dictionary<K, V> obj);
    public static void ResetToPool(HashSet<T> obj);
    public static void ResetToPool(List<T> obj);
    public static void ResetToPool(T obj);
    public static ulong userid(BasePlayer player);
}

public class DisposableBuilder : IDisposable, Pool.IPooled
{
    private StringBuilder _builder;
    public DisposableBuilder();
    public void LeavePool();
    public void EnterPool();
    public void Dispose();
    public static DisposableBuilder Get();
    public DisposableBuilder Append(DisposableBuilder obj);
    public DisposableBuilder Append(string value);
    public DisposableBuilder AppendLine(string value);
    public DisposableBuilder Clear();
    public override string ToString();
    public int Length { get; set; }
}


```

---

## RaidAlarm by haggbart - Receive raid notifications through the official Rust companion mobile app

```csharp
using System;
using System.Collections.Generic;
using CompanionServer;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

Oxide.Plugins
[Info("Raid Alarm", "haggbart", "0.4.0")]
[Description("Receive raid notifications through the official Rust companion mobile app")]
internal class RaidAlarm : RustPlugin
{
    private static HashSet<ulong> disabled;
    private const string PERMISSION;
    private void SaveData();
    private void ReadData();
    private void Init();
    private void OnServerSave();
    private void Unload();
    private PluginConfig config;
    private class PluginConfig
    {
        public bool usePermissions;
    }

    protected override void LoadDefaultConfig();
    private new void SaveConfig();
    private static PluginConfig GetDefaultConfig();
    private static class Loc
    {
        public const string TITLE;
        public const string BODY;
        public const string HELP;
        public const string HELP_COMMANDS;
        public const string STATUS_ENABLED;
        public const string STATUS_DISABLED;
        public const string TEST_SENT;
        public const string TEST_DESTROYED;
        public const string NO_PERMISSION;
    }

    private string GetStatusText(BasePlayer player);
    protected override void LoadDefaultMessages();
    private readonly Dictionary<string, DateTime> raidblocked;
    private DateTime lastAttack;
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private static bool IsRaidEntity(BaseCombatEntity entity);
    private static string GetGrid(Vector3 pos);
    [ChatCommand("raidalarm")]
    private void ChatRaidAlarm(BasePlayer player, string command, string[] args);
    private bool IsRaidBlocked(BasePlayer player);
}

private class PluginConfig
{
    public bool usePermissions;
}

private static class Loc
{
    public const string TITLE;
    public const string BODY;
    public const string HELP;
    public const string HELP_COMMANDS;
    public const string STATUS_ENABLED;
    public const string STATUS_DISABLED;
    public const string TEST_SENT;
    public const string TEST_DESTROYED;
    public const string NO_PERMISSION;
}


```

---

## RaidAlerts by Ryz0r - Raid Alerts allows players with permissions to recieve alerts in chat when an explosive is fired or thrown as a type of raid alert. You can also configure it to send alerts to Discord.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;
using Server = ConVar.Server;

Oxide.Plugins
[Info("Raid Alerts", "Ryz0r/Mevent", "1.0.2")]
[Description("Allows players with permissions to receive alerts when explosives are thrown or fired.")]
public class RaidAlerts : CovalencePlugin
{
    private const string RaidAlertCommands;
    private readonly Dictionary<string, float> _alertedUsers;
    private readonly List<string> _enabledPlayersList;
    private void SaveData();
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "UseWebhook")]
        public bool UseWebhook;
        [JsonProperty(PropertyName = "WebhookURL")]
        public string WebhookUrl;
        [JsonProperty(PropertyName = "OutputCooldown")]
        public float OutputCooldown;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnNewSave(string filename);
    private void Init();
    [Command("alerts")]
    private void AlertsCommand(IPlayer player, string command, string[] args);
    private void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnRocketLaunched(BasePlayer player, BaseEntity entity);
    private void SendDiscordMessage(string playerName, Vector3 entityLocation, string explosive);
    private class DiscordMessage
    {
        public DiscordMessage(string content, Embed[] embeds);
        [JsonProperty("content")]
        public string Content { get; set; }
        [JsonProperty("embeds")]
        public List<Embed> Embeds { get; set; }
        public string ToJson();
    }

    private class Embed
    {
        [JsonProperty("fields")]
        public List<Field> Fields { get; set; }
        public Embed AddField(string name, string value, bool inline);
    }

    private class Field
    {
        public Field(string name, string value, bool inline);
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("value")]
        public string Value { get; set; }
        [JsonProperty("inline")]
        public bool Inline { get; set; }
    }

    private static string GetGrid(Vector3 pos);
}

private class Configuration
{
    [JsonProperty(PropertyName = "UseWebhook")]
    public bool UseWebhook;
    [JsonProperty(PropertyName = "WebhookURL")]
    public string WebhookUrl;
    [JsonProperty(PropertyName = "OutputCooldown")]
    public float OutputCooldown;
}

private class DiscordMessage
{
    public DiscordMessage(string content, Embed[] embeds);
    [JsonProperty("content")]
    public string Content { get; set; }
    [JsonProperty("embeds")]
    public List<Embed> Embeds { get; set; }
    public string ToJson();
}

private class Embed
{
    [JsonProperty("fields")]
    public List<Field> Fields { get; set; }
    public Embed AddField(string name, string value, bool inline);
}

private class Field
{
    public Field(string name, string value, bool inline);
    [JsonProperty("name")]
    public string Name { get; set; }
    [JsonProperty("value")]
    public string Value { get; set; }
    [JsonProperty("inline")]
    public bool Inline { get; set; }
}


```

---

## RaidblockBuildingHealth by Razor - Changing health of created/upgraded building blocks in raidblock with slow healing

```csharp
using System;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;
using VLB;

Oxide.Plugins
[Info("Raidblock Building Health", "Razor", "2.0.0")]
[Description("Changing health of created/upgraded building blocks in raidblock")]
public class RaidblockBuildingHealth : RustPlugin
{
    private void OnEntityBuilt(Planner plan, GameObject go);
    private void OnStructureUpgrade(BuildingBlock entity, BasePlayer player, BuildingGrade.Enum grade);
    private void CheckEntity(BaseEntity entity, float health, bool isNew);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Health on spawn in percents (0-100)")]
        public int spawnHealthPercent;
        [JsonProperty(PropertyName = "Health on spawn in amount (0 to disable)")]
        public int spawnHealthAmount;
        [JsonProperty(PropertyName = "Structure should be not attacked for X seconds to start healing")]
        public float secondsAfterAttacked;
        [JsonProperty(PropertyName = "Interrupt healing at all after getting any damage")]
        public bool interruptAfterAnyDamage;
        [JsonProperty(PropertyName = "Heal rate (seconds)")]
        public float healRateSeconds;
        [JsonProperty(PropertyName = "Heal in amount (0 to disable)")]
        public float healAmount;
        [JsonProperty(PropertyName = "Heal in percents (0-100)")]
        public float healPercent;
        [JsonProperty(PropertyName = "Work for Building Blocks")]
        public bool buildingBlocks;
        [JsonProperty(PropertyName = "Work for Doors")]
        public bool doors;
    }

    protected override void LoadConfig();
    private static void ValidateConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class HealComponent : MonoBehaviour
    {
        private BaseCombatEntity entity;
        private bool MaxHealth { get; set; }
        private void Awake();
        public void OnChangedState(float health, bool isNew);
        private void Regen();
    }

    [PluginReference]
    private Plugin NoEscape;
    private bool InRaidBlock(BasePlayer player);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Health on spawn in percents (0-100)")]
    public int spawnHealthPercent;
    [JsonProperty(PropertyName = "Health on spawn in amount (0 to disable)")]
    public int spawnHealthAmount;
    [JsonProperty(PropertyName = "Structure should be not attacked for X seconds to start healing")]
    public float secondsAfterAttacked;
    [JsonProperty(PropertyName = "Interrupt healing at all after getting any damage")]
    public bool interruptAfterAnyDamage;
    [JsonProperty(PropertyName = "Heal rate (seconds)")]
    public float healRateSeconds;
    [JsonProperty(PropertyName = "Heal in amount (0 to disable)")]
    public float healAmount;
    [JsonProperty(PropertyName = "Heal in percents (0-100)")]
    public float healPercent;
    [JsonProperty(PropertyName = "Work for Building Blocks")]
    public bool buildingBlocks;
    [JsonProperty(PropertyName = "Work for Doors")]
    public bool doors;
}

private class HealComponent : MonoBehaviour
{
    private BaseCombatEntity entity;
    private bool MaxHealth { get; set; }
    private void Awake();
    public void OnChangedState(float health, bool isNew);
    private void Regen();
}


```

---

## RaidLimit by  - Limits the number of raids on buildings

```csharp
using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins;
using Rust;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Raid Limit", "noname", "2.2.3")]
[Description("Limits the number of raids per day on buildings")]
 class RaidLimit : CovalencePlugin
{
    [PluginReference]
     Plugin ImageLibrary;
     Plugin PlaytimeTracker;
    private static RaidLimit Instance;
    private int MaskInt;
    private const string raidlimit_admin_Perm;
    private const string raidlimit_bypass_Perm;
    private List<ulong> PlayerSpamMessageBlockFlags;
    private new void LoadDefaultConfig();
    private void Init();
    private void OnServerSave();
    private void Unload();
    private void Loaded();
    private void OnServerInitialized();
    private void OnPlayerConnected(BasePlayer player);
    private void OnUserGroupAdded(string id, string groupName);
    private void OnUserGroupRemoved(string id, string groupName);
    private void OnUserPermissionGranted(string id, string permName);
    private void OnUserPermissionRevoked(string id, string permName);
    private void OnGroupPermissionGranted(string name, string perm);
    private void OnGroupPermissionRevoked(string name, string perm);
    private void OnGroupDeleted(string name);
    private PluginConfig config;
    private void LoadConfig();
    private class PluginConfig
    {
        [JsonProperty("1.RaidLimitOperationType")]
        public RaidLimitOperationType RaidLimitOperationType;
        [JsonProperty("2.RaidLimitSettings")]
        public RaidLimitSettings RaidLimitSettings;
        [JsonProperty("3.UISettings")]
        public UISettings UISettings;
        [JsonProperty("4.TeamSyncSettings")]
        public TeamSyncSettings TeamSyncSettings;
    }

    private class RaidLimitOperationType
    {
        [JsonProperty("1.1.OperationType")]
        public int OperationType;
        [JsonProperty("1.2.ObjectOwnerIdentification")]
        public ObjectOwnerIdentification ObjectOwnerIdentification;
        [JsonProperty("1.3.ToolCupboardIdentification")]
        public ToolCupboardIdentification ToolCupboardIdentification;
    }

    private class ObjectOwnerIdentification
    {
        [JsonProperty("1.2.1.ObjectSearchDepth")]
        public int ObjectSearchDepth;
        [JsonProperty("1.2.2.ObjectSearchRange")]
        public int ObjectSearchRange;
    }

    private class ToolCupboardIdentification
    {
        [JsonProperty("1.3.1.ObjectSearchDepth")]
        public int ObjectSearchDepth;
        [JsonProperty("1.3.2.ObjectSearchRange")]
        public int ObjectSearchRange;
        [JsonProperty("1.3.3.CheckToolCupboardInstanceID")]
        public bool CheckToolCupboardInstanceID;
        [JsonProperty("1.3.4.CheckAuthorizedPeoples")]
        public bool CheckAuthorizedPeoples;
    }

    private class RaidLimitSettings
    {
        [JsonProperty("2.1.OneTimeMaximumRaidableHomeCount")]
        public int? OneTimeMaximumRaidableHomeCount;
        [JsonProperty("2.2.NoobCantRaidSecond")]
        public int? NoobCantRaidSecond;
        [JsonProperty("2.3.InitializeCounterOnMidnightTime")]
        public bool? InitializeCounterOnMidnightTime;
        [JsonProperty("2.4.MidnightTimeDetectionTimerInterval")]
        public int? MidnightTimeDetectionTimerInterval;
        [JsonProperty("2.5.CounterChargeDelay")]
        public int? CounterChargeDelay;
        [JsonProperty("2.6.CounterChargeDelayType")]
        public int? CounterChargeDelayType;
        [JsonProperty("2.7.CounterChargeType")]
        public int? CounterChargeType;
    }

    private class UISettings
    {
        [JsonProperty("3.1.UIEnable")]
        public bool UIEnable;
        [JsonProperty("3.2.UIUpdateInterval")]
        public int UIUpdateInterval;
        [JsonProperty("3.3.UIPosition")]
        public UIPosition UIPosition;
    }

    private class UIPosition
    {
        [JsonProperty("3.3.1.AnchorMin")]
        public string AnchorMin;
        [JsonProperty("3.3.2.AnchorMax")]
        public string AnchorMax;
    }

    private class TeamSyncSettings
    {
        [JsonProperty("4.1.TeamCounterSync")]
        public bool TeamCounterSync;
        [JsonProperty("4.2.PreventTempDisband")]
        public bool PreventTempDisband;
        [JsonProperty("4.3.OldTeamSaveInterval")]
        public int OldTeamSaveInterval;
    }

    private PluginConfig GetDefaultConfig();
    private void CheckMissingVariable();
     DynamicConfigFile playersdataFile;
     PlayersData playersData;
     DynamicConfigFile playersuidataFile;
     PlayersUIData playersUIData;
     DynamicConfigFile playersteamdataFile;
     PlayersTeamData playersTeamData;
    private void LoadPlayersData();
    private void ChargeDataCheck();
    private void SavePlayersData();
    private class PlayersTeamData
    {
        public Dictionary<ulong, PlayerTeam> TeamsData1;
        public Dictionary<ulong, PlayerTeam> TeamsData2;
        public int OldDataIndicator;
        public PlayersTeamData();
        public void UpdateData();
    }

    private class PlayerTeam
    {
        public List<ulong> Members { get; set; }
        public PlayerTeam();
        public PlayerTeam(List<ulong> members);
    }

    private class PlayersUIData
    {
        public Dictionary<string, bool> PlayersUIToggle;
        public PlayersUIData();
        public void AddPlayer(BasePlayer player);
    }

    private class PlayersData
    {
        public DateTime excutteddate;
        public Dictionary<string, PlayerInfo> Players;
        public PlayersData();
        public void AddPlayer(string playerId);
        public void AddPlayer(BasePlayer player);
        public void PlayerAddTime(string PlayerID, TimeSpan time);
    }

    private class PlayerInfo
    {
        public string Id;
        public string Name;
        public int RaidLeftCount;
        public List<RaidCountItem> RaidCountItems;
        public bool Charging;
        public TimeSpan NextChargePlaytime;
        public DateTime NextChargeRealtime;
        public TimeSpan Playtime;
        public bool NoobCanRaidPlaytimeTracker;
        public bool NoobCanRaid;
        public PlayerInfo();
        public PlayerInfo(string playerId);
        public PlayerInfo(IPlayer player);
        public bool AddRaidTarget(RaidCountItem raidCountItem);
        public void AddChargeSchedule();
        public void StopCharging();
        public void ChargeRaidCount(bool chargeAll);
        public int AddRaidCount(int amount);
        public void ResetRaidDataNCount();
    }

    private class RaidCountItem
    {
        public List<ulong> RaidTargets;
        public List<int> TCInstanceIDs;
        public RaidCountItem();
        public RaidCountItem(List<ulong> raidTargets, List<int> tcInstanceIDs);
        public void AddRaidTargetsRange(List<ulong> raidTargets);
        public void AddTCInstanceIDsRange(List<int> tcInstanceIDs);
    }

    private void RegisterPermissions();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private void StartTimer();
    private void PreventTempDisband_Timer_Tick();
    private void CheckDayChanged_Timer_Tick();
    private void UIUpdate_Timer_Tick();
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void PlayerAddToData(BasePlayer player);
    private void PlayersAddToData();
    private void PlayerUpdateNameData(BasePlayer player);
    private void PlayersUpdateNameData();
    private bool CheckRaidCountItemContainsNAdd(List<RaidCountItem> player, RaidCountItem target);
    private RaidCountItem FindLinkedStructuresRaidCountItem(BaseEntity entity);
     PlayersDateTimeData playersDateTimeData;
    private class PlayersDateTimeData
    {
        public ListHashSet<BasePlayer> BasePlayerList;
        public DateTime SaveTickTime;
        public PlayersDateTimeData();
    }

    [Command("rl.reset")]
    private void ResetLimitCount(IPlayer player, string command, string[] args);
    [Command("rl.addvalue")]
    private void IncreaseLimitCount(IPlayer player, string command, string[] args);
    [Command("rlcheck")]
    private void CheckLimitCount(IPlayer player, string command, string[] args);
    private void UIToggle(IPlayer player, string command, string[] args);
    private void RegisterUICommand();
    private void ShowUI(BasePlayer player);
    private void HideUI(BasePlayer player);
    public string RaidLimit_boomb;
    public string BaseRaidLimitUI;
    public string LabelPanel;
    public void LoadImage();
    private void UpdateRaidLimitUI(BasePlayer player, bool Imageupdate, int FontSize, string Msg);
    private void UpdatePlayerCountUI(BasePlayer player, bool imageupdate);
    private void UpdatePlayerNoobTimeUI(BasePlayer player, TimeSpan playtime, bool imageupdate);
    private void UpdatePlayerTimeUI(BasePlayer player, TimeSpan displaytime, bool imageupdate);
    private void PlayerUpdateRaidLimitUI(BasePlayer player, bool imageupdate);
    private void PlayerDestroyRaidLimitUI(BasePlayer player);
    private void PlayersUpdateRaidLimitUI(bool imageupdate);
    private void PlayersDestroyRaidLimitUI();
    private IPlayer GetPlayer(string nameOrID, IPlayer player);
    private void TryChatMessage(BasePlayer player, string msg);
    private bool GetCanRaid(PlayerInfo playerInfo);
    private string GetimeToString(TimeSpan lefttime);
    private TimeSpan GetPlayerPlaytime(IPlayer player);
    private TimeSpan GetPlayerPlaytime(BasePlayer player);
    private TimeSpan GetPlayerPlaytime(string playerId);
    private BasePlayer TryGetPlayer(ulong playerId);
}

private class PluginConfig
{
    [JsonProperty("1.RaidLimitOperationType")]
    public RaidLimitOperationType RaidLimitOperationType;
    [JsonProperty("2.RaidLimitSettings")]
    public RaidLimitSettings RaidLimitSettings;
    [JsonProperty("3.UISettings")]
    public UISettings UISettings;
    [JsonProperty("4.TeamSyncSettings")]
    public TeamSyncSettings TeamSyncSettings;
}

private class RaidLimitOperationType
{
    [JsonProperty("1.1.OperationType")]
    public int OperationType;
    [JsonProperty("1.2.ObjectOwnerIdentification")]
    public ObjectOwnerIdentification ObjectOwnerIdentification;
    [JsonProperty("1.3.ToolCupboardIdentification")]
    public ToolCupboardIdentification ToolCupboardIdentification;
}

private class ObjectOwnerIdentification
{
    [JsonProperty("1.2.1.ObjectSearchDepth")]
    public int ObjectSearchDepth;
    [JsonProperty("1.2.2.ObjectSearchRange")]
    public int ObjectSearchRange;
}

private class ToolCupboardIdentification
{
    [JsonProperty("1.3.1.ObjectSearchDepth")]
    public int ObjectSearchDepth;
    [JsonProperty("1.3.2.ObjectSearchRange")]
    public int ObjectSearchRange;
    [JsonProperty("1.3.3.CheckToolCupboardInstanceID")]
    public bool CheckToolCupboardInstanceID;
    [JsonProperty("1.3.4.CheckAuthorizedPeoples")]
    public bool CheckAuthorizedPeoples;
}

private class RaidLimitSettings
{
    [JsonProperty("2.1.OneTimeMaximumRaidableHomeCount")]
    public int? OneTimeMaximumRaidableHomeCount;
    [JsonProperty("2.2.NoobCantRaidSecond")]
    public int? NoobCantRaidSecond;
    [JsonProperty("2.3.InitializeCounterOnMidnightTime")]
    public bool? InitializeCounterOnMidnightTime;
    [JsonProperty("2.4.MidnightTimeDetectionTimerInterval")]
    public int? MidnightTimeDetectionTimerInterval;
    [JsonProperty("2.5.CounterChargeDelay")]
    public int? CounterChargeDelay;
    [JsonProperty("2.6.CounterChargeDelayType")]
    public int? CounterChargeDelayType;
    [JsonProperty("2.7.CounterChargeType")]
    public int? CounterChargeType;
}

private class UISettings
{
    [JsonProperty("3.1.UIEnable")]
    public bool UIEnable;
    [JsonProperty("3.2.UIUpdateInterval")]
    public int UIUpdateInterval;
    [JsonProperty("3.3.UIPosition")]
    public UIPosition UIPosition;
}

private class UIPosition
{
    [JsonProperty("3.3.1.AnchorMin")]
    public string AnchorMin;
    [JsonProperty("3.3.2.AnchorMax")]
    public string AnchorMax;
}

private class TeamSyncSettings
{
    [JsonProperty("4.1.TeamCounterSync")]
    public bool TeamCounterSync;
    [JsonProperty("4.2.PreventTempDisband")]
    public bool PreventTempDisband;
    [JsonProperty("4.3.OldTeamSaveInterval")]
    public int OldTeamSaveInterval;
}

private class PlayersTeamData
{
    public Dictionary<ulong, PlayerTeam> TeamsData1;
    public Dictionary<ulong, PlayerTeam> TeamsData2;
    public int OldDataIndicator;
    public PlayersTeamData();
    public void UpdateData();
}

private class PlayerTeam
{
    public List<ulong> Members { get; set; }
    public PlayerTeam();
    public PlayerTeam(List<ulong> members);
}

private class PlayersUIData
{
    public Dictionary<string, bool> PlayersUIToggle;
    public PlayersUIData();
    public void AddPlayer(BasePlayer player);
}

private class PlayersData
{
    public DateTime excutteddate;
    public Dictionary<string, PlayerInfo> Players;
    public PlayersData();
    public void AddPlayer(string playerId);
    public void AddPlayer(BasePlayer player);
    public void PlayerAddTime(string PlayerID, TimeSpan time);
}

private class PlayerInfo
{
    public string Id;
    public string Name;
    public int RaidLeftCount;
    public List<RaidCountItem> RaidCountItems;
    public bool Charging;
    public TimeSpan NextChargePlaytime;
    public DateTime NextChargeRealtime;
    public TimeSpan Playtime;
    public bool NoobCanRaidPlaytimeTracker;
    public bool NoobCanRaid;
    public PlayerInfo();
    public PlayerInfo(string playerId);
    public PlayerInfo(IPlayer player);
    public bool AddRaidTarget(RaidCountItem raidCountItem);
    public void AddChargeSchedule();
    public void StopCharging();
    public void ChargeRaidCount(bool chargeAll);
    public int AddRaidCount(int amount);
    public void ResetRaidDataNCount();
}

private class RaidCountItem
{
    public List<ulong> RaidTargets;
    public List<int> TCInstanceIDs;
    public RaidCountItem();
    public RaidCountItem(List<ulong> raidTargets, List<int> tcInstanceIDs);
    public void AddRaidTargetsRange(List<ulong> raidTargets);
    public void AddTCInstanceIDsRange(List<int> tcInstanceIDs);
}

private class PlayersDateTimeData
{
    public ListHashSet<BasePlayer> BasePlayerList;
    public DateTime SaveTickTime;
    public PlayersDateTimeData();
}


```

---

## RaidMarkers by Paulsimik - Adds markers on the map if players destroy entities with explosives

```csharp
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using System;
using Rust;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Raid Markers", "Paulsimik", "1.0.3")]
[Description("Raid Markers on the map")]
 class RaidMarkers : RustPlugin
{
    private const string permAllow;
    private Configuration config;
    private HashSet<MapMarkerGenericRadius> raidMarkers;
    private void Init();
    private void Unload();
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer player);
    private void CreateRaidMarker(Vector3 position);
    private void ClearRaidMarkers();
    private bool IsFar(Vector3 position);
    private bool IsAuthed(BasePlayer player, BuildingPrivlidge buildingPrivlidge);
    private bool IsOnlineRaid(BuildingPrivlidge buildingPrivlidge);
    private double GetDistance(Vector3 pos1, Vector3 pos2);
    private Color ParseColor(string hexColor);
    public static string GetGridPosition(Vector3 position);
    [ChatCommand("rmtest")]
    private void cmdRaidMarker(BasePlayer player, string command, string[] args);
    private class Configuration
    {
        [JsonProperty(PropertyName = "Blaclisted prefabs")]
        public List<string> blacklistedPrefab;
        [JsonProperty(PropertyName = "Additional prefabs")]
        public List<string> additionalPrefab;
        [JsonProperty(PropertyName = "Distance when place new marker from another marker")]
        public int markerDistance;
        [JsonProperty("Enable write grid position to chat")]
        public bool chatGridPosition;
        [JsonProperty("Disable marker for authorized players in cupboard")]
        public bool authorizedPlayer;
        [JsonProperty("Create marker for online raid")]
        public bool showOnline;
        [JsonProperty("Create marker for offline raid")]
        public bool showOffline;
        [JsonProperty(PropertyName = "Marker configuration")]
        public MarkerConfiguration markerConfiguration;
        public VersionNumber version;
    }

    private class MarkerConfiguration
    {
        [JsonProperty(PropertyName = "Alpha")]
        public float markerAlpha;
        [JsonProperty(PropertyName = "Radius")]
        public float markerRadius;
        [JsonProperty(PropertyName = "Color1")]
        public string markerColor1;
        [JsonProperty(PropertyName = "Color2")]
        public string markerColor2;
        [JsonProperty(PropertyName = "Duration")]
        public float markerDuration;
    }

    private Configuration GetDefaultConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadConfig();
    private void UpdateConfig();
    private string GetLang(string key, string playerID, object[] args);
    protected override void LoadDefaultMessages();
}

private class Configuration
{
    [JsonProperty(PropertyName = "Blaclisted prefabs")]
    public List<string> blacklistedPrefab;
    [JsonProperty(PropertyName = "Additional prefabs")]
    public List<string> additionalPrefab;
    [JsonProperty(PropertyName = "Distance when place new marker from another marker")]
    public int markerDistance;
    [JsonProperty("Enable write grid position to chat")]
    public bool chatGridPosition;
    [JsonProperty("Disable marker for authorized players in cupboard")]
    public bool authorizedPlayer;
    [JsonProperty("Create marker for online raid")]
    public bool showOnline;
    [JsonProperty("Create marker for offline raid")]
    public bool showOffline;
    [JsonProperty(PropertyName = "Marker configuration")]
    public MarkerConfiguration markerConfiguration;
    public VersionNumber version;
}

private class MarkerConfiguration
{
    [JsonProperty(PropertyName = "Alpha")]
    public float markerAlpha;
    [JsonProperty(PropertyName = "Radius")]
    public float markerRadius;
    [JsonProperty(PropertyName = "Color1")]
    public string markerColor1;
    [JsonProperty(PropertyName = "Color2")]
    public string markerColor2;
    [JsonProperty(PropertyName = "Duration")]
    public float markerDuration;
}


```

---

## RaidNotes by Calytic - Broadcasts raid activity to chat

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using UnityEngine;
using Rust;
using Facepunch;

Oxide.Plugins
[Info ("RaidNotes", "Calytic", "1.0.21", ResourceId = 2117)]
[Description ("Broadcasts raid activity to chat & more")]
public class RaidNotes : RustPlugin
{
    [PluginReference]
     Plugin Discord;
     Plugin Slack;
     Plugin Clans;
     Plugin LustyMap;
     DynamicConfigFile data;
    public static JsonSerializer SERIALIZER;
    public static JsonConverter [] CONVERTERS;
     Dictionary<string, bool> _raidableCache;
     int blockLayer;
    static Dictionary<string, int> reverseItems;
    static List<string> explosionRadiusPrefabs;
     Dictionary<Raid, Timer> timers;
     Dictionary<string, DateTime> detectionCooldowns;
    static Regex _htmlRegex;
     Color [] colors;
     float raidDuration;
     float raidDistance;
     float shoulderHeight;
     bool isNewSave;
     float detectionDuration;
     string slackType;
     int logHours;
     bool trackExplosives;
     bool checkEntityDamage;
     bool checkEntityDeath;
     bool announceGlobal;
     bool printToLog;
     bool announceRaidStart;
     bool announceRaidEnd;
     bool announceToVictims;
     bool announceToSlack;
     bool announceToDiscord;
     bool announceToLustyMap;
     bool announceClan;
     string announcePrefixColor;
     string announceIcon;
     string announceNameColor;
     string announceClanColor;
     string lustyMapIcon;
     float lustyMapDuration;
     int detectionDistance;
     float detectionCountdown;
    private Dictionary<string, object> weaponColors;
    private Dictionary<string, object> gradeColors;
    private float announceDelay;
    private float announceRadius;
    internal int announceMinParticipants;
    internal int announceMinWeapons;
    internal int announceMinKills;
    internal int announceMinDestroyed;
    internal int announceMinMinutes;
     List<string> prefabs;
     Dictionary<long, Raid> raids;
    public class AttackVector
    {
        public Vector3 start;
        public Vector3 end;
        public int weapon;
        public ulong victim;
        public ulong initiator;
        [JsonConstructor]
        public AttackVector(Vector3 start, Vector3 end, int weapon, ulong victim, ulong initiator);
    }

    public class Raid
    {
        public long start;
        public long end;
        public Vector3 firstDamage;
        public Vector3 lastDamage;
        public List<AttackVector> attackVector;
        public List<AttackVector> killMap;
        public ulong initiator;
        public ulong victim;
        public List<ulong> blockOwners;
        public List<ulong> participants;
        public int lastWeapon;
        public Dictionary<int, int> weapons;
        public Dictionary<BuildingGrade.Enum, int> blocksDestroyed;
        public Dictionary<string, int> entitiesDestroyed;
        [JsonConstructor]
        public Raid(long start, long end, Vector3 firstDamage, Vector3 lastDamage, List<AttackVector> attackVector, ulong initiator, ulong victim, List<ulong> blockOwners, List<ulong> participants, int lastWeapon, Dictionary<int, int> weapons, List<AttackVector> killMap, Dictionary<BuildingGrade.Enum, int> blocksDestroyed, Dictionary<string, int> entitiesDestroyed);
        [JsonIgnore]
        internal AttackVector lastAttackVector;
        [JsonIgnore]
         RaidNotes plugin;
        [JsonIgnore]
        public bool Completed { get; set; }
        [JsonIgnore]
        public DateTime lastRefresh;
        [JsonIgnore]
        public IPlayer Initiator { get; set; }
        [JsonIgnore]
        public IPlayer Victim { get; set; }
        [JsonIgnore]
        [JsonConverter (typeof (IsoDateTimeConverter))]
        public DateTime Start { get; set; }
        [JsonIgnore]
        [JsonConverter (typeof (IsoDateTimeConverter))]
        public DateTime End { get; set; }
        public Raid(RaidNotes plugin, ulong initiator, ulong victim, Vector3 firstDamage);
        [JsonIgnore]
        public double Hours { get; set; }
        public bool HasHours(int hours);
        public void Participate(BasePlayer player);
        public bool IsAnnounced();
        internal JObject Vector2JObject(Vector3 vector);
        public override string ToString();
        internal JObject ToJObject();
        internal void OnEnded();
        internal void OnStarted();
        internal void Attack(AttackVector vector);
        internal void Kill(AttackVector vector);
    }

    public class RaidBehavior : MonoBehaviour
    {
        public BasePlayer player;
        internal Raid raid;
         void Awake();
         void OnDestroy();
    }

    public class ExplosiveTracker : MonoBehaviour
    {
        public BaseEntity entity;
        public Vector3 lastValidPosition;
        public BasePlayer thrownBy;
        public Vector3 thrownFrom;
         void Awake();
         void Update();
         void OnDestroy();
    }

    protected override void LoadDefaultConfig();
     void LoadMessages();
     void OnServerInitialized();
    protected void ReloadConfig();
     void LoadData();
     void SaveData(bool force);
     void ClearData();
     void OnNewSave(string filename);
     void OnServerSave();
     void Unload();
     void OnExplosiveThrown(BasePlayer player, BaseEntity entity);
     void OnRocketLaunched(BasePlayer player, BaseEntity entity);
     List<uint> recentAttacks;
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo);
    [ConsoleCommand ("raids.wipe")]
    private void ccRaidsWipe(ConsoleSystem.Arg arg);
    [ChatCommand ("inspect")]
    private void cmdInspect(BasePlayer player, string command, string [] args);
     void PlayerCooldown(BasePlayer player);
     bool CheckCooldown(BasePlayer player);
     void AddTracker(BasePlayer player, BaseEntity entity);
     Vector3 Track(BaseEntity initiator, BaseEntity entity);
     List<Raid> GetRaids(BasePlayer player, string [] args);
     void SendRaids(BasePlayer player, string [] args);
    public string ToHex(Color c);
    private byte ToByte(float f);
     bool SendRaid(BasePlayer player, Raid raid, StringBuilder sb, int found);
     void RegisterKill(BasePlayer player, BasePlayer attacker);
     void StructureAttack(BaseEntity targetEntity, BaseEntity sourceEntity, int weapon, bool destroy);
     Raid FindRaid(Vector3 position, List<BasePlayer> nearbyTargets);
     List<BasePlayer> GetNearbyPlayers(Vector3 position);
     bool TryGetRaid(BasePlayer source, ulong victim, Vector3 position, Raid raid);
    public Raid StartRaid(BasePlayer source, ulong victim, Vector3 position);
    private string GetAnnouncementMsg(AnnouncementType type);
    public void CheckRaid(Raid raid);
     void AnnounceRaidMsg(Raid raid, AnnouncementType type);
    public void RefreshRaid(Raid raid);
    public void DestroyTimer(Raid raid);
    public void StopRaid(Raid raid);
     string GetWeaponColor(int weaponid);
     string GetGradeColor(int grade);
     string GetWeaponList(Raid raid);
     string GetDestroyedList(Raid raid);
     void AnnounceRaid(Raid raid, AnnouncementType type);
     void BroadcastGlobal(string prefix, string message);
     void BroadcastLocal(string prefix, string message, Vector3 position);
     void BroadcastToPlayer(string prefix, string userID, string message);
     void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo);
    public List<string> GetClanMembers(string tag);
    public List<string> GetOnlineClanMembers(string tag);
    public List<Raid> GetRaids();
    public bool IsEntityRaidable(BaseCombatEntity entity);
     string Format(string str, Expression<Func<string, object>> [] args);
     T GetConfig(string key, T defaultValue);
     T GetConfig(string name, string name2, T defaultValue);
     string GetMsg(string key, BasePlayer player);
    public static List<BasePlayer> Sort(Vector3 position, List<BasePlayer> hits);
     bool HasPerm(BasePlayer p, string pe);
     bool HasPerm(string userid, string pe);
     class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

     class DateTimeConverter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    public string StripTags(string source);
     void SendHelpText(BasePlayer player);
}

public class AttackVector
{
    public Vector3 start;
    public Vector3 end;
    public int weapon;
    public ulong victim;
    public ulong initiator;
    [JsonConstructor]
    public AttackVector(Vector3 start, Vector3 end, int weapon, ulong victim, ulong initiator);
}

public class Raid
{
    public long start;
    public long end;
    public Vector3 firstDamage;
    public Vector3 lastDamage;
    public List<AttackVector> attackVector;
    public List<AttackVector> killMap;
    public ulong initiator;
    public ulong victim;
    public List<ulong> blockOwners;
    public List<ulong> participants;
    public int lastWeapon;
    public Dictionary<int, int> weapons;
    public Dictionary<BuildingGrade.Enum, int> blocksDestroyed;
    public Dictionary<string, int> entitiesDestroyed;
    [JsonConstructor]
    public Raid(long start, long end, Vector3 firstDamage, Vector3 lastDamage, List<AttackVector> attackVector, ulong initiator, ulong victim, List<ulong> blockOwners, List<ulong> participants, int lastWeapon, Dictionary<int, int> weapons, List<AttackVector> killMap, Dictionary<BuildingGrade.Enum, int> blocksDestroyed, Dictionary<string, int> entitiesDestroyed);
    [JsonIgnore]
    internal AttackVector lastAttackVector;
    [JsonIgnore]
     RaidNotes plugin;
    [JsonIgnore]
    public bool Completed { get; set; }
    [JsonIgnore]
    public DateTime lastRefresh;
    [JsonIgnore]
    public IPlayer Initiator { get; set; }
    [JsonIgnore]
    public IPlayer Victim { get; set; }
    [JsonIgnore]
    [JsonConverter (typeof (IsoDateTimeConverter))]
    public DateTime Start { get; set; }
    [JsonIgnore]
    [JsonConverter (typeof (IsoDateTimeConverter))]
    public DateTime End { get; set; }
    public Raid(RaidNotes plugin, ulong initiator, ulong victim, Vector3 firstDamage);
    [JsonIgnore]
    public double Hours { get; set; }
    public bool HasHours(int hours);
    public void Participate(BasePlayer player);
    public bool IsAnnounced();
    internal JObject Vector2JObject(Vector3 vector);
    public override string ToString();
    internal JObject ToJObject();
    internal void OnEnded();
    internal void OnStarted();
    internal void Attack(AttackVector vector);
    internal void Kill(AttackVector vector);
}

public class RaidBehavior : MonoBehaviour
{
    public BasePlayer player;
    internal Raid raid;
     void Awake();
     void OnDestroy();
}

public class ExplosiveTracker : MonoBehaviour
{
    public BaseEntity entity;
    public Vector3 lastValidPosition;
    public BasePlayer thrownBy;
    public Vector3 thrownFrom;
     void Awake();
     void Update();
     void OnDestroy();
}

 class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

 class DateTimeConverter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## RaidProtection by mr01sam - Configurable online and/or offline raid protection at the cost of a resource

```csharp
using Newtonsoft.Json;
using System.Text;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Raid Protection", "mr01sam", "2.1.10")]
[Description("Configurable raid protection at the cost of a resource")]
public class RaidProtection : CovalencePlugin
{
    [PluginReference]
    private readonly Plugin Economics;
    [PluginReference]
    private readonly Plugin ServerRewards;
    [PluginReference]
    private readonly Plugin ScrapRaidProtection;
    [PluginReference]
    private readonly Plugin ImageLibrary;
    public static RaidProtection PLUGIN;
    public readonly int COLLECTION_INTERVAL;
    public readonly string PermissionLevel;
    public const string PermissionAdmin;
    private readonly HashSet<ulong> onCooldown;
    private readonly EconomyPanel economyPanel;
    private readonly string[] trackedBuildingBlocks;
    private bool UseMaterialPrices;
    private ItemDefinition CurrencyItemDef;
    private void Init();
    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private void OnUserConnected(IPlayer player);
    private void OnUserDisconnected(IPlayer player);
     void OnPlayerSleepEnded(BasePlayer player);
    private void OnEntitySpawned(BuildingPrivlidge priv);
    private void OnEntityKill(BuildingPrivlidge priv);
    private void OnEntityDeath(BuildingPrivlidge priv, HitInfo hitInfo);
    private object OnCupboardAuthorize(BuildingPrivlidge priv, BasePlayer player);
    private object OnCupboardDeauthorize(BuildingPrivlidge priv, BasePlayer player);
    private object OnCupboardClearList(BuildingPrivlidge priv, BasePlayer player);
    private void OnUserPermissionGranted(string id, string permName);
    private void OnUserPermissionRevoked(string id, string permName);
     void OnUserGroupAdded(string id, string groupName);
     void OnUserGroupRemoved(string id, string groupName);
    private void OnGroupPermissionGranted(string group, string permName);
    private void OnGroupPermissionRevoked(string group, string permName);
     void OnLootEntity(BasePlayer player, BuildingPrivlidge priv);
    private void OnLootEntityEnd(BasePlayer player, BuildingPrivlidge priv);
     object OnLootNetworkUpdate(PlayerLoot loot);
    private object OnEntityTakeDamage(DecayEntity entity, HitInfo info);
    private object OnEntityTakeDamage(LootContainer entity, HitInfo info);
    private object OnEntityTakeDamage(BaseMountable entity, HitInfo info);
    private object OnEntityTakeDamage(BasePlayer entity, HitInfo info);
    private object OnEntityTakeDamage(NPCPlayer entity, HitInfo info);
    private object OnEntityTakeDamage(IOEntity entity, HitInfo info);
    private object OnEntityTakeDamage(BaseResourceExtractor entity, HitInfo info);
    private void OnEntityBuilt(Planner plan, GameObject go);
    private void OnEntityKill(BuildingBlock block);
    private void OnEntityDeath(BuildingBlock block, HitInfo hitInfo);
    private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade);
    private object ProtectFromDamage(BaseCombatEntity entity, HitInfo info);
    private void ApplyDamageCost(ProtectedCupboard tc, HitInfo info, Rust.DamageType majorityDamage, float ratio);
    private void InitProtectionLevels();
    private string FormatCurrency(double amount);
    private string GetStatusMessage(BasePlayer player, ProtectedCupboard tc);
    private string GetTimeRemaining(BasePlayer player, ProtectedCupboard tc);
    private string GetTimeRemaining(string UserIDString, ProtectedCupboard tc);
    private void LoadImages();
    private void LoadAllTcs();
    private void StartCollecting();
    private void StartIndicatorLoops();
    private void SaveTcBalances();
    private void LoadTcBalances();
    private void ResetUI();
    private double GetBalance(ulong userId);
    private void TakeBalance(ulong userId, double amount);
    private void GiveBalance(ulong userId, double amount);
    private void HandleUserPermissionChanged(string id, string permName);
    private void HandleGroupPermissionChanged(string group, string permName);
    private void HandleUserConnected(IPlayer player);
    private void HandleUserDisconnected(IPlayer player);
    private void IndicatorLoop(BasePlayer player);
    private class EconomyPanel
    {
        private const float MIN;
        private const float MAX;
        private Dictionary<string, float> SetBalances;
        public void Increment(string userIdString, float amount);
        public void Decrement(string userIdString, float amount);
        public float Get(string userIdString);
        public void Reset(string userIdString);
    }

    private class ProtectionLevel
    {
        public static ProtectionLevel NONE { get; set; }
        [JsonProperty(PropertyName = "Online protection percentage (0-100)")]
        public float OnlineProtectionPercentage { get; set; }
        [JsonProperty(PropertyName = "Offline protection percentage (0-100)")]
        public float OfflineProtectionPercentage { get; set; }
        [JsonProperty(PropertyName = "Hourly building cost", NullValueHandling = NullValueHandling.Ignore)]
        public float? HourlyBuildingCost { get; set; }
        [JsonProperty(PropertyName = "Hourly base cost", NullValueHandling = NullValueHandling.Ignore)]
        public float? HourlyBaseCost { get; set; }
        [JsonProperty(PropertyName = "Structure damage cost", NullValueHandling = NullValueHandling.Ignore)]
        public float? CostPerDamage { get; set; }
        public static int LevelOf(string useridstring);
        public override string ToString();
        public static void Load();
        public static void Unload();
    }

    private class ProtectedCupboard
    {
        public static Dictionary<ulong, ProtectedCupboard> toolcupboards;
        public static ProtectedCupboard InitCupboard(BuildingPrivlidge priv);
        public static void RemoveCupboard(BuildingPrivlidge priv);
        public BuildingPrivlidge Priv { get; set; }
        public float ProtectionCostPerHour { get; set; }
        public float HoursRemaining { get; set; }
        public float ProtectionCostPerInterval { get; set; }
        public int SurfaceBlockCount { get; set; }
        public DateTime MostRecentAttack { get; set; }
        public bool RecentlyDamaged { get; set; }
        public float StoredBalance { get; set; }
        public float CostDebt { get; set; }
        public bool ContentsLocked { get; set; }
        public int ItemAmount { get; set; }
        public float HourlyBaseCost { get; set; }
        public float HourlyBuildingCost { get; set; }
        public float TotalBuildingCost { get; set; }
        public float CostPerDamage { get; set; }
        public bool CanAffordProtection { get; set; }
        public HashSet<BasePlayer> PlayersViewing { get; set; }
        public HashSet<ulong> AllOwnerIds { get; set; }
        public HashSet<BasePlayer> OnlineOwners { get; set; }
        public ProtectionLevel HighestProtectionLevel { get; set; }
        public bool ForcedProtectionLevel { get; set; }
        public bool IsActive { get; set; }
        public bool HasPermission { get; set; }
        public bool HasOnlineProtection { get; set; }
        public bool HasOfflineProtection { get; set; }
        public bool HasAnyProtection { get; set; }
        public bool HasOwnersOnline { get; set; }
        public ProtectionStatus Status { get; set; }
        public float ProtectionPercentage { get; set; }
        public ProtectedCupboard(BuildingPrivlidge priv);
        public void UpdateHighestProtectionLevel();
        public void UpdateProtectionCostPerHour();
        public void UpdateTotalBuildingCost();
        public void InitialPurchaseProtection();
        public void PurchaseProtection();
        public void StopProtection();
        private void CollectionLoop();
        public void UpdateCostDebt(float amount, int minAmount);
        public void UpdateStoredBalance(float amount);
        public void UpdateStatus();
        public static void Unload();
    }

    private Configuration config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "General settings")]
        public GeneralConfig Settings;
        [JsonProperty(PropertyName = "Protection settings")]
        public ProtectionConfig Protection;
        [JsonProperty(PropertyName = "Cost settings")]
        public PricingConfig Pricing;
        [JsonProperty(PropertyName = "Indicator settings")]
        public IndicatorConfig Indicator;
        public class GeneralConfig
        {
            [JsonProperty(PropertyName = "Currency item ID (if not using economics)")]
            public int CurrencyItemId;
            [JsonProperty(PropertyName = "Use economics balance (requires economics plugin)")]
            public bool UseEconomics;
            [JsonProperty(PropertyName = "Use reward points (requires server rewards plugin)")]
            public bool UseRP;
        }

        public class ProtectionConfig
        {
            [JsonProperty(PropertyName = "Delay after taking damage (seconds)")]
            public int ProtectedDelayAfterTakingDamage { get; set; }
            [JsonProperty(PropertyName = "Delay for offline protection (seconds)")]
            public int OfflineProtectionDelay { get; set; }
            [JsonProperty(PropertyName = "Protect buildings and deployables (true/false)")]
            public bool ProtectBuildings { get; set; }
            [JsonProperty(PropertyName = "Protect players (true/false)")]
            public bool ProtectPlayers { get; set; }
            [JsonProperty(PropertyName = "Protect vehicles and horses (true/false)")]
            public bool ProtectVehicles { get; set; }
            [JsonProperty(PropertyName = "Protect traps and electronics (true/false)")]
            public bool ProtectTraps { get; set; }
            [JsonProperty(PropertyName = "Protection levels")]
            public Dictionary<int, ProtectionLevel> ProtectionLevels;
        }

        public class PricingConfig
        {
            [JsonProperty(PropertyName = "Material cost multipliers")]
            public Dictionary<string, float> MaterialMultipliers { get; set; }
            [JsonProperty(PropertyName = "Default hourly building cost")]
            public float DefaultBuildingCost { get; set; }
            [JsonProperty(PropertyName = "Default hourly base cost")]
            public float DefaultBasePrice { get; set; }
            [JsonProperty(PropertyName = "Default structure damage cost")]
            public float DefaultCostPerDamage { get; set; }
        }

        public class IndicatorConfig
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Persistent")]
            public bool Persistent { get; set; }
            [JsonProperty(PropertyName = "Image url")]
            public string ImageUrl { get; set; }
        }

    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private string Label(string message, string color);
    private string Color(string message, string color);
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private readonly string COLOR_TRANSPARENT;
    private readonly string COLOR_GREEN;
    private readonly string COLOR_RED;
    private readonly string COLOR_GREEN_DARK;
    private readonly string COLOR_GREEN_DARK_LESS;
    private readonly string COLOR_RED_DARK;
    private readonly string COLOR_RED_DARK_LESS;
    private readonly string COLOR_YELLOW;
    private void RefreshUi(ProtectedCupboard tc);
    private void OpenUi(BasePlayer player, BuildingPrivlidge priv);
    private void CloseUi(BasePlayer player);
    private void CloseIndicator(BasePlayer player);
    private void ShowIndicatorForOwners(ProtectedCupboard tc);
    private void ShowIndicator(BasePlayer player, BuildingPrivlidge priv, bool fromDamage, bool ignoreCooldown, bool isPersistent);
    [Command("protection")]
    private void cmd_protection(IPlayer player, string command, string[] args);
    [Command("srp.balance.increment")]
    private void cmd_balance_increment(IPlayer player, string command, string[] args);
    [Command("srp.balance.decrement")]
    private void cmd_balance_decrement(IPlayer player, string command, string[] args);
    [Command("srp.balance.deposit")]
    private void cmd_balance_deposit(IPlayer player, string command, string[] args);
    [Command("srp.balance.withdraw")]
    private void cmd_balance_withdraw(IPlayer player, string command, string[] args);
    [Command("srp.test.online"), Permission(PermissionAdmin)]
    private void cmd_test_online(IPlayer player, string command, string[] args);
    [Command("srp.test.offline"), Permission(PermissionAdmin)]
    private void cmd_test_offline(IPlayer player, string command, string[] args);
    private const bool _debugging;
    private HashSet<BasePlayer> _onlinePlayers;
    private Dictionary<string, long> _startTimes;
    private HashSet<string> _trackedHooks;
    private void Debug(string stmt);
    private void DebugTimeStart(string function);
    private void DebugTimeEnd(string function);
}

private class EconomyPanel
{
    private const float MIN;
    private const float MAX;
    private Dictionary<string, float> SetBalances;
    public void Increment(string userIdString, float amount);
    public void Decrement(string userIdString, float amount);
    public float Get(string userIdString);
    public void Reset(string userIdString);
}

private class ProtectionLevel
{
    public static ProtectionLevel NONE { get; set; }
    [JsonProperty(PropertyName = "Online protection percentage (0-100)")]
    public float OnlineProtectionPercentage { get; set; }
    [JsonProperty(PropertyName = "Offline protection percentage (0-100)")]
    public float OfflineProtectionPercentage { get; set; }
    [JsonProperty(PropertyName = "Hourly building cost", NullValueHandling = NullValueHandling.Ignore)]
    public float? HourlyBuildingCost { get; set; }
    [JsonProperty(PropertyName = "Hourly base cost", NullValueHandling = NullValueHandling.Ignore)]
    public float? HourlyBaseCost { get; set; }
    [JsonProperty(PropertyName = "Structure damage cost", NullValueHandling = NullValueHandling.Ignore)]
    public float? CostPerDamage { get; set; }
    public static int LevelOf(string useridstring);
    public override string ToString();
    public static void Load();
    public static void Unload();
}

private class ProtectedCupboard
{
    public static Dictionary<ulong, ProtectedCupboard> toolcupboards;
    public static ProtectedCupboard InitCupboard(BuildingPrivlidge priv);
    public static void RemoveCupboard(BuildingPrivlidge priv);
    public BuildingPrivlidge Priv { get; set; }
    public float ProtectionCostPerHour { get; set; }
    public float HoursRemaining { get; set; }
    public float ProtectionCostPerInterval { get; set; }
    public int SurfaceBlockCount { get; set; }
    public DateTime MostRecentAttack { get; set; }
    public bool RecentlyDamaged { get; set; }
    public float StoredBalance { get; set; }
    public float CostDebt { get; set; }
    public bool ContentsLocked { get; set; }
    public int ItemAmount { get; set; }
    public float HourlyBaseCost { get; set; }
    public float HourlyBuildingCost { get; set; }
    public float TotalBuildingCost { get; set; }
    public float CostPerDamage { get; set; }
    public bool CanAffordProtection { get; set; }
    public HashSet<BasePlayer> PlayersViewing { get; set; }
    public HashSet<ulong> AllOwnerIds { get; set; }
    public HashSet<BasePlayer> OnlineOwners { get; set; }
    public ProtectionLevel HighestProtectionLevel { get; set; }
    public bool ForcedProtectionLevel { get; set; }
    public bool IsActive { get; set; }
    public bool HasPermission { get; set; }
    public bool HasOnlineProtection { get; set; }
    public bool HasOfflineProtection { get; set; }
    public bool HasAnyProtection { get; set; }
    public bool HasOwnersOnline { get; set; }
    public ProtectionStatus Status { get; set; }
    public float ProtectionPercentage { get; set; }
    public ProtectedCupboard(BuildingPrivlidge priv);
    public void UpdateHighestProtectionLevel();
    public void UpdateProtectionCostPerHour();
    public void UpdateTotalBuildingCost();
    public void InitialPurchaseProtection();
    public void PurchaseProtection();
    public void StopProtection();
    private void CollectionLoop();
    public void UpdateCostDebt(float amount, int minAmount);
    public void UpdateStoredBalance(float amount);
    public void UpdateStatus();
    public static void Unload();
}

private class Configuration
{
    [JsonProperty(PropertyName = "General settings")]
    public GeneralConfig Settings;
    [JsonProperty(PropertyName = "Protection settings")]
    public ProtectionConfig Protection;
    [JsonProperty(PropertyName = "Cost settings")]
    public PricingConfig Pricing;
    [JsonProperty(PropertyName = "Indicator settings")]
    public IndicatorConfig Indicator;
    public class GeneralConfig
    {
        [JsonProperty(PropertyName = "Currency item ID (if not using economics)")]
        public int CurrencyItemId;
        [JsonProperty(PropertyName = "Use economics balance (requires economics plugin)")]
        public bool UseEconomics;
        [JsonProperty(PropertyName = "Use reward points (requires server rewards plugin)")]
        public bool UseRP;
    }

    public class ProtectionConfig
    {
        [JsonProperty(PropertyName = "Delay after taking damage (seconds)")]
        public int ProtectedDelayAfterTakingDamage { get; set; }
        [JsonProperty(PropertyName = "Delay for offline protection (seconds)")]
        public int OfflineProtectionDelay { get; set; }
        [JsonProperty(PropertyName = "Protect buildings and deployables (true/false)")]
        public bool ProtectBuildings { get; set; }
        [JsonProperty(PropertyName = "Protect players (true/false)")]
        public bool ProtectPlayers { get; set; }
        [JsonProperty(PropertyName = "Protect vehicles and horses (true/false)")]
        public bool ProtectVehicles { get; set; }
        [JsonProperty(PropertyName = "Protect traps and electronics (true/false)")]
        public bool ProtectTraps { get; set; }
        [JsonProperty(PropertyName = "Protection levels")]
        public Dictionary<int, ProtectionLevel> ProtectionLevels;
    }

    public class PricingConfig
    {
        [JsonProperty(PropertyName = "Material cost multipliers")]
        public Dictionary<string, float> MaterialMultipliers { get; set; }
        [JsonProperty(PropertyName = "Default hourly building cost")]
        public float DefaultBuildingCost { get; set; }
        [JsonProperty(PropertyName = "Default hourly base cost")]
        public float DefaultBasePrice { get; set; }
        [JsonProperty(PropertyName = "Default structure damage cost")]
        public float DefaultCostPerDamage { get; set; }
    }

    public class IndicatorConfig
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Persistent")]
        public bool Persistent { get; set; }
        [JsonProperty(PropertyName = "Image url")]
        public string ImageUrl { get; set; }
    }

}

public class GeneralConfig
{
    [JsonProperty(PropertyName = "Currency item ID (if not using economics)")]
    public int CurrencyItemId;
    [JsonProperty(PropertyName = "Use economics balance (requires economics plugin)")]
    public bool UseEconomics;
    [JsonProperty(PropertyName = "Use reward points (requires server rewards plugin)")]
    public bool UseRP;
}

public class ProtectionConfig
{
    [JsonProperty(PropertyName = "Delay after taking damage (seconds)")]
    public int ProtectedDelayAfterTakingDamage { get; set; }
    [JsonProperty(PropertyName = "Delay for offline protection (seconds)")]
    public int OfflineProtectionDelay { get; set; }
    [JsonProperty(PropertyName = "Protect buildings and deployables (true/false)")]
    public bool ProtectBuildings { get; set; }
    [JsonProperty(PropertyName = "Protect players (true/false)")]
    public bool ProtectPlayers { get; set; }
    [JsonProperty(PropertyName = "Protect vehicles and horses (true/false)")]
    public bool ProtectVehicles { get; set; }
    [JsonProperty(PropertyName = "Protect traps and electronics (true/false)")]
    public bool ProtectTraps { get; set; }
    [JsonProperty(PropertyName = "Protection levels")]
    public Dictionary<int, ProtectionLevel> ProtectionLevels;
}

public class PricingConfig
{
    [JsonProperty(PropertyName = "Material cost multipliers")]
    public Dictionary<string, float> MaterialMultipliers { get; set; }
    [JsonProperty(PropertyName = "Default hourly building cost")]
    public float DefaultBuildingCost { get; set; }
    [JsonProperty(PropertyName = "Default hourly base cost")]
    public float DefaultBasePrice { get; set; }
    [JsonProperty(PropertyName = "Default structure damage cost")]
    public float DefaultCostPerDamage { get; set; }
}

public class IndicatorConfig
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Persistent")]
    public bool Persistent { get; set; }
    [JsonProperty(PropertyName = "Image url")]
    public string ImageUrl { get; set; }
}


```

---

## RaidTracker by Mabel - Track raids by explosives, weapons, and ammo with detailed on-screen visuals

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Raid Tracker", "Mabel", "2.1.3")]
[Description("Track raids by explosives, weapons, and ammo with detailed on-screen visuals")]
 class RaidTracker : CovalencePlugin
{
    private readonly bool _dev;
    private bool _debug;
    private readonly float _debugDrawDuration;
    private static RaidTracker _instance;
    private PluginConfig _config;
    private bool _isConfigValid;
    private readonly StringBuilder _sb;
    private readonly Game.Rust.Libraries.Player _rustPlayer;
    private readonly DiscordWebhookManager _discordWebhookManager;
    private readonly int _collisionLayerMask;
    private readonly Dictionary<Vector3, ulong> _MLRSRocketOwners;
    private readonly Dictionary<ulong, bool> _verboseMode;
    private readonly Dictionary<ulong, string[]> _lastViewCommand;
    private Dictionary<string, DecayEntityIgnoreOptions> _decayEntityIgnoreList;
    private readonly Dictionary<string, string> _prefabToItem;
    private readonly Dictionary<string, string> _buildingBlockPrettyNames;
    private readonly Dictionary<ulong, float> _notificationCooldown;
    private bool _wipeData;
    private List<RaidEvent> _raidEventLog;
    private string _raidEventLogFilename;
    private int _raidEventLogCount;
    private readonly string[] _ignoredTimedExplosives;
    private readonly string[] _uniqueHexColors;
    private readonly List<Color> _uniqueColors;
    private readonly Dictionary<ulong, Color> _teamColors;
    private int _currentTeamColorIdx;
    [PluginReference]
    private readonly Plugin AbandonedBases;
    private readonly Plugin Clans;
    private readonly Plugin RaidableBases;
    private const string PERM_WIPE;
    private const string PERM_PX;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerDisconnected(BasePlayer pl, string reason);
    private void OnMlrsFired(MLRS mlrs, BasePlayer driver);
    private void OnMlrsFiringEnded(MLRS mlrs);
    private void OnEntitySpawned(TimedExplosive ent);
    private void OnEntityDeath(DecayEntity entity, HitInfo info);
    private void OnServerSave();
    private void OnNewSave(string filename);
    [Command("x")]
    private void ViewExplosionsCommand(IPlayer player, string command, string[] args);
    [Command("px")]
    private void PlayerViewExplosionsCommand(IPlayer player, string command, string[] args);
    [Command("re")]
    private void RaidEventDetailsCommand(IPlayer player, string command, string[] args);
    [Command("rt.debug")]
    private void DebugCommand(IPlayer player, string command, string[] args);
    [Command("rt.weapon_colors")]
    private void WeaponColorsCommand(IPlayer player, string command, string[] args);
    private void DrawRaidEvents(BasePlayer pl, IEnumerable<IGrouping<RaidFilter, RaidEvent>> groupedRaidsNearMe, string filterType, string filter, float radius, bool drawAttackerName);
    private void LogToSingleFile(string filename, string text);
    private void PrintDebug(string msg);
    private void SendChatMsg(BasePlayer pl, string msg, string prefix);
    public void Arrow(BasePlayer player, Vector3 from, Vector3 to, float headSize, Color color, float duration);
    public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration);
    public void Box(BasePlayer player, Vector3 pos, float size, Color color, float duration);
    public void Text(BasePlayer player, Vector3 pos, string text, Color color, float duration);
    private void AddPrefabToItem(string prefab, string itemShortname, string prefabSource);
    private string GetItemFromPrefabShortname(string prefabShortname);
    private string GetPrefabShortname(string prefab);
    private string GetPrettyItemName(string itemShortname);
    private IEnumerable<RaidEvent> FindRaidEventsInSphere(Vector3 pos, float r);
    private Color GetRandomColor();
    private string GetHexColor(Color color);
    private PluginConfig.WeaponConfig AddOrFindWeaponConfig(string category, string shortname);
    private PluginConfig.WeaponConfig FindWeaponConfig(string category, string shortname);
    private string GetDecayEntityShortname(DecayEntity entity);
    private bool IsDecayEntityIgnored(DecayEntity entity);
    private bool IsDecayEntityOrAttackerIgnored(DecayEntity entity, BasePlayer attacker);
    private string FormatPosition(Vector3 pos);
    private string StringReplaceKeys(string str, Dictionary<string, string> kv);
    private void SaveRaidEventLog();
    protected override void LoadDefaultMessages();
    private PluginConfig GetDefaultConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class PluginConfig : SerializableConfiguration
    {
        public bool debug;
        public ulong chatIconID;
        public bool deleteDataOnWipe;
        public float daysBeforeDelete;
        public float searchRadius;
        public float drawDuration;
        [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<BuildingGrade.Enum, bool> ignoreBuildingGrades;
        public bool ignoreSameOwner;
        public bool ignoreTeamMember;
        public bool ignoreClanMemberOrAlly;
        public bool enableNewTrackers;
        public bool printToClientConsole;
        public PlayerViewExplosionsCommand playerViewExplosionsCommand;
        public NotificationCooldown notificationCooldown;
        public DiscordConfig discord;
        [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SortedDictionary<string, SortedDictionary<string, WeaponConfig>> trackers;
        [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public SortedDictionary<string, string> eventTypes;
        public class WeaponConfig
        {
            public bool enabled;
            public string name;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
            public string hexColor;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
            public bool alwaysLog;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
            public bool shortArrow;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
            public string discordIcon;
            public bool notifyConsole;
            public bool notifyAdmin;
            public bool notifyDiscord;
            public bool logToFile;
            public Color GetWeaponColor();
        }

        public class DiscordConfig
        {
            public string webhookURL;
            public DiscordSimpleMessage simpleMessage;
            public DiscordEmbed embed;
        }

        public class DiscordSimpleMessage
        {
            public bool enabled;
            public string message;
        }

        public class DiscordEmbed
        {
            public string title;
            public DiscordEmbedThumbnail thumbnail;
            [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<DiscordEmbedField> fields;
            public DiscordEmbedFooter footer;
        }

        public class DiscordEmbedThumbnail
        {
            public string newUrl;
        }

        public class DiscordEmbedField
        {
            public string name;
            public string value;
            public bool inline;
        }

        public class DiscordEmbedFooter
        {
            public string text;
            public string icon_url;
        }

        public class PlayerViewExplosionsCommand
        {
            public bool drawAttackerName;
            public float ignoreRaidEventsLessThanMinutes;
        }

        public class NotificationCooldown
        {
            public bool enabled;
            public float cooldown;
        }

    }

    public class DecayEntityIgnoreOptions
    {
        public string name;
        public bool ignore;
        public bool ignoreDiscord;
    }

    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    private class DiscordWebhookManager
    {
        private float _timeout;
        private float _busy;
        private bool _rateLimited;
        private Queue<RaidEvent> _queue;
        private readonly Dictionary<string, string> _headers;
        public void Enqueue(RaidEvent raidEvent);
        private void SendNextRequest();
        public void SendWebhook(RaidEvent raidEvent);
    }

    public class Vector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private class RaidEvent
    {
        public string attackerName;
        public ulong attackerSteamID;
        public ulong attackerTeamID;
        public ulong victimSteamID;
        public string weapon;
        public string hitEntity;
        [JsonConverter(typeof(Vector3Converter))]
        public Vector3 startPos;
        [JsonConverter(typeof(Vector3Converter))]
        public Vector3 endPos;
        public DateTime timestamp;
        public int GetIndex();
        public string GetPrimaryWeapon();
        public string GetPrimaryWeaponShortname();
        public string GetSecondaryWeapon();
        public string GetSecondaryWeaponShortname();
        private string GetWeaponShortname(string w);
        public string GetTrackerCategory();
        private string GetTrackerCategory(string w);
        public string GetWeaponName();
        public string GetEventType();
        public string GetPrettyEventType();
        public string GetHitEntityShortname();
        public string GetMessage();
        public string GetPrettyMessage(BasePlayer pl);
        public void Notify(BaseEntity entity, string damagedEntityPrefab);
        private void NotifyAdmin();
        private void DebugNotify(BaseEntity entity);
    }

    private class RaidFilter
    {
        public string filter;
        public string filterType;
        public override bool Equals(object other);
        public override int GetHashCode();
        public bool Equals(RaidFilter other);
    }

    public class ExplosiveTracker : MonoBehaviour
    {
        private float startTime;
        private double millisecondsTaken;
        private string hitEntityPrefab;
        private BaseEntity explosiveEntity;
        private DecayEntity parentEntity;
        private BasePlayer attacker;
        private Vector3 position;
        private RaidEvent raidEvent;
        public string trackerCategory;
        public bool logEvent;
        public void Init(string category);
        private void FixedUpdate();
        private void OnDestroy();
    }

}

private class PluginConfig : SerializableConfiguration
{
    public bool debug;
    public ulong chatIconID;
    public bool deleteDataOnWipe;
    public float daysBeforeDelete;
    public float searchRadius;
    public float drawDuration;
    [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<BuildingGrade.Enum, bool> ignoreBuildingGrades;
    public bool ignoreSameOwner;
    public bool ignoreTeamMember;
    public bool ignoreClanMemberOrAlly;
    public bool enableNewTrackers;
    public bool printToClientConsole;
    public PlayerViewExplosionsCommand playerViewExplosionsCommand;
    public NotificationCooldown notificationCooldown;
    public DiscordConfig discord;
    [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SortedDictionary<string, SortedDictionary<string, WeaponConfig>> trackers;
    [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public SortedDictionary<string, string> eventTypes;
    public class WeaponConfig
    {
        public bool enabled;
        public string name;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
        public string hexColor;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
        public bool alwaysLog;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
        public bool shortArrow;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
        public string discordIcon;
        public bool notifyConsole;
        public bool notifyAdmin;
        public bool notifyDiscord;
        public bool logToFile;
        public Color GetWeaponColor();
    }

    public class DiscordConfig
    {
        public string webhookURL;
        public DiscordSimpleMessage simpleMessage;
        public DiscordEmbed embed;
    }

    public class DiscordSimpleMessage
    {
        public bool enabled;
        public string message;
    }

    public class DiscordEmbed
    {
        public string title;
        public DiscordEmbedThumbnail thumbnail;
        [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<DiscordEmbedField> fields;
        public DiscordEmbedFooter footer;
    }

    public class DiscordEmbedThumbnail
    {
        public string newUrl;
    }

    public class DiscordEmbedField
    {
        public string name;
        public string value;
        public bool inline;
    }

    public class DiscordEmbedFooter
    {
        public string text;
        public string icon_url;
    }

    public class PlayerViewExplosionsCommand
    {
        public bool drawAttackerName;
        public float ignoreRaidEventsLessThanMinutes;
    }

    public class NotificationCooldown
    {
        public bool enabled;
        public float cooldown;
    }

}

public class WeaponConfig
{
    public bool enabled;
    public string name;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
    public string hexColor;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
    public bool alwaysLog;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
    public bool shortArrow;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate)]
    public string discordIcon;
    public bool notifyConsole;
    public bool notifyAdmin;
    public bool notifyDiscord;
    public bool logToFile;
    public Color GetWeaponColor();
}

public class DiscordConfig
{
    public string webhookURL;
    public DiscordSimpleMessage simpleMessage;
    public DiscordEmbed embed;
}

public class DiscordSimpleMessage
{
    public bool enabled;
    public string message;
}

public class DiscordEmbed
{
    public string title;
    public DiscordEmbedThumbnail thumbnail;
    [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<DiscordEmbedField> fields;
    public DiscordEmbedFooter footer;
}

public class DiscordEmbedThumbnail
{
    public string newUrl;
}

public class DiscordEmbedField
{
    public string name;
    public string value;
    public bool inline;
}

public class DiscordEmbedFooter
{
    public string text;
    public string icon_url;
}

public class PlayerViewExplosionsCommand
{
    public bool drawAttackerName;
    public float ignoreRaidEventsLessThanMinutes;
}

public class NotificationCooldown
{
    public bool enabled;
    public float cooldown;
}

public class DecayEntityIgnoreOptions
{
    public string name;
    public bool ignore;
    public bool ignoreDiscord;
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private class DiscordWebhookManager
{
    private float _timeout;
    private float _busy;
    private bool _rateLimited;
    private Queue<RaidEvent> _queue;
    private readonly Dictionary<string, string> _headers;
    public void Enqueue(RaidEvent raidEvent);
    private void SendNextRequest();
    public void SendWebhook(RaidEvent raidEvent);
}

public class Vector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

private class RaidEvent
{
    public string attackerName;
    public ulong attackerSteamID;
    public ulong attackerTeamID;
    public ulong victimSteamID;
    public string weapon;
    public string hitEntity;
    [JsonConverter(typeof(Vector3Converter))]
    public Vector3 startPos;
    [JsonConverter(typeof(Vector3Converter))]
    public Vector3 endPos;
    public DateTime timestamp;
    public int GetIndex();
    public string GetPrimaryWeapon();
    public string GetPrimaryWeaponShortname();
    public string GetSecondaryWeapon();
    public string GetSecondaryWeaponShortname();
    private string GetWeaponShortname(string w);
    public string GetTrackerCategory();
    private string GetTrackerCategory(string w);
    public string GetWeaponName();
    public string GetEventType();
    public string GetPrettyEventType();
    public string GetHitEntityShortname();
    public string GetMessage();
    public string GetPrettyMessage(BasePlayer pl);
    public void Notify(BaseEntity entity, string damagedEntityPrefab);
    private void NotifyAdmin();
    private void DebugNotify(BaseEntity entity);
}

private class RaidFilter
{
    public string filter;
    public string filterType;
    public override bool Equals(object other);
    public override int GetHashCode();
    public bool Equals(RaidFilter other);
}

public class ExplosiveTracker : MonoBehaviour
{
    private float startTime;
    private double millisecondsTaken;
    private string hitEntityPrefab;
    private BaseEntity explosiveEntity;
    private DecayEntity parentEntity;
    private BasePlayer attacker;
    private Vector3 position;
    private RaidEvent raidEvent;
    public string trackerCategory;
    public bool logEvent;
    public void Init(string category);
    private void FixedUpdate();
    private void OnDestroy();
}


```

---

## RainOfFire by k1lly0u - Custom event that adds meteor showers to the game

```csharp
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;
using Rust;

Oxide.Plugins
[Info("RainOfFire", "emu / k1lly0u", "0.2.52")]
[Description("Simulate a meteor strike using rockets falling from the sky")]
 class RainOfFire : RustPlugin
{
    [PluginReference]
     Plugin PopupNotifications;
    private Timer EventTimer;
    private List<Timer> RocketTimers;
    private void OnServerInitialized();
    private void Unload();
    private void StartEventTimer();
    private void StopTimer();
    private void StartRandomOnMap();
    private bool StartOnPlayer(string playerName, ConfigData.Settings setting);
    private void StartBarrage(Vector3 origin, Vector3 direction);
    private void StartRainOfFire(Vector3 origin, ConfigData.Settings setting);
    private void RandomRocket(Vector3 origin, float radius, ConfigData.Settings setting);
    private void SpreadRocket(Vector3 origin, Vector3 direction);
    private BaseEntity CreateRocket(Vector3 startPoint, Vector3 direction, bool isFireRocket);
    private void ScaleAllDamage(List<DamageTypeEntry> damageTypes, float scale);
    private void SetIntervals(int intervals);
    private void SetDamageMult(float scale);
    private void SetNotifyEvent(bool notify);
    private void SetDropRate(float rate);
    [ChatCommand("rof")]
    private void cmdROF(BasePlayer player, string command, string[] args);
    [ConsoleCommand("rof.random")]
    private void ccmdEventRandom(ConsoleSystem.Arg arg);
    [ConsoleCommand("rof.onposition")]
    private void ccmdEventOnPosition(ConsoleSystem.Arg arg);
    private BasePlayer GetPlayerByName(string name);
    private static int RandomRange(int min, int max);
    private Vector3 GetGroundPosition(Vector3 sourcePos);
    private class ItemCarrier : MonoBehaviour
    {
        private ItemDrop[] carriedItems;
        private float multiplier;
        public void SetCarriedItems(ItemDrop[] carriedItems);
        public void SetDropMultiplier(float multiplier);
        private void OnDestroy();
    }

    private class ItemDrop
    {
        public string Shortname { get; set; }
        public int Minimum { get; set; }
        public int Maximum { get; set; }
    }

    private ConfigData configData;
     class ConfigData
    {
        public BarrageOptions BarrageSettings { get; set; }
        public DamageOptions DamageControl { get; set; }
        public ConfigOptions Options { get; set; }
        public IntensityOptions z_IntensitySettings { get; set; }
        public class DamageOptions
        {
            public float DamageMultiplier { get; set; }
        }

        public class BarrageOptions
        {
            public int NumberOfRockets { get; set; }
            public float RocketDelay { get; set; }
            public float RocketSpread { get; set; }
        }

        public class Drops
        {
            public bool EnableItemDrop { get; set; }
            public ItemDrop[] ItemsToDrop { get; set; }
        }

        public class ConfigOptions
        {
            public bool EnableAutomaticEvents { get; set; }
            public Timers EventTimers { get; set; }
            public float GlobalDropMultiplier { get; set; }
            public bool NotifyEvent { get; set; }
        }

        public class Timers
        {
            public int EventInterval { get; set; }
            public bool UseRandomTimer { get; set; }
            public int RandomTimerMin { get; set; }
            public int RandomTimerMax { get; set; }
        }

        public class Settings
        {
            public int FireRocketChance { get; set; }
            public float Radius { get; set; }
            public int RocketAmount { get; set; }
            public int Duration { get; set; }
            public Drops ItemDropControl { get; set; }
        }

        public class IntensityOptions
        {
            public Settings Settings_Mild { get; set; }
            public Settings Settings_Optimal { get; set; }
            public Settings Settings_Extreme { get; set; }
        }

    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     string msg(string key, string playerId);
     Dictionary<string, string> Messages;
}

private class ItemCarrier : MonoBehaviour
{
    private ItemDrop[] carriedItems;
    private float multiplier;
    public void SetCarriedItems(ItemDrop[] carriedItems);
    public void SetDropMultiplier(float multiplier);
    private void OnDestroy();
}

private class ItemDrop
{
    public string Shortname { get; set; }
    public int Minimum { get; set; }
    public int Maximum { get; set; }
}

 class ConfigData
{
    public BarrageOptions BarrageSettings { get; set; }
    public DamageOptions DamageControl { get; set; }
    public ConfigOptions Options { get; set; }
    public IntensityOptions z_IntensitySettings { get; set; }
    public class DamageOptions
    {
        public float DamageMultiplier { get; set; }
    }

    public class BarrageOptions
    {
        public int NumberOfRockets { get; set; }
        public float RocketDelay { get; set; }
        public float RocketSpread { get; set; }
    }

    public class Drops
    {
        public bool EnableItemDrop { get; set; }
        public ItemDrop[] ItemsToDrop { get; set; }
    }

    public class ConfigOptions
    {
        public bool EnableAutomaticEvents { get; set; }
        public Timers EventTimers { get; set; }
        public float GlobalDropMultiplier { get; set; }
        public bool NotifyEvent { get; set; }
    }

    public class Timers
    {
        public int EventInterval { get; set; }
        public bool UseRandomTimer { get; set; }
        public int RandomTimerMin { get; set; }
        public int RandomTimerMax { get; set; }
    }

    public class Settings
    {
        public int FireRocketChance { get; set; }
        public float Radius { get; set; }
        public int RocketAmount { get; set; }
        public int Duration { get; set; }
        public Drops ItemDropControl { get; set; }
    }

    public class IntensityOptions
    {
        public Settings Settings_Mild { get; set; }
        public Settings Settings_Optimal { get; set; }
        public Settings Settings_Extreme { get; set; }
    }

}

public class DamageOptions
{
    public float DamageMultiplier { get; set; }
}

public class BarrageOptions
{
    public int NumberOfRockets { get; set; }
    public float RocketDelay { get; set; }
    public float RocketSpread { get; set; }
}

public class Drops
{
    public bool EnableItemDrop { get; set; }
    public ItemDrop[] ItemsToDrop { get; set; }
}

public class ConfigOptions
{
    public bool EnableAutomaticEvents { get; set; }
    public Timers EventTimers { get; set; }
    public float GlobalDropMultiplier { get; set; }
    public bool NotifyEvent { get; set; }
}

public class Timers
{
    public int EventInterval { get; set; }
    public bool UseRandomTimer { get; set; }
    public int RandomTimerMin { get; set; }
    public int RandomTimerMax { get; set; }
}

public class Settings
{
    public int FireRocketChance { get; set; }
    public float Radius { get; set; }
    public int RocketAmount { get; set; }
    public int Duration { get; set; }
    public Drops ItemDropControl { get; set; }
}

public class IntensityOptions
{
    public Settings Settings_Mild { get; set; }
    public Settings Settings_Optimal { get; set; }
    public Settings Settings_Extreme { get; set; }
}


```

---

## RandomDeployables by  - Randomize deployable skins

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Random Deployables", "Norn/Arainrr", "1.1.0", ResourceId = 2187)]
[Description("Randomize deployable skins")]
public class RandomDeployables : RustPlugin
{
    private const string PERMISSION_USE;
    private readonly Hash<string, List<ulong>> itemSkins;
    private readonly Dictionary<string, string> deployed2Item;
    private readonly Dictionary<string, List<ulong>> approvedSkins;
    private void Init();
    private void OnServerInitialized();
    private void OnEntityBuilt(Planner planner, GameObject obj);
    private void FindApprovedSkins();
    private IEnumerable<ulong> GetItemSkins(ItemDefinition itemDefinition);
    [ConsoleCommand("rd.skins")]
    private void CmdOutputSkins();
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Allow default skin")]
        public bool defaultSkin;
        [JsonProperty(PropertyName = "If the item has skin, block random skin")]
        public bool blockRandom;
        [JsonProperty(PropertyName = "Block item list (item short name)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> blockItems;
        [JsonProperty(PropertyName = "Block skin list (item skin id)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> blockSkins;
        [JsonProperty(PropertyName = "Custom skin list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<ulong>> customSkins;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Allow default skin")]
    public bool defaultSkin;
    [JsonProperty(PropertyName = "If the item has skin, block random skin")]
    public bool blockRandom;
    [JsonProperty(PropertyName = "Block item list (item short name)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> blockItems;
    [JsonProperty(PropertyName = "Block skin list (item skin id)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> blockSkins;
    [JsonProperty(PropertyName = "Custom skin list", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<ulong>> customSkins;
}


```

---

## RandomGatherPremium by kaysharp - Get random items on gathering resources or on full gather

```csharp
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = System.Random;

Oxide.Plugins
[Info("Random Gather Premium", "Kaysharp", "1.0.8")]
[Description("Get random items on gathering resources, quarry gather, Excavator gather and loot containers")]
 class RandomGatherPremium : CovalencePlugin
{
    private readonly Random _random;
    public static ConfigData config { get; set; }
    public List<string> ContainterBlacklist;
    private void Init();
    private void OnServerInitialized();
    private ItemDefinition FindItem(string itemNameOrId);
    private void Unload();
    private void RepopulateContainers();
     BaseCorpse OnCorpsePopulate(BasePlayer npcPlayer, BaseCorpse corpse);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     object OnExcavatorGather(ExcavatorArm excavator, Item item);
     object OnQuarryGather(MiningQuarry quarry, Item item);
    private object OnLootSpawn(LootContainer container);
     void OnSupplyDropDropped(SupplyDrop SupplyDrop, CargoPlane plane);
     object OnCollectiblePickup(CollectibleEntity entity, BasePlayer player);
     object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
     object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item);
    public class ConfigData
    {
        [JsonProperty(PropertyName = "Give bonuses if player have active boost")]
        public bool isBoost;
        [JsonProperty(PropertyName = "How many items should spawn when barrel is destroyed?")]
        public int NumbOfItemsInBarrels;
        [JsonProperty(PropertyName = "Give random items when barrel is destroyed")]
        public bool isOnEntityDeath { get; set; }
        [JsonProperty(PropertyName = "Give random items on gathering resources")]
        public bool isOnDispenserGather { get; set; }
        [JsonProperty(PropertyName = "Give random items only on full gather")]
        public bool isOnDispenserBonus { get; set; }
        [JsonProperty(PropertyName = "Give random item when collecting resources")]
        public bool OnCollectiblePickup { get; set; }
        [JsonProperty(PropertyName = "Give random items on quarry gather")]
        public bool isOnQuarryGather { get; set; }
        [JsonProperty(PropertyName = "Give random items on Excavator gather")]
        public bool isOnExcavatorGather { get; set; }
        [JsonProperty(PropertyName = "Fill loot containers with random items")]
        public bool isOnLootEntity { get; set; }
        [JsonProperty(PropertyName = "Fill airdrops with random items")]
        public bool isOnSupplyDropDropped { get; set; }
        [JsonProperty(PropertyName = "Populate NPC corps with random loot")]
        public bool isOnCorpsePopulate { get; set; }
        [JsonProperty(PropertyName = "Items")]
        public List<string> Items;
        [JsonProperty(PropertyName = "Amount")]
        public Dictionary<string, int> Amount;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetDefaultSettings();
    protected override void SaveConfig();
}

public class ConfigData
{
    [JsonProperty(PropertyName = "Give bonuses if player have active boost")]
    public bool isBoost;
    [JsonProperty(PropertyName = "How many items should spawn when barrel is destroyed?")]
    public int NumbOfItemsInBarrels;
    [JsonProperty(PropertyName = "Give random items when barrel is destroyed")]
    public bool isOnEntityDeath { get; set; }
    [JsonProperty(PropertyName = "Give random items on gathering resources")]
    public bool isOnDispenserGather { get; set; }
    [JsonProperty(PropertyName = "Give random items only on full gather")]
    public bool isOnDispenserBonus { get; set; }
    [JsonProperty(PropertyName = "Give random item when collecting resources")]
    public bool OnCollectiblePickup { get; set; }
    [JsonProperty(PropertyName = "Give random items on quarry gather")]
    public bool isOnQuarryGather { get; set; }
    [JsonProperty(PropertyName = "Give random items on Excavator gather")]
    public bool isOnExcavatorGather { get; set; }
    [JsonProperty(PropertyName = "Fill loot containers with random items")]
    public bool isOnLootEntity { get; set; }
    [JsonProperty(PropertyName = "Fill airdrops with random items")]
    public bool isOnSupplyDropDropped { get; set; }
    [JsonProperty(PropertyName = "Populate NPC corps with random loot")]
    public bool isOnCorpsePopulate { get; set; }
    [JsonProperty(PropertyName = "Items")]
    public List<string> Items;
    [JsonProperty(PropertyName = "Amount")]
    public Dictionary<string, int> Amount;
}


```

---

## RandomKit by VisEntities - Gives players a random kit

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Random Kit", "VisEntities", "2.0.0")]
[Description("Gives players a random kit.")]
public class RandomKit : RustPlugin
{
    [PluginReference]
    private readonly Plugin Kits;
    private static RandomKit _plugin;
    private static Configuration _config;
    private Dictionary<ulong, DateTime> _kitCooldowns;
    private class Configuration
    {
        [JsonProperty("Version")]
        public string Version { get; set; }
        [JsonProperty("Cooldown Seconds")]
        public float CooldownSeconds { get; set; }
        [JsonProperty("Kits")]
        public List<string> Kits { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private Configuration GetDefaultConfig();
    private void Init();
    private void Unload();
    public static bool TryGiveKit(BasePlayer player, string kitName);
    private static bool VerifyPluginBeingLoaded(Plugin plugin);
    private static class PermissionUtil
    {
        public const string USE;
        public static void RegisterPermissions();
        public static bool VerifyHasPermission(BasePlayer player, string permissionName);
    }

    [ChatCommand("randomkit")]
    private void cmdGetRandomKit(BasePlayer player, string cmd, string[] args);
    private class Lang
    {
        public const string NoPermission;
        public const string KitGiven;
        public const string KitCooldown;
        public const string NoKitsAvailable;
        public const string KitGiveError;
    }

    protected override void LoadDefaultMessages();
    private void SendReplyToPlayer(BasePlayer player, string messageKey, object[] args);
}

private class Configuration
{
    [JsonProperty("Version")]
    public string Version { get; set; }
    [JsonProperty("Cooldown Seconds")]
    public float CooldownSeconds { get; set; }
    [JsonProperty("Kits")]
    public List<string> Kits { get; set; }
}

private static class PermissionUtil
{
    public const string USE;
    public static void RegisterPermissions();
    public static bool VerifyHasPermission(BasePlayer player, string permissionName);
}

private class Lang
{
    public const string NoPermission;
    public const string KitGiven;
    public const string KitCooldown;
    public const string NoKitsAvailable;
    public const string KitGiveError;
}


```

---

## RandomPositions by  - Randomized positions for plugins or for players respawn points

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Random Positions", "Orange", "1.0.3")]
[Description("Randomized positions for plugins or for players respawn points")]
public class RandomPositions : RustPlugin
{
    private HashSet<Vector3> positions;
    private const int scanHeight;
    private static int getBlockMask { get; set; }
    private static bool MaskIsBlocked(int mask);
    private const string commandName;
    private void Init();
    private void OnServerInitialized();
    private object OnPlayerRespawn(BasePlayer player);
    private object GetRandomPosition();
    private void cmdControlConsole(ConsoleSystem.Arg arg);
    private void GeneratePositions();
    private Vector3 GetClosestValidPosition(Vector3 original, BasePlayer player);
    private Vector3 GetValidSpawnPoint();
    private static bool IsValidPosition(Vector3 position);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Use for player spawns")]
        public bool useForPlayerSpawns;
        [JsonProperty(PropertyName = "Buildings radius check")]
        public int radiusCheck;
        [JsonProperty(PropertyName = "Positions to generate")]
        public int positionsToGenerate;
        [JsonProperty(PropertyName = "Maximal generation attempts")]
        public int maxGenerationAttempts;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Use for player spawns")]
    public bool useForPlayerSpawns;
    [JsonProperty(PropertyName = "Buildings radius check")]
    public int radiusCheck;
    [JsonProperty(PropertyName = "Positions to generate")]
    public int positionsToGenerate;
    [JsonProperty(PropertyName = "Maximal generation attempts")]
    public int maxGenerationAttempts;
}


```

---

## RandomRespawner by Tryhard - Respawns players in random location after death

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("Random Respawner", "Egor Blagov/Arainrr/Tryhard", "1.2.7")]
[Description("Plugin respawns player in random place")]
internal class RandomRespawner : RustPlugin
{
    private const string PERMISSION_USE;
    private Coroutine findSpawnPosCoroutine;
    private readonly List<Collider> colliders;
    private readonly List<Vector3> spawnPositionCache;
    private BasePlayer.SpawnPoint reusableSpawnPoint;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private object OnPlayerRespawn(BasePlayer player);
    private IEnumerator FindSpawnPositions(int attempts);
    private Vector3? GetRandomSpawnPos();
    private bool TestPos(Vector3 randomPos);
    private bool VBounds(Vector3 pos);
    internal bool IsInside(Vector3 vPos);
    private bool TestPosAgain(Vector3 spawnPos);
    private void UpdateConfig();
    private static float GetPosSlope(Vector3 position);
    private static TerrainBiome.Enum GetPosBiome(Vector3 position);
    private static TerrainSplat.Enum GetPosSplat(Vector3 position);
    private static TerrainTopology.Enum GetPosTopology(Vector3 position);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Maximum Attempts To Find A Respawn Position")]
        public int maxAttempts;
        [JsonProperty(PropertyName = "Minimum Distance From Other Players (Including NPC Players)")]
        public float radiusFromPlayers;
        [JsonProperty(PropertyName = "Minimum Distance From Building")]
        public float radiusFromBuilding;
        [JsonProperty(PropertyName = "Prevent Players To Be Respawn At Monuments")]
        public bool preventSpawnAtMonument;
        [JsonProperty(PropertyName = "Prevent Players To Be Respawn At ZoneManager")]
        public bool preventSpawnAtZone;
        [JsonProperty(PropertyName = "Prevent Players To Be Respawn At RadiationZone")]
        public bool preventSpawnAtRadZone;
        [JsonProperty(PropertyName = "Minimum Slope")]
        public float minSlope;
        [JsonProperty(PropertyName = "Maximum Slope")]
        public float maxSlope;
        [JsonProperty(PropertyName = "Biome Settings")]
        public Dictionary<TerrainBiome.Enum, bool> biomes;
        [JsonProperty(PropertyName = "Splat Settings")]
        public Dictionary<TerrainSplat.Enum, bool> splats;
        [JsonProperty(PropertyName = "Topology Settings")]
        public Dictionary<TerrainTopology.Enum, bool> topologies;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Maximum Attempts To Find A Respawn Position")]
    public int maxAttempts;
    [JsonProperty(PropertyName = "Minimum Distance From Other Players (Including NPC Players)")]
    public float radiusFromPlayers;
    [JsonProperty(PropertyName = "Minimum Distance From Building")]
    public float radiusFromBuilding;
    [JsonProperty(PropertyName = "Prevent Players To Be Respawn At Monuments")]
    public bool preventSpawnAtMonument;
    [JsonProperty(PropertyName = "Prevent Players To Be Respawn At ZoneManager")]
    public bool preventSpawnAtZone;
    [JsonProperty(PropertyName = "Prevent Players To Be Respawn At RadiationZone")]
    public bool preventSpawnAtRadZone;
    [JsonProperty(PropertyName = "Minimum Slope")]
    public float minSlope;
    [JsonProperty(PropertyName = "Maximum Slope")]
    public float maxSlope;
    [JsonProperty(PropertyName = "Biome Settings")]
    public Dictionary<TerrainBiome.Enum, bool> biomes;
    [JsonProperty(PropertyName = "Splat Settings")]
    public Dictionary<TerrainSplat.Enum, bool> splats;
    [JsonProperty(PropertyName = "Topology Settings")]
    public Dictionary<TerrainTopology.Enum, bool> topologies;
}


```

---

## RandomWarps by LaserHydra - Teleports you to a random location of a multi-location warp

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;
using Oxide.Core;

Oxide.Plugins
[Info("Random Warps", "LaserHydra", "1.2.0", ResourceId = 1397)]
[Description("Teleports you to a random location of a multi-location warp")]
 class RandomWarps : RustPlugin
{
     string pluginColor;
     class Data
    {
        public Dictionary<string, List<Dictionary<char, float>>> warps;
        public Data();
    }

     Data data;
     void LoadData();
     void SaveData();
     Vector3 GetRandom(List<Dictionary<char, float>> warpPositions);
     void Loaded();
     void LoadConfig();
    protected override void LoadDefaultConfig();
    [ChatCommand("rwarp")]
     void rWarp(BasePlayer player, string cmd, string[] args);
     bool IsAdmin(BasePlayer player);
    public void Teleport(BasePlayer player, Vector3 pos);
     BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix);
     string ListToString(List<string> list, int first, string seperator);
     void SetConfig(string Arg1, object Arg2, object Arg3, object Arg4);
     void BroadcastChat(string prefix, string msg);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
}

 class Data
{
    public Dictionary<string, List<Dictionary<char, float>>> warps;
    public Data();
}


```

---

## RandomWrappedGift by Ryz0r - Receive a randomly wrapped gift in a configured interval

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using Random = System.Random;

Oxide.Plugins
[Info("Random Wrapped Gift", "Ryz0r", "1.1.1")]
[Description("Enables players with permission to receive a randomly wrapped gift in a configured interval.")]
public class RandomWrappedGift : RustPlugin
{
    private const string GifteePerm;
    private const string GifterPerm;
    public string EffectToUse;
    private Random random;
    private Configuration _config;
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private class Configuration
    {
        [JsonProperty(PropertyName = "Gift Items (Item Shortname)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, int> GiftItems;
        [JsonProperty(PropertyName = "Wrapped Gift Interval (Seconds)")]
        public float WrappedGiftInterval;
        [JsonProperty(PropertyName = "Play Effect When Opened?")]
        public bool EffectWhenOpened;
        [JsonProperty(PropertyName = "Give gift to sleepers with permissions?")]
        public bool GiftToSleepers;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultMessages();
    private void CreateGift(BasePlayer bp);
    private void Init();
    private void OnServerInitialized();
    private void GiveGifts();
    private void GiveGiftCommand(IPlayer player, string command, string[] args);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Gift Items (Item Shortname)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, int> GiftItems;
    [JsonProperty(PropertyName = "Wrapped Gift Interval (Seconds)")]
    public float WrappedGiftInterval;
    [JsonProperty(PropertyName = "Play Effect When Opened?")]
    public bool EffectWhenOpened;
    [JsonProperty(PropertyName = "Give gift to sleepers with permissions?")]
    public bool GiftToSleepers;
}


```

---

## RCIdentifierFix by WhiteThunder - (Obsolete) Auto updates RC identifiers saved in computer stations to refer to the correct entity

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("RC Identifier Fix", "WhiteThunder", "1.0.0")]
[Description("Automatically updates saved RC identifiers in computer stations after an entity is destroyed and the ID is reused.")]
internal class RCIdentifierFix : CovalencePlugin
{
    private void OnEntityMounted(ComputerStation computerStation, BasePlayer player);
    private BaseEntity FindControllable(string bookmarkName, uint cachedEntityId, BaseEntity entityWithRCIdentifier);
}


```

---

## RealBearTraps by ArtiIOMI - Makes bear traps actually trap bears, and other animals

```csharp
using Facepunch;
using Rust;
using System;
using System.Linq;
using System.Globalization;
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

Oxide.Plugins
[Info("Real Bear Traps", "XavierB", "0.0.8")]
[Description("Makes bear traps actually trap bears")]
public class RealBearTraps : RustPlugin
{
    static RealBearTraps plugin;
    const string perms;
    private bool ConfigChanged;
    private DynamicConfigFile data;
    private StoredData storedData;
     bool TrapTeam;
     float TrapDamage;
     float TrapRadius;
     bool TrapBears;
     bool TrapChicken;
     bool TrapStag;
     bool TrapBoar;
     bool TrapWolf;
     bool Messages;
    private List<ulong> BearTrapList;
    private class StoredData
    {
        public List<ulong> BearTrapList;
    }

    private void SaveData();
     void LoadVariables();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    protected override void LoadDefaultConfig();
     void Init();
    private void OnServerSave();
     void Unload();
     void OnServerInitialized();
    private static BasePlayer FindOwner(string nameOrId);
    private void OnEntitySpawned(BearTrap trap);
    private object OnTrapTrigger(BearTrap trap, GameObject obj);
    private void OnEntityKill(BearTrap trap);
     class ColliderCheck : FacepunchBehaviour
    {
        private BaseTrap trap;
        private BaseCombatEntity targetEnt;
        private float radius;
         void Awake();
         void FixedUpdate();
        internal void OnKill(BearTrap trap);
        public void UnloadComponent();
        public void Destroy();
    }

    protected override void LoadDefaultMessages();
}

private class StoredData
{
    public List<ulong> BearTrapList;
}

 class ColliderCheck : FacepunchBehaviour
{
    private BaseTrap trap;
    private BaseCombatEntity targetEnt;
    private float radius;
     void Awake();
     void FixedUpdate();
    internal void OnKill(BearTrap trap);
    public void UnloadComponent();
    public void Destroy();
}


```

---

## RealisticExplosions by 2CHEVSKII - Pushes back dropped items when they are near the explosion

```csharp
using System;
using System.Collections.Generic;
using Facepunch;
using JetBrains.Annotations;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Realistic Explosions", "2CHEVSKII", "1.0.0")]
[Description("Pushes back dropped items when they are near the explosion")]
 class RealisticExplosions : CovalencePlugin
{
    static RealisticExplosions Instance;
     PluginSettings settings;
     void Init();
     void Unload();
     void OnExplosiveDropped(BasePlayer player, BaseEntity entity);
     void OnExplosiveThrown(BasePlayer player, BaseEntity entity);
     void OnRocketLaunched(BasePlayer player, BaseEntity entity);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    [UsedImplicitly]
     class RealisticExplosion : MonoBehaviour
    {
        static List<DroppedItem> ItemList;
        static List<BaseCorpse> CorpseList;
         BaseEntity entity;
         PluginSettings settings;
        public static void Init();
        public static void Shutdown();
         void Awake();
         void OnDestroy();
         void IterateEntities();
         void Cleanup();
         void CollectItems();
         void CollectCorpses();
         void ApplyForce(Rigidbody rigidbody, bool isCorpse);
         bool IsVisible(BaseEntity baseEntity);
    }

     class PluginSettings
    {
        public static PluginSettings Default { get; set; }
        [JsonProperty("Explosion force")]
        public float ExplosionForce { get; set; }
        [JsonProperty("Explosion radius")]
        public float ExplosionRadius { get; set; }
        [JsonProperty("Check visibility from explosion to object (less performant)")]
        public bool CheckVisibility { get; set; }
        [JsonProperty("Affect ragdolls")]
        public bool AffectRagdolls { get; set; }
        [JsonProperty("Affect dropped items")]
        public bool AffectDroppedItems { get; set; }
    }

}

[UsedImplicitly]
 class RealisticExplosion : MonoBehaviour
{
    static List<DroppedItem> ItemList;
    static List<BaseCorpse> CorpseList;
     BaseEntity entity;
     PluginSettings settings;
    public static void Init();
    public static void Shutdown();
     void Awake();
     void OnDestroy();
     void IterateEntities();
     void Cleanup();
     void CollectItems();
     void CollectCorpses();
     void ApplyForce(Rigidbody rigidbody, bool isCorpse);
     bool IsVisible(BaseEntity baseEntity);
}

 class PluginSettings
{
    public static PluginSettings Default { get; set; }
    [JsonProperty("Explosion force")]
    public float ExplosionForce { get; set; }
    [JsonProperty("Explosion radius")]
    public float ExplosionRadius { get; set; }
    [JsonProperty("Check visibility from explosion to object (less performant)")]
    public bool CheckVisibility { get; set; }
    [JsonProperty("Affect ragdolls")]
    public bool AffectRagdolls { get; set; }
    [JsonProperty("Affect dropped items")]
    public bool AffectDroppedItems { get; set; }
}


```

---

## RealisticIgniter by ArtiIOMI - Use a flamethrower or torch to set fire to a bonfire

```csharp
using Rust;
using ConVar;
using Network;
using Oxide.Core;
using System;
using UnityEngine;
using UnityEngine.Assertions;

Oxide.Plugins
[Info("Realistic Igniter", "ArtiIOMI", "1.1.4")]
[Description("You can now set fire to the fireplace using the flamethrower or torch.")]
internal class RealisticIgniter : RustPlugin
{
     void OnEntityTakeDamage(BaseOven entity, HitInfo info);
}


```

---

## RealisticTorch by synvy - Prevents cold damage to players holding a lit torch.

```csharp
using Rust;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Realistic Torch", "Synvy", "1.1.1")]
[Description("Prevents cold damage to players holding a lit torch.")]
public class RealisticTorch : RustPlugin
{
    private const string _perm;
    private void Init();
    private void OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity entity);
    private bool HasPerm(string id, string perm);
    private bool IsHoldingTorch(BasePlayer player);
    private bool IsTorchIgnited(BasePlayer player);
}


```

---

## RealTime by haggbart - Syncs ingame time with real time

```csharp
using System;
using System.Collections;
using UnityEngine;

Oxide.Plugins
[Info("Real Time", "haggbart", "1.0.0")]
[Description("Syncs ingame time with real time")]
 class RealTime : RustPlugin
{
    private bool enabled;
    private TOD_Time todTime;
    private WaitForSeconds waitForSeconds;
    private float offsetHours;
    private const string OFFSET_HOURS;
    private const float SECONDS_BETWEEN;
    protected override void LoadDefaultConfig();
    private void OnServerInitialized();
    private void Unload();
    private IEnumerator AddTimeAndSync();
    private void SyncRealTime();
}


```

---

## RealTimeChat by TheFriendlyChap - Shows the server's IRL time on command

```csharp
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Real Time Chat", "The Friendly Chap", "1.0.2")]
[Description("Returns the server real time in chat.")]
public class RealTimeChat : RustPlugin
{
     void LoadDefaultMessages();
    [ChatCommand("time")]
     void RealTimeCommand(BasePlayer player);
     void Init();
}


```

---

## RealtimeWipeInfo by Ryan - Auto title and description updating, auto wipe schedule, chat filter, and more

```csharp
using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("Realtime Wipe Info", "Ryan", "2.1.68")]
[Description("Auto title and description updating, auto wipe schedule, chat filter, and more")]
public class RealtimeWipeInfo : RustPlugin
{
    [PluginReference]
    private Plugin BetterChat;
    private Plugin ColouredChat;
    private DateTime _cachedWipeTime;
    private const string BypassPerm;
    private Timer _descriptionTimer;
    private Timer _titleTimer;
    private static ConfigFile _config;
    private static DataFile _data;
    private bool _newConfig;
    private class ConfigFile
    {
        [JsonProperty("Description Settings")]
        public DescriptionSettings Description;
        [JsonProperty("Title Settings")]
        public TitleSettings Title;
        [JsonProperty("Phrase Settings")]
        public PhraseSettings Phrase;
        [JsonProperty("Connect Message Settings")]
        public ConnectSettings Connect;
        [JsonProperty("Command Settings")]
        public CommandSettings Command;
        [JsonProperty("Blueprint settings")]
        public BlueprintSettings Blueprint;
        public VersionNumber Version;
        public static ConfigFile DefaultConfig();
    }

    private class DescriptionSettings
    {
        [JsonProperty("Enable Description")]
        public bool Enabled;
        [JsonProperty("Full Server Description")]
        public string Description;
        [JsonProperty("Include Seed & Map Size")]
        public bool SeedSize;
        [JsonProperty("Enable Use Of Time")]
        public bool UseTime;
        public Date Date;
        [JsonProperty("Refresh Interval")]
        public float Refresh;
    }

    private class TitleSettings
    {
        [JsonProperty("Enable Title")]
        public bool Enabled;
        [JsonProperty("Full Server Hostname")]
        public string Title;
        [JsonProperty("Enable Use Of Time")]
        public bool UseTime;
        public Date Date;
        [JsonProperty("Refresh Interval")]
        public float Refresh;
    }

    private class PhraseSettings
    {
        [JsonProperty("Enable Phrases")]
        public bool Enabled;
        public Dictionary<string, PhraseItem> Phrases;
        [JsonProperty("Enable Use Of Time")]
        public bool UseTime;
        public Date Date;
        [JsonProperty("Schedule Settings")]
        public ScheduleSettings Schedule;
    }

    private class ConnectSettings
    {
        [JsonProperty("Enable Connect Messages")]
        public bool Enabled;
    }

    private class CommandSettings
    {
        public bool Enabled;
        public string Command;
    }

    private class Date
    {
        [JsonProperty("Enable Use Of Date")]
        public bool Enabled;
        [JsonProperty("Date format")]
        public string Format;
    }

    private class ScheduleSettings
    {
        [JsonProperty("Enable Wipe Schedule Messages")]
        public bool Enabled;
        [JsonProperty("Wipe Schedule In Days")]
        public int Schedule;
        [JsonProperty("Date Format")]
        public string Format;
    }

    private class PhraseItem
    {
        [JsonProperty("Send Reply")]
        public bool Message;
        [JsonProperty("Block Message")]
        public bool Block;
        public PhraseItem(bool message, bool block);
    }

    private class BlueprintSettings
    {
        [JsonProperty("Enable blueprint wipe tracking")]
        public bool Enabled;
        [JsonProperty("Add BP wipe to description")]
        public bool UseDescription;
        [JsonProperty("Use BP chat reply")]
        public bool UseChat;
        public BlueprintSettings();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Regenerate();
    protected override void LoadDefaultMessages();
    private class DataFile
    {
        public string Hostname;
        public string Description;
        public DateTime BlueprintWipe;
        public DataFile();
        public DataFile(string hostname, string description);
    }

    private string Lang(string key, string id, object[] args);
    private string GetFormattedTime(double time);
    private void ApplyTitle(string title);
    private void StartTitleRefresh();
    private string GetFormattedTitleTime();
    private string GetFormattedTitle();
    private void ApplyDescription(string description);
    private void StartDescriptionRefresh();
    private string GetFormattedDescription();
    private object ChatMessageResult(BasePlayer player, string input, bool reply);
    private string GetFormattedMessageTime();
    private string GetFormattedMessage(BasePlayer player);
    private void OnBpsWiped();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnPluginUnloaded(Plugin plugin);
    private void OnPluginLoaded(Plugin plugin);
    private void OnPlayerConnected(BasePlayer player);
    private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    private object OnColouredChat(Dictionary<string, object> data);
    private object OnBetterChat(Dictionary<string, object> data);
    private void WipeCommand(BasePlayer player, string command, string[] args);
}

private class ConfigFile
{
    [JsonProperty("Description Settings")]
    public DescriptionSettings Description;
    [JsonProperty("Title Settings")]
    public TitleSettings Title;
    [JsonProperty("Phrase Settings")]
    public PhraseSettings Phrase;
    [JsonProperty("Connect Message Settings")]
    public ConnectSettings Connect;
    [JsonProperty("Command Settings")]
    public CommandSettings Command;
    [JsonProperty("Blueprint settings")]
    public BlueprintSettings Blueprint;
    public VersionNumber Version;
    public static ConfigFile DefaultConfig();
}

private class DescriptionSettings
{
    [JsonProperty("Enable Description")]
    public bool Enabled;
    [JsonProperty("Full Server Description")]
    public string Description;
    [JsonProperty("Include Seed & Map Size")]
    public bool SeedSize;
    [JsonProperty("Enable Use Of Time")]
    public bool UseTime;
    public Date Date;
    [JsonProperty("Refresh Interval")]
    public float Refresh;
}

private class TitleSettings
{
    [JsonProperty("Enable Title")]
    public bool Enabled;
    [JsonProperty("Full Server Hostname")]
    public string Title;
    [JsonProperty("Enable Use Of Time")]
    public bool UseTime;
    public Date Date;
    [JsonProperty("Refresh Interval")]
    public float Refresh;
}

private class PhraseSettings
{
    [JsonProperty("Enable Phrases")]
    public bool Enabled;
    public Dictionary<string, PhraseItem> Phrases;
    [JsonProperty("Enable Use Of Time")]
    public bool UseTime;
    public Date Date;
    [JsonProperty("Schedule Settings")]
    public ScheduleSettings Schedule;
}

private class ConnectSettings
{
    [JsonProperty("Enable Connect Messages")]
    public bool Enabled;
}

private class CommandSettings
{
    public bool Enabled;
    public string Command;
}

private class Date
{
    [JsonProperty("Enable Use Of Date")]
    public bool Enabled;
    [JsonProperty("Date format")]
    public string Format;
}

private class ScheduleSettings
{
    [JsonProperty("Enable Wipe Schedule Messages")]
    public bool Enabled;
    [JsonProperty("Wipe Schedule In Days")]
    public int Schedule;
    [JsonProperty("Date Format")]
    public string Format;
}

private class PhraseItem
{
    [JsonProperty("Send Reply")]
    public bool Message;
    [JsonProperty("Block Message")]
    public bool Block;
    public PhraseItem(bool message, bool block);
}

private class BlueprintSettings
{
    [JsonProperty("Enable blueprint wipe tracking")]
    public bool Enabled;
    [JsonProperty("Add BP wipe to description")]
    public bool UseDescription;
    [JsonProperty("Use BP chat reply")]
    public bool UseChat;
    public BlueprintSettings();
}

private class DataFile
{
    public string Hostname;
    public string Description;
    public DateTime BlueprintWipe;
    public DataFile();
    public DataFile(string hostname, string description);
}


```

---

## Recycle by nivex - Recycle items into their resources

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core;
using System;
using Facepunch;

Oxide.Plugins
[Info("Recycle", "nivex", "3.1.7")]
[Description("Recycle items into their resources")]
public class Recycle : RustPlugin
{
    private const string RecyclePrefab;
    private const string BackpackPrefab;
    private const string AdminPermission;
    private const string RecyclerPermission;
    private const string CooldownBypassPermission;
    private readonly Dictionary<ulong, (DroppedItemContainer container, BasePlayer player)> _droppedContainers;
    private readonly Dictionary<ulong, (Recycler recycler, BasePlayer player)> _recyclers;
    private readonly Dictionary<string, long> _cooldowns;
    private ConfigData config;
    private void Loaded();
    private void Unload();
    private void OnLootEntityEnd(BasePlayer player, Recycler recycler);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private object CanMoveItem(Item item, PlayerInventory inv, ItemContainerId targetContainerId, int targetSlot, int amount);
    private object CanAcceptItem(ItemContainer container, Item item, int targetPos);
    private object CanLootEntity(BasePlayer player, DroppedItemContainer container);
    private void OnEntityKill(DroppedItemContainer container);
    protected override void LoadDefaultMessages();
    private void OnUseNPC(BasePlayer npc, BasePlayer player);
    private void RecycleCommand(IPlayer user, string command, string[] args);
    private void PurgeRecyclersCommand(IPlayer user, string command, string[] args);
    private void PurgeBagsCommand(IPlayer user, string command, string[] args);
    private void Message(IPlayer user, string top, string bottom);
    private void Message(BasePlayer player, string top, string bottom, object[] args);
    public bool IsValid(BaseNetworkable e);
    public class ConfigData
    {
        public class SettingsWrapper
        {
            [JsonProperty("Command To Open Recycler")]
            public string RecycleCommand;
            [JsonProperty("Cooldown (in minutes)")]
            public float Cooldown;
            [JsonProperty("Maximum Radiation")]
            public float RadiationMax;
            [JsonProperty("Refund Ratio")]
            public float RefundRatio;
            [JsonProperty("NPCs Only")]
            public bool NPCOnly;
            [JsonProperty("Allowed In Safe Zones")]
            public bool AllowedInSafeZones;
            [JsonProperty("Instant Recycling")]
            public bool InstantRecycling;
            [JsonProperty("Send Recycled Items To Inventory")]
            public bool ToInventory;
            [JsonProperty("Send Items To Inventory Before Bag")]
            public bool InventoryBeforeBag;
            [JsonProperty("NPC Ids", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<object> NPCIds;
            [JsonProperty("Recyclable Types", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<object> RecyclableTypes;
            [JsonProperty("Blacklisted Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<object> Blacklist;
        }

        public SettingsWrapper Settings;
        public string VERSION;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private bool canSaveConfig;
    protected override void SaveConfig();
    private Recycler CreateRecycler(BasePlayer player);
    private void OpenContainer(BasePlayer player, StorageContainer container);
    private void DropRecyclerContents(Recycler recycler, BasePlayer player);
    private void DestroyRecycler(BasePlayer player);
    private void DestroyRecyclers();
    private void DestroyBags();
    private string GetMessage(string top, string bottom, string userid);
    private int[] GetCooldown(string userid);
    private string CooldownTimesToString(int[] times, BasePlayer player);
    private BasePlayer PlayerFromRecycler(ulong netID);
    private Recycler RecyclerFromPlayer(ulong userid);
    private bool IsOnCooldown(IPlayer user);
    private bool CanUseRecycler(IPlayer user);
    private bool CanManageRecyclers(IPlayer user);
    private bool CanBypassCooldown(IPlayer user);
    private bool IsRecycleBox(BaseNetworkable e);
    private bool CanPlayerOpenRecycler(BasePlayer player);
    private void OpenRecycler(BasePlayer player);
    private void AddNpc(string id);
    private void RemoveNpc(string id);
}

public class ConfigData
{
    public class SettingsWrapper
    {
        [JsonProperty("Command To Open Recycler")]
        public string RecycleCommand;
        [JsonProperty("Cooldown (in minutes)")]
        public float Cooldown;
        [JsonProperty("Maximum Radiation")]
        public float RadiationMax;
        [JsonProperty("Refund Ratio")]
        public float RefundRatio;
        [JsonProperty("NPCs Only")]
        public bool NPCOnly;
        [JsonProperty("Allowed In Safe Zones")]
        public bool AllowedInSafeZones;
        [JsonProperty("Instant Recycling")]
        public bool InstantRecycling;
        [JsonProperty("Send Recycled Items To Inventory")]
        public bool ToInventory;
        [JsonProperty("Send Items To Inventory Before Bag")]
        public bool InventoryBeforeBag;
        [JsonProperty("NPC Ids", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<object> NPCIds;
        [JsonProperty("Recyclable Types", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<object> RecyclableTypes;
        [JsonProperty("Blacklisted Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<object> Blacklist;
    }

    public SettingsWrapper Settings;
    public string VERSION;
}

public class SettingsWrapper
{
    [JsonProperty("Command To Open Recycler")]
    public string RecycleCommand;
    [JsonProperty("Cooldown (in minutes)")]
    public float Cooldown;
    [JsonProperty("Maximum Radiation")]
    public float RadiationMax;
    [JsonProperty("Refund Ratio")]
    public float RefundRatio;
    [JsonProperty("NPCs Only")]
    public bool NPCOnly;
    [JsonProperty("Allowed In Safe Zones")]
    public bool AllowedInSafeZones;
    [JsonProperty("Instant Recycling")]
    public bool InstantRecycling;
    [JsonProperty("Send Recycled Items To Inventory")]
    public bool ToInventory;
    [JsonProperty("Send Items To Inventory Before Bag")]
    public bool InventoryBeforeBag;
    [JsonProperty("NPC Ids", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<object> NPCIds;
    [JsonProperty("Recyclable Types", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<object> RecyclableTypes;
    [JsonProperty("Blacklisted Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<object> Blacklist;
}


```

---

## RecycleBlueprints by Zugzwang - Allows players to recycle blueprints for scrap

```csharp
using Oxide.Core.Configuration;
using Rust;

Oxide.Plugins
[Info("Recycle Blueprints", "Zugzwang", "1.0.7")]
[Description("Allows players to recycle blueprints for scrap.")]
 class RecycleBlueprints : CovalencePlugin
{
     int scrapID;
     int defaultbp;
     int common;
     int uncommon;
     int rare;
     int veryrare;
    protected override void LoadDefaultConfig();
     void Init();
     void OnServerInitialized();
     int ScrapValue(Item i);
     object CanRecycle(Recycler recycler, Item item);
     object CanBeRecycled(Item i, Recycler r);
     object OnItemRecycle(Item item, Recycler recycler);
}


```

---

## RecycleManager by WhiteThunder - Customize recycler speed, efficiency and outputs

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Libraries;
using UnityEngine;

Oxide.Plugins
[Info("Recycle Manager", "WhiteThunder", "2.1.0")]
[Description("Allows customizing recycler speed, input, and output")]
internal class RecycleManager : CovalencePlugin
{
    private Configuration _config;
    private const string PermissionAdmin;
    private const int ScrapItemId;
    private const float ClassicRecycleEfficiency;
    private const float VanillaMaxItemsInStackFraction;
    private readonly object True;
    private readonly object False;
    private const int NumInputSlots;
    private const int NumOutputSlots;
    private readonly RecyclerComponentManager _recyclerComponentManager;
    private readonly RecycleEditManager _recycleEditManager;
    private readonly float[] _recycleTime;
    private readonly float[] _recycleEfficiency;
    private static readonly FieldInfo ScrapRemainderField;
    private bool IsEditUIEnabled { get; set; }
    public RecycleManager();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private object CanBeRecycled(Item item, Recycler recycler);
    private object CanRecycle(Recycler recycler, Item item);
    private void OnRecyclerToggle(Recycler recycler, BasePlayer player);
    private object OnItemRecycle(Item item, Recycler recycler);
    private void OnLootEntity(BasePlayer player, Recycler recycler);
    private static class ExposedHooks
    {
        public static object OnRecycleManagerItemRecyclable(Item item, Recycler recycler);
        public static object OnRecycleManagerSpeed(Recycler recycler, BasePlayer player, float[] recycleTime);
        public static void OnRecycleManagerEfficiency(Recycler recycler, BasePlayer player, float[] recyclerEfficiency);
        public static object OnRecycleManagerRecycle(Item item, Recycler recycler);
    }

    [Command("recyclemanager.add", "recman.add")]
    private void CommandAddItem(IPlayer player, string cmd, string[] args);
    [Command("recyclemanager.reset", "recman.reset")]
    private void CommandResetItem(IPlayer player, string cmd, string[] args);
    [Command("recyclemanager.ui")]
    private void CommandEdit(IPlayer player, string cmd, string[] args);
    private bool VerifyHasPermission(IPlayer player, string perm);
    private bool VerifyConfigLoaded(IPlayer player);
    private bool VerifyValidItemIdOrShortName(IPlayer player, string itemArg, ItemDefinition itemDefinition, string command);
    private float GetRecyclerEfficiency(Recycler recycler, BasePlayer player, float vanillaEfficiency);
    private bool TryDetermineRecycleTime(Recycler recycler, BasePlayer player, float recycleTime);
    private object CallCanBeRecycled(Item item, Recycler recycler);
    private bool IsOutputCustomized(ItemBlueprint blueprint);
    public static void LogError(string message);
    public static void LogWarning(string message);
    private static void Swap(T a, T b);
    private static bool IsVanillaRecyclable(Item item);
    private static bool RecyclableWasBlocked(Item item, Recycler recycler);
    private static bool RecycleItemWasBlocked(Item item, Recycler recycler);
    private static Item CreateItem(ItemDefinition itemDefinition, int amount, ulong skinId, string displayName);
    private static int CalculateOutputAmountVanillaRandom(int recycleAmount, float adjustedIngredientChance);
    private static int CalculateOutputAmountFast(int recycleAmount, float ingredientAmount);
    private static int CalculateOutputAmountRandom(int recycleAmount, float ingredientAmount, float recycleEfficiency, float outputMultiplier);
    private static int CalculateOutputAmountNoRandom(int recycleAmount, float ingredientAmount, float recycleEfficiency, float outputMultiplier);
    private static int CalculateOutputAmount(int recycleAmount, float ingredientAmount, float recycleEfficiency, float outputMultiplier);
    private static bool AddItemToRecyclerOutput(Recycler recycler, ItemDefinition itemDefinition, int ingredientAmount, ulong skinId, string displayName);
    private static float DetermineVanillaRecycleEfficiency(Recycler recycler);
    private static IngredientInfo[] GetVanillaOutput(ItemDefinition itemDefinition);
    private static float DetermineItemRecycleEfficiency(Item item, float recyclerEfficiency);
    private static int DetermineConsumptionAmount(Recycler recycler, Item item, float maxItemsInStackFraction);
    private static bool PopulateOutputWithOverride(Recycler recycler, IngredientInfo[] customIngredientList, int recycleAmount, float recycleEfficiency, bool forEditor);
    private static bool PopulateOutputVanilla(Configuration config, Recycler recycler, Item item, int recycleAmount, float recycleEfficiency);
    private class LayoutProvider
    {
        public const string AnchorBottomLeft;
        public const string AnchorBottomRight;
        public const string AnchorTopLeft;
        public const string AnchorTopRight;
        public static LayoutProvider Once(float width, float height);
        private static LayoutProvider _reusable;
        private LayoutOptions _options;
        private string _anchor;
        private float _x;
        private float _y;
        private float _xSpacing;
        private float _ySpacing;
        private float _width;
        private float _height;
        private bool _isVertical { get; set; }
        private bool _isLeftToRight { get; set; }
        private bool _isTopToBottom { get; set; }
        private int _xSign { get; set; }
        private int _ySign { get; set; }
        private float XMin;
        private float XMax;
        private float YMin;
        private float YMax;
        public string AnchorMin { get; set; }
        public string AnchorMax { get; set; }
        public string OffsetMin { get; set; }
        public string OffsetMax { get; set; }
        public LayoutProvider(float width, float height);
        public LayoutProvider WithDimensions(float width, float height);
        public LayoutProvider WithOptions(LayoutOptions options);
        public LayoutProvider WithSpacing(float x, float y);
        public LayoutProvider WithOffset(float x, float y);
        public LayoutProvider Next();
        public CuiRectTransformComponent GetRectTransform();
        private string DetermineAnchor();
    }

    private class ButtonColor
    {
        public readonly string Color;
        public readonly string TextColor;
        public ButtonColor(string color, string textColor);
    }

    private class ButtonColorScheme
    {
        public ButtonColor Active;
        public ButtonColor Enabled;
        public ButtonColor Disabled;
        public ButtonColor Get(bool active, bool enabled);
    }

    private class CuiInputFieldComponentHud : CuiInputFieldComponent
    {
        [JsonProperty("hudMenuInput", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool HudMenuInput { get; set; }
    }

    private class CuiElementRecreate : CuiElement
    {
        [JsonProperty("destroyUi", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string DestroyUi { get; set; }
    }

    private static class EditUI
    {
        private const string UIName;
        private const string EditPanelUIName;
        private const string PercentagePanelUIName;
        private const string AnchorMin;
        private const string AnchorMax;
        private const float PanelWidth;
        private const float PanelHeight;
        private const float HeaderHeight;
        private const int ItemPaddingLeft;
        private const int ItemSize;
        private const int ItemSpacing;
        private const string BaseUICommand;
        private const string TextColor;
        private const string BackgroundColor;
        private static ButtonColorScheme DefaultButtonColorScheme;
        private static ButtonColorScheme SaveButtonColorScheme;
        private static ButtonColorScheme ResetButtonColorScheme;
        public static void DestroyUI(BasePlayer player);
        public static void DrawUI(RecycleManager plugin, BasePlayer player, EditState state);
        private static void DrawDefaultUI(RecycleManager plugin, BasePlayer player);
        private static void DrawEditUI(RecycleManager plugin, BasePlayer player, EditState state);
        private static CuiElementContainer CreateContainer();
        private static void AddEditButton(CuiElementContainer elements, RecycleManager plugin, BasePlayer player);
        private static void AddEditHeader(CuiElementContainer elements, RecycleManager plugin, BasePlayer player);
        private static void AddEditPanel(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
        private static void AddPercentageControllers(CuiElementContainer elements, EditState state);
        private static void AddButton(CuiElementContainer elements, LayoutProvider layoutProvider, ButtonColorScheme buttonColorScheme, string parent, string text, string command, bool active, bool enabled);
        private static void AddItemIdentificationControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
        private static void AddItemAllowedControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
        private static void AddPrimaryControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
    }

    private class EditState
    {
        public Item InputItem;
        public IdentificationType IdentificationType;
        public OutputType OutputType;
        public float[] Chances;
        public bool BlockedByAnotherPlugin;
        public bool CanSave;
        public bool CanReset;
    }

    private class EditController : FacepunchBehaviour
    {
        public static EditController AddToRecycler(RecycleManager plugin, RecycleEditManager recycleEditManager, Recycler recycler);
        private RecycleManager _plugin;
        private RecycleEditManager _recycleEditManager;
        private Recycler _recycler;
        private BasePlayer _player;
        private EditState _editState;
        private Func<Item, int, bool> _originalCanAcceptItem;
        private Action _onDirtyDelayed;
        private bool _pauseAutoChangeOutput;
        private Configuration _config { get; set; }
        private EditController();
        public void StartViewing(BasePlayer player);
        public void DestroyImmediate();
        private IngredientInfo[] GetSavedIngredients();
        private bool CanSave();
        private bool CanReset();
        private void DrawUI();
        private List<IngredientInfo> GetOutputIngredients();
        public void HandleUICommand(BasePlayer player, string[] args);
        private IngredientInfo[] GetOutput(IdentificationType identificationType, OutputType outputType);
        private void PopulateOutputItems();
        private void RemoveInputItems();
        private void RemoveOutputItems(BasePlayer player);
        private void StartEditing();
        private bool CanAcceptItem(Item item);
        private void StopEditing(bool redraw);
        private void StopViewing();
        private Item TrimInputs();
        private void RemoveExcessInput(Item item);
        private IngredientInfo[] GetOverride(IdentificationType identificationType);
        private IngredientInfo[] GetOverride();
        private bool IsDisallowed(IdentificationType identificationType);
        private bool IsDisallowed();
        private OutputType DetermineBestOutputType(IdentificationType identificationType);
        private OutputType DetermineBestOutputType();
        private IdentificationType DetermineBestIdentificationType();
        private void HandleNewInputItem();
        private void HandleChanges();
        private void OnDirtyDelayed();
        private void OnDirty();
        private void PlayerStoppedLooting(BasePlayer player);
        private void OnDestroy();
    }

    private class RecycleEditManager
    {
        private RecycleManager _plugin;
        private Dictionary<Recycler, EditController> _controllers;
        private Dictionary<BasePlayer, EditController> _playerControllers;
        public RecycleEditManager(RecycleManager plugin);
        public void HandlePlayerStartedLooting(BasePlayer player, Recycler recycler);
        public EditController GetController(BasePlayer player);
        public EditController EnsureController(Recycler recycler);
        public void HandlePlayerStoppedLooting(BasePlayer player);
        public void HandleControllerDestroyed(Recycler recycler);
        public void Unload();
        private EditController GetController(Recycler recycler);
    }

    private class RecyclerComponent : FacepunchBehaviour
    {
        public static RecyclerComponent AddToRecycler(RecycleManager plugin, RecyclerComponentManager recyclerComponentManager, Recycler recycler);
        public BasePlayer Player { get; set; }
        private RecycleManager _plugin;
        private RecyclerComponentManager _recyclerComponentManager;
        private Recycler _recycler;
        private Action _vanillaRecycleThink;
        private Action _customRecycleThink;
        private float _recycleTime;
        private Configuration _config { get; set; }
        private bool _enableIncrementalRecycling { get; set; }
        private RecyclerComponent();
        public void DestroyImmediate();
        public void HandleRecyclerToggle(BasePlayer player);
        private void HandleRecyclerToggleDelayed(BasePlayer player);
        private void CustomRecycleThink();
        private float GetItemRecycleTime(Item item);
        private Item GetNextItem();
        private void OnDestroy();
    }

    private class RecyclerComponentManager
    {
        private RecycleManager _plugin;
        private readonly Dictionary<Recycler, RecyclerComponent> _recyclerComponents;
        public void Init(RecycleManager plugin);
        public void Unload();
        public void HandleRecyclerToggle(Recycler recycler, BasePlayer player);
        public void HandleRecyclerComponentDestroyed(Recycler recycler);
        public RecyclerComponent EnsureRecyclerComponent(Recycler recycler);
    }

    private class CaseInsensitiveDictionary : Dictionary<string, TValue>
    {
        public CaseInsensitiveDictionary();
    }

    private class CaseInsensitiveHashSet : HashSet<string>
    {
        public CaseInsensitiveHashSet();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class EditUISettings
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class PermissionSpeedProfile
    {
        [JsonProperty("Permission suffix")]
        public string PermissionSuffix;
        [JsonProperty("Recycle time (seconds)")]
        private float RecycleTime { get; set; }
        [JsonProperty("Recycle time multiplier")]
        public float TimeMultiplier;
        [JsonIgnore]
        public string Permission { get; set; }
        public void Init(RecycleManager plugin);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class SpeedSettings
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
        [JsonProperty("Default recycle time (seconds)")]
        public float DefaultRecycleTime;
        [JsonProperty("Recycle time (seconds)")]
        private float DeprecatedRecycleTime { get; set; }
        [JsonProperty("Recycle time multiplier while in safe zone")]
        public float SafeZoneTimeMultiplier;
        [JsonProperty("Recycle time multiplier by item short name (item: multiplier)")]
        public Dictionary<string, float> TimeMultiplierByShortName;
        [JsonProperty("Recycle time multiplier by permission")]
        public PermissionSpeedProfile[] PermissionSpeedProfiles;
        [JsonProperty("Speeds requiring permission")]
        private PermissionSpeedProfile[] DeprecatedSpeedsRequiringPermission { get; set; }
        [JsonIgnore]
        private Permission _permission;
        [JsonIgnore]
        private Dictionary<int, float> _timeMultiplierByItemId;
        [JsonIgnore]
        public bool EnableIncrementalRecycling;
        public void Init(RecycleManager plugin);
        public float GetTimeMultiplierForPlayer(BasePlayer player);
        public float GetTimeMultiplierForItem(Item item);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class EfficiencySettings
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
        [JsonProperty("Default recycle efficiency")]
        public float DefaultRecyclerEfficiency;
        [JsonProperty("Recycle efficiency while in safe zone")]
        public float RecyclerEfficiencyWhileInSafeZone;
        public float GetRecyclerEfficiency(Recycler recycler);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class MaxItemsPerRecycle
    {
        [JsonProperty("Default percent")]
        public float DefaultPercent;
        [JsonProperty("Percent by input item short name")]
        public Dictionary<string, float> PercentByShortName;
        [JsonProperty("Percent by input item skin ID")]
        public Dictionary<ulong, float> PercentBySkinId;
        [JsonProperty("Percent by input item display name (custom items)")]
        public CaseInsensitiveDictionary<float> PercentByDisplayName;
        [JsonIgnore]
        private Dictionary<int, float> PercentByItemId;
        public void Init();
        public float GetPercent(Item item);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class OutputMultiplierSettings
    {
        [JsonProperty("Default multiplier")]
        public float DefaultMultiplier;
        [JsonProperty("Multiplier by output item short name")]
        public Dictionary<string, float> MultiplierByOutputShortName;
        [JsonIgnore]
        private Dictionary<int, float> MultiplierByOutputItemId;
        public void Init();
        public float GetOutputMultiplier(int itemId);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class IngredientInfo : IEquatable<IngredientInfo>
    {
        [JsonProperty("Item short name")]
        public string ShortName;
        [JsonProperty("Item skin ID", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ulong SkinId;
        [JsonProperty("Display name", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string DisplayName;
        [JsonProperty("Amount")]
        public float Amount;
        [JsonIgnore]
        public ItemDefinition ItemDefinition;
        public void Init();
        public bool Equals(IngredientInfo other);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class RestrictedInputItems
    {
        [JsonProperty("Item short names")]
        public CaseInsensitiveHashSet DisallowedInputShortNames;
        [JsonProperty("Item skin IDs")]
        public HashSet<ulong> DisallowedInputSkinIds;
        [JsonProperty("Item display names (custom items)")]
        public CaseInsensitiveHashSet DisallowedInputDisplayNames;
        [JsonIgnore]
        private HashSet<int> DisallowedInputItemIds;
        public void Init();
        public bool IsDisallowed(Item item, IdentificationType identificationType);
        public bool IsDisallowed(Item item);
        public bool Allow(Item item, IdentificationType identificationType);
        public bool Disallow(Item item, IdentificationType identificationType);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class OverrideOutput
    {
        [JsonProperty("Override output by input item short name")]
        public Dictionary<string, IngredientInfo[]> OverrideOutputByShortName;
        [JsonProperty("Override output by input item skin ID")]
        public Dictionary<ulong, IngredientInfo[]> OverrideOutputBySkinId;
        [JsonProperty("Override output by input item display name (custom items)")]
        public CaseInsensitiveDictionary<IngredientInfo[]> OverrideOutputByDisplayName;
        [JsonIgnore]
        private Dictionary<int, IngredientInfo[]> OverrideOutputByItemId;
        public void Init();
        public IngredientInfo[] GetOverride(Item item, IdentificationType identificationType);
        public IngredientInfo[] GetBestOverride(Item item);
        public bool AddOverride(RecycleManager plugin, ItemDefinition itemDefinition);
        public void SetOverride(Item item, IdentificationType identificationType, IngredientInfo[] customIngredientList);
        public bool RemoveOverride(Item item, IdentificationType identificationType);
        public void ResetOverride(RecycleManager plugin, ItemDefinition itemDefinition);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : BaseConfiguration
    {
        [JsonProperty("Edit UI")]
        public EditUISettings EditUISettings;
        [JsonProperty("Custom recycle speed")]
        public SpeedSettings Speed;
        [JsonProperty("Custom recycle efficiency")]
        public EfficiencySettings Efficiency;
        [JsonProperty("Restricted input items")]
        public RestrictedInputItems RestrictedInputItems;
        [JsonProperty("Max items in stack per recycle (% of max stack size)")]
        public MaxItemsPerRecycle MaxItemsPerRecycle;
        [JsonProperty("Output multipliers")]
        public OutputMultiplierSettings OutputMultipliers;
        [JsonProperty("Override output")]
        public OverrideOutput OverrideOutput;
        [JsonProperty("Override output (before efficiency factor)")]
        private OverrideOutput DeprecatedOverrideOutput { get; set; }
        public void Init(RecycleManager plugin);
    }

    private Configuration GetDefaultConfig();
    [JsonObject(MemberSerialization.OptIn)]
    private class BaseConfiguration
    {
        [JsonIgnore]
        public bool UsingDefaults;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class LangEntry
    {
        public static List<LangEntry> AllLangEntries;
        public static readonly LangEntry ErrorNoPermission;
        public static readonly LangEntry ErrorConfig;
        public static readonly LangEntry ErrorInvalidItem;
        public static readonly LangEntry ItemSyntax;
        public static readonly LangEntry AddExists;
        public static readonly LangEntry AddSuccess;
        public static readonly LangEntry ResetSuccess;
        public static readonly LangEntry UIButtonAdmin;
        public static readonly LangEntry UIHeader;
        public static readonly LangEntry UIButtonClose;
        public static readonly LangEntry UIEmptyState;
        public static readonly LangEntry UIItemBlocked;
        public static readonly LangEntry UILabelConfigureBy;
        public static readonly LangEntry UIButtonItem;
        public static readonly LangEntry UIButtonSkin;
        public static readonly LangEntry UIButtonDisplayName;
        public static readonly LangEntry UILabelOutput;
        public static readonly LangEntry UIButtonNotRecyclable;
        public static readonly LangEntry UIButtonDefaultOutput;
        public static readonly LangEntry UIButtonCustomOutput;
        public static readonly LangEntry UILabelActions;
        public static readonly LangEntry UIButtonSave;
        public static readonly LangEntry UIButtonReset;
        public static readonly LangEntry UIButtonCancel;
        public string Name;
        public string English;
        public LangEntry(string name, string english);
    }

    private string GetMessage(string playerId, LangEntry langEntry);
    private string GetMessage(string playerId, LangEntry langEntry, object arg1);
    private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2);
    private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2, string arg3);
    private string GetMessage(string playerId, LangEntry langEntry, object[] args);
    private void ReplyToPlayer(IPlayer player, LangEntry langEntry);
    private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1);
    private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2);
    private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2, object arg3);
    private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object[] args);
    protected override void LoadDefaultMessages();
}

private static class ExposedHooks
{
    public static object OnRecycleManagerItemRecyclable(Item item, Recycler recycler);
    public static object OnRecycleManagerSpeed(Recycler recycler, BasePlayer player, float[] recycleTime);
    public static void OnRecycleManagerEfficiency(Recycler recycler, BasePlayer player, float[] recyclerEfficiency);
    public static object OnRecycleManagerRecycle(Item item, Recycler recycler);
}

private class LayoutProvider
{
    public const string AnchorBottomLeft;
    public const string AnchorBottomRight;
    public const string AnchorTopLeft;
    public const string AnchorTopRight;
    public static LayoutProvider Once(float width, float height);
    private static LayoutProvider _reusable;
    private LayoutOptions _options;
    private string _anchor;
    private float _x;
    private float _y;
    private float _xSpacing;
    private float _ySpacing;
    private float _width;
    private float _height;
    private bool _isVertical { get; set; }
    private bool _isLeftToRight { get; set; }
    private bool _isTopToBottom { get; set; }
    private int _xSign { get; set; }
    private int _ySign { get; set; }
    private float XMin;
    private float XMax;
    private float YMin;
    private float YMax;
    public string AnchorMin { get; set; }
    public string AnchorMax { get; set; }
    public string OffsetMin { get; set; }
    public string OffsetMax { get; set; }
    public LayoutProvider(float width, float height);
    public LayoutProvider WithDimensions(float width, float height);
    public LayoutProvider WithOptions(LayoutOptions options);
    public LayoutProvider WithSpacing(float x, float y);
    public LayoutProvider WithOffset(float x, float y);
    public LayoutProvider Next();
    public CuiRectTransformComponent GetRectTransform();
    private string DetermineAnchor();
}

private class ButtonColor
{
    public readonly string Color;
    public readonly string TextColor;
    public ButtonColor(string color, string textColor);
}

private class ButtonColorScheme
{
    public ButtonColor Active;
    public ButtonColor Enabled;
    public ButtonColor Disabled;
    public ButtonColor Get(bool active, bool enabled);
}

private class CuiInputFieldComponentHud : CuiInputFieldComponent
{
    [JsonProperty("hudMenuInput", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool HudMenuInput { get; set; }
}

private class CuiElementRecreate : CuiElement
{
    [JsonProperty("destroyUi", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string DestroyUi { get; set; }
}

private static class EditUI
{
    private const string UIName;
    private const string EditPanelUIName;
    private const string PercentagePanelUIName;
    private const string AnchorMin;
    private const string AnchorMax;
    private const float PanelWidth;
    private const float PanelHeight;
    private const float HeaderHeight;
    private const int ItemPaddingLeft;
    private const int ItemSize;
    private const int ItemSpacing;
    private const string BaseUICommand;
    private const string TextColor;
    private const string BackgroundColor;
    private static ButtonColorScheme DefaultButtonColorScheme;
    private static ButtonColorScheme SaveButtonColorScheme;
    private static ButtonColorScheme ResetButtonColorScheme;
    public static void DestroyUI(BasePlayer player);
    public static void DrawUI(RecycleManager plugin, BasePlayer player, EditState state);
    private static void DrawDefaultUI(RecycleManager plugin, BasePlayer player);
    private static void DrawEditUI(RecycleManager plugin, BasePlayer player, EditState state);
    private static CuiElementContainer CreateContainer();
    private static void AddEditButton(CuiElementContainer elements, RecycleManager plugin, BasePlayer player);
    private static void AddEditHeader(CuiElementContainer elements, RecycleManager plugin, BasePlayer player);
    private static void AddEditPanel(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
    private static void AddPercentageControllers(CuiElementContainer elements, EditState state);
    private static void AddButton(CuiElementContainer elements, LayoutProvider layoutProvider, ButtonColorScheme buttonColorScheme, string parent, string text, string command, bool active, bool enabled);
    private static void AddItemIdentificationControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
    private static void AddItemAllowedControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
    private static void AddPrimaryControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state);
}

private class EditState
{
    public Item InputItem;
    public IdentificationType IdentificationType;
    public OutputType OutputType;
    public float[] Chances;
    public bool BlockedByAnotherPlugin;
    public bool CanSave;
    public bool CanReset;
}

private class EditController : FacepunchBehaviour
{
    public static EditController AddToRecycler(RecycleManager plugin, RecycleEditManager recycleEditManager, Recycler recycler);
    private RecycleManager _plugin;
    private RecycleEditManager _recycleEditManager;
    private Recycler _recycler;
    private BasePlayer _player;
    private EditState _editState;
    private Func<Item, int, bool> _originalCanAcceptItem;
    private Action _onDirtyDelayed;
    private bool _pauseAutoChangeOutput;
    private Configuration _config { get; set; }
    private EditController();
    public void StartViewing(BasePlayer player);
    public void DestroyImmediate();
    private IngredientInfo[] GetSavedIngredients();
    private bool CanSave();
    private bool CanReset();
    private void DrawUI();
    private List<IngredientInfo> GetOutputIngredients();
    public void HandleUICommand(BasePlayer player, string[] args);
    private IngredientInfo[] GetOutput(IdentificationType identificationType, OutputType outputType);
    private void PopulateOutputItems();
    private void RemoveInputItems();
    private void RemoveOutputItems(BasePlayer player);
    private void StartEditing();
    private bool CanAcceptItem(Item item);
    private void StopEditing(bool redraw);
    private void StopViewing();
    private Item TrimInputs();
    private void RemoveExcessInput(Item item);
    private IngredientInfo[] GetOverride(IdentificationType identificationType);
    private IngredientInfo[] GetOverride();
    private bool IsDisallowed(IdentificationType identificationType);
    private bool IsDisallowed();
    private OutputType DetermineBestOutputType(IdentificationType identificationType);
    private OutputType DetermineBestOutputType();
    private IdentificationType DetermineBestIdentificationType();
    private void HandleNewInputItem();
    private void HandleChanges();
    private void OnDirtyDelayed();
    private void OnDirty();
    private void PlayerStoppedLooting(BasePlayer player);
    private void OnDestroy();
}

private class RecycleEditManager
{
    private RecycleManager _plugin;
    private Dictionary<Recycler, EditController> _controllers;
    private Dictionary<BasePlayer, EditController> _playerControllers;
    public RecycleEditManager(RecycleManager plugin);
    public void HandlePlayerStartedLooting(BasePlayer player, Recycler recycler);
    public EditController GetController(BasePlayer player);
    public EditController EnsureController(Recycler recycler);
    public void HandlePlayerStoppedLooting(BasePlayer player);
    public void HandleControllerDestroyed(Recycler recycler);
    public void Unload();
    private EditController GetController(Recycler recycler);
}

private class RecyclerComponent : FacepunchBehaviour
{
    public static RecyclerComponent AddToRecycler(RecycleManager plugin, RecyclerComponentManager recyclerComponentManager, Recycler recycler);
    public BasePlayer Player { get; set; }
    private RecycleManager _plugin;
    private RecyclerComponentManager _recyclerComponentManager;
    private Recycler _recycler;
    private Action _vanillaRecycleThink;
    private Action _customRecycleThink;
    private float _recycleTime;
    private Configuration _config { get; set; }
    private bool _enableIncrementalRecycling { get; set; }
    private RecyclerComponent();
    public void DestroyImmediate();
    public void HandleRecyclerToggle(BasePlayer player);
    private void HandleRecyclerToggleDelayed(BasePlayer player);
    private void CustomRecycleThink();
    private float GetItemRecycleTime(Item item);
    private Item GetNextItem();
    private void OnDestroy();
}

private class RecyclerComponentManager
{
    private RecycleManager _plugin;
    private readonly Dictionary<Recycler, RecyclerComponent> _recyclerComponents;
    public void Init(RecycleManager plugin);
    public void Unload();
    public void HandleRecyclerToggle(Recycler recycler, BasePlayer player);
    public void HandleRecyclerComponentDestroyed(Recycler recycler);
    public RecyclerComponent EnsureRecyclerComponent(Recycler recycler);
}

private class CaseInsensitiveDictionary : Dictionary<string, TValue>
{
    public CaseInsensitiveDictionary();
}

private class CaseInsensitiveHashSet : HashSet<string>
{
    public CaseInsensitiveHashSet();
}

[JsonObject(MemberSerialization.OptIn)]
private class EditUISettings
{
    [JsonProperty("Enabled")]
    public bool Enabled;
}

[JsonObject(MemberSerialization.OptIn)]
private class PermissionSpeedProfile
{
    [JsonProperty("Permission suffix")]
    public string PermissionSuffix;
    [JsonProperty("Recycle time (seconds)")]
    private float RecycleTime { get; set; }
    [JsonProperty("Recycle time multiplier")]
    public float TimeMultiplier;
    [JsonIgnore]
    public string Permission { get; set; }
    public void Init(RecycleManager plugin);
}

[JsonObject(MemberSerialization.OptIn)]
private class SpeedSettings
{
    [JsonProperty("Enabled")]
    public bool Enabled;
    [JsonProperty("Default recycle time (seconds)")]
    public float DefaultRecycleTime;
    [JsonProperty("Recycle time (seconds)")]
    private float DeprecatedRecycleTime { get; set; }
    [JsonProperty("Recycle time multiplier while in safe zone")]
    public float SafeZoneTimeMultiplier;
    [JsonProperty("Recycle time multiplier by item short name (item: multiplier)")]
    public Dictionary<string, float> TimeMultiplierByShortName;
    [JsonProperty("Recycle time multiplier by permission")]
    public PermissionSpeedProfile[] PermissionSpeedProfiles;
    [JsonProperty("Speeds requiring permission")]
    private PermissionSpeedProfile[] DeprecatedSpeedsRequiringPermission { get; set; }
    [JsonIgnore]
    private Permission _permission;
    [JsonIgnore]
    private Dictionary<int, float> _timeMultiplierByItemId;
    [JsonIgnore]
    public bool EnableIncrementalRecycling;
    public void Init(RecycleManager plugin);
    public float GetTimeMultiplierForPlayer(BasePlayer player);
    public float GetTimeMultiplierForItem(Item item);
}

[JsonObject(MemberSerialization.OptIn)]
private class EfficiencySettings
{
    [JsonProperty("Enabled")]
    public bool Enabled;
    [JsonProperty("Default recycle efficiency")]
    public float DefaultRecyclerEfficiency;
    [JsonProperty("Recycle efficiency while in safe zone")]
    public float RecyclerEfficiencyWhileInSafeZone;
    public float GetRecyclerEfficiency(Recycler recycler);
}

[JsonObject(MemberSerialization.OptIn)]
private class MaxItemsPerRecycle
{
    [JsonProperty("Default percent")]
    public float DefaultPercent;
    [JsonProperty("Percent by input item short name")]
    public Dictionary<string, float> PercentByShortName;
    [JsonProperty("Percent by input item skin ID")]
    public Dictionary<ulong, float> PercentBySkinId;
    [JsonProperty("Percent by input item display name (custom items)")]
    public CaseInsensitiveDictionary<float> PercentByDisplayName;
    [JsonIgnore]
    private Dictionary<int, float> PercentByItemId;
    public void Init();
    public float GetPercent(Item item);
}

[JsonObject(MemberSerialization.OptIn)]
private class OutputMultiplierSettings
{
    [JsonProperty("Default multiplier")]
    public float DefaultMultiplier;
    [JsonProperty("Multiplier by output item short name")]
    public Dictionary<string, float> MultiplierByOutputShortName;
    [JsonIgnore]
    private Dictionary<int, float> MultiplierByOutputItemId;
    public void Init();
    public float GetOutputMultiplier(int itemId);
}

[JsonObject(MemberSerialization.OptIn)]
private class IngredientInfo : IEquatable<IngredientInfo>
{
    [JsonProperty("Item short name")]
    public string ShortName;
    [JsonProperty("Item skin ID", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public ulong SkinId;
    [JsonProperty("Display name", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string DisplayName;
    [JsonProperty("Amount")]
    public float Amount;
    [JsonIgnore]
    public ItemDefinition ItemDefinition;
    public void Init();
    public bool Equals(IngredientInfo other);
}

[JsonObject(MemberSerialization.OptIn)]
private class RestrictedInputItems
{
    [JsonProperty("Item short names")]
    public CaseInsensitiveHashSet DisallowedInputShortNames;
    [JsonProperty("Item skin IDs")]
    public HashSet<ulong> DisallowedInputSkinIds;
    [JsonProperty("Item display names (custom items)")]
    public CaseInsensitiveHashSet DisallowedInputDisplayNames;
    [JsonIgnore]
    private HashSet<int> DisallowedInputItemIds;
    public void Init();
    public bool IsDisallowed(Item item, IdentificationType identificationType);
    public bool IsDisallowed(Item item);
    public bool Allow(Item item, IdentificationType identificationType);
    public bool Disallow(Item item, IdentificationType identificationType);
}

[JsonObject(MemberSerialization.OptIn)]
private class OverrideOutput
{
    [JsonProperty("Override output by input item short name")]
    public Dictionary<string, IngredientInfo[]> OverrideOutputByShortName;
    [JsonProperty("Override output by input item skin ID")]
    public Dictionary<ulong, IngredientInfo[]> OverrideOutputBySkinId;
    [JsonProperty("Override output by input item display name (custom items)")]
    public CaseInsensitiveDictionary<IngredientInfo[]> OverrideOutputByDisplayName;
    [JsonIgnore]
    private Dictionary<int, IngredientInfo[]> OverrideOutputByItemId;
    public void Init();
    public IngredientInfo[] GetOverride(Item item, IdentificationType identificationType);
    public IngredientInfo[] GetBestOverride(Item item);
    public bool AddOverride(RecycleManager plugin, ItemDefinition itemDefinition);
    public void SetOverride(Item item, IdentificationType identificationType, IngredientInfo[] customIngredientList);
    public bool RemoveOverride(Item item, IdentificationType identificationType);
    public void ResetOverride(RecycleManager plugin, ItemDefinition itemDefinition);
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : BaseConfiguration
{
    [JsonProperty("Edit UI")]
    public EditUISettings EditUISettings;
    [JsonProperty("Custom recycle speed")]
    public SpeedSettings Speed;
    [JsonProperty("Custom recycle efficiency")]
    public EfficiencySettings Efficiency;
    [JsonProperty("Restricted input items")]
    public RestrictedInputItems RestrictedInputItems;
    [JsonProperty("Max items in stack per recycle (% of max stack size)")]
    public MaxItemsPerRecycle MaxItemsPerRecycle;
    [JsonProperty("Output multipliers")]
    public OutputMultiplierSettings OutputMultipliers;
    [JsonProperty("Override output")]
    public OverrideOutput OverrideOutput;
    [JsonProperty("Override output (before efficiency factor)")]
    private OverrideOutput DeprecatedOverrideOutput { get; set; }
    public void Init(RecycleManager plugin);
}

[JsonObject(MemberSerialization.OptIn)]
private class BaseConfiguration
{
    [JsonIgnore]
    public bool UsingDefaults;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private class LangEntry
{
    public static List<LangEntry> AllLangEntries;
    public static readonly LangEntry ErrorNoPermission;
    public static readonly LangEntry ErrorConfig;
    public static readonly LangEntry ErrorInvalidItem;
    public static readonly LangEntry ItemSyntax;
    public static readonly LangEntry AddExists;
    public static readonly LangEntry AddSuccess;
    public static readonly LangEntry ResetSuccess;
    public static readonly LangEntry UIButtonAdmin;
    public static readonly LangEntry UIHeader;
    public static readonly LangEntry UIButtonClose;
    public static readonly LangEntry UIEmptyState;
    public static readonly LangEntry UIItemBlocked;
    public static readonly LangEntry UILabelConfigureBy;
    public static readonly LangEntry UIButtonItem;
    public static readonly LangEntry UIButtonSkin;
    public static readonly LangEntry UIButtonDisplayName;
    public static readonly LangEntry UILabelOutput;
    public static readonly LangEntry UIButtonNotRecyclable;
    public static readonly LangEntry UIButtonDefaultOutput;
    public static readonly LangEntry UIButtonCustomOutput;
    public static readonly LangEntry UILabelActions;
    public static readonly LangEntry UIButtonSave;
    public static readonly LangEntry UIButtonReset;
    public static readonly LangEntry UIButtonCancel;
    public string Name;
    public string English;
    public LangEntry(string name, string english);
}


```

---

## RecycleModifier by birthdates - Easily change the output of the recycler

```csharp
using Newtonsoft.Json;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Recycle Modifier", "birthdates", "1.0.3")]
[Description("Ability to change the output of the recycler")]
public class RecycleModifier : RustPlugin
{
    private ConfigFile config;
    public class ConfigFile
    {
        [JsonProperty(PropertyName = "Blacklisted items (wont get the modifier)")]
        public List<string> bAP;
        [JsonProperty(PropertyName = "Modifier")]
        public float mod;
        public static ConfigFile DefaultConfig();
    }

     void OnRecycleItem(Recycler recycler, Item item);
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    protected override void SaveConfig();
    private void Init();
}

public class ConfigFile
{
    [JsonProperty(PropertyName = "Blacklisted items (wont get the modifier)")]
    public List<string> bAP;
    [JsonProperty(PropertyName = "Modifier")]
    public float mod;
    public static ConfigFile DefaultConfig();
}


```

---

## RecyclerBlock by KrunghCrow - Blocks usage of any recycler with exclude permission

```csharp
using Oxide.Core;

Oxide.Plugins
[Info("Recycler Block", "Krungh Crow", "1.0.2")]
[Description("Disables using the recycler")]
 class RecyclerBlock : RustPlugin
{
     void Init();
    private object CanLootEntity(BasePlayer player, Recycler recycler);
}


```

---

## RecyclerSpeed by yetzt - Change the Speed of Recyclers

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Recycler Speed", "Ryz0r/yetzt", "2.0.2")]
[Description("Easily set the speed at which the recycler... recycles")]
public class RecyclerSpeed : RustPlugin
{
    private const string UsePerm;
    private Configuration _config;
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private class Configuration
    {
        [JsonProperty(PropertyName = "Recyler Speed (Lower = Faster) (Seconds)")]
        public float RecyclerSpeed;
    }

    protected override void LoadConfig();
    private void Init();
    private void OnRecyclerToggle(Recycler recycler, BasePlayer player);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Recyler Speed (Lower = Faster) (Seconds)")]
    public float RecyclerSpeed;
}


```

---

## RecyclerTeleport by  - Teleports player to a random recycler on command

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Recycler Teleport", "Norn/Arainrr", "1.1.1")]
[Description("Teleport to recyclers via command.")]
public class RecyclerTeleport : RustPlugin
{
    private const string PERMISSION_USE;
    private readonly List<Vector3> recyclerPositions;
    private void Init();
    private void OnServerInitialized();
    private void Findrecycler();
    private void TeleportToRecycler(BasePlayer player);
    private void RecyclerCommand(BasePlayer player, string command, string[] args);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Chat command")]
        public string command;
        [JsonProperty(PropertyName = "Chat prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat prefix color")]
        public string prefixColor;
        [JsonProperty(PropertyName = "Chat steamID icon")]
        public ulong steamIDIcon;
        [JsonProperty(PropertyName = "Teleport seconds")]
        public float teleportSeconds;
        [JsonProperty(PropertyName = "Block list")]
        public Dictionary<string, bool> monumentBlockList;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Print(BasePlayer player, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Chat command")]
    public string command;
    [JsonProperty(PropertyName = "Chat prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat prefix color")]
    public string prefixColor;
    [JsonProperty(PropertyName = "Chat steamID icon")]
    public ulong steamIDIcon;
    [JsonProperty(PropertyName = "Teleport seconds")]
    public float teleportSeconds;
    [JsonProperty(PropertyName = "Block list")]
    public Dictionary<string, bool> monumentBlockList;
}


```

---

## Referral by misticos - Players can enter codes or step up and say they were brought here by someone

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Referral", "birthdates", "0.1", ResourceId = 0)]
public class Referral : RustPlugin
{
    private new void LoadDefaultConfig();
     void Loaded();
    private new void LoadDefaultMessages();
    [ConsoleCommand("refercodes")]
     void codeList(ConsoleSystem.Arg arg);
    [ConsoleCommand("refercode.add")]
     void addReferralCode(ConsoleSystem.Arg arg);
    [ChatCommand("refer")]
     void referCommand(BasePlayer player, string command, string[] args);
}


```

---

## RemoteDetonatedExplosives by birthdates - Allows players to detonate explosives remotely with a RF Transmitter

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Remote Detonated Explosives", "birthdates", "2.0.2")]
[Description("Allows players to detonate explosives remotely with a RF Transmitter")]
public class RemoteDetonatedExplosives : RustPlugin
{
    private const string DetonatePermission;
    private static float Time { get; set; }
    private IDictionary<ulong, Queue<Explosive>> ActiveExplosives { get; set; }
    private class Explosive
    {
        public TimedExplosive Entity { get; set; }
        public float Expiry { get; set; }
        public ExplosiveSettings Settings { get; set; }
    }

    private void Init();
    private void OnExplosiveThrown(BasePlayer player, TimedExplosive timedExplosive, BaseNetworkable item);
    private void Unload();
    private void OnRfBroadcasterAdded(Detonator detonator, int frequency);
    private void AddActiveExplosive(ExplosiveSettings settings, ulong id, TimedExplosive timedExplosive);
    private void LifespanExplode(ulong id, IEnumerable<Explosive> explosives, Explosive explosive);
    private static void CancelExplode(TimedExplosive timedExplosive);
    private Queue<Explosive> GetExplosives(ulong id, bool create);
    private static void UpdateCollider(ExplosiveSettings explosiveSettings, Component obj);
    private ConfigFile _config;
    private class PhysicsSettings
    {
        public float Friction { get; set; }
        public float Mass { get; set; }
    }

    private class ConfigFile
    {
        [JsonProperty("Explosive Settings")]
        public IDictionary<string, ExplosiveSettings> AllExplosiveSettings { get; set; }
        public static ConfigFile DefaultConfig();
    }

    private class ExplosiveSettings
    {
        [JsonProperty("Collision Settings")]
        public PhysicsSettings PhysicsSettings { get; set; }
        [JsonProperty("Max Time Before it Automatically Explodes (-1 to disable)")]
        public float MaxLifespan { get; set; }
        [JsonProperty("Max Detonation Distance")]
        public float MaxDistance { get; set; }
        [JsonProperty("Max Explosions with One Click")]
        public int MaxExplosions { get; set; }
        [JsonProperty("Initial Delay (time before you can explode in seconds)")]
        public float InitialDelay { get; set; }
        [JsonProperty("Required Frequency (-1 for all)")]
        public int Frequency;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class Explosive
{
    public TimedExplosive Entity { get; set; }
    public float Expiry { get; set; }
    public ExplosiveSettings Settings { get; set; }
}

private class PhysicsSettings
{
    public float Friction { get; set; }
    public float Mass { get; set; }
}

private class ConfigFile
{
    [JsonProperty("Explosive Settings")]
    public IDictionary<string, ExplosiveSettings> AllExplosiveSettings { get; set; }
    public static ConfigFile DefaultConfig();
}

private class ExplosiveSettings
{
    [JsonProperty("Collision Settings")]
    public PhysicsSettings PhysicsSettings { get; set; }
    [JsonProperty("Max Time Before it Automatically Explodes (-1 to disable)")]
    public float MaxLifespan { get; set; }
    [JsonProperty("Max Detonation Distance")]
    public float MaxDistance { get; set; }
    [JsonProperty("Max Explosions with One Click")]
    public int MaxExplosions { get; set; }
    [JsonProperty("Initial Delay (time before you can explode in seconds)")]
    public float InitialDelay { get; set; }
    [JsonProperty("Required Frequency (-1 for all)")]
    public int Frequency;
}


```

---

## RemoveAnimalsAI by Whispers88 - Disables animal based AI from moving, while allowing NPC humans (scientists) to move as per normal.

```csharp
using HarmonyLib;
using Oxide.Core.Plugins;
using Rust.Ai.Gen2;
using static Rust.Ai.Gen2.FSMComponent;

Oxide.Plugins
[Info("Remove Animals AI", "Whipers88 @CobaltStudios", "1.1.1")]
[Description("Removing AI only for animals (not for bots)")]
public class RemoveAnimalsAI : RustPlugin
{
    private void Init();
    [HarmonyPatch(typeof(BaseNpc), nameof(BaseNpc.TickAi)), AutoPatch]
    public static class TickAiPatch
    {
        [HarmonyPrefix]
        private static bool Prefix();
    }

    [HarmonyPatch(typeof(LimitedTurnNavAgent), nameof(LimitedTurnNavAgent.TickSteering)), AutoPatch]
    public static class TickSteeringPatch
    {
        [HarmonyPrefix]
        private static bool Prefix();
    }

    [HarmonyPatch(typeof(TickFSMWorkQueue), "RunJob"), AutoPatch]
    public static class RunJobPatch
    {
        [HarmonyPrefix]
        private static bool Prefix(FSMComponent component);
    }

    [HarmonyPatch(typeof(AIThinkManager), nameof(AIThinkManager.ProcessQueue)), AutoPatch]
    public static class ProcessQueuePatch
    {
        [HarmonyPrefix]
        private static bool Prefix(AIThinkManager.QueueType queueType);
    }

    [HarmonyPatch(typeof(AnimalBrain), nameof(AnimalBrain.InitializeAI)), AutoPatch]
    public static class InitializeAIPatch
    {
        [HarmonyPrefix]
        private static bool Prefix(BaseAIBrain __instance);
    }

}

[HarmonyPatch(typeof(BaseNpc), nameof(BaseNpc.TickAi)), AutoPatch]
public static class TickAiPatch
{
    [HarmonyPrefix]
    private static bool Prefix();
}

[HarmonyPatch(typeof(LimitedTurnNavAgent), nameof(LimitedTurnNavAgent.TickSteering)), AutoPatch]
public static class TickSteeringPatch
{
    [HarmonyPrefix]
    private static bool Prefix();
}

[HarmonyPatch(typeof(TickFSMWorkQueue), "RunJob"), AutoPatch]
public static class RunJobPatch
{
    [HarmonyPrefix]
    private static bool Prefix(FSMComponent component);
}

[HarmonyPatch(typeof(AIThinkManager), nameof(AIThinkManager.ProcessQueue)), AutoPatch]
public static class ProcessQueuePatch
{
    [HarmonyPrefix]
    private static bool Prefix(AIThinkManager.QueueType queueType);
}

[HarmonyPatch(typeof(AnimalBrain), nameof(AnimalBrain.InitializeAI)), AutoPatch]
public static class InitializeAIPatch
{
    [HarmonyPrefix]
    private static bool Prefix(BaseAIBrain __instance);
}


```

---

## RemoveDefaultRadiation by k1lly0u - Removes default radiation zones, for use with plugins that enable server radiation

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("RemoveDefaultRadiation", "k1lly0u", "0.1.0", ResourceId = 0)]
 class RemoveDefaultRadiation : RustPlugin
{
     void OnServerInitialized();
    private ConfigData configData;
     class ConfigData
    {
        public List<string> PluginList { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
}

 class ConfigData
{
    public List<string> PluginList { get; set; }
}


```

---

## RemovePuzzleDoors by ziptie - Removes puzzle doors

```csharp
using UnityEngine;
using System.Linq;

Oxide.Plugins
[Info("Remove Puzzle Doors", "ziptie", 1.1)]
[Description("Removes puzzle doors.")]
public class RemovePuzzleDoors : CovalencePlugin
{
    public RemovePuzzleDoorsConfig config;
    protected override void LoadDefaultConfig();
    private RemovePuzzleDoorsConfig GetDefaultConfig();
    private void OnServerInitialized(bool initial);
}

public class RemovePuzzleDoorsConfig
{
    public RemovalSettings RemovalSettings;
    public PrefabSettings PrefabSettings;
}

[System.Serializable]
public class RemovalSettings
{
    public bool RemoveRedDoors;
    public bool RemoveBlueDoors;
    public bool RemoveGreenDoors;
}

[System.Serializable]
public class PrefabSettings
{
    public string RedDoorPrefab;
    public string BlueDoorPrefab;
    public string GreenDoorPrefab;
}


```

---

## RemoverTool by Tryhard - Building and entity removal tool

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using VLB;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Remover Tool", "Reneb/Fuji/Arainrr/Tryhard", "4.3.43", ResourceId = 651)]
[Description("Building and entity removal tool")]
public class RemoverTool : RustPlugin
{
    [PluginReference]
    private readonly Plugin Friends;
    private readonly Plugin ServerRewards;
    private readonly Plugin Clans;
    private readonly Plugin Economics;
    private readonly Plugin ImageLibrary;
    private readonly Plugin BuildingOwners;
    private readonly Plugin RustTranslationAPI;
    private readonly Plugin NoEscape;
    private const string ECONOMICS_KEY;
    private const string SERVER_REWARDS_KEY;
    private const string PERMISSION_ALL;
    private const string PERMISSION_ADMIN;
    private const string PERMISSION_NORMAL;
    private const string PERMISSION_TARGET;
    private const string PERMISSION_EXTERNAL;
    private const string PERMISSION_OVERRIDE;
    private const string PERMISSION_STRUCTURE;
    private const string PREFAB_ITEM_DROP;
    private const int LAYER_ALL;
    private const int LAYER_TARGET;
    private static RemoverTool _instance;
    private static BUTTON _removeButton;
    private static RemoveMode _removeMode;
    private readonly object _false;
    private bool _configChanged;
    private bool _removeOverride;
    private Coroutine _removeAllCoroutine;
    private Coroutine _removeStructureCoroutine;
    private Coroutine _removeExternalCoroutine;
    private Coroutine _removePlayerEntityCoroutine;
    private StringBuilder _debugStringBuilder;
    private Hash<ulong, float> _entitySpawnedTimes;
    private readonly Hash<ulong, float> _cooldownTimes;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnServerSave();
    private void OnEntitySpawned(BaseEntity entity);
    private void OnEntityKill(BaseEntity entity);
    private object OnPlayerAttack(BasePlayer player, HitInfo info);
    private object OnHammerHit(BasePlayer player, HitInfo info);
    private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem);
    private readonly HashSet<Construction> _constructions;
    private readonly Dictionary<string, int> _itemShortNameToItemId;
    private readonly Dictionary<string, string> _prefabNameToStructure;
    private readonly Dictionary<string, string> _shortPrefabNameToDeployable;
    private void Initialize();
    private static string GetRemoveTypeName(RemoveType removeType);
    private static void DropItemContainer(ItemContainer itemContainer, Vector3 position, Quaternion rotation);
    private static bool IsExternalWall(StabilityEntity stabilityEntity);
    private static bool CanEntityBeDisplayed(BaseEntity entity, BasePlayer player);
    private static bool CanEntityBeSaved(BaseEntity entity);
    private static bool HasEntityEnabled(BaseEntity entity);
    private static bool IsRemovableEntity(BaseEntity entity);
    private static string GetEntityImage(string name);
    private static string GetItemImage(string shortname);
    private static void TryFindEntityName(BasePlayer player, BaseEntity entity, string displayName, string imageName);
    private static string GetDisplayNameByCurrencyName(string language, string currencyName, long skinId);
    private static string GetCurrencyDisplayName(string currencyName, string defaultName, bool readOnly);
    private static PermissionSettings GetPermissionSettings(BasePlayer player);
    private static Vector2 GetAnchor(string anchor);
    private static bool AddImageToLibrary(string url, string shortname, ulong skin);
    private static string GetImageFromLibrary(string shortname, ulong skin, bool returnUrl);
    private void OnRaidBlock(BasePlayer player);
    private void OnCombatBlock(BasePlayer player);
    private bool IsPlayerBlocked(BasePlayer player, string reason);
    private bool IsRaidBlocked(string playerID);
    private bool IsCombatBlocked(string playerID);
    private static class UI
    {
        public static CuiElementContainer CreateElementContainer(string parent, string panelName, string backgroundColor, string anchorMin, string anchorMax, string offsetMin, string offsetMax, bool cursor);
        public static void CreatePanel(CuiElementContainer container, string panelName, string backgroundColor, string anchorMin, string anchorMax, bool cursor);
        public static void CreateLabel(CuiElementContainer container, string panelName, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align, float fadeIn);
        public static void CreateImage(CuiElementContainer container, string panelName, string image, string anchorMin, string anchorMax, string color);
        public static void CreateImage(CuiElementContainer container, string panelName, int itemId, ulong skinId, string anchorMin, string anchorMax);
    }

    private const string UINAME_MAIN;
    private const string UINAME_TIMELEFT;
    private const string UINAME_ENTITY;
    private const string UINAME_PRICE;
    private const string UINAME_REFUND;
    private const string UINAME_AUTH;
    private const string UINAME_CROSSHAIR;
    private static void CreateCrosshairUI(BasePlayer player);
    private static void CreateMainUI(BasePlayer player, RemoveType removeType);
    private static void UpdateTimeLeftUI(BasePlayer player, RemoveType removeType, int timeLeft, int currentRemoved, int maxRemovable);
    private static void UpdateEntityUI(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info);
    private static void UpdatePriceUI(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info, bool usePrice);
    private static void UpdateRefundUI(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info, bool useRefund);
    private static void UpdateAuthorizationUI(BasePlayer player, RemoveType removeType, BaseEntity targetEntity, RemovableEntityInfo? info, bool shouldPay);
    private static void DestroyAllUI(BasePlayer player);
    private static void DestroyUiEntry(BasePlayer player, UiEntry uiEntry);
    private static bool IsSpecificTool(BasePlayer player);
    private static bool IsSpecificTool(Item heldItem);
    private static bool IsMeleeTool(BasePlayer player);
    private static bool IsMeleeTool(Item heldItem);
    private class ToolRemover : FacepunchBehaviour
    {
        private const float MinInterval;
        public int CurrentRemoved { get; set; }
        public BaseEntity HitEntity { get; set; }
        public bool CanOverride { get; set; }
        public BasePlayer Player { get; set; }
        public RemoveType RemoveType { get; set; }
        private bool _resetTime;
        private bool _shouldPay;
        private bool _shouldRefund;
        private int _removeTime;
        private int _maxRemovable;
        private float _distance;
        private float _removeInterval;
        private int _timeLeft;
        private float _lastRemove;
        private ItemId _currentItemId;
        private bool _disableInHand;
        private Item _lastHeldItem;
        private BaseEntity _targetEntity;
        private UiEntry _activeUiEntries;
        private void Awake();
        public void Init(RemoveType removeType, int removeTime, int maxRemovable, float distance, float removeInterval, bool shouldPay, bool shouldRefund, bool resetTime, bool canOverride);
        private void RemoveUpdate();
        private BaseEntity GetTargetEntity();
        private void Update();
        private void UnEquip();
        private bool HandleUiEntry(UiEntry uiEntry, bool canShow);
        public void DisableTool(bool showMessage);
        private void OnDestroy();
    }

    private bool TryRemove(BasePlayer player, BaseEntity targetEntity, RemoveType removeType, bool shouldPay, bool shouldRefund);
    private bool CanRemoveEntity(BasePlayer player, RemoveType removeType, BaseEntity targetEntity, RemovableEntityInfo? info, bool shouldPay, string reason);
    private bool HasAccess(BasePlayer player, BaseEntity targetEntity);
    private static bool HasTotalAccess(BasePlayer player, BaseEntity targetEntity);
    private static bool CanOpenAllLocks(BasePlayer player, BaseEntity targetEntity);
    private static bool OnTryToOpen(BasePlayer player, BaseLock baseLock);
    private static bool IsDamagedEntity(BaseEntity entity);
    private static bool IsEntityTimeLimit(BaseEntity entity);
    private static void DropContainerEntity(BaseEntity targetEntity);
    private bool AreFriends(ulong playerID, ulong friendID);
    private static bool SameTeam(ulong playerID, ulong friendID);
    private bool HasFriend(ulong playerID, ulong friendID);
    private bool SameClan(ulong playerID, ulong friendID);
    private Dictionary<string, CurrencyInfo> GetPrice(BaseEntity targetEntity, RemovableEntityInfo? info);
    private bool TryPay(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info);
    private bool CanPay(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info);
    private bool CheckOrPay(BaseEntity targetEntity, BasePlayer player, string itemName, CurrencyInfo currencyInfo, bool check);
    private static int GetInventoryAmount(BasePlayer player, int itemId, CurrencyInfo currencyInfo);
    private static int TakeInventory(BasePlayer player, int itemId, CurrencyInfo currencyInfo, List<Item> collect);
    private void GiveRefund(BasePlayer player, BaseEntity targetEntity, RemovableEntityInfo? info);
    private Dictionary<string, CurrencyInfo> GetRefund(BaseEntity targetEntity, RemovableEntityInfo? info);
    private IEnumerable<string> GetSlots(BaseEntity targetEntity);
    private IEnumerator RemoveAll(BaseEntity sourceEntity, BasePlayer player);
    private IEnumerator RemoveExternal(StabilityEntity sourceEntity, BasePlayer player);
    private IEnumerator RemoveStructure(DecayEntity sourceEntity, BasePlayer player);
    private IEnumerator RemovePlayerEntity(ConsoleSystem.Arg arg, ulong targetID, PlayerEntityRemoveType playerEntityRemoveType);
    private IEnumerator DelayRemove(IEnumerable<BaseEntity> entities, BasePlayer player, RemoveType removeType);
    private static IEnumerator GetNearbyEntities(T sourceEntity, HashSet<T> removeList, int layers, Func<T, bool> filter);
    private static IEnumerator ProcessContainers(HashSet<BaseEntity> removeList);
    private static IEnumerator ProcessBuilding(DecayEntity sourceEntity, HashSet<BaseEntity> removeList);
    private static void ProcessContainer(BaseEntity entity);
    private static bool DoRemove(BaseEntity entity, BaseNetworkable.DestroyMode destroyMode);
    private static void DoNormalRemove(BasePlayer player, BaseEntity entity, bool gibs);
    private static RemovableEntityInfo? GetRemovableEntityInfo(BaseEntity entity, BasePlayer player);
    private bool IsToolRemover(BasePlayer player);
    private string GetPlayerRemoveType(BasePlayer player);
    private void CmdRemove(BasePlayer player, string command, string[] args);
    private bool ToggleRemove(BasePlayer player, RemoveType removeType, int time);
    [ConsoleCommand("remove.toggle")]
    private void CCmdRemoveToggle(ConsoleSystem.Arg arg);
    [ConsoleCommand("remove.target")]
    private void CCmdRemoveTarget(ConsoleSystem.Arg arg);
    [ConsoleCommand("remove.building")]
    private void CCmdConstruction(ConsoleSystem.Arg arg);
    [ConsoleCommand("remove.allow")]
    private void CCmdRemoveAllow(ConsoleSystem.Arg arg);
    [ConsoleCommand("remove.playerentity")]
    private void CCmdRemoveEntity(ConsoleSystem.Arg arg);
    private void PrintDebug(string message, bool warning);
    private void SaveDebug();
    private string GetItemTranslationByShortName(string language, string itemShortName);
    private string GetConstructionTranslation(string language, string prefabName);
    private string GetDeployableTranslation(string language, string deployable);
    private string GetItemDisplayName(string language, string itemShortName);
    private string GetConstructionDisplayName(BasePlayer player, string shortPrefabName, string displayName);
    private string GetDeployableDisplayName(BasePlayer player, string deployable, string displayName);
    private void UpdateConfig();
    private static ConfigData _configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Settings")]
        public readonly GlobalSettings global;
        [JsonProperty(PropertyName = "Container Settings")]
        public readonly ContainerSettings container;
        [JsonProperty(PropertyName = "Remove Damaged Entities")]
        public readonly DamagedEntitySettings damagedEntity;
        [JsonProperty(PropertyName = "Chat Settings")]
        public readonly ChatSettings chat;
        [JsonProperty(PropertyName = "Permission Settings (Just for normal type)")]
        public readonly Dictionary<string, PermissionSettings> permission;
        [JsonProperty(PropertyName = "Remove Type Settings")]
        public readonly Dictionary<RemoveType, RemoveTypeSettings> removeType;
        [JsonProperty(PropertyName = "Remove Mode Settings (Only one model works)")]
        public readonly RemoverModeSettings removerMode;
        [JsonProperty(PropertyName = "NoEscape Settings")]
        public readonly NoEscapeSettings noEscape;
        [JsonProperty(PropertyName = "Image Urls (Used to UI image)")]
        public readonly Dictionary<string, string> imageUrls;
        [JsonProperty(PropertyName = "GUI")]
        public readonly UiSettings ui;
        [JsonProperty(PropertyName = "Remove Info (Refund & Price)")]
        public readonly RemoveSettings remove;
        [JsonProperty(PropertyName = "Version")]
        public VersionNumber version;
    }

    public class GlobalSettings
    {
        [JsonProperty(PropertyName = "Enable Debug Mode")]
        public bool debugEnabled;
        [JsonProperty(PropertyName = "Log Debug To File")]
        public bool logToFile;
        [JsonProperty(PropertyName = "Use Teams")]
        public bool useTeams;
        [JsonProperty(PropertyName = "Use Clans")]
        public bool useClans;
        [JsonProperty(PropertyName = "Use Friends")]
        public bool useFriends;
        [JsonProperty(PropertyName = "Use Entity Owners")]
        public bool useEntityOwners;
        [JsonProperty(PropertyName = "Use Building Locks")]
        public bool useBuildingLocks;
        [JsonProperty(PropertyName = "Use Tool Cupboards (Strongly unrecommended)")]
        public bool useToolCupboards;
        [JsonProperty(PropertyName = "Use Building Owners (You will need BuildingOwners plugin)")]
        public bool useBuildingOwners;
        [JsonProperty(PropertyName = "Remove Button")]
        public string removeButton;
        [JsonProperty(PropertyName = "Remove Interval (Min = 0.2)")]
        public float removeInterval;
        [JsonProperty(PropertyName = "Only start cooldown when an entity is removed")]
        public bool startCooldownOnRemoved;
        [JsonProperty(PropertyName = "RemoveType - All/Structure - Remove per frame")]
        public int removePerFrame;
        [JsonProperty(PropertyName = "RemoveType - All/Structure - No item container dropped")]
        public bool noItemContainerDrop;
        [JsonProperty(PropertyName = "RemoveType - Normal - Max Removable Objects - Exclude admins")]
        public bool maxRemovableExclude;
        [JsonProperty(PropertyName = "RemoveType - Normal - Cooldown - Exclude admins")]
        public bool cooldownExclude;
        [JsonProperty(PropertyName = "RemoveType - Normal - Entity Spawned Time Limit - Enabled")]
        public bool entityTimeLimit;
        [JsonProperty(PropertyName = "RemoveType - Normal - Entity Spawned Time Limit - Cannot be removed when entity spawned time more than it")]
        public float limitTime;
        [JsonProperty(PropertyName = "Default Entity Settings (When automatically adding new entities to 'Other Entity Settings')")]
        public DefaultEntitySettings defaultEntity;
        public class DefaultEntitySettings
        {
            [JsonProperty(PropertyName = "Default Remove Allowed")]
            public bool removeAllowed;
        }

    }

    public class ContainerSettings
    {
        [JsonProperty(PropertyName = "Storage Container - Enable remove of not empty storages")]
        public bool removeNotEmptyStorage;
        [JsonProperty(PropertyName = "Storage Container - Drop items from container")]
        public bool dropItemsStorage;
        [JsonProperty(PropertyName = "Storage Container - Drop a item container from container")]
        public bool dropContainerStorage;
        [JsonProperty(PropertyName = "IOEntity Container - Enable remove of not empty storages")]
        public bool removeNotEmptyIoEntity;
        [JsonProperty(PropertyName = "IOEntity Container - Drop items from container")]
        public bool dropItemsIoEntity;
        [JsonProperty(PropertyName = "IOEntity Container - Drop a item container from container")]
        public bool dropContainerIoEntity;
    }

    public class DamagedEntitySettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool enabled;
        [JsonProperty(PropertyName = "Exclude Quarries")]
        public bool excludeQuarries;
        [JsonProperty(PropertyName = "Exclude Building Blocks")]
        public bool excludeBuildingBlocks;
        [JsonProperty(PropertyName = "Percentage (Can be removed when (health / max health * 100) is not less than it)")]
        public float percentage;
    }

    public class ChatSettings
    {
        [JsonProperty(PropertyName = "Chat Command")]
        public string command;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong steamIDIcon;
        [JsonProperty(PropertyName = "Show Message When Enabled/Disabled")]
        public bool showMessageWhenEnabledOrDisabled;
    }

    public class PermissionSettings
    {
        [JsonProperty(PropertyName = "Priority")]
        public int priority;
        [JsonProperty(PropertyName = "Distance")]
        public float distance;
        [JsonProperty(PropertyName = "Cooldown")]
        public float cooldown;
        [JsonProperty(PropertyName = "Max Time")]
        public int maxTime;
        [JsonProperty(PropertyName = "Remove Interval (Min = 0.2)")]
        public float removeInterval;
        [JsonProperty(PropertyName = "Max Removable Objects (0 = Unlimited)")]
        public int maxRemovable;
        [JsonProperty(PropertyName = "Pay")]
        public bool pay;
        [JsonProperty(PropertyName = "Refund")]
        public bool refund;
        [JsonProperty(PropertyName = "Reset the time after removing an entity")]
        public bool resetTime;
    }

    public class RemoveTypeSettings
    {
        [JsonProperty(PropertyName = "Display Name")]
        public string displayName;
        [JsonProperty(PropertyName = "Distance")]
        public float distance;
        [JsonProperty(PropertyName = "Default Time")]
        public int defaultTime;
        [JsonProperty(PropertyName = "Max Time")]
        public int maxTime;
        [JsonProperty(PropertyName = "Gibs")]
        public bool gibs;
        [JsonProperty(PropertyName = "Reset the time after removing an entity")]
        public bool resetTime;
    }

    public class RemoverModeSettings
    {
        [JsonProperty(PropertyName = "No Held Item Mode")]
        public bool noHeldMode;
        [JsonProperty(PropertyName = "No Held Item Mode - Disable remover tool when you have any item in hand")]
        public bool noHeldDisableInHand;
        [JsonProperty(PropertyName = "Melee Tool Hit Mode")]
        public bool meleeHitMode;
        [JsonProperty(PropertyName = "Melee Tool Hit Mode - Item shortname")]
        public string meleeHitItemShortname;
        [JsonProperty(PropertyName = "Melee Tool Hit Mode - Item skin (-1 = All skins)")]
        public long meleeHitModeSkin;
        [JsonProperty(PropertyName = "Melee Tool Hit Mode - Auto enable remover tool when you hold a melee tool")]
        public bool meleeHitEnableInHand;
        [JsonProperty(PropertyName = "Melee Tool Hit Mode - Requires a melee tool in your hand when remover tool is enabled")]
        public bool meleeHitRequires;
        [JsonProperty(PropertyName = "Melee Tool Hit Mode - Disable remover tool when you are not holding a melee tool")]
        public bool meleeHitDisableInHand;
        [JsonProperty(PropertyName = "Specific Tool Mode")]
        public bool specificToolMode;
        [JsonProperty(PropertyName = "Specific Tool Mode - Item shortname")]
        public string specificToolShortName;
        [JsonProperty(PropertyName = "Specific Tool Mode - Item skin (-1 = All skins)")]
        public long specificToolSkin;
        [JsonProperty(PropertyName = "Specific Tool Mode - Auto enable remover tool when you hold a specific tool")]
        public bool specificToolEnableInHand;
        [JsonProperty(PropertyName = "Specific Tool Mode - Requires a specific tool in your hand when remover tool is enabled")]
        public bool specificToolRequires;
        [JsonProperty(PropertyName = "Specific Tool Mode - Disable remover tool when you are not holding a specific tool")]
        public bool specificToolDisableInHand;
    }

    public class NoEscapeSettings
    {
        [JsonProperty(PropertyName = "Use Raid Blocker")]
        public bool useRaidBlocker;
        [JsonProperty(PropertyName = "Use Combat Blocker")]
        public bool useCombatBlocker;
    }

    public class UiSettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool enabled;
        [JsonProperty(PropertyName = "Main Box - Min Anchor (in Rust Window)")]
        public string removerToolAnchorMin;
        [JsonProperty(PropertyName = "Main Box - Max Anchor (in Rust Window)")]
        public string removerToolAnchorMax;
        [JsonProperty(PropertyName = "Main Box - Min Offset (in Rust Window)")]
        public string removerToolOffsetMin;
        [JsonProperty(PropertyName = "Main Box - Max Offset (in Rust Window)")]
        public string removerToolOffsetMax;
        [JsonProperty(PropertyName = "Main Box - Background Color")]
        public string removerToolBackgroundColor;
        [JsonProperty(PropertyName = "Remove Title - Box - Min Anchor (in Main Box)")]
        public string removeAnchorMin;
        [JsonProperty(PropertyName = "Remove Title - Box - Max Anchor (in Main Box)")]
        public string removeAnchorMax;
        [JsonProperty(PropertyName = "Remove Title - Box - Background Color")]
        public string removeBackgroundColor;
        [JsonProperty(PropertyName = "Remove Title - Text - Min Anchor (in Main Box)")]
        public string removeTextAnchorMin;
        [JsonProperty(PropertyName = "Remove Title - Text - Max Anchor (in Main Box)")]
        public string removeTextAnchorMax;
        [JsonProperty(PropertyName = "Remove Title - Text - Text Color")]
        public string removeTextColor;
        [JsonProperty(PropertyName = "Remove Title - Text - Text Size")]
        public int removeTextSize;
        [JsonProperty(PropertyName = "Timeleft - Box - Min Anchor (in Main Box)")]
        public string timeLeftAnchorMin;
        [JsonProperty(PropertyName = "Timeleft - Box - Max Anchor (in Main Box)")]
        public string timeLeftAnchorMax;
        [JsonProperty(PropertyName = "Timeleft - Box - Background Color")]
        public string timeLeftBackgroundColor;
        [JsonProperty(PropertyName = "Timeleft - Text - Min Anchor (in Timeleft Box)")]
        public string timeLeftTextAnchorMin;
        [JsonProperty(PropertyName = "Timeleft - Text - Max Anchor (in Timeleft Box)")]
        public string timeLeftTextAnchorMax;
        [JsonProperty(PropertyName = "Timeleft - Text - Text Color")]
        public string timeLeftTextColor;
        [JsonProperty(PropertyName = "Timeleft - Text - Text Size")]
        public int timeLeftTextSize;
        [JsonProperty(PropertyName = "Entity - Box - Min Anchor (in Main Box)")]
        public string entityAnchorMin;
        [JsonProperty(PropertyName = "Entity - Box - Max Anchor (in Main Box)")]
        public string entityAnchorMax;
        [JsonProperty(PropertyName = "Entity - Box - Background Color")]
        public string entityBackgroundColor;
        [JsonProperty(PropertyName = "Entity - Text - Min Anchor (in Entity Box)")]
        public string entityTextAnchorMin;
        [JsonProperty(PropertyName = "Entity - Text - Max Anchor (in Entity Box)")]
        public string entityTextAnchorMax;
        [JsonProperty(PropertyName = "Entity - Text - Text Color")]
        public string entityTextColor;
        [JsonProperty(PropertyName = "Entity - Text - Text Size")]
        public int entityTextSize;
        [JsonProperty(PropertyName = "Entity - Image - Enabled")]
        public bool entityImageEnabled;
        [JsonProperty(PropertyName = "Entity - Image - Min Anchor (in Entity Box)")]
        public string entityImageAnchorMin;
        [JsonProperty(PropertyName = "Entity - Image - Max Anchor (in Entity Box)")]
        public string entityImageAnchorMax;
        [JsonProperty(PropertyName = "Authorization Check Enabled")]
        public bool authorizationEnabled;
        [JsonProperty(PropertyName = "Authorization Check - Box - Min Anchor (in Main Box)")]
        public string authorizationsAnchorMin;
        [JsonProperty(PropertyName = "Authorization Check - Box - Max Anchor (in Main Box)")]
        public string authorizationsAnchorMax;
        [JsonProperty(PropertyName = "Authorization Check - Box - Allowed Background Color")]
        public string allowedBackgroundColor;
        [JsonProperty(PropertyName = "Authorization Check - Box - Refused Background Color")]
        public string refusedBackgroundColor;
        [JsonProperty(PropertyName = "Authorization Check - Text - Min Anchor (in Authorization Check Box)")]
        public string authorizationsTextAnchorMin;
        [JsonProperty(PropertyName = "Authorization Check - Text - Max Anchor (in Authorization Check Box)")]
        public string authorizationsTextAnchorMax;
        [JsonProperty(PropertyName = "Authorization Check - Text - Text Color")]
        public string authorizationsTextColor;
        [JsonProperty(PropertyName = "Authorization Check Box - Text - Text Size")]
        public int authorizationsTextSize;
        [JsonProperty(PropertyName = "Price & Refund - Image Enabled")]
        public bool imageEnabled;
        [JsonProperty(PropertyName = "Price & Refund - Image Scale")]
        public float imageScale;
        [JsonProperty(PropertyName = "Price & Refund - Distance of image from right border")]
        public float rightDistance;
        [JsonProperty(PropertyName = "Price Enabled")]
        public bool priceEnabled;
        [JsonProperty(PropertyName = "Price - Box - Min Anchor (in Main Box)")]
        public string priceAnchorMin;
        [JsonProperty(PropertyName = "Price - Box - Max Anchor (in Main Box)")]
        public string priceAnchorMax;
        [JsonProperty(PropertyName = "Price - Box - Background Color")]
        public string priceBackgroundColor;
        [JsonProperty(PropertyName = "Price - Text - Min Anchor (in Price Box)")]
        public string priceTextAnchorMin;
        [JsonProperty(PropertyName = "Price - Text - Max Anchor (in Price Box)")]
        public string priceTextAnchorMax;
        [JsonProperty(PropertyName = "Price - Text - Text Color")]
        public string priceTextColor;
        [JsonProperty(PropertyName = "Price - Text - Text Size")]
        public int priceTextSize;
        [JsonProperty(PropertyName = "Price - Text2 - Min Anchor (in Price Box)")]
        public string price2TextAnchorMin;
        [JsonProperty(PropertyName = "Price - Text2 - Max Anchor (in Price Box)")]
        public string price2TextAnchorMax;
        [JsonProperty(PropertyName = "Price - Text2 - Text Color")]
        public string price2TextColor;
        [JsonProperty(PropertyName = "Price - Text2 - Text Size")]
        public int price2TextSize;
        [JsonProperty(PropertyName = "Refund Enabled")]
        public bool refundEnabled;
        [JsonProperty(PropertyName = "Refund - Box - Min Anchor (in Main Box)")]
        public string refundAnchorMin;
        [JsonProperty(PropertyName = "Refund - Box - Max Anchor (in Main Box)")]
        public string refundAnchorMax;
        [JsonProperty(PropertyName = "Refund - Box - Background Color")]
        public string refundBackgroundColor;
        [JsonProperty(PropertyName = "Refund - Text - Min Anchor (in Refund Box)")]
        public string refundTextAnchorMin;
        [JsonProperty(PropertyName = "Refund - Text - Max Anchor (in Refund Box)")]
        public string refundTextAnchorMax;
        [JsonProperty(PropertyName = "Refund - Text - Text Color")]
        public string refundTextColor;
        [JsonProperty(PropertyName = "Refund - Text - Text Size")]
        public int refundTextSize;
        [JsonProperty(PropertyName = "Refund - Text2 - Min Anchor (in Refund Box)")]
        public string refund2TextAnchorMin;
        [JsonProperty(PropertyName = "Refund - Text2 - Max Anchor (in Refund Box)")]
        public string refund2TextAnchorMax;
        [JsonProperty(PropertyName = "Refund - Text2 - Text Color")]
        public string refund2TextColor;
        [JsonProperty(PropertyName = "Refund - Text2 - Text Size")]
        public int refund2TextSize;
        [JsonProperty(PropertyName = "Crosshair - Enabled")]
        public bool showCrosshair;
        [JsonProperty(PropertyName = "Crosshair - Image Url")]
        public string crosshairImageUrl;
        [JsonProperty(PropertyName = "Crosshair - Box - Min Anchor (in Rust Window)")]
        public string crosshairAnchorMin;
        [JsonProperty(PropertyName = "Crosshair - Box - Max Anchor (in Rust Window)")]
        public string crosshairAnchorMax;
        [JsonProperty(PropertyName = "Crosshair - Box - Min Offset (in Rust Window)")]
        public string crosshairOffsetMin;
        [JsonProperty(PropertyName = "Crosshair - Box - Max Offset (in Rust Window)")]
        public string crosshairOffsetMax;
        [JsonProperty(PropertyName = "Crosshair - Box - Image Color")]
        public string crosshairColor;
        [JsonIgnore]
        public Vector2 Price2TextAnchorMin;
        public Vector2 Price2TextAnchorMax;
        public Vector2 Refund2TextAnchorMin;
        public Vector2 Refund2TextAnchorMax;
    }

    public class RemoveSettings
    {
        [JsonProperty(PropertyName = "Price Enabled")]
        public bool priceEnabled;
        [JsonProperty(PropertyName = "Refund Enabled")]
        public bool refundEnabled;
        [JsonProperty(PropertyName = "Refund Items In Entity Slot")]
        public bool refundSlot;
        [JsonProperty(PropertyName = "Allowed Building Grade")]
        public Dictionary<BuildingGrade.Enum, bool> validConstruction;
        [JsonProperty(PropertyName = "Display Names (Refund & Price)")]
        public readonly Dictionary<string, string> displayNames;
        [JsonProperty(PropertyName = "Building Blocks Settings")]
        public Dictionary<string, BuildingBlocksSettings> buildingBlock;
        [JsonProperty(PropertyName = "Other Entity Settings")]
        public Dictionary<string, EntitySettings> entity;
    }

    public class BuildingBlocksSettings
    {
        [JsonProperty(PropertyName = "Display Name")]
        public string displayName;
        [JsonProperty(PropertyName = "Building Grade")]
        public Dictionary<BuildingGrade.Enum, BuildingGradeSettings> buildingGrade;
    }

    public class BuildingGradeSettings
    {
        [JsonProperty(PropertyName = "Price")]
        public object price;
        [JsonProperty(PropertyName = "Refund")]
        public object refund;
        [JsonIgnore]
        public float pricePercentage;
        public float refundPercentage;
        [JsonIgnore]
        public Dictionary<string, CurrencyInfo> priceDict;
        public Dictionary<string, CurrencyInfo> refundDict;
    }

    public class EntitySettings
    {
        [JsonProperty(PropertyName = "Remove Allowed")]
        public bool enabled;
        [JsonProperty(PropertyName = "Display Name")]
        public string displayName;
        [JsonProperty(PropertyName = "Price")]
        public object price;
        [JsonProperty(PropertyName = "Refund")]
        public object refund;
        [JsonIgnore]
        public Dictionary<string, CurrencyInfo> priceDict;
        public Dictionary<string, CurrencyInfo> refundDict;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void PreprocessConfigValues();
    private void UpdateConfigValues();
    private bool GetConfigValue(T value, string[] path);
    private void SetConfigValue(object[] pathAndTrailingValue);
    private void PreprocessOldConfig();
    private JObject GetConfigValue(JObject config, string[] path);
    private bool GetConfigValuePre(JObject config, T value, string[] path);
    private void SetConfigValuePre(JObject config, object value, string[] path);
    private bool GetConfigVersionPre(JObject config, VersionNumber version);
    private void Print(BasePlayer player, string message);
    private void Print(ConsoleSystem.Arg arg, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

private static class UI
{
    public static CuiElementContainer CreateElementContainer(string parent, string panelName, string backgroundColor, string anchorMin, string anchorMax, string offsetMin, string offsetMax, bool cursor);
    public static void CreatePanel(CuiElementContainer container, string panelName, string backgroundColor, string anchorMin, string anchorMax, bool cursor);
    public static void CreateLabel(CuiElementContainer container, string panelName, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align, float fadeIn);
    public static void CreateImage(CuiElementContainer container, string panelName, string image, string anchorMin, string anchorMax, string color);
    public static void CreateImage(CuiElementContainer container, string panelName, int itemId, ulong skinId, string anchorMin, string anchorMax);
}

private class ToolRemover : FacepunchBehaviour
{
    private const float MinInterval;
    public int CurrentRemoved { get; set; }
    public BaseEntity HitEntity { get; set; }
    public bool CanOverride { get; set; }
    public BasePlayer Player { get; set; }
    public RemoveType RemoveType { get; set; }
    private bool _resetTime;
    private bool _shouldPay;
    private bool _shouldRefund;
    private int _removeTime;
    private int _maxRemovable;
    private float _distance;
    private float _removeInterval;
    private int _timeLeft;
    private float _lastRemove;
    private ItemId _currentItemId;
    private bool _disableInHand;
    private Item _lastHeldItem;
    private BaseEntity _targetEntity;
    private UiEntry _activeUiEntries;
    private void Awake();
    public void Init(RemoveType removeType, int removeTime, int maxRemovable, float distance, float removeInterval, bool shouldPay, bool shouldRefund, bool resetTime, bool canOverride);
    private void RemoveUpdate();
    private BaseEntity GetTargetEntity();
    private void Update();
    private void UnEquip();
    private bool HandleUiEntry(UiEntry uiEntry, bool canShow);
    public void DisableTool(bool showMessage);
    private void OnDestroy();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Settings")]
    public readonly GlobalSettings global;
    [JsonProperty(PropertyName = "Container Settings")]
    public readonly ContainerSettings container;
    [JsonProperty(PropertyName = "Remove Damaged Entities")]
    public readonly DamagedEntitySettings damagedEntity;
    [JsonProperty(PropertyName = "Chat Settings")]
    public readonly ChatSettings chat;
    [JsonProperty(PropertyName = "Permission Settings (Just for normal type)")]
    public readonly Dictionary<string, PermissionSettings> permission;
    [JsonProperty(PropertyName = "Remove Type Settings")]
    public readonly Dictionary<RemoveType, RemoveTypeSettings> removeType;
    [JsonProperty(PropertyName = "Remove Mode Settings (Only one model works)")]
    public readonly RemoverModeSettings removerMode;
    [JsonProperty(PropertyName = "NoEscape Settings")]
    public readonly NoEscapeSettings noEscape;
    [JsonProperty(PropertyName = "Image Urls (Used to UI image)")]
    public readonly Dictionary<string, string> imageUrls;
    [JsonProperty(PropertyName = "GUI")]
    public readonly UiSettings ui;
    [JsonProperty(PropertyName = "Remove Info (Refund & Price)")]
    public readonly RemoveSettings remove;
    [JsonProperty(PropertyName = "Version")]
    public VersionNumber version;
}

public class GlobalSettings
{
    [JsonProperty(PropertyName = "Enable Debug Mode")]
    public bool debugEnabled;
    [JsonProperty(PropertyName = "Log Debug To File")]
    public bool logToFile;
    [JsonProperty(PropertyName = "Use Teams")]
    public bool useTeams;
    [JsonProperty(PropertyName = "Use Clans")]
    public bool useClans;
    [JsonProperty(PropertyName = "Use Friends")]
    public bool useFriends;
    [JsonProperty(PropertyName = "Use Entity Owners")]
    public bool useEntityOwners;
    [JsonProperty(PropertyName = "Use Building Locks")]
    public bool useBuildingLocks;
    [JsonProperty(PropertyName = "Use Tool Cupboards (Strongly unrecommended)")]
    public bool useToolCupboards;
    [JsonProperty(PropertyName = "Use Building Owners (You will need BuildingOwners plugin)")]
    public bool useBuildingOwners;
    [JsonProperty(PropertyName = "Remove Button")]
    public string removeButton;
    [JsonProperty(PropertyName = "Remove Interval (Min = 0.2)")]
    public float removeInterval;
    [JsonProperty(PropertyName = "Only start cooldown when an entity is removed")]
    public bool startCooldownOnRemoved;
    [JsonProperty(PropertyName = "RemoveType - All/Structure - Remove per frame")]
    public int removePerFrame;
    [JsonProperty(PropertyName = "RemoveType - All/Structure - No item container dropped")]
    public bool noItemContainerDrop;
    [JsonProperty(PropertyName = "RemoveType - Normal - Max Removable Objects - Exclude admins")]
    public bool maxRemovableExclude;
    [JsonProperty(PropertyName = "RemoveType - Normal - Cooldown - Exclude admins")]
    public bool cooldownExclude;
    [JsonProperty(PropertyName = "RemoveType - Normal - Entity Spawned Time Limit - Enabled")]
    public bool entityTimeLimit;
    [JsonProperty(PropertyName = "RemoveType - Normal - Entity Spawned Time Limit - Cannot be removed when entity spawned time more than it")]
    public float limitTime;
    [JsonProperty(PropertyName = "Default Entity Settings (When automatically adding new entities to 'Other Entity Settings')")]
    public DefaultEntitySettings defaultEntity;
    public class DefaultEntitySettings
    {
        [JsonProperty(PropertyName = "Default Remove Allowed")]
        public bool removeAllowed;
    }

}

public class DefaultEntitySettings
{
    [JsonProperty(PropertyName = "Default Remove Allowed")]
    public bool removeAllowed;
}

public class ContainerSettings
{
    [JsonProperty(PropertyName = "Storage Container - Enable remove of not empty storages")]
    public bool removeNotEmptyStorage;
    [JsonProperty(PropertyName = "Storage Container - Drop items from container")]
    public bool dropItemsStorage;
    [JsonProperty(PropertyName = "Storage Container - Drop a item container from container")]
    public bool dropContainerStorage;
    [JsonProperty(PropertyName = "IOEntity Container - Enable remove of not empty storages")]
    public bool removeNotEmptyIoEntity;
    [JsonProperty(PropertyName = "IOEntity Container - Drop items from container")]
    public bool dropItemsIoEntity;
    [JsonProperty(PropertyName = "IOEntity Container - Drop a item container from container")]
    public bool dropContainerIoEntity;
}

public class DamagedEntitySettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool enabled;
    [JsonProperty(PropertyName = "Exclude Quarries")]
    public bool excludeQuarries;
    [JsonProperty(PropertyName = "Exclude Building Blocks")]
    public bool excludeBuildingBlocks;
    [JsonProperty(PropertyName = "Percentage (Can be removed when (health / max health * 100) is not less than it)")]
    public float percentage;
}

public class ChatSettings
{
    [JsonProperty(PropertyName = "Chat Command")]
    public string command;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong steamIDIcon;
    [JsonProperty(PropertyName = "Show Message When Enabled/Disabled")]
    public bool showMessageWhenEnabledOrDisabled;
}

public class PermissionSettings
{
    [JsonProperty(PropertyName = "Priority")]
    public int priority;
    [JsonProperty(PropertyName = "Distance")]
    public float distance;
    [JsonProperty(PropertyName = "Cooldown")]
    public float cooldown;
    [JsonProperty(PropertyName = "Max Time")]
    public int maxTime;
    [JsonProperty(PropertyName = "Remove Interval (Min = 0.2)")]
    public float removeInterval;
    [JsonProperty(PropertyName = "Max Removable Objects (0 = Unlimited)")]
    public int maxRemovable;
    [JsonProperty(PropertyName = "Pay")]
    public bool pay;
    [JsonProperty(PropertyName = "Refund")]
    public bool refund;
    [JsonProperty(PropertyName = "Reset the time after removing an entity")]
    public bool resetTime;
}

public class RemoveTypeSettings
{
    [JsonProperty(PropertyName = "Display Name")]
    public string displayName;
    [JsonProperty(PropertyName = "Distance")]
    public float distance;
    [JsonProperty(PropertyName = "Default Time")]
    public int defaultTime;
    [JsonProperty(PropertyName = "Max Time")]
    public int maxTime;
    [JsonProperty(PropertyName = "Gibs")]
    public bool gibs;
    [JsonProperty(PropertyName = "Reset the time after removing an entity")]
    public bool resetTime;
}

public class RemoverModeSettings
{
    [JsonProperty(PropertyName = "No Held Item Mode")]
    public bool noHeldMode;
    [JsonProperty(PropertyName = "No Held Item Mode - Disable remover tool when you have any item in hand")]
    public bool noHeldDisableInHand;
    [JsonProperty(PropertyName = "Melee Tool Hit Mode")]
    public bool meleeHitMode;
    [JsonProperty(PropertyName = "Melee Tool Hit Mode - Item shortname")]
    public string meleeHitItemShortname;
    [JsonProperty(PropertyName = "Melee Tool Hit Mode - Item skin (-1 = All skins)")]
    public long meleeHitModeSkin;
    [JsonProperty(PropertyName = "Melee Tool Hit Mode - Auto enable remover tool when you hold a melee tool")]
    public bool meleeHitEnableInHand;
    [JsonProperty(PropertyName = "Melee Tool Hit Mode - Requires a melee tool in your hand when remover tool is enabled")]
    public bool meleeHitRequires;
    [JsonProperty(PropertyName = "Melee Tool Hit Mode - Disable remover tool when you are not holding a melee tool")]
    public bool meleeHitDisableInHand;
    [JsonProperty(PropertyName = "Specific Tool Mode")]
    public bool specificToolMode;
    [JsonProperty(PropertyName = "Specific Tool Mode - Item shortname")]
    public string specificToolShortName;
    [JsonProperty(PropertyName = "Specific Tool Mode - Item skin (-1 = All skins)")]
    public long specificToolSkin;
    [JsonProperty(PropertyName = "Specific Tool Mode - Auto enable remover tool when you hold a specific tool")]
    public bool specificToolEnableInHand;
    [JsonProperty(PropertyName = "Specific Tool Mode - Requires a specific tool in your hand when remover tool is enabled")]
    public bool specificToolRequires;
    [JsonProperty(PropertyName = "Specific Tool Mode - Disable remover tool when you are not holding a specific tool")]
    public bool specificToolDisableInHand;
}

public class NoEscapeSettings
{
    [JsonProperty(PropertyName = "Use Raid Blocker")]
    public bool useRaidBlocker;
    [JsonProperty(PropertyName = "Use Combat Blocker")]
    public bool useCombatBlocker;
}

public class UiSettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool enabled;
    [JsonProperty(PropertyName = "Main Box - Min Anchor (in Rust Window)")]
    public string removerToolAnchorMin;
    [JsonProperty(PropertyName = "Main Box - Max Anchor (in Rust Window)")]
    public string removerToolAnchorMax;
    [JsonProperty(PropertyName = "Main Box - Min Offset (in Rust Window)")]
    public string removerToolOffsetMin;
    [JsonProperty(PropertyName = "Main Box - Max Offset (in Rust Window)")]
    public string removerToolOffsetMax;
    [JsonProperty(PropertyName = "Main Box - Background Color")]
    public string removerToolBackgroundColor;
    [JsonProperty(PropertyName = "Remove Title - Box - Min Anchor (in Main Box)")]
    public string removeAnchorMin;
    [JsonProperty(PropertyName = "Remove Title - Box - Max Anchor (in Main Box)")]
    public string removeAnchorMax;
    [JsonProperty(PropertyName = "Remove Title - Box - Background Color")]
    public string removeBackgroundColor;
    [JsonProperty(PropertyName = "Remove Title - Text - Min Anchor (in Main Box)")]
    public string removeTextAnchorMin;
    [JsonProperty(PropertyName = "Remove Title - Text - Max Anchor (in Main Box)")]
    public string removeTextAnchorMax;
    [JsonProperty(PropertyName = "Remove Title - Text - Text Color")]
    public string removeTextColor;
    [JsonProperty(PropertyName = "Remove Title - Text - Text Size")]
    public int removeTextSize;
    [JsonProperty(PropertyName = "Timeleft - Box - Min Anchor (in Main Box)")]
    public string timeLeftAnchorMin;
    [JsonProperty(PropertyName = "Timeleft - Box - Max Anchor (in Main Box)")]
    public string timeLeftAnchorMax;
    [JsonProperty(PropertyName = "Timeleft - Box - Background Color")]
    public string timeLeftBackgroundColor;
    [JsonProperty(PropertyName = "Timeleft - Text - Min Anchor (in Timeleft Box)")]
    public string timeLeftTextAnchorMin;
    [JsonProperty(PropertyName = "Timeleft - Text - Max Anchor (in Timeleft Box)")]
    public string timeLeftTextAnchorMax;
    [JsonProperty(PropertyName = "Timeleft - Text - Text Color")]
    public string timeLeftTextColor;
    [JsonProperty(PropertyName = "Timeleft - Text - Text Size")]
    public int timeLeftTextSize;
    [JsonProperty(PropertyName = "Entity - Box - Min Anchor (in Main Box)")]
    public string entityAnchorMin;
    [JsonProperty(PropertyName = "Entity - Box - Max Anchor (in Main Box)")]
    public string entityAnchorMax;
    [JsonProperty(PropertyName = "Entity - Box - Background Color")]
    public string entityBackgroundColor;
    [JsonProperty(PropertyName = "Entity - Text - Min Anchor (in Entity Box)")]
    public string entityTextAnchorMin;
    [JsonProperty(PropertyName = "Entity - Text - Max Anchor (in Entity Box)")]
    public string entityTextAnchorMax;
    [JsonProperty(PropertyName = "Entity - Text - Text Color")]
    public string entityTextColor;
    [JsonProperty(PropertyName = "Entity - Text - Text Size")]
    public int entityTextSize;
    [JsonProperty(PropertyName = "Entity - Image - Enabled")]
    public bool entityImageEnabled;
    [JsonProperty(PropertyName = "Entity - Image - Min Anchor (in Entity Box)")]
    public string entityImageAnchorMin;
    [JsonProperty(PropertyName = "Entity - Image - Max Anchor (in Entity Box)")]
    public string entityImageAnchorMax;
    [JsonProperty(PropertyName = "Authorization Check Enabled")]
    public bool authorizationEnabled;
    [JsonProperty(PropertyName = "Authorization Check - Box - Min Anchor (in Main Box)")]
    public string authorizationsAnchorMin;
    [JsonProperty(PropertyName = "Authorization Check - Box - Max Anchor (in Main Box)")]
    public string authorizationsAnchorMax;
    [JsonProperty(PropertyName = "Authorization Check - Box - Allowed Background Color")]
    public string allowedBackgroundColor;
    [JsonProperty(PropertyName = "Authorization Check - Box - Refused Background Color")]
    public string refusedBackgroundColor;
    [JsonProperty(PropertyName = "Authorization Check - Text - Min Anchor (in Authorization Check Box)")]
    public string authorizationsTextAnchorMin;
    [JsonProperty(PropertyName = "Authorization Check - Text - Max Anchor (in Authorization Check Box)")]
    public string authorizationsTextAnchorMax;
    [JsonProperty(PropertyName = "Authorization Check - Text - Text Color")]
    public string authorizationsTextColor;
    [JsonProperty(PropertyName = "Authorization Check Box - Text - Text Size")]
    public int authorizationsTextSize;
    [JsonProperty(PropertyName = "Price & Refund - Image Enabled")]
    public bool imageEnabled;
    [JsonProperty(PropertyName = "Price & Refund - Image Scale")]
    public float imageScale;
    [JsonProperty(PropertyName = "Price & Refund - Distance of image from right border")]
    public float rightDistance;
    [JsonProperty(PropertyName = "Price Enabled")]
    public bool priceEnabled;
    [JsonProperty(PropertyName = "Price - Box - Min Anchor (in Main Box)")]
    public string priceAnchorMin;
    [JsonProperty(PropertyName = "Price - Box - Max Anchor (in Main Box)")]
    public string priceAnchorMax;
    [JsonProperty(PropertyName = "Price - Box - Background Color")]
    public string priceBackgroundColor;
    [JsonProperty(PropertyName = "Price - Text - Min Anchor (in Price Box)")]
    public string priceTextAnchorMin;
    [JsonProperty(PropertyName = "Price - Text - Max Anchor (in Price Box)")]
    public string priceTextAnchorMax;
    [JsonProperty(PropertyName = "Price - Text - Text Color")]
    public string priceTextColor;
    [JsonProperty(PropertyName = "Price - Text - Text Size")]
    public int priceTextSize;
    [JsonProperty(PropertyName = "Price - Text2 - Min Anchor (in Price Box)")]
    public string price2TextAnchorMin;
    [JsonProperty(PropertyName = "Price - Text2 - Max Anchor (in Price Box)")]
    public string price2TextAnchorMax;
    [JsonProperty(PropertyName = "Price - Text2 - Text Color")]
    public string price2TextColor;
    [JsonProperty(PropertyName = "Price - Text2 - Text Size")]
    public int price2TextSize;
    [JsonProperty(PropertyName = "Refund Enabled")]
    public bool refundEnabled;
    [JsonProperty(PropertyName = "Refund - Box - Min Anchor (in Main Box)")]
    public string refundAnchorMin;
    [JsonProperty(PropertyName = "Refund - Box - Max Anchor (in Main Box)")]
    public string refundAnchorMax;
    [JsonProperty(PropertyName = "Refund - Box - Background Color")]
    public string refundBackgroundColor;
    [JsonProperty(PropertyName = "Refund - Text - Min Anchor (in Refund Box)")]
    public string refundTextAnchorMin;
    [JsonProperty(PropertyName = "Refund - Text - Max Anchor (in Refund Box)")]
    public string refundTextAnchorMax;
    [JsonProperty(PropertyName = "Refund - Text - Text Color")]
    public string refundTextColor;
    [JsonProperty(PropertyName = "Refund - Text - Text Size")]
    public int refundTextSize;
    [JsonProperty(PropertyName = "Refund - Text2 - Min Anchor (in Refund Box)")]
    public string refund2TextAnchorMin;
    [JsonProperty(PropertyName = "Refund - Text2 - Max Anchor (in Refund Box)")]
    public string refund2TextAnchorMax;
    [JsonProperty(PropertyName = "Refund - Text2 - Text Color")]
    public string refund2TextColor;
    [JsonProperty(PropertyName = "Refund - Text2 - Text Size")]
    public int refund2TextSize;
    [JsonProperty(PropertyName = "Crosshair - Enabled")]
    public bool showCrosshair;
    [JsonProperty(PropertyName = "Crosshair - Image Url")]
    public string crosshairImageUrl;
    [JsonProperty(PropertyName = "Crosshair - Box - Min Anchor (in Rust Window)")]
    public string crosshairAnchorMin;
    [JsonProperty(PropertyName = "Crosshair - Box - Max Anchor (in Rust Window)")]
    public string crosshairAnchorMax;
    [JsonProperty(PropertyName = "Crosshair - Box - Min Offset (in Rust Window)")]
    public string crosshairOffsetMin;
    [JsonProperty(PropertyName = "Crosshair - Box - Max Offset (in Rust Window)")]
    public string crosshairOffsetMax;
    [JsonProperty(PropertyName = "Crosshair - Box - Image Color")]
    public string crosshairColor;
    [JsonIgnore]
    public Vector2 Price2TextAnchorMin;
    public Vector2 Price2TextAnchorMax;
    public Vector2 Refund2TextAnchorMin;
    public Vector2 Refund2TextAnchorMax;
}

public class RemoveSettings
{
    [JsonProperty(PropertyName = "Price Enabled")]
    public bool priceEnabled;
    [JsonProperty(PropertyName = "Refund Enabled")]
    public bool refundEnabled;
    [JsonProperty(PropertyName = "Refund Items In Entity Slot")]
    public bool refundSlot;
    [JsonProperty(PropertyName = "Allowed Building Grade")]
    public Dictionary<BuildingGrade.Enum, bool> validConstruction;
    [JsonProperty(PropertyName = "Display Names (Refund & Price)")]
    public readonly Dictionary<string, string> displayNames;
    [JsonProperty(PropertyName = "Building Blocks Settings")]
    public Dictionary<string, BuildingBlocksSettings> buildingBlock;
    [JsonProperty(PropertyName = "Other Entity Settings")]
    public Dictionary<string, EntitySettings> entity;
}

public class BuildingBlocksSettings
{
    [JsonProperty(PropertyName = "Display Name")]
    public string displayName;
    [JsonProperty(PropertyName = "Building Grade")]
    public Dictionary<BuildingGrade.Enum, BuildingGradeSettings> buildingGrade;
}

public class BuildingGradeSettings
{
    [JsonProperty(PropertyName = "Price")]
    public object price;
    [JsonProperty(PropertyName = "Refund")]
    public object refund;
    [JsonIgnore]
    public float pricePercentage;
    public float refundPercentage;
    [JsonIgnore]
    public Dictionary<string, CurrencyInfo> priceDict;
    public Dictionary<string, CurrencyInfo> refundDict;
}

public class EntitySettings
{
    [JsonProperty(PropertyName = "Remove Allowed")]
    public bool enabled;
    [JsonProperty(PropertyName = "Display Name")]
    public string displayName;
    [JsonProperty(PropertyName = "Price")]
    public object price;
    [JsonProperty(PropertyName = "Refund")]
    public object refund;
    [JsonIgnore]
    public Dictionary<string, CurrencyInfo> priceDict;
    public Dictionary<string, CurrencyInfo> refundDict;
}


```

---


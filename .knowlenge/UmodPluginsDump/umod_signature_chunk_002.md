# uMod Plugins Dataset - Code Abstractions (Continued)

Chunk 2 - Generated: 2025-07-06 20:25:18

## BetterResearching by  - Modify research time, cost, chance.

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Better Researching", "Arainrr", "1.1.5")]
[Description("Modify research time, cost, chance")]
public class BetterResearching : RustPlugin
{
    [PluginReference]
    private readonly Plugin PopupNotifications;
    private readonly Plugin RustTranslationAPI;
    private static BetterResearching instance;
    private const string PREFAB_RESEARCH_TABLE;
    private ItemDefinition researchResource;
    private ItemDefinition defaultResearchResource;
    private readonly Hash<ResearchTable, BasePlayer> researchers;
    private readonly Hash<ResearchTable, HashSet<BasePlayer>> lootingPlayers;
    private void Init();
    private void OnServerInitialized();
    private void OnEntitySpawned(ResearchTable researchTable);
    private void Unload();
    private void OnServerSave();
    private object CanResearchItem(BasePlayer player, Item targetItem);
    private void OnItemResearch(ResearchTable researchTable, Item targetItem, BasePlayer player);
    private object OnItemResearched(ResearchTable researchTable, int chance);
    private void OnLootEntity(BasePlayer player, ResearchTable researchTable);
    private void OnLootEntityEnd(BasePlayer player, ResearchTable researchTable);
    private void OnItemSplit(Item item, int splitAmount);
    private void CanAcceptItem(ItemContainer itemContainer, Item item, int targetPos);
    private void OnItemRemovedFromContainer(ItemContainer itemContainer, Item item);
    private void UpdateConfig();
    private void UpdateUI(ItemContainer itemContainer, Item item);
    private bool CanResearch(ResearchTable researchTable, int scrapAmount);
    private void TryConsumeItem(BasePlayer researcher, Item scrapItem, Item targetItem, ConfigData.ResearchSettings researchS, HashSet<BasePlayer> players);
    private int GetNumberOfFailures(ulong playerID, string shortname);
    private static void DoResearch(ResearchTable researchTable, BasePlayer player);
    private static Item GetScrapItem(ResearchTable researchTable);
    private static void TakeItem(Item item, int amount);
    private static ConfigData.ConsumeSettings GetConsumeSettings(ConfigData.ResearchSettings researchS, int failures);
    private void SendMessage(BasePlayer player, string message);
    private void CreatePopupNotification(string message, BasePlayer player, float duration);
    private string GetItemTranslationByShortName(string language, string itemShortName);
    private string GetItemDisplayName(BasePlayer player, ItemDefinition itemDefinition, string displayName);
    private const string UINAME_COST;
    private const string UINAME_RESEARCH;
    public class UI
    {
        public static CuiElementContainer CreateElementContainer(string parent, string panelName, string backgroundColor, string anchorMin, string anchorMax, string offsetMin, string offsetMax, bool cursor);
        public static void CreateLabel(CuiElementContainer container, string panelName, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align, float fadeIn);
        public static void CreateButton(CuiElementContainer container, string panelName, string buttonColor, string command, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align, float fadeIn);
    }

    private static void CreateResearchUI(BasePlayer player, string message, int fontSize);
    private static void CreateCostUI(BasePlayer player, int scrapAmount);
    private static void DestroyAllUI(BasePlayer player);
    [ConsoleCommand("ResearchUI_DoResearch")]
    private void CCmdDoResearch(ConsoleSystem.Arg arg);
    [ConsoleCommand("br.lvl")]
    private void CCmdResearchS(ConsoleSystem.Arg arg);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Research Resource (Item Short Name)")]
        public string researchResource;
        [JsonProperty(PropertyName = "Chat Settings")]
        public ChatSettings chatS;
        [JsonProperty(PropertyName = "Research UI Settings")]
        public UISettings uiS;
        [JsonProperty(PropertyName = "Research Settings")]
        public Dictionary<string, ResearchSettings> researchS;
        [JsonProperty(PropertyName = "Version")]
        public VersionNumber version;
        public class ChatSettings
        {
            [JsonProperty(PropertyName = "Use PopupNotifications")]
            public bool usePop;
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix;
            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon;
        }

        public class UISettings
        {
            [JsonProperty(PropertyName = "Research - Box - Background Color")]
            public string researchBackgroundColor;
            [JsonProperty(PropertyName = "Research - Text - Text Color")]
            public string researchTextColor;
            [JsonProperty(PropertyName = "Research - Text - Text Size")]
            public int researchTextSize;
            [JsonProperty(PropertyName = "Research - Text - Timeleft Text Size")]
            public int researchTimeleftTextSize;
            [JsonProperty(PropertyName = "ResearchCost - Box - Background Color")]
            public string researchCostBackgroundColor;
            [JsonProperty(PropertyName = "ResearchCost - Text - Text Color")]
            public string researchCostTextColor;
            [JsonProperty(PropertyName = "ResearchCost - Text - Text Size")]
            public int researchCostTextSize;
        }

        public class ResearchSettings
        {
            [JsonProperty(PropertyName = "Can Research")]
            public bool canResearch;
            [JsonProperty(PropertyName = "Display Name")]
            public string displayName;
            [JsonProperty(PropertyName = "Research Cost")]
            public int scrapAmount;
            [JsonProperty(PropertyName = "Research Time")]
            public float researchTime;
            [JsonProperty(PropertyName = "Research Success Chance")]
            public float successChance;
            [JsonProperty(PropertyName = "Item Consumed When Research Fails")]
            public Dictionary<int, ConsumeSettings> itemConsumedSettings;
        }

        public class ConsumeSettings
        {
            [JsonProperty(PropertyName = "Scrap Consumed Chance")]
            public float scrapChance;
            [JsonProperty(PropertyName = "Percentage Of Scrap Amount Consumed")]
            public float scrapPercentage;
            [JsonProperty(PropertyName = "Target Item Consumed Chance")]
            public float targetItemChance;
        }

    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private bool GetConfigValue(T value, string[] path);
    private StoredData storedData;
    private class StoredData
    {
        public readonly Dictionary<ulong, Dictionary<string, int>> playerResearchFailures;
    }

    private void LoadData();
    private void ClearData();
    private void SaveData();
    private void OnNewSave(string filename);
    private void Print(BasePlayer player, string message);
    private void Print(ConsoleSystem.Arg arg, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

public class UI
{
    public static CuiElementContainer CreateElementContainer(string parent, string panelName, string backgroundColor, string anchorMin, string anchorMax, string offsetMin, string offsetMax, bool cursor);
    public static void CreateLabel(CuiElementContainer container, string panelName, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align, float fadeIn);
    public static void CreateButton(CuiElementContainer container, string panelName, string buttonColor, string command, string textColor, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align, float fadeIn);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Research Resource (Item Short Name)")]
    public string researchResource;
    [JsonProperty(PropertyName = "Chat Settings")]
    public ChatSettings chatS;
    [JsonProperty(PropertyName = "Research UI Settings")]
    public UISettings uiS;
    [JsonProperty(PropertyName = "Research Settings")]
    public Dictionary<string, ResearchSettings> researchS;
    [JsonProperty(PropertyName = "Version")]
    public VersionNumber version;
    public class ChatSettings
    {
        [JsonProperty(PropertyName = "Use PopupNotifications")]
        public bool usePop;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong steamIDIcon;
    }

    public class UISettings
    {
        [JsonProperty(PropertyName = "Research - Box - Background Color")]
        public string researchBackgroundColor;
        [JsonProperty(PropertyName = "Research - Text - Text Color")]
        public string researchTextColor;
        [JsonProperty(PropertyName = "Research - Text - Text Size")]
        public int researchTextSize;
        [JsonProperty(PropertyName = "Research - Text - Timeleft Text Size")]
        public int researchTimeleftTextSize;
        [JsonProperty(PropertyName = "ResearchCost - Box - Background Color")]
        public string researchCostBackgroundColor;
        [JsonProperty(PropertyName = "ResearchCost - Text - Text Color")]
        public string researchCostTextColor;
        [JsonProperty(PropertyName = "ResearchCost - Text - Text Size")]
        public int researchCostTextSize;
    }

    public class ResearchSettings
    {
        [JsonProperty(PropertyName = "Can Research")]
        public bool canResearch;
        [JsonProperty(PropertyName = "Display Name")]
        public string displayName;
        [JsonProperty(PropertyName = "Research Cost")]
        public int scrapAmount;
        [JsonProperty(PropertyName = "Research Time")]
        public float researchTime;
        [JsonProperty(PropertyName = "Research Success Chance")]
        public float successChance;
        [JsonProperty(PropertyName = "Item Consumed When Research Fails")]
        public Dictionary<int, ConsumeSettings> itemConsumedSettings;
    }

    public class ConsumeSettings
    {
        [JsonProperty(PropertyName = "Scrap Consumed Chance")]
        public float scrapChance;
        [JsonProperty(PropertyName = "Percentage Of Scrap Amount Consumed")]
        public float scrapPercentage;
        [JsonProperty(PropertyName = "Target Item Consumed Chance")]
        public float targetItemChance;
    }

}

public class ChatSettings
{
    [JsonProperty(PropertyName = "Use PopupNotifications")]
    public bool usePop;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong steamIDIcon;
}

public class UISettings
{
    [JsonProperty(PropertyName = "Research - Box - Background Color")]
    public string researchBackgroundColor;
    [JsonProperty(PropertyName = "Research - Text - Text Color")]
    public string researchTextColor;
    [JsonProperty(PropertyName = "Research - Text - Text Size")]
    public int researchTextSize;
    [JsonProperty(PropertyName = "Research - Text - Timeleft Text Size")]
    public int researchTimeleftTextSize;
    [JsonProperty(PropertyName = "ResearchCost - Box - Background Color")]
    public string researchCostBackgroundColor;
    [JsonProperty(PropertyName = "ResearchCost - Text - Text Color")]
    public string researchCostTextColor;
    [JsonProperty(PropertyName = "ResearchCost - Text - Text Size")]
    public int researchCostTextSize;
}

public class ResearchSettings
{
    [JsonProperty(PropertyName = "Can Research")]
    public bool canResearch;
    [JsonProperty(PropertyName = "Display Name")]
    public string displayName;
    [JsonProperty(PropertyName = "Research Cost")]
    public int scrapAmount;
    [JsonProperty(PropertyName = "Research Time")]
    public float researchTime;
    [JsonProperty(PropertyName = "Research Success Chance")]
    public float successChance;
    [JsonProperty(PropertyName = "Item Consumed When Research Fails")]
    public Dictionary<int, ConsumeSettings> itemConsumedSettings;
}

public class ConsumeSettings
{
    [JsonProperty(PropertyName = "Scrap Consumed Chance")]
    public float scrapChance;
    [JsonProperty(PropertyName = "Percentage Of Scrap Amount Consumed")]
    public float scrapPercentage;
    [JsonProperty(PropertyName = "Target Item Consumed Chance")]
    public float targetItemChance;
}

private class StoredData
{
    public readonly Dictionary<ulong, Dictionary<string, int>> playerResearchFailures;
}


```

---

## BetterRootCombiners by WhiteThunder - Allows root combiners to accept input from any electrical source

```csharp

Oxide.Plugins
[Info("Better Root Combiners", "WhiteThunder", "1.0.1")]
[Description("Allows root combiners to accept input from any electrical source.")]
internal class BetterRootCombiners : CovalencePlugin
{
    private const string PermissionUse;
    private const string RootCombinerPrefab;
    private uint RootCombinerPrefabId;
    private void Init();
    private void OnServerInitialized();
    private void OnEntitySpawned(ElectricalCombiner combiner);
}


```

---

## BetterSay by LaserHydra - Allows customizing the output of the Rust say command

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Better Say", "LaserHydra", "3.0.1")]
[Description("Allows customizing the output of the Rust 'say' command")]
public class BetterSay : RustPlugin
{
    private Configuration _config;
    private void Init();
    private object OnServerCommand(ConsoleSystem.Arg arg);
    protected override void LoadDefaultMessages();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private class Configuration
    {
        [JsonProperty("Format")]
        public string Format { get; set; }
        [JsonProperty("Title")]
        public string Title { get; set; }
        [JsonProperty("Title Color")]
        public string TitleColor { get; set; }
        [JsonProperty("Message Color")]
        public string MessageColor { get; set; }
        [JsonProperty("Chat Icon (SteamID64)")]
        public ulong ChatIcon { get; set; }
    }

}

private class Configuration
{
    [JsonProperty("Format")]
    public string Format { get; set; }
    [JsonProperty("Title")]
    public string Title { get; set; }
    [JsonProperty("Title Color")]
    public string TitleColor { get; set; }
    [JsonProperty("Message Color")]
    public string MessageColor { get; set; }
    [JsonProperty("Chat Icon (SteamID64)")]
    public ulong ChatIcon { get; set; }
}


```

---

## BetterScarecrows by Spiikesan - Fix and improves the scarecrows

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

Oxide.Plugins
[Info("Better Scarecrows", "Spiikesan", "1.5.9")]
[Description("Fix and improve scarecrows")]
public class BetterScarecrows : RustPlugin
{
    const string b64ScarecrowDesign;
    const float SOUND_DELAY;
    static AIState _lastAIStateEnumValue;
    static AIState _maxAIStateEnumValue;
    static BetterScarecrows _instance;
     ProtoBuf.AIDesign _customDesign;
    private ScarecrowConfiguration _config;
    private ConVars _previousConVars;
    public class ConVars
    {
        [JsonProperty("OverrideConVars")]
        public bool OverrideConVars;
        [JsonProperty("ScarecrowPopulation")]
        public float ScarecrowPopulation;
        [JsonProperty("scarecrowsThrowBeancans")]
        public bool ScarecrowsThrowBeancans;
        [JsonProperty("scarecrowThrowBeancanGlobalDelay")]
        public float ScarecrowThrowBeancanGlobalDelay;
    }

    public class Sounds
    {
        [JsonProperty("Death")]
        public string Death;
    }

    public class ScarecrowConfiguration
    {
        [JsonProperty("Health")]
        public float Health;
        [JsonProperty("AttackRangeMultiplier")]
        public float AttackRangeMultiplier;
        [JsonProperty("TargetLostRange")]
        public float TargetLostRange;
        [JsonProperty("SenseRange")]
        public float SenseRange;
        [JsonProperty("WalkSpeedFraction")]
        public float WalkSpeed;
        [JsonProperty("RunSpeedFraction")]
        public float RunSpeed;
        [JsonProperty("IgnoreSafeZonePlayers")]
        public bool IgnoreSafeZonePlayers;
        [JsonProperty("CanBradleyAPCTargetScarecrow")]
        public bool CanBradleyAPCTargetScarecrow;
        [JsonProperty("CanNPCTurretsTargetScarecrow")]
        public bool CanNPCTurretsTargetScarecrow;
        [JsonProperty("CanNPCScientistsTargetScarecrow")]
        public bool CanNPCScientistsTargetScarecrow;
        [JsonProperty("CanScarecrowTargetNPCScientists")]
        public bool CanScarecrowTargetNPCScientists;
        [JsonProperty("CanNPCBanditGuardTargetScarecrow")]
        public bool CanNPCBanditGuardTargetScarecrow;
        [JsonProperty("CanScarecrowTargetNPCBanditGuard")]
        public bool CanScarecrowTargetNPCBanditGuard;
        [JsonProperty("DisableLoot")]
        public bool DisableLoot;
        [JsonProperty("UseCustomAI")]
        public bool UseCustomAI;
        public Sounds Sounds;
        [JsonProperty("ConVars")]
        public ConVars ConVars;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     void Init();
    private void computeNewDesign(int offset);
     void OnServerInitialized();
     void Unload();
    private void OnEntitySpawned(ScarecrowNPC entity);
    private void OnEntityDeath(ScarecrowNPC entity);
    private object CanBradleyApcTarget(BradleyAPC bradley, ScarecrowNPC scarecrow);
    private object CanBeTargeted(ScarecrowNPC scarecrow, NPCAutoTurret turret);
    private object OnNpcTarget(BaseEntity npc, BaseEntity entity);
    private object OnCorpsePopulate(ScarecrowNPC scarecrow, NPCPlayerCorpse corpse);
    static AIState GetAIState(AICustomState state);
    static AICustomState GetAICustomState(AIState state);
    static bool IsCustomState(AIState state);
    static void TraceLog(string format, int lineNumber, string caller);
    public void updateAllScarecrows(bool revert);
    private void UpdateScarecrowConfiguration(ScarecrowNPC entity, bool revert);
    public class AttackState : BaseAIBrain.BasicAIState
    {
        private IAIAttack attack;
         Chainsaw chainsaw;
        public AttackState();
        private static Vector3 GetAimDirection(Vector3 from, Vector3 target);
        private void StartAttacking(BaseEntity entity);
        public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
        public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
        public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
        private void StopAttacking();
    }

    private class RoamState : BaseAIBrain.BasicAIState
    {
        private StateStatus status;
        public RoamState();
        public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
        public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
        public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
    }

    private class ThrowGrenadeState : BaseAIBrain.BasicAIState
    {
         bool _isThrown;
         NPCPlayer _entity;
         BasePlayer _target;
         Item _grenade;
        const float _MAX_DISTANCE;
        const float _THROW_TIME;
        public ThrowGrenadeState();
        public override bool CanEnter();
        public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
        public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
        public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
    }

    public class FleeInhuman : BaseAIBrain.BasicAIState
    {
        private float nextInterval;
        private float stopFleeDistance;
        public FleeInhuman();
        private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity);
        public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
        public override bool CanLeave();
        public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
        public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
        private void Stop();
    }

    public class Awaken : BaseAIBrain.BasicAIState
    {
         BasePlayer[] players;
        public Awaken();
        public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
    }

}

public class ConVars
{
    [JsonProperty("OverrideConVars")]
    public bool OverrideConVars;
    [JsonProperty("ScarecrowPopulation")]
    public float ScarecrowPopulation;
    [JsonProperty("scarecrowsThrowBeancans")]
    public bool ScarecrowsThrowBeancans;
    [JsonProperty("scarecrowThrowBeancanGlobalDelay")]
    public float ScarecrowThrowBeancanGlobalDelay;
}

public class Sounds
{
    [JsonProperty("Death")]
    public string Death;
}

public class ScarecrowConfiguration
{
    [JsonProperty("Health")]
    public float Health;
    [JsonProperty("AttackRangeMultiplier")]
    public float AttackRangeMultiplier;
    [JsonProperty("TargetLostRange")]
    public float TargetLostRange;
    [JsonProperty("SenseRange")]
    public float SenseRange;
    [JsonProperty("WalkSpeedFraction")]
    public float WalkSpeed;
    [JsonProperty("RunSpeedFraction")]
    public float RunSpeed;
    [JsonProperty("IgnoreSafeZonePlayers")]
    public bool IgnoreSafeZonePlayers;
    [JsonProperty("CanBradleyAPCTargetScarecrow")]
    public bool CanBradleyAPCTargetScarecrow;
    [JsonProperty("CanNPCTurretsTargetScarecrow")]
    public bool CanNPCTurretsTargetScarecrow;
    [JsonProperty("CanNPCScientistsTargetScarecrow")]
    public bool CanNPCScientistsTargetScarecrow;
    [JsonProperty("CanScarecrowTargetNPCScientists")]
    public bool CanScarecrowTargetNPCScientists;
    [JsonProperty("CanNPCBanditGuardTargetScarecrow")]
    public bool CanNPCBanditGuardTargetScarecrow;
    [JsonProperty("CanScarecrowTargetNPCBanditGuard")]
    public bool CanScarecrowTargetNPCBanditGuard;
    [JsonProperty("DisableLoot")]
    public bool DisableLoot;
    [JsonProperty("UseCustomAI")]
    public bool UseCustomAI;
    public Sounds Sounds;
    [JsonProperty("ConVars")]
    public ConVars ConVars;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

public class AttackState : BaseAIBrain.BasicAIState
{
    private IAIAttack attack;
     Chainsaw chainsaw;
    public AttackState();
    private static Vector3 GetAimDirection(Vector3 from, Vector3 target);
    private void StartAttacking(BaseEntity entity);
    public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
    public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
    public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
    private void StopAttacking();
}

private class RoamState : BaseAIBrain.BasicAIState
{
    private StateStatus status;
    public RoamState();
    public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
    public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
    public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
}

private class ThrowGrenadeState : BaseAIBrain.BasicAIState
{
     bool _isThrown;
     NPCPlayer _entity;
     BasePlayer _target;
     Item _grenade;
    const float _MAX_DISTANCE;
    const float _THROW_TIME;
    public ThrowGrenadeState();
    public override bool CanEnter();
    public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
    public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
    public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
}

public class FleeInhuman : BaseAIBrain.BasicAIState
{
    private float nextInterval;
    private float stopFleeDistance;
    public FleeInhuman();
    private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity);
    public override void StateEnter(BaseAIBrain brain, BaseEntity entity);
    public override bool CanLeave();
    public override void StateLeave(BaseAIBrain brain, BaseEntity entity);
    public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
    private void Stop();
}

public class Awaken : BaseAIBrain.BasicAIState
{
     BasePlayer[] players;
    public Awaken();
    public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity);
}


```

---

## BetterTurretAim by WhiteThunder - Improves the speed at which auto turrets aim at their current target

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Better Turret Aim", "WhiteThunder", "1.0.2")]
[Description("Improves the speed at which auto turrets aim at their current target.")]
internal class BetterTurretAim : CovalencePlugin
{
    [PluginReference]
     Plugin ImprovedTurretAim;
    private static BetterTurretAim _pluginInstance;
    private const string PermissionUse;
    private Configuration _pluginConfig;
    private void Init();
    private void OnServerInitialized(bool initialBoot);
    private void Unload();
    private void OnEntitySpawned(AutoTurret autoTurret);
    private void OnGroupPermissionGranted(string group, string perm);
    private void OnGroupPermissionRevoked(string group, string perm);
    private void OnUserPermissionGranted(string userId, string perm);
    private void OnUserPermissionRevoked(string userId, string perm);
    private void InitializeAutoTurrets();
    private bool ImproveAimWasBlocked(AutoTurret autoTurret);
    private void OnUsagePermissionChanged(string userIdString);
    private void MaybeImproveAim(AutoTurret autoTurret);
    private BaseVehicle GetParentVehicle(BaseEntity entity);
    private void ImproveAiming(AutoTurret autoTurret);
    private void DestroyAimComponents();
    private class TurretAimImprover : FacepunchBehaviour
    {
        private AutoTurret Turret;
        private void Awake();
        private void MaybeUpdateAim();
    }

    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("RequirePermission")]
        public bool RequirePermission;
        [JsonProperty("OnlyVehicles")]
        public bool OnlyVehicles;
        [JsonProperty("UpdateIntervalSeconds")]
        public float UpdateIntervalSeconds;
        [JsonProperty("Interpolation")]
        public float Interpolation;
    }

    private Configuration GetDefaultConfig();
    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

private class TurretAimImprover : FacepunchBehaviour
{
    private AutoTurret Turret;
    private void Awake();
    private void MaybeUpdateAim();
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("RequirePermission")]
    public bool RequirePermission;
    [JsonProperty("OnlyVehicles")]
    public bool OnlyVehicles;
    [JsonProperty("UpdateIntervalSeconds")]
    public float UpdateIntervalSeconds;
    [JsonProperty("Interpolation")]
    public float Interpolation;
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## BGrade by Ryan - Auto update building blocks when placed

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using Rust;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Plugins.BGradeExt;

Oxide.Plugins
[Info("BGrade", "Ryan / Rustoria.co", "1.1.6")]
[Description("Auto update building blocks when placed")]
public class BGrade : RustPlugin
{
    public static BGrade Instance;
    private ListHashSet<string> _registeredPermissions;
    private Dictionary<Vector3, int> _lastAttacked;
    private bool ConfigChanged;
    private bool AllowTimer;
    private int MaxTimer;
    private int DefaultTimer;
    private bool CheckLastAttack;
    private int UpgradeCooldown;
    private List<string> ChatCommands;
    private List<string> ConsoleCommands;
    private bool RefundOnBlock;
    private bool DestroyOnDisconnect;
    protected override void LoadDefaultConfig();
    private void InitConfig();
    private T GetConfig(T defaultVal, string[] path);
    protected override void LoadDefaultMessages();
    private void RegisterPermissions();
    private void RegisterPermission(string permissionName);
    private void RegisterCommands();
    private void DestroyAll();
    private void DealWithHookResult(BasePlayer player, BuildingBlock buildingBlock, int hookResult, GameObject gameObject);
    private string TakeResources(BasePlayer player, int playerGrade, BuildingBlock buildingBlock, Dictionary<int, int> items);
    private void CheckLastAttacked();
    private bool WasAttackedRecently(Vector3 position);
    private class BGradePlayer : FacepunchBehaviour
    {
        public static Dictionary<BasePlayer, BGradePlayer> Players;
        private BasePlayer _player;
        private Timer _timer;
        private int _grade;
        private int _time;
        public void Awake();
        public int GetTime(bool updateTime);
        public void UpdateTime();
        public int GetGrade();
        public bool IsTimerValid { get; set; }
        private void SetTimer(Timer timer);
        public void SetGrade(int newGrade);
        public void SetTime(int newTime);
        public void DestroyTimer();
        public void Destroy();
        public void OnDestroy();
    }

    private void Init();
    private void OnServerSave();
    private void Unload();
    private void OnEntityBuilt(Planner plan, GameObject gameObject);
    private object OnPayForPlacement(BasePlayer player, Planner planner, Construction component);
    private void OnEntityDeath(BuildingBlock buildingBlock, HitInfo info);
    private void OnPlayerDisconnected(BasePlayer player);
    private void BGradeCommand(BasePlayer player, string command, string[] args);
    private void BGradeUpCommand(ConsoleSystem.Arg arg);
}

private class BGradePlayer : FacepunchBehaviour
{
    public static Dictionary<BasePlayer, BGradePlayer> Players;
    private BasePlayer _player;
    private Timer _timer;
    private int _grade;
    private int _time;
    public void Awake();
    public int GetTime(bool updateTime);
    public void UpdateTime();
    public int GetGrade();
    public bool IsTimerValid { get; set; }
    private void SetTimer(Timer timer);
    public void SetGrade(int newGrade);
    public void SetTime(int newTime);
    public void DestroyTimer();
    public void Destroy();
    public void OnDestroy();
}

Oxide.Plugins.BGradeExt
public static class BGradeExtensions
{
    private static readonly Permission permission;
    private static readonly Lang lang;
    public static bool HasAnyPermission(BasePlayer player, ListHashSet<string> perms);
    public static bool HasPermission(BasePlayer player, string perm);
    public static bool HasPluginPerm(BasePlayer player, string perm);
    public static string Lang(string key, string id, object[] args);
    public static bool HasItemAmount(BasePlayer player, int itemId, int itemAmount);
    public static bool HasItemAmount(BasePlayer player, int itemId, int itemAmount, int amountGot);
    public static void TakeItem(BasePlayer player, int itemId, int itemAmount);
}


```

---

## BigWheelSpawnFix by smallo - Fixes big wheels spawned faced down

```csharp
using UnityEngine;

Oxide.Plugins
[Info("Big Wheel Spawn Fix", "Orange and Smallo", "1.1.0")]
[Description("Fixes big wheels spawned faced down")]
public class BigWheelSpawnFix : RustPlugin
{
    private void Init();
    private void OnServerInitialized();
    private void OnEntitySpawned(BigWheelGame entity);
}


```

---

## BiomeChatPrefix by  - Adds a chat prefix when a player enters a certain biome

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Biome Chat Prefix", "Enforcer", "2.0.2")]
[Description("Adds a prefix when a player is in a certain biome")]
public class BiomeChatPrefix : RustPlugin
{
    [PluginReference]
     Plugin BetterChat;
    private List<JObject> groupList;
    private const string showPerm;
    private void OnServerInitialized();
     object OnPlayerChat(BasePlayer player, string message);
     Dictionary<string, object> OnBetterChat(Dictionary<string, object> data);
     string GetRegion(BasePlayer player, Vector3 Pos);
     ConfigData config;
    public class ConfigData
    {
        [JsonProperty(PropertyName = "Arid (Desert) Biome")]
        public AridRegionSettings aridRegionSettings { get; set; }
        [JsonProperty(PropertyName = "Temperate (Grass) Biome")]
        public TemperateRegionSettings temperateRegionSettings { get; set; }
        [JsonProperty(PropertyName = "Tundra (Forest) Biome")]
        public TundraRegionSettings tundraRegionSettings { get; set; }
        [JsonProperty(PropertyName = "Arctic (Snow) Biome")]
        public ArcticRegionSettings arcticRegionSettings { get; set; }
    }

    public class AridRegionSettings
    {
        [JsonProperty(PropertyName = "Enable arid biome")]
        public bool enableAridRegion { get; set; }
        [JsonProperty(PropertyName = "Use arid biome chat prefix")]
        public bool useAridRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Arid biome prefix")]
        public string aridRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Arid biome prefix/name colour")]
        public string aridChatPrefixColour { get; set; }
        [JsonProperty(PropertyName = "Arid biome Exclusions")]
        public Exclusions aridRegionExclusions { get; set; }
    }

    public class TemperateRegionSettings
    {
        [JsonProperty(PropertyName = "Enable temperate biome")]
        public bool enableTemperateRegion { get; set; }
        [JsonProperty(PropertyName = "Use temperate biome chat prefix")]
        public bool useTemperateRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Temperate biome prefix")]
        public string TemperateRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Temperate biome prefix/name colour")]
        public string temperateChatPrefixColour { get; set; }
        [JsonProperty(PropertyName = "Arctic Biome Exclusions")]
        public Exclusions temperateRegionExclusions { get; set; }
    }

    public class TundraRegionSettings
    {
        [JsonProperty(PropertyName = "Enable tundra biome")]
        public bool enableTundraRegion { get; set; }
        [JsonProperty(PropertyName = "Use tundra biome chat prefix")]
        public bool useTundraRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Tundra biome prefix")]
        public string TundraRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Tundra biome prefix/name colour")]
        public string TundraChatPrefixColour { get; set; }
        [JsonProperty(PropertyName = "Tundra Biome Exclusions")]
        public Exclusions tundraRegionExclusions { get; set; }
    }

    public class ArcticRegionSettings
    {
        [JsonProperty(PropertyName = "Enable arctic biome")]
        public bool enableArcticRegion { get; set; }
        [JsonProperty(PropertyName = "Use arctic biome chat prefix")]
        public bool useArcticRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Arctic biome prefix")]
        public string arcticRegionPrefix { get; set; }
        [JsonProperty(PropertyName = "Arctic biome prefix/name colour")]
        public string arcticChatPrefixColour { get; set; }
        [JsonProperty(PropertyName = "Arctic Biome Exclusions")]
        public Exclusions arcticRegionExclusions { get; set; }
    }

    public class Exclusions
    {
        [JsonProperty(PropertyName = "Add prefix to admins")]
        public bool addPrefixToAdmins { get; set; }
        [JsonProperty(PropertyName = "Add prefix to moderators")]
        public bool addPrefixToModerators { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class ConfigData
{
    [JsonProperty(PropertyName = "Arid (Desert) Biome")]
    public AridRegionSettings aridRegionSettings { get; set; }
    [JsonProperty(PropertyName = "Temperate (Grass) Biome")]
    public TemperateRegionSettings temperateRegionSettings { get; set; }
    [JsonProperty(PropertyName = "Tundra (Forest) Biome")]
    public TundraRegionSettings tundraRegionSettings { get; set; }
    [JsonProperty(PropertyName = "Arctic (Snow) Biome")]
    public ArcticRegionSettings arcticRegionSettings { get; set; }
}

public class AridRegionSettings
{
    [JsonProperty(PropertyName = "Enable arid biome")]
    public bool enableAridRegion { get; set; }
    [JsonProperty(PropertyName = "Use arid biome chat prefix")]
    public bool useAridRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Arid biome prefix")]
    public string aridRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Arid biome prefix/name colour")]
    public string aridChatPrefixColour { get; set; }
    [JsonProperty(PropertyName = "Arid biome Exclusions")]
    public Exclusions aridRegionExclusions { get; set; }
}

public class TemperateRegionSettings
{
    [JsonProperty(PropertyName = "Enable temperate biome")]
    public bool enableTemperateRegion { get; set; }
    [JsonProperty(PropertyName = "Use temperate biome chat prefix")]
    public bool useTemperateRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Temperate biome prefix")]
    public string TemperateRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Temperate biome prefix/name colour")]
    public string temperateChatPrefixColour { get; set; }
    [JsonProperty(PropertyName = "Arctic Biome Exclusions")]
    public Exclusions temperateRegionExclusions { get; set; }
}

public class TundraRegionSettings
{
    [JsonProperty(PropertyName = "Enable tundra biome")]
    public bool enableTundraRegion { get; set; }
    [JsonProperty(PropertyName = "Use tundra biome chat prefix")]
    public bool useTundraRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Tundra biome prefix")]
    public string TundraRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Tundra biome prefix/name colour")]
    public string TundraChatPrefixColour { get; set; }
    [JsonProperty(PropertyName = "Tundra Biome Exclusions")]
    public Exclusions tundraRegionExclusions { get; set; }
}

public class ArcticRegionSettings
{
    [JsonProperty(PropertyName = "Enable arctic biome")]
    public bool enableArcticRegion { get; set; }
    [JsonProperty(PropertyName = "Use arctic biome chat prefix")]
    public bool useArcticRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Arctic biome prefix")]
    public string arcticRegionPrefix { get; set; }
    [JsonProperty(PropertyName = "Arctic biome prefix/name colour")]
    public string arcticChatPrefixColour { get; set; }
    [JsonProperty(PropertyName = "Arctic Biome Exclusions")]
    public Exclusions arcticRegionExclusions { get; set; }
}

public class Exclusions
{
    [JsonProperty(PropertyName = "Add prefix to admins")]
    public bool addPrefixToAdmins { get; set; }
    [JsonProperty(PropertyName = "Add prefix to moderators")]
    public bool addPrefixToModerators { get; set; }
}


```

---

## BlindDeath by  - Hide the killer on death screen

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

Oxide.Plugins
[Info("Blind Death", "UNKNOWN", "0.0.1")]
[Description("Hide Killer DeathScreen")]
public class BlindDeath : RustPlugin
{
     string BlindContainer;
    private void OnEntityDeath(BasePlayer player);
    private void OnPlayerRespawn(BasePlayer player);
    private void BlindUI(BasePlayer player);
     void Unload();
    private Configuration _config;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class Configuration
    {
        [JsonProperty("UI DestoryTime")]
        public float UI_DestoryTime { get; set; }
        [JsonProperty("UI AnchorMin")]
        public string UI_AnchorMin { get; set; }
        [JsonProperty("UI AnchorMax")]
        public string UI_AnchorMax { get; set; }
        [JsonProperty("UI Color")]
        public string UI_Color { get; set; }
    }

}

private class Configuration
{
    [JsonProperty("UI DestoryTime")]
    public float UI_DestoryTime { get; set; }
    [JsonProperty("UI AnchorMin")]
    public string UI_AnchorMin { get; set; }
    [JsonProperty("UI AnchorMax")]
    public string UI_AnchorMax { get; set; }
    [JsonProperty("UI Color")]
    public string UI_Color { get; set; }
}


```

---

## BlockBoxPlacement by  - Checking if player can upgrade building block and no objects is under

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

Oxide.Plugins
[Info("BlockBoxPlacement", "wazzzup", "0.0.3", ResourceId = 2312)]
[Description("Blocks box and oven placement under foundations")]
public class BlockBoxPlacement : RustPlugin
{
    private object CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum iGrade);
}


```

---

## BlockBugPrevent by sami37 - Prevent foundation block build on another foundation

```csharp
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("BlockBugPrevent", "sami37", "1.1.1", ResourceId = 2166)]
[Description("Prevent foundation block build on another foundation.")]
public class BlockBugPrevent : RustPlugin
{
     void Loaded();
    private object RaycastAll(Ray ray);
     void OnEntityBuilt(Planner planner, GameObject gameObject);
}


```

---

## BlockRemover by austinv900 - Allows admins to count and remove building blocks outside of cupboard range

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Block Remover", "austinv900", "0.4.55")]
[Description("Allows admins to count and remove building blocks outside of cupboard range")]
 class BlockRemover : RustPlugin
{
    private ConfigData configData;
    private const string PermCount;
    private const string PermRemove;
     class ConfigData
    {
        public bool WarnPlayers { get; set; }
        public VersionNumber Version { get; set; }
    }

    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
     void OnServerInitialized();
    [ConsoleCommand("block.countall")]
     void cmdCountBlockAll(ConsoleSystem.Arg arg);
    [ConsoleCommand("block.count")]
     void cmdCountBlock(ConsoleSystem.Arg arg);
    [ConsoleCommand("block.remove")]
     void cmdRemoveBlock(ConsoleSystem.Arg arg);
    [ConsoleCommand("block.removeall")]
     void cmdRemoveBlockAll(ConsoleSystem.Arg arg);
     List<BuildingBlock> FindAllCupboardlessBlocks(BuildingGrade.Enum grade, StringBuilder reply);
     List<StabilityEntity> FindAllCupboardlessStabilityEntities(StringBuilder reply);
     void FilterAllCupboardless(List<T> blocks, StringBuilder reply);
     List<BuildingBlock> FindAllBuildingBlocks(BuildingGrade.Enum grade, StringBuilder reply);
     List<StabilityEntity> FindAllStabilityEntities(StringBuilder reply);
     bool CheckAccess(ConsoleSystem.Arg arg, string perm);
     bool ParseGrade(ConsoleSystem.Arg arg, BuildingGrade.Enum grade);
     void WarnOnlineMembers(string langKey, Dictionary<string, string> args);
     string GetMessage(string key, ulong id);
    private IEnumerator ProcessRemoval(List<T> blocks, Action<List<T>> onFinish);
}

 class ConfigData
{
    public bool WarnPlayers { get; set; }
    public VersionNumber Version { get; set; }
}


```

---

## BlockStructure by  - Building blocks in the rocks, terrain and icebergs. Sets a limit build in height and depth in water.

```csharp
using System.Collections.Generic;
using UnityEngine;
using System;

Oxide.Plugins
[Info("BlockStructure", "Marat", "1.0.4", ResourceId = 2092)]
[Description("Building blocks in the rocks, terrain and icebergs. Sets a limit build in height and depth in water.")]
 class BlockStructure : RustPlugin
{
     void Loaded();
     double HeightBlock;
     double WaterBlock;
     int AuthLvl;
     bool ConfigChanged;
     bool usePermissions;
     bool BlockInHeight;
     bool BlockInWater;
     bool BlockInRock;
     bool BlockOnIceberg;
     bool BlockUnTerrain;
     string permBS;
    protected override void LoadDefaultConfig();
     void LoadConfiguration();
     T GetConfigValue(string category, string setting, T defaultValue);
     void LoadDefaultMessages();
     void Block(BaseNetworkable block, BasePlayer player, bool Height, bool Water);
     string Lang(string key, string id, object[] args);
     void Reply(BasePlayer player, string message, string args);
     void OnEntityBuilt(Planner plan, GameObject obj);
     bool IsAllowed(string id, string perm);
}


```

---

## BlockUsers by ViolationHandler - Blocking Users system and API managing blocked users/list of blocked users

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("BlockUsers", "ViolationHandler", "1.0.5")]
[Description("A system and API for managing blocked users lists")]
internal class BlockUsers : CovalencePlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("Blocked Users list cache time (0 to disable)")]
        public int CacheTime;
        [JsonProperty("Maximum number of blocked users (0 to disable)")]
        public int MaxBlockedUsers;
        [JsonProperty("Cooldown for block command in seconds (00:00:00 to disable)")]
        public TimeSpan BlockDelay;
        [JsonProperty("Use permission system")]
        public bool UsePermissions;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private readonly Dictionary<string, HashSet<string>> reverseData;
    private Dictionary<string, PlayerData> blockedData;
    private static readonly DateTime Epoch;
    private class PlayerData
    {
        public string Name { get; set; }
        public HashSet<string> BlockedUsers { get; set; }
        public Dictionary<string, int> Cached { get; set; }
        public Dictionary<string, DateTime> LastCalled { get; set; }
        public bool IsCached(string playerId);
    }

    private void SaveData();
    protected override void LoadDefaultMessages();
    private const string permUse;
    private void Init();
    private bool AddBlockedUser(string playerId, string blockedId);
    private bool AddBlockedUser(ulong playerId, ulong blockedId);
    private void AddBlockedUserReverse(string playerId, string blockedId);
    private bool RemoveBlockedUser(string playerId, string blockedId);
    private bool RemoveBlockedUser(ulong playerId, ulong blockedId);
    private bool HasBlockedUser(string playerId, string blockedUserId);
    private bool HasBlockedUser(ulong playerId, ulong blockedUserId);
    private bool HadBlockedUser(string playerId, string blockedUserId);
    private bool HadBlockedUser(ulong playerId, ulong blockedUserId);
    private bool AreBlockedUsers(string playerId, string blockedUserId);
    private bool AreBlockedUsers(ulong playerId, ulong blockedUserId);
    private bool WereBlockedUsers(string playerId, string blockedUserId);
    private bool WereBlockedUsers(ulong playerId, ulong blockedUserId);
    private bool IsBlockedUser(string playerId, string blockedUserId);
    private bool IsBlockedUser(ulong playerId, ulong blockedUserId);
    private bool WasBlockedUser(string playerId, string blockedUserId);
    private bool WasBlockedUser(ulong playerId, ulong blockedUserId);
    private int GetMaxBlockedUsers();
    private string[] GetBlockedUsers(string playerId);
    private ulong[] GetBlockedUsers(ulong playerId);
    private string[] GetBlockedUsersList(string playerId);
    private string[] GetBlockedUsersList(ulong playerId);
    private string[] IsBlockedUsersOf(string playerId);
    private ulong[] IsBlockedUsersOf(ulong playerId);
    private void CommandBlock(IPlayer player, string command, string[] args);
    private void SendHelpText(object obj);
    private string FindBlockedUser(string nameOrId);
    private PlayerData GetPlayerData(string playerId);
    private IPlayer FindPlayer(string playerNameOrId, IPlayer player);
    private void AddLocalizedCommand(string command);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string textOrLang, object[] args);
}

public class Configuration
{
    [JsonProperty("Blocked Users list cache time (0 to disable)")]
    public int CacheTime;
    [JsonProperty("Maximum number of blocked users (0 to disable)")]
    public int MaxBlockedUsers;
    [JsonProperty("Cooldown for block command in seconds (00:00:00 to disable)")]
    public TimeSpan BlockDelay;
    [JsonProperty("Use permission system")]
    public bool UsePermissions;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class PlayerData
{
    public string Name { get; set; }
    public HashSet<string> BlockedUsers { get; set; }
    public Dictionary<string, int> Cached { get; set; }
    public Dictionary<string, DateTime> LastCalled { get; set; }
    public bool IsCached(string playerId);
}


```

---

## BlockVehiclePush by Clearshot - Block players from pushing vehicles if any player sitting in the vehicle is not associated with them

```csharp
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Block Vehicle Push", "Clearshot", "1.1.0")]
[Description("Block players from pushing vehicles under certain conditions")]
 class BlockVehiclePush : CovalencePlugin
{
    private PluginConfig _config;
    private Game.Rust.Libraries.Player _rustPlayer;
    private void SendChatMsg(BasePlayer pl, string msg, string prefix);
    [PluginReference]
    private Plugin Clans;
    private Plugin Friends;
    private object OnVehiclePush(BaseVehicle vehicle, BasePlayer pl);
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadConfig();
    private class PluginConfig
    {
        public string chatIconID;
        public bool requireBuildingPrivilegeToPush;
        public bool allowClanMemberOrAllyToPush;
        public bool allowFriendsToPush;
        public bool chatMessage;
    }

}

private class PluginConfig
{
    public string chatIconID;
    public bool requireBuildingPrivilegeToPush;
    public bool allowClanMemberOrAllyToPush;
    public bool allowFriendsToPush;
    public bool chatMessage;
}


```

---

## BloodBags by VisEntities - Craft and use blood bags to restore health, stop bleeding, boost hydration, and more

```csharp
using Network;
using Newtonsoft.Json;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Blood Bags", "VisEntities", "2.3.0")]
[Description("Craft and use blood bags to restore health, stop bleeding, boost hydration, and more.")]
public class BloodBags : RustPlugin
{
    private static BloodBags _plugin;
    private static Configuration _config;
    private BloodUsageListenerManager _manager;
    private List<Timer> _activeCraftingTimers;
    private const int ITEM_ID_BLOOD;
    private const string ITEM_SHORTNAME_BLOOD;
    private const string FX_DRINK;
    private const string FX_TAKE_DAMAGE;
    private class Configuration
    {
        [JsonProperty("Version")]
        public string Version { get; set; }
        [JsonProperty("Instant Health Increase")]
        public float InstantHealthIncrease { get; set; }
        [JsonProperty("Health Increase Over Time")]
        public float HealthIncreaseOverTime { get; set; }
        [JsonProperty("Calorie Boost")]
        public float CalorieBoost { get; set; }
        [JsonProperty("Hydration Boost")]
        public float HydrationBoost { get; set; }
        [JsonProperty("Stop Bleeding")]
        public bool StopBleeding { get; set; }
        [JsonProperty("Temperature Target")]
        public float TemperatureTarget { get; set; }
        [JsonProperty("Radiation Poisoning Reduction")]
        public float RadiationPoisoningReduction { get; set; }
        [JsonProperty("Amount To Consume")]
        public int AmountToConsume { get; set; }
        [JsonProperty("Crafting")]
        public CraftingConfig Crafting { get; set; }
    }

    private class CraftingConfig
    {
        [JsonProperty("Command")]
        public string Command { get; set; }
        [JsonProperty("Workbench Level Required")]
        public float WorkbenchLevelRequired { get; set; }
        [JsonProperty("Health Sacrifice Amount")]
        public float HealthSacrificeAmount { get; set; }
        [JsonProperty("Crafting Time Seconds")]
        public float CraftingTimeSeconds { get; set; }
        [JsonProperty("Crafting Amount")]
        public int CraftingAmount { get; set; }
        [JsonProperty("Ingredients")]
        public List<ItemInfo> Ingredients { get; set; }
    }

    public class ItemInfo
    {
        [JsonProperty("Shortname")]
        public string Shortname { get; set; }
        [JsonProperty("Amount")]
        public int Amount { get; set; }
        [JsonIgnore]
        private bool _validated;
        [JsonIgnore]
        private ItemDefinition _itemDefinition;
        [JsonIgnore]
        public ItemDefinition ItemDefinition { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private Configuration GetDefaultConfig();
    private void Init();
    private void Unload();
    private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem);
    public class BloodUsageListenerManager
    {
        private Dictionary<BasePlayer, BloodUsageListenerComponent> _bloodUsageListeners;
        public bool AddBloodUsageListener(BasePlayer player, Item bloodItem);
        public void HandleBloodUsageListenerDestroyed(BasePlayer player);
        public void Unload();
        public void DestroyBloodUsageListener(BasePlayer player);
        public BloodUsageListenerComponent GetBloodUsageListener(BasePlayer player);
        public bool BloodUsageListenerCurrentlyActive(BasePlayer player);
    }

    public class BloodUsageListenerComponent : FacepunchBehaviour
    {
        public BasePlayer Player { get; set; }
        private BloodUsageListenerManager _manager;
        private InputState _playerInput;
        private Item _bloodItem;
        private bool _useButtonPressed;
        public static BloodUsageListenerComponent InstallComponent(BasePlayer player, BloodUsageListenerManager manager, Item bloodItem);
        public BloodUsageListenerComponent InitializeComponent(BloodUsageListenerManager manager, Item bloodItem);
        public static BloodUsageListenerComponent GetComponent(BasePlayer player);
        public void DestroyComponent();
        private void Update();
        private void OnDestroy();
        private void ConsumeBlood();
    }

    private static class PermissionUtil
    {
        public const string USE;
        public static void RegisterPermissions();
        public static bool VerifyHasPermission(BasePlayer player, string permissionName);
    }

    private void SendGameTip(BasePlayer player, string message, float durationSeconds, object[] args);
    private static void RunEffect(string prefab, BaseEntity entity, uint boneId, Vector3 localPosition, Vector3 localDirection, Connection effectRecipient, bool sendToAll);
    public static int GetItemAmount(int itemId, ItemContainer container);
    public static void GiveItem(BasePlayer player, int itemId, int amount, ItemContainer container);
    public static int TakeItem(BasePlayer player, int itemId, int amount, ItemContainer container);
    private void cmdCraftBloodBag(BasePlayer player, string command, string[] args);
    private class Lang
    {
        public const string NoPermission;
        public const string NeedWorkbench;
        public const string NotEnoughIngredient;
        public const string CraftingStart;
        public const string NotEnoughBloodBags;
        public const string InsufficientHealth;
        public const string UseInstruction;
        public const string CraftingCountdown;
    }

    protected override void LoadDefaultMessages();
    private void SendReplyToPlayer(BasePlayer player, string messageKey, object[] args);
}

private class Configuration
{
    [JsonProperty("Version")]
    public string Version { get; set; }
    [JsonProperty("Instant Health Increase")]
    public float InstantHealthIncrease { get; set; }
    [JsonProperty("Health Increase Over Time")]
    public float HealthIncreaseOverTime { get; set; }
    [JsonProperty("Calorie Boost")]
    public float CalorieBoost { get; set; }
    [JsonProperty("Hydration Boost")]
    public float HydrationBoost { get; set; }
    [JsonProperty("Stop Bleeding")]
    public bool StopBleeding { get; set; }
    [JsonProperty("Temperature Target")]
    public float TemperatureTarget { get; set; }
    [JsonProperty("Radiation Poisoning Reduction")]
    public float RadiationPoisoningReduction { get; set; }
    [JsonProperty("Amount To Consume")]
    public int AmountToConsume { get; set; }
    [JsonProperty("Crafting")]
    public CraftingConfig Crafting { get; set; }
}

private class CraftingConfig
{
    [JsonProperty("Command")]
    public string Command { get; set; }
    [JsonProperty("Workbench Level Required")]
    public float WorkbenchLevelRequired { get; set; }
    [JsonProperty("Health Sacrifice Amount")]
    public float HealthSacrificeAmount { get; set; }
    [JsonProperty("Crafting Time Seconds")]
    public float CraftingTimeSeconds { get; set; }
    [JsonProperty("Crafting Amount")]
    public int CraftingAmount { get; set; }
    [JsonProperty("Ingredients")]
    public List<ItemInfo> Ingredients { get; set; }
}

public class ItemInfo
{
    [JsonProperty("Shortname")]
    public string Shortname { get; set; }
    [JsonProperty("Amount")]
    public int Amount { get; set; }
    [JsonIgnore]
    private bool _validated;
    [JsonIgnore]
    private ItemDefinition _itemDefinition;
    [JsonIgnore]
    public ItemDefinition ItemDefinition { get; set; }
}

public class BloodUsageListenerManager
{
    private Dictionary<BasePlayer, BloodUsageListenerComponent> _bloodUsageListeners;
    public bool AddBloodUsageListener(BasePlayer player, Item bloodItem);
    public void HandleBloodUsageListenerDestroyed(BasePlayer player);
    public void Unload();
    public void DestroyBloodUsageListener(BasePlayer player);
    public BloodUsageListenerComponent GetBloodUsageListener(BasePlayer player);
    public bool BloodUsageListenerCurrentlyActive(BasePlayer player);
}

public class BloodUsageListenerComponent : FacepunchBehaviour
{
    public BasePlayer Player { get; set; }
    private BloodUsageListenerManager _manager;
    private InputState _playerInput;
    private Item _bloodItem;
    private bool _useButtonPressed;
    public static BloodUsageListenerComponent InstallComponent(BasePlayer player, BloodUsageListenerManager manager, Item bloodItem);
    public BloodUsageListenerComponent InitializeComponent(BloodUsageListenerManager manager, Item bloodItem);
    public static BloodUsageListenerComponent GetComponent(BasePlayer player);
    public void DestroyComponent();
    private void Update();
    private void OnDestroy();
    private void ConsumeBlood();
}

private static class PermissionUtil
{
    public const string USE;
    public static void RegisterPermissions();
    public static bool VerifyHasPermission(BasePlayer player, string permissionName);
}

private class Lang
{
    public const string NoPermission;
    public const string NeedWorkbench;
    public const string NotEnoughIngredient;
    public const string CraftingStart;
    public const string NotEnoughBloodBags;
    public const string InsufficientHealth;
    public const string UseInstruction;
    public const string CraftingCountdown;
}


```

---

## BloodTrail by MrBlue - Leaves a trail of blood behind players while bleeding

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Blood Trail", "hoppel", "2.0.0")]
[Description("Leaves a trail of blood behind players while bleeding")]
public class BloodTrail : CovalencePlugin
{
    private static Configuration config;
    public class Configuration
    {
        [JsonProperty("Blood trail refresh time")]
        public float RefreshTime;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private static BloodTrail instance;
    private const string permAllow;
    private const string permBypass;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    public class Blood : MonoBehaviour
    {
        private BasePlayer player;
        private Vector3 position;
        private void Awake();
        private void Track();
        private void OnDestroy();
    }

    private bool HasPermission(BasePlayer player);
}

public class Configuration
{
    [JsonProperty("Blood trail refresh time")]
    public float RefreshTime;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

public class Blood : MonoBehaviour
{
    private BasePlayer player;
    private Vector3 position;
    private void Awake();
    private void Track();
    private void OnDestroy();
}


```

---

## BlueprintManager by Whispers88 - Manage blueprints on your server easily

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Facepunch;

Oxide.Plugins
[Info("Blueprint Manager", "Whispers88", "2.1.3")]
[Description("Allows you to manage and modify blueprints")]
public class BlueprintManager : RustPlugin
{
    private Configuration config;
    private static Dictionary<int, BlueprintData> defaultsetup;
    public class BlueprintData
    {
        public bool defaultBP;
        public bool canResearch;
        public int scrapRequired;
        public int unlockMinutesAfterWipe;
        public bool autoUnlockMinutesAfterWipe;
        public BlueprintData();
    }

    public class Configuration
    {
        [JsonProperty("Simple Mode (disables advance blueprint management options)")]
        public bool SimpleMode;
        [JsonProperty("Update players on permission change (automatically updates a players BPs when their permissions change)")]
        public bool updateBPs;
        [JsonProperty("Wipe BPs with Map Wipe")]
        public bool wipeOnMap;
        [JsonProperty("Blacklist (items from being automatically learnt)")]
        public List<string> Blacklist;
        [JsonProperty("DefaultBPs (Blueprints to be automatically learnt)")]
        public List<string> DefaultBPs;
        [JsonProperty("Assign custom BP unlocks to various perms (permission, BP List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, List<string>> BonusBPs;
        [JsonProperty("Advanced Blueprint Management Options")]
        public Dictionary<string, BlueprintData> BlueprintOptions;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private const string permunlockall;
    private const string permadmin;
    private DateTime _lastWipe;
    private Coroutine unlockAfterWipeCoroutine;
    private Coroutine updateAllPlayers;
    private List<string> _permissions;
    private List<int> _blacklist;
    private List<int> _defaultBlueprints;
    private Dictionary<string, List<int>> _permissionBPs;
    private Dictionary<ItemBlueprint, int> _unlockAfterWipe;
    private List<string> commands;
    private void OnServerInitialized();
    private IEnumerator UpdateAllPlayers();
     IEnumerator UnlockAfterWipe();
    private void Unload();
    protected override void LoadDefaultMessages();
    private void CMDBPReset(IPlayer iplayer, string command, string[] args);
    private void CMDUnlockAll(IPlayer iplayer, string command, string[] args);
    private void CMDUnlock(IPlayer iplayer, string command, string[] args);
    private void CMDBPRemove(IPlayer iplayer, string command, string[] args);
    private void CMDWipeAll(IPlayer iplayer, string command, string[] args);
    private void WipeAllBps();
    private void WipeBPs(BasePlayer player);
    private void RemoveBPs(BasePlayer player, List<int> bps);
    private void UnlockBPs(BasePlayer player, List<int> bps);
    private void UnlockAllBPs(BasePlayer player);
    private void UpdatePlayerBPs(BasePlayer player, bool defaultOnly);
     void OnNewSave(string filename);
     object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree);
    private void OnUserPermissionGranted(string userId, string perm);
    private void OnUserGroupAdded(string userId, string groupname);
    private void OnPlayerConnected(BasePlayer player);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string langKey, object[] args);
    private bool HasPerm(string id, string perm);
    private void AddLocalizedCommand(string command);
}

public class BlueprintData
{
    public bool defaultBP;
    public bool canResearch;
    public int scrapRequired;
    public int unlockMinutesAfterWipe;
    public bool autoUnlockMinutesAfterWipe;
    public BlueprintData();
}

public class Configuration
{
    [JsonProperty("Simple Mode (disables advance blueprint management options)")]
    public bool SimpleMode;
    [JsonProperty("Update players on permission change (automatically updates a players BPs when their permissions change)")]
    public bool updateBPs;
    [JsonProperty("Wipe BPs with Map Wipe")]
    public bool wipeOnMap;
    [JsonProperty("Blacklist (items from being automatically learnt)")]
    public List<string> Blacklist;
    [JsonProperty("DefaultBPs (Blueprints to be automatically learnt)")]
    public List<string> DefaultBPs;
    [JsonProperty("Assign custom BP unlocks to various perms (permission, BP List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, List<string>> BonusBPs;
    [JsonProperty("Advanced Blueprint Management Options")]
    public Dictionary<string, BlueprintData> BlueprintOptions;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## BlueprintShare by NomadWarrior - Allows players to share blueprints with their clan, team or friends.

```csharp
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Blueprint Share", "c_creep", "1.4.1")]
[Description("Allows players to share researched blueprints with their friends, clan or team")]
 class BlueprintShare : RustPlugin
{
    [PluginReference]
    private Plugin Clans;
    private Plugin Friends;
    private StoredData storedData;
    private const string usePermission;
    private const string togglePermission;
    private const string sharePermission;
    private const string showPermission;
    private const string bypassPermission;
    private void Init();
    private void OnNewSave(string filename);
    private void OnPlayerConnected(BasePlayer player);
    private void OnItemAction(Item item, string action, BasePlayer player);
    private void OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player);
    private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player);
    private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player);
    private void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target);
    private bool HasFriends(ulong playerId);
    private List<ulong> GetFriends(ulong playerId);
    private bool AreFriends(ulong playerId, ulong targetId);
    private bool InClan(ulong playerId);
    private List<ulong> GetClanMembers(ulong playerId);
    private bool SameClan(ulong playerId, ulong targetId);
    private bool InTeam(ulong playerId);
    private List<ulong> GetTeamMembers(ulong playerId);
    private bool SameTeam(ulong playerId, ulong targetId);
    private void OnFriendAdded(string playerId, string friendId);
    private void OnFriendRemoved(string playerId, string friendId);
    private void OnClanMemberJoined(ulong playerId, string clanName);
    private void OnClanMemberGone(ulong playerId, string tag);
    private bool TryShareBlueprint(ItemDefinition item, BasePlayer player);
    private bool HasSocialConnections(ulong playerId);
    private void ShareAdditionalBlueprints(BasePlayer player, ItemDefinition item);
    private bool UnlockBlueprint(BasePlayer player, BasePlayer sharer, int blueprint);
    private int UnlockBlueprints(BasePlayer player, BasePlayer sharer, List<int> blueprints);
    private void ShareWithPlayers(BasePlayer player, ItemDefinition item);
    private void ShareWithPlayer(BasePlayer player, BasePlayer target);
    private List<int> RemoveBlockedBlueprints(List<int> blueprints);
    private bool SomeoneWillLearnBlueprint(ulong playerId, ItemDefinition item);
    private List<BasePlayer> GetPlayersToShareWith(ulong playerId);
    private void AddBlueprintToDatabase(ulong playerId, ulong sharerId, int blueprint);
    private void RemoveBlueprintsFromDatabase(ShareType type, string playerId, string friendId);
    private void RemoveBlueprints(BasePlayer player, List<int> blueprints, ShareType type, string friendId);
    private void PlayerLeftTeam(BasePlayer player);
    private void PlaySoundEffect(BasePlayer player);
    private List<BasePlayer> FindPlayersFromIds(List<ulong> ids, ulong playerId);
    private bool BlueprintBlocked(ItemDefinition item);
    private HashSet<int> GetSharedBlueprints(string playerId, ShareType type, string friendId);
    private void SortBlueprintsByWorkbenchLevel(HashSet<int> learntBlueprints, Dictionary<int, List<string>> workbenchTiers);
    private void DisplayLearntBlueprints(BasePlayer player, ShareType type, string friendId);
    private int GetWorkbenchTierForBlueprint(int itemId);
    [ChatCommand("bs")]
    private void ChatCommands(BasePlayer player, string command, string[] args);
    private void ToggleCommand(BasePlayer player, string playerId);
    private void ShareCommand(BasePlayer player, string playerId, string[] args);
    private void ShowCommand(BasePlayer player, string playerId, string[] args);
    private Configuration config;
    private class Configuration
    {
        [JsonProperty("Teams Sharing Enabled")]
        public bool TeamsEnabled;
        [JsonProperty("Clans Sharing Enabled")]
        public bool ClansEnabled;
        [JsonProperty("Friends Sharing Enabled")]
        public bool FriendsEnabled;
        [JsonProperty("Share Blueprint Items")]
        public bool PhysicalSharingEnabled;
        [JsonProperty("Share Tech Tree Blueprints")]
        public bool TechTreeSharingEnabled;
        [JsonProperty("Share Blueprints on Join")]
        public bool ShareBlueprintsOnJoin;
        [JsonProperty("Share Blueprints with New Member or Friend")]
        public bool ShareBlueprintsWithNewMember;
        [JsonProperty("Lose Blueprints on Leave")]
        public bool LoseBlueprintsOnLeave;
        [JsonProperty("Clear Data File on Wipe")]
        public bool ClearDataOnWipe;
        [JsonProperty("Receive Messages Enabled")]
        public bool ReceiveMessagesEnabled;
        [JsonProperty("Share Messages Enabled")]
        public bool ShareMessagesEnabled;
        [JsonProperty("Items Blocked from Sharing")]
        public List<string> BlockedItems;
    }

    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadConfig();
    private class StoredData
    {
        public Dictionary<string, PlayerData> Players;
    }

    private class PlayerData
    {
        public bool SharingEnabled;
        public ShareData LearntBlueprints;
    }

    private class ShareData
    {
        public List<int> Team;
        public List<int> Clan;
        public Dictionary<string, List<int>> Friends;
    }

    private void AddClanShare(string playerId, int blueprint);
    private void AddTeamShare(string playerId, int blueprint);
    private void AddFriendShare(string playerId, string friendId, int blueprint);
    private void RemoveClanShare(string playerId);
    private void RemoveTeamShare(string playerId);
    private void RemoveFriendShare(string playerId, string friendId);
    private List<int> GetClanBlueprints(string playerId);
    private List<int> GetTeamBlueprints(string playerId);
    private List<int> GetFriendBlueprints(string playerId, string friendId);
    private void CreateData();
    private void LoadData();
    private void SaveData();
    private void EnsureDataFileExists();
    private void EnsurePlayerDataExists(string playerId);
    private void CreatePlayerData(string playerId);
    protected override void LoadDefaultMessages();
    private string GetLangValue(string key, string id, object[] args);
    private void SendMessage(string key, BasePlayer player, bool prefix, object[] args);
    private bool SharingEnabled(string playerId);
}

private class Configuration
{
    [JsonProperty("Teams Sharing Enabled")]
    public bool TeamsEnabled;
    [JsonProperty("Clans Sharing Enabled")]
    public bool ClansEnabled;
    [JsonProperty("Friends Sharing Enabled")]
    public bool FriendsEnabled;
    [JsonProperty("Share Blueprint Items")]
    public bool PhysicalSharingEnabled;
    [JsonProperty("Share Tech Tree Blueprints")]
    public bool TechTreeSharingEnabled;
    [JsonProperty("Share Blueprints on Join")]
    public bool ShareBlueprintsOnJoin;
    [JsonProperty("Share Blueprints with New Member or Friend")]
    public bool ShareBlueprintsWithNewMember;
    [JsonProperty("Lose Blueprints on Leave")]
    public bool LoseBlueprintsOnLeave;
    [JsonProperty("Clear Data File on Wipe")]
    public bool ClearDataOnWipe;
    [JsonProperty("Receive Messages Enabled")]
    public bool ReceiveMessagesEnabled;
    [JsonProperty("Share Messages Enabled")]
    public bool ShareMessagesEnabled;
    [JsonProperty("Items Blocked from Sharing")]
    public List<string> BlockedItems;
}

private class StoredData
{
    public Dictionary<string, PlayerData> Players;
}

private class PlayerData
{
    public bool SharingEnabled;
    public ShareData LearntBlueprints;
}

private class ShareData
{
    public List<int> Team;
    public List<int> Clan;
    public Dictionary<string, List<int>> Friends;
}


```

---

## BodiesToBags by Ryan - Turns bodies to bags in a configurable time

```csharp
using System.Linq;

Oxide.Plugins
[Info("Bodies to Bags", "Ryan", "2.0.0")]
[Description("Modifies the time it takes for bodies to become bags")]
public class BodiesToBags : RustPlugin
{
    private bool ConfigChanged;
    private int _despawnTime;
    protected override void LoadDefaultConfig();
    private void InitConfig();
    private T GetConfig(T defaultVal, string[] path);
    private void Init();
    private void OnEntitySpawned(LootableCorpse corpse);
    private void OnLootEntityEnd(BasePlayer player, PlayerCorpse corpse);
}


```

---

## BombTrucks by WhiteThunder - Allow players to spawn bomb trucks which can be detonated by RF frequency

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust.Modular;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Bomb Trucks", "WhiteThunder", "0.9.0")]
[Description("Allow players to spawn bomb trucks.")]
internal class BombTrucks : CovalencePlugin
{
    [PluginReference]
    private readonly Plugin NoEngineParts;
    private readonly Plugin NoEscape;
    private readonly Plugin SpawnModularCar;
    private const int RfReservedRangeMin;
    private const int RfReservedRangeMax;
    private const string DefaultTruckConfigName;
    private const string PermissionSpawnFormat;
    private const string PermissionGiveBombTruck;
    private const string PermissionFreeDetonator;
    private const string PrefabExplosiveRocket;
    private const string PrefabRfReceiver;
    private const int DetonatorItemId;
    private const int InvalidFrequency;
    private readonly object False;
    private readonly Vector3 RfReceiverPosition;
    private readonly Quaternion RfReceiverRotation;
    private readonly RFReceiverManager _receiverManager;
    private readonly BombTruckTracker _bombTruckTracker;
    private readonly Dictionary<ulong, float> _dismountTimeByPlayer;
    private StoredData _pluginData;
    private Configuration _pluginConfig;
    private ProtectionProperties _immortalProtection;
    private bool _pluginUnloaded;
    public BombTrucks();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnNewSave();
    private void OnEntityDeath(ModularCar car);
    private void OnEntityMounted(ModularCarSeat seat, BasePlayer player);
    private void OnEntityDismounted(BaseMountable mountable, BasePlayer player);
    private object CanLootEntity(BasePlayer player, ModularCarGarage carLift);
    private object CanDeployCarCodeLock(ModularCar car, BasePlayer player);
    private object CanDeployVehicleCodeLock(ModularCar car, BasePlayer player);
    private object CanDeployVehicleKeyLock(ModularCar car, BasePlayer player);
    private object CanLockVehicle(ModularCar car, BasePlayer player);
    private void OnRfBroadcasterAdded(IRFObject obj, int frequency);
    private void OnRfListenerAdded(IRFObject obj, int frequency);
    private void OnRfListenerRemoved(IRFObject obj, int frequency);
    private object OnVehicleUnclaim(BasePlayer player, ModularCar car);
    private object OnCarAutoTurretDeploy(BaseVehicleModule module, BasePlayer player, bool automatedDeployment);
    private object OnEngineLoadoutOverride(EngineStorage engineStorage);
    private object OnEngineDamageMultiplierChange(EngineStorage engineStorage, float desiredMultiplier);
    private object OnEngineStorageFill(EngineStorage engineStorage, int enginePartsTier);
    [Command("bombtruck", "bt", "boomer")]
    private void SpawnBombTruckCommand(IPlayer player, string cmd, string[] args);
    private void SubCommand_Help(IPlayer player, string[] args);
    private void SubCommand_SpawnBombTruck(IPlayer player, string[] args);
    [Command("givebombtruck")]
    private void GiveBombTruckCommand(IPlayer player, string cmd, string[] args);
    private static bool SpawnWasBlocked(BasePlayer player);
    private bool VerifyNotRaidOrCombatBlocked(BasePlayer player);
    private bool IsRaidBlocked(BasePlayer player);
    private bool IsCombatBlocked(BasePlayer player);
    private bool VerifyHasPermission(IPlayer player, string perm);
    private bool VerifyTruckConfigDefined(IPlayer player, string truckName, TruckConfig truckConfig);
    private bool VerifyNotBuildingBlocked(IPlayer player, BasePlayer basePlayer);
    private bool VerifyNotInSafeZone(IPlayer player, BasePlayer basePlayer);
    private bool VerifyOffCooldown(IPlayer player, TruckConfig truckConfig);
    private bool VerifyNotMounted(IPlayer player, BasePlayer basePlayer);
    private bool VerifyNotRecentlyDismounted(IPlayer player, BasePlayer basePlayer);
    private bool VerifyOnGround(IPlayer player, BasePlayer basePlayer);
    private bool VerifyNotParented(IPlayer player, BasePlayer basePlayer);
    private bool VerifyBelowTruckLimit(IPlayer player, TruckConfig truckConfig);
    private static void DisableEnginePartDamage(ModularCar car);
    private static EngineStorage GetEngineStorage(BaseVehicleModule module);
    private static string GetSpawnPermission(string truckName);
    private static int SortTruckNames(string a, string b);
    private static ModularCar GetReceiverCar(RFReceiver receiver);
    private static RFReceiver GetBombTruckReceiver(ModularCar car);
    private static T GetChildOfType(BaseEntity entity);
    private static void RemoveProblemComponents(BaseEntity entity);
    private static VehicleModuleSeating FindFirstDriverModule(ModularCar car);
    private static bool HasExistingDetonator(ItemContainer container, int frequency);
    private static bool HasExistingDetonator(BasePlayer player, int frequency);
    private static Item CreateRFTransmitter(int frequency);
    private static int GenerateRandomFrequency();
    private static string FormatTime(double seconds);
    private bool VerifyDependencies();
    private void SetupReceiver(RFReceiver receiver);
    private void InitializeBombTrucks();
    private bool IsBombTruck(ModularCar car);
    private ModularCar SpawnBombTruck(BasePlayer player, TruckConfig truckConfig, bool shouldTrack);
    private RFReceiver AttachRFReceiver(ModularCar car, int frequency);
    private double GetPlayerRemainingCooldownSeconds(string userID, TruckConfig truckConfig);
    private void UpdatePlayerCooldown(string userID, string truckName);
    private class BombTruckComponent : FacepunchBehaviour
    {
        public static BombTruckComponent AddToCar(BombTruckTracker tracker, ModularCar car);
        public ModularCar Car { get; set; }
        public NetworkableId NetId { get; set; }
        public ulong OwnerId { get; set; }
        private BombTruckTracker _tracker;
        private void OnDestroy();
    }

    private class BombTruckTracker
    {
        private BombTrucks _plugin;
        private HashSet<Component> _bombTruckComponents;
        public BombTruckTracker(BombTrucks plugin);
        public void TrackBombTruck(ModularCar car);
        public void HandleBombTruckDestroyed(BombTruckComponent component);
        public void Unload();
    }

    private class RFReceiverManager
    {
        private BombTrucks _plugin;
        private readonly Dictionary<int, List<RFReceiver>> Receivers;
        public RFReceiverManager(BombTrucks plugin);
        public void AddReceiver(int frequency, RFReceiver receiver);
        public void RemoveReceiver(int frequency, RFReceiver receiver);
        public void DetonateFrequency(int frequency);
    }

    private static void FireRocket(BasePlayer attackerPlayer, ulong attackerId, string rocketPrefab, Vector3 origin, Vector3 direction, float time, float damageRadiusMult, float damageMult);
    private void DetonateBombTruck(ModularCar car);
    private void DetonateExplosion(BasePlayer attackerPlayer, ulong attackerId, ExplosionSpec spec, Vector3 origin);
    private IEnumerator ExplosionCoroutine(BasePlayer attackerPlayer, ulong attackerId, ExplosionSpec spec, Vector3 origin);
    private Vector3 MakeRandomDomeVector();
    private PlayerData GetPlayerData(string userID);
    private void CleanStaleTruckData();
    private void SaveData();
    private void ClearData();
    private class StoredData
    {
        [JsonProperty("PlayerData")]
        public Dictionary<string, PlayerData> PlayerData;
    }

    private class PlayerData
    {
        [JsonProperty("BombTrucks")]
        public List<PlayerTruckData> BombTrucks;
        [JsonProperty("Cooldowns")]
        public Dictionary<string, long> Cooldowns;
        public void UpdateCooldown(string truckName, long time);
        public int GetTruckCount(string truckName);
        public PlayerTruckData FindTruck(ulong netID);
        public void RemoveTruck(ulong netID);
    }

    private class PlayerTruckData
    {
        [JsonProperty("ID")]
        public ulong ID;
        [JsonProperty("Name")]
        public string Name;
        [JsonProperty("Tracked")]
        public bool Tracked;
    }

    private TruckConfig GetTruckConfig(string truckName);
    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("BombTrucks")]
        public TruckConfig[] BombTrucks;
        [JsonProperty("AttributeDamageToBombTruckOwner")]
        public bool AttributeDamageToBombTruckOwner;
        [JsonProperty("NoEscapeSettings")]
        public NoEscapeSettings NoEscapeSettings;
    }

    private class TruckConfig
    {
        [JsonProperty("Name")]
        public string Name;
        [JsonProperty("CooldownSeconds")]
        public long CooldownSeconds;
        [JsonProperty("SpawnLimitPerPlayer")]
        public int SpawnLimit;
        [JsonProperty("AttachRFReceiver")]
        public bool AttachRFReceiver;
        private int _enginePartsTier;
        [JsonProperty("EnginePartsTier")]
        public int EnginePartsTier { get; set; }
        [JsonProperty("Modules")]
        public object[] Modules;
        [JsonProperty("ExplosionSettings")]
        public ExplosionSpec ExplosionSpec;
    }

    private Configuration GetDefaultConfig();
    private class ExplosionSpec
    {
        private double _speed;
        private double _densityCoefficient;
        private double _densityExponent;
        [JsonProperty("Radius")]
        public double Radius;
        [JsonProperty("DensityCoefficient")]
        public double DensityCoefficient { get; set; }
        [JsonProperty("DensityExponent")]
        public double DensityExponent { get; set; }
        [JsonProperty("Speed")]
        public double Speed { get; set; }
        [JsonProperty("BlastRadiusMult")]
        public float BlastRadiusMult;
        [JsonProperty("DamageMult")]
        public float DamageMult;
    }

    private class NoEscapeSettings
    {
        [JsonProperty("CanSpawnWhileRaidBlocked")]
        public bool CanSpawnWhileRaidBlocked;
        [JsonProperty("CanSpawnWhileCombatBlocked")]
        public bool CanSpawnWhileCombatBlocked;
    }

    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    private void ChatMessage(BasePlayer player, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    protected override void LoadDefaultMessages();
}

private class BombTruckComponent : FacepunchBehaviour
{
    public static BombTruckComponent AddToCar(BombTruckTracker tracker, ModularCar car);
    public ModularCar Car { get; set; }
    public NetworkableId NetId { get; set; }
    public ulong OwnerId { get; set; }
    private BombTruckTracker _tracker;
    private void OnDestroy();
}

private class BombTruckTracker
{
    private BombTrucks _plugin;
    private HashSet<Component> _bombTruckComponents;
    public BombTruckTracker(BombTrucks plugin);
    public void TrackBombTruck(ModularCar car);
    public void HandleBombTruckDestroyed(BombTruckComponent component);
    public void Unload();
}

private class RFReceiverManager
{
    private BombTrucks _plugin;
    private readonly Dictionary<int, List<RFReceiver>> Receivers;
    public RFReceiverManager(BombTrucks plugin);
    public void AddReceiver(int frequency, RFReceiver receiver);
    public void RemoveReceiver(int frequency, RFReceiver receiver);
    public void DetonateFrequency(int frequency);
}

private class StoredData
{
    [JsonProperty("PlayerData")]
    public Dictionary<string, PlayerData> PlayerData;
}

private class PlayerData
{
    [JsonProperty("BombTrucks")]
    public List<PlayerTruckData> BombTrucks;
    [JsonProperty("Cooldowns")]
    public Dictionary<string, long> Cooldowns;
    public void UpdateCooldown(string truckName, long time);
    public int GetTruckCount(string truckName);
    public PlayerTruckData FindTruck(ulong netID);
    public void RemoveTruck(ulong netID);
}

private class PlayerTruckData
{
    [JsonProperty("ID")]
    public ulong ID;
    [JsonProperty("Name")]
    public string Name;
    [JsonProperty("Tracked")]
    public bool Tracked;
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("BombTrucks")]
    public TruckConfig[] BombTrucks;
    [JsonProperty("AttributeDamageToBombTruckOwner")]
    public bool AttributeDamageToBombTruckOwner;
    [JsonProperty("NoEscapeSettings")]
    public NoEscapeSettings NoEscapeSettings;
}

private class TruckConfig
{
    [JsonProperty("Name")]
    public string Name;
    [JsonProperty("CooldownSeconds")]
    public long CooldownSeconds;
    [JsonProperty("SpawnLimitPerPlayer")]
    public int SpawnLimit;
    [JsonProperty("AttachRFReceiver")]
    public bool AttachRFReceiver;
    private int _enginePartsTier;
    [JsonProperty("EnginePartsTier")]
    public int EnginePartsTier { get; set; }
    [JsonProperty("Modules")]
    public object[] Modules;
    [JsonProperty("ExplosionSettings")]
    public ExplosionSpec ExplosionSpec;
}

private class ExplosionSpec
{
    private double _speed;
    private double _densityCoefficient;
    private double _densityExponent;
    [JsonProperty("Radius")]
    public double Radius;
    [JsonProperty("DensityCoefficient")]
    public double DensityCoefficient { get; set; }
    [JsonProperty("DensityExponent")]
    public double DensityExponent { get; set; }
    [JsonProperty("Speed")]
    public double Speed { get; set; }
    [JsonProperty("BlastRadiusMult")]
    public float BlastRadiusMult;
    [JsonProperty("DamageMult")]
    public float DamageMult;
}

private class NoEscapeSettings
{
    [JsonProperty("CanSpawnWhileRaidBlocked")]
    public bool CanSpawnWhileRaidBlocked;
    [JsonProperty("CanSpawnWhileCombatBlocked")]
    public bool CanSpawnWhileCombatBlocked;
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## BoobyTraps by k1lly0u - Booby trap boxes and doors with a variety of traps

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using Network;
using Rust;

Oxide.Plugins
[Info("BoobyTraps", "k1lly0u", "0.2.18")]
[Description("Booby trap boxes and doors with a variety of traps")]
 class BoobyTraps : RustPlugin
{
    [PluginReference]
     Plugin Clans;
     Plugin Friends;
    private DynamicConfigFile datafile;
    private bool initialized;
    private List<ZoneList> m_RadiationZones;
    private List<Timer> m_TrapTimers;
    private Dictionary<ulong, TrapInfo> m_CurrentTraps;
    private const string GRENADE_FX;
    private const string EXPLOSIVE_FX;
    private const string BEANCAN_FX;
    private const string RADIATION_FX;
    private const string LANDMINE_FX;
    private const string BEARTRAP_FX;
    private const string SHOCK_FX;
    private const string LANDMINE_PREFAB;
    private const string BEARTRAP_PREFAB;
    private const string EXPLOSIVE_PREFAB;
    private const string BEANCAN_PREFAB;
    private const string GRENADE_PREFAB;
    private const string FIRE_PREFAB;
    private const string EXPLOSIVE_PERMISSION;
    private const string DEPLOY_PERMISSION;
    private const string ELEMENT_PERMISSION;
    private const string ADMIN_PERMISSION;
    private const int PLAYER_MASK;
    private void Loaded();
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private void Unload();
    private void OnEntitySpawned(BaseEntity entity);
    private void OnLootEntity(BasePlayer inventory, BaseEntity target);
    private void OnEntityTakeDamage(BaseCombatEntity target, HitInfo info);
    private void OnEntityDeath(BaseCombatEntity target, HitInfo info);
    private void CanUseDoor(BasePlayer player, BaseLock locks);
    private void OnDoorOpened(Door target, BasePlayer player);
    private void OnDoorClosed(Door target, BasePlayer player);
    private void OnEntityKill(BaseNetworkable entity);
    private void RemoveInvalidTrapData();
    private void ProcessEntity(BaseEntity entity, int chance);
    private void SetTrap(BaseEntity entity, Traps trap, string owner);
    private bool TryPurchaseTrap(BasePlayer player, Traps trap);
    private void TryActivateTrap(NetworkableId networkableId, BasePlayer player);
    private Vector3 GetPositionOnCircle(Vector3 pos, float ang, float radius);
    private Vector3 GetGroundPosition(Vector3 sourcePos);
    private BaseEntity FindValidEntity(BasePlayer player, bool set);
    private BaseEntity FindEntity(BasePlayer player);
    private object CastRay(Vector3 Pos, Vector3 Aim);
    private void SendEchoConsole(Network.Connection cn, string msg);
    private bool HasPermission(string userId, string perm);
    private bool HasAnyPerm(string userId);
    private bool IsBoobyTrapped(NetworkableId networkableId);
    private void RemoveTrap(NetworkableId networkableId);
    private bool HasEnoughRes(BasePlayer player, int itemid, int amount);
    private void TakeResources(BasePlayer player, int itemid, int amount);
    private double GrabCurrentTime();
    private int GetRandom(int chance);
    private bool SetRandom(int chance);
    private void InitializeZone(Vector3 Location, float intensity, float duration, float radius);
    private void DestroyZone(ZoneList zone);
    public class ZoneList
    {
        public RadiationZone zone;
        public Timer time;
        public void Destroy();
    }

    public class RadiationZone : MonoBehaviour
    {
        private void Awake();
        public void Activate(Vector3 pos, float radius, float amount);
    }

    [ChatCommand("trap")]
    private void cmdTrap(BasePlayer player, string command, string[] args);
    [ConsoleCommand("trap")]
    private void ccmdTrap(ConsoleSystem.Arg arg);
    private bool AreFriends(string playerId, string friendId);
    private bool IsClanmate(string playerId, string friendId);
    private ConfigData configData;
    private class TrapCostEntry
    {
        public string Shortname { get; set; }
        public int Amount { get; set; }
    }

    private class TrapEntry
    {
        public bool Enabled { get; set; }
        public bool AdminOnly { get; set; }
        public float DamageAmount { get; set; }
        public float Radius { get; set; }
        public float FuseTimer { get; set; }
        public float Duration { get; set; }
        public List<TrapCostEntry> Costs { get; set; }
    }

    private class Autotraps
    {
        public bool UseAirdrops { get; set; }
        public bool UseLootContainers { get; set; }
        public int AirdropChance { get; set; }
        public int LootContainerChance { get; set; }
    }

    private class Options
    {
        public bool NotifyRandomSetTraps { get; set; }
        public bool NotifyPlayersWhenTrapTriggered { get; set; }
        public bool PlayTrapWarningSoundFX { get; set; }
        public bool CanTrapBoxes { get; set; }
        public bool CanTrapLoot { get; set; }
        public bool CanTrapSupplyDrops { get; set; }
        public bool CanTrapDoors { get; set; }
        public bool RequireOwnershipToTrap { get; set; }
        public bool RequireBuildingPrivToTrap { get; set; }
        public bool IgnoreTriggerForTrapOwner { get; set; }
        public bool IgnoreTriggerForFriendsOfTrapOwner { get; set; }
        public bool OverrideCostsForAdmins { get; set; }
    }

    private class ConfigData
    {
        public Autotraps AutotrapSettings { get; set; }
        public Dictionary<Traps, TrapEntry> TrapTypes { get; set; }
        public Options Options { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private class TrapInfo
    {
        public Traps trapType;
        public Vector3 location;
        public string trapOwner;
        public bool saveTrap;
        public TrapInfo();
        public TrapInfo(Traps trapType, Vector3 location, string trapOwner, bool saveTrap);
    }

    private void SaveData();
    private void LoadData();
    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private string Message(string key, string playerid);
    private Dictionary<string, string> Messages;
}

public class ZoneList
{
    public RadiationZone zone;
    public Timer time;
    public void Destroy();
}

public class RadiationZone : MonoBehaviour
{
    private void Awake();
    public void Activate(Vector3 pos, float radius, float amount);
}

private class TrapCostEntry
{
    public string Shortname { get; set; }
    public int Amount { get; set; }
}

private class TrapEntry
{
    public bool Enabled { get; set; }
    public bool AdminOnly { get; set; }
    public float DamageAmount { get; set; }
    public float Radius { get; set; }
    public float FuseTimer { get; set; }
    public float Duration { get; set; }
    public List<TrapCostEntry> Costs { get; set; }
}

private class Autotraps
{
    public bool UseAirdrops { get; set; }
    public bool UseLootContainers { get; set; }
    public int AirdropChance { get; set; }
    public int LootContainerChance { get; set; }
}

private class Options
{
    public bool NotifyRandomSetTraps { get; set; }
    public bool NotifyPlayersWhenTrapTriggered { get; set; }
    public bool PlayTrapWarningSoundFX { get; set; }
    public bool CanTrapBoxes { get; set; }
    public bool CanTrapLoot { get; set; }
    public bool CanTrapSupplyDrops { get; set; }
    public bool CanTrapDoors { get; set; }
    public bool RequireOwnershipToTrap { get; set; }
    public bool RequireBuildingPrivToTrap { get; set; }
    public bool IgnoreTriggerForTrapOwner { get; set; }
    public bool IgnoreTriggerForFriendsOfTrapOwner { get; set; }
    public bool OverrideCostsForAdmins { get; set; }
}

private class ConfigData
{
    public Autotraps AutotrapSettings { get; set; }
    public Dictionary<Traps, TrapEntry> TrapTypes { get; set; }
    public Options Options { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}

private class TrapInfo
{
    public Traps trapType;
    public Vector3 location;
    public string trapOwner;
    public bool saveTrap;
    public TrapInfo();
    public TrapInfo(Traps trapType, Vector3 location, string trapOwner, bool saveTrap);
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## BoomBoomBears by August - Bears explode with a fire rocket on death

```csharp
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Random = System.Random;

Oxide.Plugins
[Info("Boom Boom Bears", "August", "1.0.6")]
[Description("Bears explode with a fire rocket on death")]
public class BoomBoomBears : RustPlugin
{
    private PluginConfig config;
    private const string Perm;
    private const string PermManage;
    private Random Num;
    private string[] SupportedPrefabs;
     void Init();
    private class PluginConfig
    {
        public bool IsEnabled;
        public bool RandomEnabled;
        public int Chance;
        public string Prefab;
    }

    private void SaveConfig();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadDefaultMessages();
     void OnEntityDeath(Bear bear, HitInfo info);
    [ChatCommand("bbbears")]
     void BoomBearsCommand(BasePlayer player, string cmd, string[] args);
     bool GetRandom();
     void ToggleEnabled(BasePlayer player);
     void ToggleRandom(BasePlayer player);
    private string Lang(string key, string id, object[] args);
}

private class PluginConfig
{
    public bool IsEnabled;
    public bool RandomEnabled;
    public int Chance;
    public string Prefab;
}


```

---

## BoomboxDurability by WhiteThunder - Allows configuring deployable boomboxes to decay while playing

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Boombox Durability", "WhiteThunder", "2.0.1")]
[Description("Allows configuring deployable boomboxes to decay while playing.")]
internal class BoomboxDurability : CovalencePlugin
{
    private const string PermissionProfilePrefix;
    private const float VanillaConditionLossRate;
    private Configuration _pluginConfig;
    private void Init();
    private void OnServerInitialized();
    private void OnEntitySpawned(DeployableBoomBox boomBox);
    private void Unload();
    public float GetPlayerDecayRate(ulong userId);
    private class DurabilityProfile
    {
        [JsonProperty("PermissionSuffix")]
        public string PermissionSuffix;
        [JsonProperty("DecayRate")]
        public float DecayRate;
        [JsonIgnore]
        public string Permission;
    }

    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("DefaultDecayRate")]
        public float DefaultDecayRate;
        [JsonProperty("ProfilesRequiringPermission")]
        public DurabilityProfile[] ProfilesRequiringPermission;
        public void Init(BoomboxDurability pluginInstance);
    }

    private Configuration GetDefaultConfig();
    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
}

private class DurabilityProfile
{
    [JsonProperty("PermissionSuffix")]
    public string PermissionSuffix;
    [JsonProperty("DecayRate")]
    public float DecayRate;
    [JsonIgnore]
    public string Permission;
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("DefaultDecayRate")]
    public float DefaultDecayRate;
    [JsonProperty("ProfilesRequiringPermission")]
    public DurabilityProfile[] ProfilesRequiringPermission;
    public void Init(BoomboxDurability pluginInstance);
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## BoomBoxHealth by Waldobert - Disables decay damage of the deployable BoomBox when it is playing

```csharp
using Rust;

Oxide.Plugins
[Info("Boom Box Health", "Waldobert", "1.0.1")]
[Description("Disables the playing-decay of the boombox")]
 class BoomBoxHealth : RustPlugin
{
     void OnEntityTakeDamage(DeployableBoomBox entity, HitInfo info);
}


```

---

## BotNames by birthdates - Allows changing of bot names

```csharp
using System.Collections.Generic;
using Oxide.Core;

Oxide.Plugins
[Info("Bot Names", "birthdates", "1.0.6")]
[Description("Ability to change bot names")]
public class BotNames : RustPlugin
{
    private void Init();
    private void OnEntitySpawned(BasePlayer Player);
    private ConfigFile _config;
    private class ConfigFile
    {
        public readonly List<string> Names;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigFile
{
    public readonly List<string> Names;
}


```

---

## BouncyC4 by VisEntities - Throw non-sticking bouncy explosives

```csharp
using UnityEngine;

Oxide.Plugins
[Info("Bouncy C4", "VisEntities", "1.1.0")]
[Description("Throw non-sticking bouncy explosives.")]
public class BouncyC4 : RustPlugin
{
    private static BouncyC4 _plugin;
    private void Init();
    private void Unload();
    private object CanExplosiveStick(TimedExplosive explosive, BaseEntity entity);
    public static BasePlayer FindPlayerById(ulong playerId);
    private static class PermissionUtil
    {
        public const string USE;
        public static void RegisterPermissions();
        public static bool VerifyHasPermission(BasePlayer player, string permissionName);
    }

}

private static class PermissionUtil
{
    public const string USE;
    public static void RegisterPermissions();
    public static bool VerifyHasPermission(BasePlayer player, string permissionName);
}


```

---

## Bounty by k1lly0u - Place bounties on other players using in-game items, RP or Economics

```csharp
using System.Collections.Generic;
using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using Oxide.Core.Configuration;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Network;

Oxide.Plugins
[Info("Bounty", "k1lly0u", "0.2.7")]
[Description("Place bounties on other players using in-game items, RP or Economics")]
 class Bounty : RustPlugin
{
    [PluginReference]
     Plugin Clans;
     Plugin Friends;
     Plugin PopupNotifications;
     Plugin Economics;
     Plugin ServerRewards;
    private StoredData storedData;
    private DynamicConfigFile data;
    private Dictionary<ulong, ulong> bountyCreator;
    private Dictionary<StorageContainer, ulong> openContainers;
    private Dictionary<int, string> idToDisplayName;
    private string boxPrefab;
    private void Loaded();
    private void OnServerInitialized();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private object CanLootEntity(BasePlayer player, StorageContainer container);
    private void OnPlayerLootEnd(PlayerLoot inventory);
    private void OnServerSave();
    private void Unload();
    private void BroadcastToPlayer(BasePlayer player, string message);
    private void CreateNewBounty(BasePlayer initiator, ulong targetId, int rpAmount, int ecoAmount, ItemContainer container);
    private void CancelBounty(BasePlayer player, IPlayer target);
    private void GivePlayerRewards(BasePlayer player, RewardInfo rewardInfo);
    private Item CreateItem(RewardInfo.ItemData itemData);
    private void SpawnItemContainer(BasePlayer player);
    private void OpenInventory(BasePlayer player, StorageContainer container);
    private void ClearContainer(ItemContainer itemContainer);
    private int GetUniqueId();
    private double CurrentTime();
    private List<BasePlayer> FindPlayer(string partialNameOrId);
    private string FormatTime(double time);
    public bool IsFriendlyPlayer(ulong playerId, ulong friendId);
    private bool IsClanmate(ulong playerId, ulong friendId);
    private bool IsFriend(ulong playerID, ulong friendID);
    [ChatCommand("bounty")]
    private void cmdBounty(BasePlayer player, string command, string[] args);
    [ConsoleCommand("bounty")]
    private void ccmdBounty(ConsoleSystem.Arg arg);
    private void SendEchoConsole(Network.Connection cn, string msg);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Ignore kills by clan members")]
        public bool IgnoreClans { get; set; }
        [JsonProperty(PropertyName = "Ignore kills by friends")]
        public bool IgnoreFriends { get; set; }
        [JsonProperty(PropertyName = "Notification Options")]
        public NotificationOptions Notifications { get; set; }
        [JsonProperty(PropertyName = "Reward Options")]
        public RewardOptions Rewards { get; set; }
        public class NotificationOptions
        {
            [JsonProperty(PropertyName = "PopupNotifications - Broadcast using PopupNotifications")]
            public bool UsePopupNotifications { get; set; }
            [JsonProperty(PropertyName = "PopupNotifications - Duration of notification")]
            public float PopupDuration { get; set; }
            [JsonProperty(PropertyName = "Broadcast new bounties globally")]
            public bool BroadcastNewBounties { get; set; }
            [JsonProperty(PropertyName = "Reminders - Remind targets they have a bounty on them")]
            public bool ShowReminders { get; set; }
            [JsonProperty(PropertyName = "Reminders - Amount of time between reminders (in minutes)")]
            public int ReminderTime { get; set; }
        }

        public class RewardOptions
        {
            [JsonProperty(PropertyName = "Allow bounties to be placed using Economics")]
            public bool AllowEconomics { get; set; }
            [JsonProperty(PropertyName = "Allow bounties to be placed using RP")]
            public bool AllowServerRewards { get; set; }
            [JsonProperty(PropertyName = "Allow bounties to be placed using items")]
            public bool AllowItems { get; set; }
        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private void SaveData();
    private void LoadData();
    private class StoredData
    {
        public Dictionary<ulong, PlayerData> players;
        public Dictionary<int, RewardInfo> rewards;
    }

    private class PlayerData
    {
        public string displayName;
        public int totalBounties;
        public int bountiesClaimed;
        public double totalWantedTime;
        public List<BountyInfo> activeBounties;
        public List<int> unclaimedRewards;
        public PlayerData();
        public PlayerData(string displayName);
        public void ClaimRewards(List<int> rewards);
        public void UpdateWantedTime();
        public double GetCurrentWantedTime();
        public class BountyInfo
        {
            public ulong initiatorId;
            public string initiatorName;
            public double initiatedTime;
            public int rewardId;
            public BountyInfo();
            public BountyInfo(ulong initiatorId, string initiatorName, int rewardId);
        }

    }

    private class RewardInfo
    {
        public int rpAmount;
        public int econAmount;
        public List<ItemData> rewardItems;
        public RewardInfo();
        public RewardInfo(int rpAmount, int econAmount, ItemContainer container);
        private IEnumerable<ItemData> GetItems(ItemContainer container);
        public class ItemData
        {
            public int itemid;
            public ulong skin;
            public int amount;
            public float condition;
            public int ammo;
            public string ammotype;
            public InstanceData instanceData;
            public ItemData[] contents;
            public class InstanceData
            {
                public int dataInt;
                public int blueprintTarget;
                public int blueprintAmount;
                public InstanceData();
                public InstanceData(Item item);
                public void Restore(Item item);
            }

        }

    }

    private string msg(string key, ulong playerId);
     Dictionary<string, string> messages;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Ignore kills by clan members")]
    public bool IgnoreClans { get; set; }
    [JsonProperty(PropertyName = "Ignore kills by friends")]
    public bool IgnoreFriends { get; set; }
    [JsonProperty(PropertyName = "Notification Options")]
    public NotificationOptions Notifications { get; set; }
    [JsonProperty(PropertyName = "Reward Options")]
    public RewardOptions Rewards { get; set; }
    public class NotificationOptions
    {
        [JsonProperty(PropertyName = "PopupNotifications - Broadcast using PopupNotifications")]
        public bool UsePopupNotifications { get; set; }
        [JsonProperty(PropertyName = "PopupNotifications - Duration of notification")]
        public float PopupDuration { get; set; }
        [JsonProperty(PropertyName = "Broadcast new bounties globally")]
        public bool BroadcastNewBounties { get; set; }
        [JsonProperty(PropertyName = "Reminders - Remind targets they have a bounty on them")]
        public bool ShowReminders { get; set; }
        [JsonProperty(PropertyName = "Reminders - Amount of time between reminders (in minutes)")]
        public int ReminderTime { get; set; }
    }

    public class RewardOptions
    {
        [JsonProperty(PropertyName = "Allow bounties to be placed using Economics")]
        public bool AllowEconomics { get; set; }
        [JsonProperty(PropertyName = "Allow bounties to be placed using RP")]
        public bool AllowServerRewards { get; set; }
        [JsonProperty(PropertyName = "Allow bounties to be placed using items")]
        public bool AllowItems { get; set; }
    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class NotificationOptions
{
    [JsonProperty(PropertyName = "PopupNotifications - Broadcast using PopupNotifications")]
    public bool UsePopupNotifications { get; set; }
    [JsonProperty(PropertyName = "PopupNotifications - Duration of notification")]
    public float PopupDuration { get; set; }
    [JsonProperty(PropertyName = "Broadcast new bounties globally")]
    public bool BroadcastNewBounties { get; set; }
    [JsonProperty(PropertyName = "Reminders - Remind targets they have a bounty on them")]
    public bool ShowReminders { get; set; }
    [JsonProperty(PropertyName = "Reminders - Amount of time between reminders (in minutes)")]
    public int ReminderTime { get; set; }
}

public class RewardOptions
{
    [JsonProperty(PropertyName = "Allow bounties to be placed using Economics")]
    public bool AllowEconomics { get; set; }
    [JsonProperty(PropertyName = "Allow bounties to be placed using RP")]
    public bool AllowServerRewards { get; set; }
    [JsonProperty(PropertyName = "Allow bounties to be placed using items")]
    public bool AllowItems { get; set; }
}

private class StoredData
{
    public Dictionary<ulong, PlayerData> players;
    public Dictionary<int, RewardInfo> rewards;
}

private class PlayerData
{
    public string displayName;
    public int totalBounties;
    public int bountiesClaimed;
    public double totalWantedTime;
    public List<BountyInfo> activeBounties;
    public List<int> unclaimedRewards;
    public PlayerData();
    public PlayerData(string displayName);
    public void ClaimRewards(List<int> rewards);
    public void UpdateWantedTime();
    public double GetCurrentWantedTime();
    public class BountyInfo
    {
        public ulong initiatorId;
        public string initiatorName;
        public double initiatedTime;
        public int rewardId;
        public BountyInfo();
        public BountyInfo(ulong initiatorId, string initiatorName, int rewardId);
    }

}

public class BountyInfo
{
    public ulong initiatorId;
    public string initiatorName;
    public double initiatedTime;
    public int rewardId;
    public BountyInfo();
    public BountyInfo(ulong initiatorId, string initiatorName, int rewardId);
}

private class RewardInfo
{
    public int rpAmount;
    public int econAmount;
    public List<ItemData> rewardItems;
    public RewardInfo();
    public RewardInfo(int rpAmount, int econAmount, ItemContainer container);
    private IEnumerable<ItemData> GetItems(ItemContainer container);
    public class ItemData
    {
        public int itemid;
        public ulong skin;
        public int amount;
        public float condition;
        public int ammo;
        public string ammotype;
        public InstanceData instanceData;
        public ItemData[] contents;
        public class InstanceData
        {
            public int dataInt;
            public int blueprintTarget;
            public int blueprintAmount;
            public InstanceData();
            public InstanceData(Item item);
            public void Restore(Item item);
        }

    }

}

public class ItemData
{
    public int itemid;
    public ulong skin;
    public int amount;
    public float condition;
    public int ammo;
    public string ammotype;
    public InstanceData instanceData;
    public ItemData[] contents;
    public class InstanceData
    {
        public int dataInt;
        public int blueprintTarget;
        public int blueprintAmount;
        public InstanceData();
        public InstanceData(Item item);
        public void Restore(Item item);
    }

}

public class InstanceData
{
    public int dataInt;
    public int blueprintTarget;
    public int blueprintAmount;
    public InstanceData();
    public InstanceData(Item item);
    public void Restore(Item item);
}


```

---

## BoxLooters by k1lly0u - Logs looters for a containers to help prevent cheating

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Linq;
using Newtonsoft.Json;

Oxide.Plugins
[Info("BoxLooters", "4seti / k1lly0u", "0.3.6")]
[Description("Log looters for a containers")]
 class BoxLooters : RustPlugin
{
    private StoredBoxData boxData;
    private StoredPlayerData playerData;
    private DynamicConfigFile boxdata;
    private DynamicConfigFile playerdata;
    private static BoxLooters ins;
    private bool eraseData;
    private const string PERMISSION_CHECKBOX;
    private void Loaded();
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void OnNewSave(string filename);
    private void OnServerSave();
    private void Unload();
    private void OnLootEntity(BasePlayer looter, BaseEntity entity);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo);
    private void ClearAllData();
    private void RemoveOldData();
    private object FindBoxFromRay(BasePlayer player);
    private void ReplyInfo(BasePlayer player, ulong entityId, bool isPlayer, string additional);
    private double GrabCurrentTime();
    private bool HasPermission(BasePlayer player);
    private float GetDistance(Vector3 init, Vector3 target);
    private bool IsValidType(BaseEntity entity);
    [ChatCommand("box")]
    private void cmdBox(BasePlayer player, string command, string[] args);
    private ConfigData configData;
    private class ConfigData
    {
        public int RemoveHours { get; set; }
        public int RecordsPerContainer { get; set; }
        public bool LogPlayerLoot { get; set; }
        public bool LogBoxLoot { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
    private class BoxData
    {
        public float x;
        public float y;
        public float z;
        public string killerId;
        public string killerName;
        public LootList lootList;
        public double lastAccess;
        public BoxData();
        public BoxData(BasePlayer player, double time, string date, Vector3 pos);
        public void AddLooter(BasePlayer looter, double time, string date);
        public void OnDestroyed(BasePlayer killer);
        public Vector3 GetPosition();
    }

    private class PlayerData
    {
        public LootList lootList;
        public double lastAccess;
        public PlayerData();
        public PlayerData(BasePlayer player, double time, string date);
        public void AddLooter(BasePlayer looter, double time, string date);
    }

    private class LootList
    {
        public List<LootEntry> looters;
        public LootList();
        public LootList(BasePlayer player, string date);
        public void AddEntry(BasePlayer player, string date);
        public LootEntry[] GetLooters();
        public class LootEntry
        {
            public string userId;
            public string userName;
            public string firstLoot;
            public string lastLoot;
            public LootEntry();
            public LootEntry(BasePlayer player, string firstLoot);
        }

    }

    private void SaveData();
    private void LoadData();
    private class StoredBoxData
    {
        public Hash<ulong, BoxData> boxes;
    }

    private class StoredPlayerData
    {
        public Hash<ulong, PlayerData> players;
    }

    private string msg(string key, ulong playerId);
    private Dictionary<string, string> messages;
}

private class ConfigData
{
    public int RemoveHours { get; set; }
    public int RecordsPerContainer { get; set; }
    public bool LogPlayerLoot { get; set; }
    public bool LogBoxLoot { get; set; }
}

private class BoxData
{
    public float x;
    public float y;
    public float z;
    public string killerId;
    public string killerName;
    public LootList lootList;
    public double lastAccess;
    public BoxData();
    public BoxData(BasePlayer player, double time, string date, Vector3 pos);
    public void AddLooter(BasePlayer looter, double time, string date);
    public void OnDestroyed(BasePlayer killer);
    public Vector3 GetPosition();
}

private class PlayerData
{
    public LootList lootList;
    public double lastAccess;
    public PlayerData();
    public PlayerData(BasePlayer player, double time, string date);
    public void AddLooter(BasePlayer looter, double time, string date);
}

private class LootList
{
    public List<LootEntry> looters;
    public LootList();
    public LootList(BasePlayer player, string date);
    public void AddEntry(BasePlayer player, string date);
    public LootEntry[] GetLooters();
    public class LootEntry
    {
        public string userId;
        public string userName;
        public string firstLoot;
        public string lastLoot;
        public LootEntry();
        public LootEntry(BasePlayer player, string firstLoot);
    }

}

public class LootEntry
{
    public string userId;
    public string userName;
    public string firstLoot;
    public string lastLoot;
    public LootEntry();
    public LootEntry(BasePlayer player, string firstLoot);
}

private class StoredBoxData
{
    public Hash<ulong, BoxData> boxes;
}

private class StoredPlayerData
{
    public Hash<ulong, PlayerData> players;
}


```

---

## BoxSorterLite by haggbart - Sorts loot in boxes using an intuitive interface

```csharp
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Box Sorter Lite", "haggbart", "1.0.9")]
[Description("Sort your loot in boxes using an intuitive interface.")]
internal class BoxSorterLite : RustPlugin
{
    private const string permUse;
    private Dictionary<ulong, BoxCategory> _skinbox;
    private string boxContentCommand;
    private string boxContentName;
    private CuiElementContainer cuiContainer;
    private List<Item> selectedItems;
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void InitSorters();
    private void OnLootEntity(BasePlayer player, BaseEntity entity);
    private void OnPlayerLootEnd(PlayerLoot inventory);
    private void CreateBoxUI(BasePlayer player, BaseEntity entity, int header);
    private void AddHeaderUI(BasePlayer player);
    private readonly StringBuilder xY1;
    private readonly StringBuilder xY2;
    private readonly StringBuilder cD;
    private void AddCategoryUI(BasePlayer player, CuiElementContainer container);
    private void AddSelectedUI(BasePlayer player, BaseEntity entity);
    [ConsoleCommand("boxsorter.sort")]
    private void CmdSort(ConsoleSystem.Arg arg);
    [ConsoleCommand("boxsorter.insert")]
    private void CmdInsert(ConsoleSystem.Arg arg);
    [ConsoleCommand("boxsorter.select")]
    private void CmdSelect(ConsoleSystem.Arg arg);
    private static CuiElementContainer ContainerOffset(string panelName, string color, string aMin, string aMax, string offSetMin, string offSetMax, float fadein, bool useCursor, string parent);
    private void Panel(CuiElementContainer container, string panel, string color, string aMin, string aMax, float fadein, bool cursor);
    private static void Label(CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, float fadein, TextAnchor align);
    private static void Button(CuiElementContainer container, string panel, string color, string text, string color1, int size, string aMin, string aMax, string command, TextAnchor align);
}


```

---

## BradleyCCTV by VisEntities - Never walk into danger blindly at the launch site

```csharp
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Bradley CCTV", "Dana", "2.0.1")]
[Description("The ultimate surveillance upgrade for your Bradley APCs.")]
public class BradleyCCTV : RustPlugin
{
    private static BradleyCCTV instance;
    private static Configuration config;
    private Dictionary<BradleyAPC, List<string>> surveilledBradleys;
    private const string cctvCameraPrefab;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Version")]
        public string Version { get; set; }
        [JsonProperty(PropertyName = "Front Camera")]
        public CameraOptions FrontCamera { get; set; }
        [JsonProperty(PropertyName = "Back Camera")]
        public CameraOptions BackCamera { get; set; }
    }

    private class CameraOptions
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Static")]
        public bool Static { get; set; }
        [JsonProperty(PropertyName = "Up Down Rotation")]
        public float UpDownRotation { get; set; }
        [JsonProperty(PropertyName = "Right Left Rotation")]
        public float RightLeftRotation { get; set; }
        [JsonProperty(PropertyName = "Position")]
        public Vector3 Position { get; set; }
        [JsonProperty(PropertyName = "Rotation")]
        public Vector3 Rotation { get; set; }
    }

    private Configuration GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private void OnServerInitialized();
    private void Init();
    private void Unload();
    private void OnEntitySpawned(BradleyAPC bradley);
    private void OnEntityKill(BradleyAPC bradley);
    private void SetupCameras(BradleyAPC bradley);
    private void SpawnCamera(BradleyAPC bradley, CameraOptions cameraOptions);
    private void CleanupCameras();
    private bool HasCamerasAttached(BradleyAPC bradley);
    private List<CCTV_RC> GetCamerasAttached(BradleyAPC bradley, List<CCTV_RC> cctvCameras);
    private string GenerateIdentifier();
    private static class Permission
    {
        public const string Use;
        public static void Register();
        public static bool Verify(BasePlayer player, string permissionName);
    }

    private static class Command
    {
        public const string Identifier;
    }

    [ChatCommand(Command.Identifier)]
    private void cmdIdentifier(BasePlayer player, string cmd, string[] args);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Version")]
    public string Version { get; set; }
    [JsonProperty(PropertyName = "Front Camera")]
    public CameraOptions FrontCamera { get; set; }
    [JsonProperty(PropertyName = "Back Camera")]
    public CameraOptions BackCamera { get; set; }
}

private class CameraOptions
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Static")]
    public bool Static { get; set; }
    [JsonProperty(PropertyName = "Up Down Rotation")]
    public float UpDownRotation { get; set; }
    [JsonProperty(PropertyName = "Right Left Rotation")]
    public float RightLeftRotation { get; set; }
    [JsonProperty(PropertyName = "Position")]
    public Vector3 Position { get; set; }
    [JsonProperty(PropertyName = "Rotation")]
    public Vector3 Rotation { get; set; }
}

private static class Permission
{
    public const string Use;
    public static void Register();
    public static bool Verify(BasePlayer player, string permissionName);
}

private static class Command
{
    public const string Identifier;
}


```

---

## BradleyControl by VisEntities - Unlock Bradley's full potential with steroids

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using UnityEngine;
using Pool = Facepunch.Pool;
using Random = UnityEngine.Random;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("BradleyControl", "Dana", "1.1.0")]
[Description("Inject your armored beast with steroids and level it up with the intelligence and strength it deserves.")]
public class BradleyControl : RustPlugin
{
    private static BradleyControl _instance;
    private static Configuration _config;
    private HashSet<FireBall> _bradleyFireBalls;
    private HashSet<HelicopterDebris> _bradleyDebris;
    private HashSet<LockedByEntCrate> _bradleyCrates;
    private HashSet<BradleyAPC> _spawnedBradleys;
    private const string FIRE_BALL_PREFAB;
    private const string BRADLEY_CRATE_PREFAB;
    private const string BRADLEY_DEBRIS_PREFAB;
    private Vector3 _lastCrashSitePosition;
    private class Configuration
    {
        [JsonProperty("Version")]
        public string Version { get; set; }
        [JsonProperty("Health")]
        public HealthSettings Health { get; set; }
        [JsonProperty("Loot")]
        public LootSettings Loot { get; set; }
        [JsonProperty("Flame")]
        public FireBallSettings Flame { get; set; }
        [JsonProperty("Debris")]
        public DebrisSettings Debris { get; set; }
        [JsonProperty("Movement")]
        public MovementSettings Movement { get; set; }
        [JsonProperty("Targeting")]
        public TargetingSettings Targeting { get; set; }
        [JsonProperty("Coax Turret")]
        public CoaxTurretSettings CoaxTurret { get; set; }
        [JsonProperty("Cannon")]
        public CannonSettings Cannon { get; set; }
    }

    private class HealthSettings
    {
        [JsonProperty("Starting Health")]
        public float StartingHealth { get; set; }
        [JsonProperty("Maximum Health")]
        public float MaximumHealth { get; set; }
    }

    private class LootSettings
    {
        [JsonProperty("Maximum Crates To Drop")]
        public int MaximumCratesToDrop { get; set; }
    }

    private class DebrisSettings
    {
        [JsonProperty("Drop On Destruction")]
        public bool DropOnDestruction { get; set; }
        [JsonProperty("Harvestable Hit Points")]
        public float HarvestableHitPoints { get; set; }
        [JsonProperty("Harvest Cooldown")]
        public float HarvestCooldown { get; set; }
    }

    private class FireBallSettings
    {
        [JsonProperty("Set Crates On Fire")]
        public bool SetCratesOnFire { get; set; }
        [JsonProperty("Minimum Life Time")]
        public float MinimumLifeTime { get; set; }
        [JsonProperty("Maximum Life Time")]
        public float MaximumLifeTime { get; set; }
        [JsonProperty("Spread Chance")]
        public int SpreadChance { get; set; }
        [JsonProperty("Spread At Lifetime Percent")]
        public int SpreadAtLifetimePercent { get; set; }
        [JsonProperty("Damage Per Second")]
        public float DamagePerSecond { get; set; }
        [JsonProperty("Damage Rate")]
        public float DamageRate { get; set; }
        [JsonProperty("Water Required To Extinguish")]
        public int WaterRequiredToExtinguish { get; set; }
    }

    private class MovementSettings
    {
        [JsonProperty("Maximum Speed")]
        public float MaximumSpeed { get; set; }
        [JsonProperty("Spin Speed")]
        public float SpinSpeed { get; set; }
        [JsonProperty("Brake Force")]
        public float BrakeForce { get; set; }
    }

    private class TargetingSettings
    {
        [JsonProperty("Engagement Range")]
        public float EngagementRange { get; set; }
        [JsonProperty("Target Search Range")]
        public float TargetSearchRange { get; set; }
        [JsonProperty("Memory Duration")]
        public float MemoryDuration { get; set; }
    }

    private class CoaxTurretSettings
    {
        [JsonProperty("Time Between Bursts")]
        public float TimeBetweenBursts { get; set; }
        [JsonProperty("Maximum Shots Per Burst")]
        public int MaximumShotsPerBurst { get; set; }
        [JsonProperty("Bullet Damage")]
        public float BulletDamage { get; set; }
    }

    private class CannonSettings
    {
        [JsonProperty("Recoil Intensity")]
        public float RecoilIntensity { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
    private Configuration GetDefaultConfig();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnBradleyApcInitialize(BradleyAPC bradley);
    private void OnEntityDeath(BradleyAPC bradley, HitInfo info);
    private void CaptureAfterExplosionEntities(Vector3 position);
    private void InitializeBradley(BradleyAPC bradley);
    private void InitializeDebris();
    private void InitializeCrates();
    private void InitializeFireBall(FireBall fireBall, LockedByEntCrate crate);
    private FireBall SpawnFireBall(LockedByEntCrate crate);
    private static T FindChildByType(BaseEntity parentEntity, string prefabName);
}

private class Configuration
{
    [JsonProperty("Version")]
    public string Version { get; set; }
    [JsonProperty("Health")]
    public HealthSettings Health { get; set; }
    [JsonProperty("Loot")]
    public LootSettings Loot { get; set; }
    [JsonProperty("Flame")]
    public FireBallSettings Flame { get; set; }
    [JsonProperty("Debris")]
    public DebrisSettings Debris { get; set; }
    [JsonProperty("Movement")]
    public MovementSettings Movement { get; set; }
    [JsonProperty("Targeting")]
    public TargetingSettings Targeting { get; set; }
    [JsonProperty("Coax Turret")]
    public CoaxTurretSettings CoaxTurret { get; set; }
    [JsonProperty("Cannon")]
    public CannonSettings Cannon { get; set; }
}

private class HealthSettings
{
    [JsonProperty("Starting Health")]
    public float StartingHealth { get; set; }
    [JsonProperty("Maximum Health")]
    public float MaximumHealth { get; set; }
}

private class LootSettings
{
    [JsonProperty("Maximum Crates To Drop")]
    public int MaximumCratesToDrop { get; set; }
}

private class DebrisSettings
{
    [JsonProperty("Drop On Destruction")]
    public bool DropOnDestruction { get; set; }
    [JsonProperty("Harvestable Hit Points")]
    public float HarvestableHitPoints { get; set; }
    [JsonProperty("Harvest Cooldown")]
    public float HarvestCooldown { get; set; }
}

private class FireBallSettings
{
    [JsonProperty("Set Crates On Fire")]
    public bool SetCratesOnFire { get; set; }
    [JsonProperty("Minimum Life Time")]
    public float MinimumLifeTime { get; set; }
    [JsonProperty("Maximum Life Time")]
    public float MaximumLifeTime { get; set; }
    [JsonProperty("Spread Chance")]
    public int SpreadChance { get; set; }
    [JsonProperty("Spread At Lifetime Percent")]
    public int SpreadAtLifetimePercent { get; set; }
    [JsonProperty("Damage Per Second")]
    public float DamagePerSecond { get; set; }
    [JsonProperty("Damage Rate")]
    public float DamageRate { get; set; }
    [JsonProperty("Water Required To Extinguish")]
    public int WaterRequiredToExtinguish { get; set; }
}

private class MovementSettings
{
    [JsonProperty("Maximum Speed")]
    public float MaximumSpeed { get; set; }
    [JsonProperty("Spin Speed")]
    public float SpinSpeed { get; set; }
    [JsonProperty("Brake Force")]
    public float BrakeForce { get; set; }
}

private class TargetingSettings
{
    [JsonProperty("Engagement Range")]
    public float EngagementRange { get; set; }
    [JsonProperty("Target Search Range")]
    public float TargetSearchRange { get; set; }
    [JsonProperty("Memory Duration")]
    public float MemoryDuration { get; set; }
}

private class CoaxTurretSettings
{
    [JsonProperty("Time Between Bursts")]
    public float TimeBetweenBursts { get; set; }
    [JsonProperty("Maximum Shots Per Burst")]
    public int MaximumShotsPerBurst { get; set; }
    [JsonProperty("Bullet Damage")]
    public float BulletDamage { get; set; }
}

private class CannonSettings
{
    [JsonProperty("Recoil Intensity")]
    public float RecoilIntensity { get; set; }
}


```

---

## BradleyGuards by Bazz3l - Spawn reinforcements for bradley when destroyed at configured monuments.

```csharp
using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System;
using Oxide.Plugins.BradleyGuardsExtensionMethods;
using Oxide.Core.Plugins;
using Oxide.Core;
using Rust;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using Facepunch;
using HarmonyLib;
using Network;
using Action = System.Action;

Oxide.Plugins
[Info("Bradley Guards", "Bazz3l", "1.6.6")]
[Description("Spawn reinforcements for bradley when destroyed at configured monuments.")]
internal class BradleyGuards : RustPlugin
{
    [PluginReference]
    private Plugin NpcSpawn;
    private Plugin GUIAnnouncements;
    private const string PERM_USE;
    private const float INITIALIZE_DELAY;
    private StoredData _storedData;
    private ConfigData _configData;
    private Coroutine _setupRoutine;
    private static BradleyGuards Instance;
    protected override void LoadDefaultMessages();
    private class MessageKeys
    {
        public static readonly string Prefix;
        public static readonly string NoPermission;
        public static readonly string EventStart;
        public static readonly string EventEnded;
        public static readonly string EventNotFound;
        public static readonly string EventUpdated;
        public static readonly string DisplayNameEmpty;
        public static readonly string InvalidGuardAmount;
        public static readonly string InvalidBooleanValue;
        public static readonly string HelpEventEnable;
        public static readonly string HelpEventName;
        public static readonly string HelpGuardAmount;
        public static readonly string HelpGuardLoadout;
    }

    private void MessagePlayer(BasePlayer player, string langKey, object[] args);
    private void MessagePlayers(string langKey, object[] args);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class ConfigData
    {
        [JsonProperty("command name")]
        public string CommandName;
        [JsonProperty("enable auto unlock crates when guards are eliminated")]
        public bool EnableAutoUnlock;
        [JsonProperty("enable auto extinguish crates when guards are eliminated")]
        public bool EnableAutoExtinguish;
        [JsonProperty("bradley starting health")]
        public float BradleyHealth;
        [JsonProperty("crate spawn amount")]
        public int CrateSpawnAmount;
        [JsonProperty("message notification settings")]
        public MessageSettings MessageSettings;
        public static ConfigData DefaultConfig();
    }

    private class MessageSettings
    {
        [JsonProperty("enable toast message")]
        public bool EnableToast;
        [JsonProperty("enable chat message")]
        public bool EnableChat;
        [JsonProperty("enable chat prefix")]
        public bool EnableChatPrefix;
        [JsonProperty("custom chat message icon (steam64)")]
        public ulong ChatIcon;
        [JsonProperty("enable gui announcements plugin from umod.org")]
        public bool EnableGuiAnnouncements;
        [JsonProperty("gui announcements text color")]
        public string GuiAnnouncementsTextColor;
        [JsonProperty("gui announcements background color")]
        public string GuiAnnouncementsBgColor;
    }

    private void LoadDefaultData();
    private void LoadData();
    private void SaveData();
    private class StoredData
    {
        public Dictionary<string, EventEntry> BradleyEventEntries;
        [JsonIgnore]
        public bool IsValid { get; set; }
        public EventEntry FindEntryByName(string monumentName);
    }

    private class EventEntry
    {
        [JsonProperty("display name")]
        public string DisplayName;
        [JsonProperty("enabled")]
        public bool EnabledEvent;
        [JsonProperty("bounds center")]
        public Vector3 BoundsPosition;
        [JsonProperty("bounds size")]
        public Vector3 BoundsSize;
        [JsonProperty("landing position")]
        public Vector3 LandingPosition;
        [JsonProperty("landing rotation")]
        public Vector3 LandingRotation;
        [JsonProperty("chinook position")]
        public Vector3 ChinookPosition;
        [JsonProperty("guard spawn amount")]
        public int GuardAmount;
        [JsonProperty("guard spawn profile")]
        public GuardConfig GuardConfig;
        public IEnumerator Create(Transform transform, bool enableAutoExtinguish, bool enableAutoUnlock);
    }

    private class GuardConfig
    {
        public string Name;
        public string Kit;
        public float Health;
        public float RoamRange;
        public float ChaseRange;
        public float SenseRange;
        public float AttackRangeMultiplier;
        public bool CheckVisionCone;
        public float VisionCone;
        public float DamageScale;
        public float TurretDamageScale;
        public float AimConeScale;
        public bool DisableRadio;
        public bool CanRunAwayWater;
        public bool CanSleep;
        public float Speed;
        public int AreaMask;
        public int AgentTypeID;
        public float MemoryDuration;
        public List<WearEntry> WearItems;
        public List<BeltEntry> BeltItems;
        [JsonIgnore]
        public JObject Parsed;
        public class BeltEntry
        {
            public string ShortName;
            public ulong SkinID;
            public int Amount;
            public string Ammo;
            public List<string> Mods;
            public static List<BeltEntry> SaveItems(ItemContainer container);
        }

        public class WearEntry
        {
            public string ShortName;
            public ulong SkinID;
            public static List<WearEntry> SaveItems(ItemContainer container);
        }

        public void CacheConfig();
    }

    private void OnServerInitialized();
    private void Init();
    private void Unload();
    private void OnEntityKill(ScientistNPC npc);
    private void OnEntitySpawned(BradleyAPC bradley);
    private void OnEntityDeath(BradleyAPC bradley, HitInfo info);
    private void OnEntityDeath(ScientistNPC npc, HitInfo hitInfo);
    private void OnEntityDismounted(BaseMountable mountable, ScientistNPC scientist);
    private void PerformSetupRoutine();
    private void DestroySetupRoutine();
    private IEnumerator SetupEventsRoutine();
    private class BradleyGuardsEvent : FacepunchBehaviour
    {
        public static readonly List<BradleyGuardsEvent> EventComponents;
        private List<BaseEntity> _spawnInstances;
        private CH47LandingZone _eventLandingZone;
        private CurrentState _eventState;
        private Vector3 _eventPosition;
        private GameObject _go;
        public GuardConfig guardConfig;
        public Vector3 chinookPosition;
        public string displayName;
        public int guardAmount;
        public bool enableAutoExtinguish;
        public bool enableAutoUnlock;
        public OBB bounds;
        public BasePlayer winningPlayer;
        public static BradleyGuardsEvent GetClosest(Vector3 position);
        public static void OnUnload();
        public void Awake();
        public void OnDestroy();
        public void DestroyMe();
        public bool IsStarted();
        public void StartEvent(Vector3 deathPosition);
        private void StopEvent();
        public void ResetEvent();
        public void CheckEvent();
        private bool HasGuards();
        private void UnlockCrates();
        private void RemoveFlames();
        private void RemoveDamage();
        private void SpawnChinook();
        private void DropSmokeGrenade(Vector3 position);
        public void CreateLandingZone();
        private void SpawnGuards(CH47HelicopterAIController chinook, int numToSpawn);
        private void SpawnGuard(CH47HelicopterAIController chinook, Vector3 position);
        public void ClearGuards();
        public void OnGuardDeath(ScientistNPC npc, BasePlayer player);
        private void CachedGuardAdd(BaseEntity entity);
        private void CachedGuardRemove(BaseEntity entity);
        public void DisplayInfo();
    }

    private void ForceChinookLeave(CH47HelicopterAIController chinook);
    private object OnNpcRustEdit(ScientistNPC npc);
    private void HookUnsubscribe();
    private void HookResubscribe();
    private static class CustomProtection
    {
        private static ProtectionProperties ProtectionInstance;
        public static void Initialize();
        public static void OnUnload();
        public static void ModifyProtection(BaseCombatEntity combatEntity);
    }

    private static class EntitiesLookup
    {
        public static Dictionary<BaseEntity, BradleyGuardsEvent> Entities;
        public static BradleyGuardsEvent FindEventByEntity(BaseEntity entity);
        public static void Initialize();
        public static void OnUnload();
        public static void CreateEntity(BaseEntity entity, BradleyGuardsEvent component);
        public static void RemoveEntity(BaseEntity entity);
    }

    private void EventCommands(BasePlayer player, string command, string[] args);
    private void EventHelpText(BasePlayer player);
    private class DebugStopwatch : IDisposable
    {
        private Stopwatch _stopwatch;
        private string _format;
        public DebugStopwatch(string format);
        public void Dispose();
    }

    [AutoPatch]
    [HarmonyPatch(typeof(CH47HelicopterAIController), "CheckSpawnScientists")]
    public static class Prevent_CH47_Scientists_Spawning_Patch
    {
        public static bool Prefix(CH47HelicopterAIController __instance);
    }

}

private class MessageKeys
{
    public static readonly string Prefix;
    public static readonly string NoPermission;
    public static readonly string EventStart;
    public static readonly string EventEnded;
    public static readonly string EventNotFound;
    public static readonly string EventUpdated;
    public static readonly string DisplayNameEmpty;
    public static readonly string InvalidGuardAmount;
    public static readonly string InvalidBooleanValue;
    public static readonly string HelpEventEnable;
    public static readonly string HelpEventName;
    public static readonly string HelpGuardAmount;
    public static readonly string HelpGuardLoadout;
}

private class ConfigData
{
    [JsonProperty("command name")]
    public string CommandName;
    [JsonProperty("enable auto unlock crates when guards are eliminated")]
    public bool EnableAutoUnlock;
    [JsonProperty("enable auto extinguish crates when guards are eliminated")]
    public bool EnableAutoExtinguish;
    [JsonProperty("bradley starting health")]
    public float BradleyHealth;
    [JsonProperty("crate spawn amount")]
    public int CrateSpawnAmount;
    [JsonProperty("message notification settings")]
    public MessageSettings MessageSettings;
    public static ConfigData DefaultConfig();
}

private class MessageSettings
{
    [JsonProperty("enable toast message")]
    public bool EnableToast;
    [JsonProperty("enable chat message")]
    public bool EnableChat;
    [JsonProperty("enable chat prefix")]
    public bool EnableChatPrefix;
    [JsonProperty("custom chat message icon (steam64)")]
    public ulong ChatIcon;
    [JsonProperty("enable gui announcements plugin from umod.org")]
    public bool EnableGuiAnnouncements;
    [JsonProperty("gui announcements text color")]
    public string GuiAnnouncementsTextColor;
    [JsonProperty("gui announcements background color")]
    public string GuiAnnouncementsBgColor;
}

private class StoredData
{
    public Dictionary<string, EventEntry> BradleyEventEntries;
    [JsonIgnore]
    public bool IsValid { get; set; }
    public EventEntry FindEntryByName(string monumentName);
}

private class EventEntry
{
    [JsonProperty("display name")]
    public string DisplayName;
    [JsonProperty("enabled")]
    public bool EnabledEvent;
    [JsonProperty("bounds center")]
    public Vector3 BoundsPosition;
    [JsonProperty("bounds size")]
    public Vector3 BoundsSize;
    [JsonProperty("landing position")]
    public Vector3 LandingPosition;
    [JsonProperty("landing rotation")]
    public Vector3 LandingRotation;
    [JsonProperty("chinook position")]
    public Vector3 ChinookPosition;
    [JsonProperty("guard spawn amount")]
    public int GuardAmount;
    [JsonProperty("guard spawn profile")]
    public GuardConfig GuardConfig;
    public IEnumerator Create(Transform transform, bool enableAutoExtinguish, bool enableAutoUnlock);
}

private class GuardConfig
{
    public string Name;
    public string Kit;
    public float Health;
    public float RoamRange;
    public float ChaseRange;
    public float SenseRange;
    public float AttackRangeMultiplier;
    public bool CheckVisionCone;
    public float VisionCone;
    public float DamageScale;
    public float TurretDamageScale;
    public float AimConeScale;
    public bool DisableRadio;
    public bool CanRunAwayWater;
    public bool CanSleep;
    public float Speed;
    public int AreaMask;
    public int AgentTypeID;
    public float MemoryDuration;
    public List<WearEntry> WearItems;
    public List<BeltEntry> BeltItems;
    [JsonIgnore]
    public JObject Parsed;
    public class BeltEntry
    {
        public string ShortName;
        public ulong SkinID;
        public int Amount;
        public string Ammo;
        public List<string> Mods;
        public static List<BeltEntry> SaveItems(ItemContainer container);
    }

    public class WearEntry
    {
        public string ShortName;
        public ulong SkinID;
        public static List<WearEntry> SaveItems(ItemContainer container);
    }

    public void CacheConfig();
}

public class BeltEntry
{
    public string ShortName;
    public ulong SkinID;
    public int Amount;
    public string Ammo;
    public List<string> Mods;
    public static List<BeltEntry> SaveItems(ItemContainer container);
}

public class WearEntry
{
    public string ShortName;
    public ulong SkinID;
    public static List<WearEntry> SaveItems(ItemContainer container);
}

private class BradleyGuardsEvent : FacepunchBehaviour
{
    public static readonly List<BradleyGuardsEvent> EventComponents;
    private List<BaseEntity> _spawnInstances;
    private CH47LandingZone _eventLandingZone;
    private CurrentState _eventState;
    private Vector3 _eventPosition;
    private GameObject _go;
    public GuardConfig guardConfig;
    public Vector3 chinookPosition;
    public string displayName;
    public int guardAmount;
    public bool enableAutoExtinguish;
    public bool enableAutoUnlock;
    public OBB bounds;
    public BasePlayer winningPlayer;
    public static BradleyGuardsEvent GetClosest(Vector3 position);
    public static void OnUnload();
    public void Awake();
    public void OnDestroy();
    public void DestroyMe();
    public bool IsStarted();
    public void StartEvent(Vector3 deathPosition);
    private void StopEvent();
    public void ResetEvent();
    public void CheckEvent();
    private bool HasGuards();
    private void UnlockCrates();
    private void RemoveFlames();
    private void RemoveDamage();
    private void SpawnChinook();
    private void DropSmokeGrenade(Vector3 position);
    public void CreateLandingZone();
    private void SpawnGuards(CH47HelicopterAIController chinook, int numToSpawn);
    private void SpawnGuard(CH47HelicopterAIController chinook, Vector3 position);
    public void ClearGuards();
    public void OnGuardDeath(ScientistNPC npc, BasePlayer player);
    private void CachedGuardAdd(BaseEntity entity);
    private void CachedGuardRemove(BaseEntity entity);
    public void DisplayInfo();
}

private static class CustomProtection
{
    private static ProtectionProperties ProtectionInstance;
    public static void Initialize();
    public static void OnUnload();
    public static void ModifyProtection(BaseCombatEntity combatEntity);
}

private static class EntitiesLookup
{
    public static Dictionary<BaseEntity, BradleyGuardsEvent> Entities;
    public static BradleyGuardsEvent FindEventByEntity(BaseEntity entity);
    public static void Initialize();
    public static void OnUnload();
    public static void CreateEntity(BaseEntity entity, BradleyGuardsEvent component);
    public static void RemoveEntity(BaseEntity entity);
}

private class DebugStopwatch : IDisposable
{
    private Stopwatch _stopwatch;
    private string _format;
    public DebugStopwatch(string format);
    public void Dispose();
}

[AutoPatch]
[HarmonyPatch(typeof(CH47HelicopterAIController), "CheckSpawnScientists")]
public static class Prevent_CH47_Scientists_Spawning_Patch
{
    public static bool Prefix(CH47HelicopterAIController __instance);
}

Oxide.Plugins.BradleyGuardsExtensionMethods
public static class Utils
{
    public static T CreateObjectWithComponent(Vector3 position, Quaternion rotation, string name);
    public static void Segments(List<Connection> connections, Vector3 origin, Vector3 target, Color color, float duration);
    public static void DLine(List<Connection> connections, Vector3 start, Vector3 end, Color color, float duration);
    public static void DText(List<Connection> connections, Vector3 origin, string text, Color color, float duration);
    public static void DCube(List<Connection> connections, Vector3 center, Quaternion rotation, Vector3 extents, Color color, float duration);
}

public static class ExtensionMethods
{
    public static bool IsNullOrEmpty(string value);
    public static bool IsReady(Plugin plugin);
    public static Vector3 GetPointAround(Vector3 position, float radius);
}


```

---

## BradleyProtection by Nobu - Protects you from the tank (Bradley APC) and vice versa

```csharp
using Newtonsoft.Json;

Oxide.Plugins
[Info("Bradley Protection", "Nobu", "1.0.2")]
[Description("Protects you from the tank and vice versa")]
 class BradleyProtection : RustPlugin
{
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Use permissions to enable")]
        public bool perms;
        [JsonProperty(PropertyName = "Time on server before bradley targets them")]
        public double contime;
        [JsonProperty(PropertyName = "Protect players from bradley")]
        public bool protectplayer;
        [JsonProperty(PropertyName = "Protect bradley from players")]
        public bool protecttank;
    }

    private bool LoadConfigVariables();
     void Init();
    protected override void LoadDefaultConfig();
     void SaveConfig(ConfigData config);
     bool? CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity);
     object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Use permissions to enable")]
    public bool perms;
    [JsonProperty(PropertyName = "Time on server before bradley targets them")]
    public double contime;
    [JsonProperty(PropertyName = "Protect players from bradley")]
    public bool protectplayer;
    [JsonProperty(PropertyName = "Protect bradley from players")]
    public bool protecttank;
}


```

---

## BreakableCCTV by Clearshot - Shoot monument CCTV cameras to temporarily disable them

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;

Oxide.Plugins
[Info("Breakable CCTV", "Clearshot", "1.1.0")]
[Description("Shoot monument CCTV cameras to temporarily disable them")]
 class BreakableCCTV : CovalencePlugin
{
    private PluginConfig _config;
    private Game.Rust.Libraries.Player _rustPlayer;
    private Dictionary<string, int> _cctvHealth;
    private void SendChatMsg(BasePlayer pl, string msg, string prefix);
    private void OnServerInitialized();
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void Unload();
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadConfig();
    private class PluginConfig
    {
        public string chatIconID;
        public int globalRespawnTime;
        public int damagePerHitMin;
        public int damagePerHitMax;
        public string destroyEffect;
        public string restoreEffect;
        public Dictionary<string, CCTVConfig> cctvConfig;
    }

    private class CCTVConfig
    {
        public bool enabled;
        public int health;
        public int respawnTime;
    }

}

private class PluginConfig
{
    public string chatIconID;
    public int globalRespawnTime;
    public int damagePerHitMin;
    public int damagePerHitMax;
    public string destroyEffect;
    public string restoreEffect;
    public Dictionary<string, CCTVConfig> cctvConfig;
}

private class CCTVConfig
{
    public bool enabled;
    public int health;
    public int respawnTime;
}


```

---

## Build by DevGonzi - Build, spawn, plant, upgrade, deploy anything the way that you want it

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Facepunch;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Build", "Gonzi", "2.2.2")]
[Description("Build, spawn, plant, upgrade, deploy anything the way that you want it")]
public class Build : RustPlugin
{
    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string parent, string panelName, string color, string aMin, string aMax, bool useCursor);
        static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateImage(CuiElementContainer container, string panel, string url, string name, string aMin, string aMax, bool cursor);
        static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
        static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
    }

     bool permBuildForAll;
    private static float mdist;
    private static int generalColl;
    private static int constructionColl;
    private string green;
    private string red;
    private string gray;
    private string lightgray;
    private string permBuild;
    private static Vector3 newPos;
    private static Quaternion newRot;
    private static Quaternion defaultQuaternion;
    private static BuildingConstruction sourcebuild;
    private static BuildingConstruction targetbuild;
    private static Dictionary<string, BuildingConstruction> buildings;
    private static Dictionary<Building, string> BuildingToPrefab;
    private static Dictionary<string, uint> deployables;
    private static List<string> resourcesList;
    private static Dictionary<string, string> resourcesDictionary;
    private static List<string> resourcesListSortedKeys;
    private static List<object> houseList;
    private static List<Vector3> checkFrom;
    private Dictionary<ulong, PlayerBuild> playerBuild;
    private Dictionary<ulong, bool> buildToggled;
    static Build build;
     bool hasAuth(BasePlayer player);
     void OnServerInitialized();
     void OnPlayerInput(BasePlayer player, InputState state);
     void BuildMenu_Toggle(BasePlayer player);
     void BuildMenu_UnToggle(BasePlayer player);
     void BuildMenu_Sub(BasePlayer player);
    private void SortResourcesList();
     void BuildGUI_Refresh(BasePlayer player);
     class BuildLog
    {
        public GameObject go;
        public PlayerBuildType e;
        public string svalue1;
        public float fvalue1;
        public int ivalue1;
        public Vector3 vvalue1;
        public Quaternion qvalue1;
        public BuildingGrade.Enum bvalue1;
        public BuildLog(GameObject go, PlayerBuildType e);
        public BuildLog(GameObject go, PlayerBuildType e, float value1);
        public BuildLog(GameObject go, PlayerBuildType e, int value1);
        public BuildLog(GameObject go, PlayerBuildType e, Vector3 value1);
        public BuildLog(GameObject go, PlayerBuildType e, Quaternion value1);
        public BuildLog(string value1, PlayerBuildType e, Vector3 value2, Quaternion value3, BuildingGrade.Enum value4);
    }

     class PlayerBuild
    {
        public bool crosshair;
        public int spawnpage;
        public int deploypage;
        public float height;
        public float rotation;
        public float lastClick;
        public string currentSpawn;
        public object closestEnt;
        public Vector3 closestHitpoint;
        public Quaternion currentRot;
        public Quaternion currentRotate;
        public Quaternion rotate;
        public BasePlayer player;
        public BaseNetworkable currentBaseNet;
        public Collider currentCollider;
        public Construction currentConstruction;
        public Building constructionBuild;
        public BuildingGrade.Enum grade;
        public Selection select;
        public Placement placement;
        public PlayerBuildType buildType;
        public List<List<BuildLog>> logs;
        public PlayerBuild(BasePlayer player);
        public void Execute();
    }

     class VectorQuaternion
    {
        public Vector3 vector3;
        public Quaternion quaternion;
        public VectorQuaternion(Vector3 vector3, Quaternion quaternion);
    }

     class BuildingSocket
    {
        public SocketType sock;
        public Dictionary<SocketType, List<VectorQuaternion>> sockets;
        public BuildingSocket(SocketType sock);
        public void AddTargetSock(SocketType s, Vector3 v, Quaternion q);
    }

     class BuildingConstruction
    {
        public string prefab;
        public BuildingSocket socket;
        public Building build;
        public BuildingConstruction(string prefab, BuildingSocket socket, Building build);
    }

    private static bool TryGetPlayerView(BasePlayer player, Quaternion viewAngle);
    private static bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, object closestEnt, Vector3 closestHitpoint);
    static private void DoHeal(PlayerBuild buildplayer, BasePlayer player, Collider baseentity);
    static bool GetAllBaseEntities(BaseEntity initialEntity);
    private static void DoSpawn(PlayerBuild buildplayer, BasePlayer player, Collider baseentity);
    private static void DoBuild(PlayerBuild buildplayer, BasePlayer player, Collider baseentity, Placement placement);
    private static bool IsColliding(string prefabname, Vector3 position, float radius);
    private static GameObject SpawnPrefab(string prefabname, Vector3 pos, Quaternion angles, bool active);
    private static void SpawnStructure(PlayerBuild bp, string prefabname, Vector3 pos, Quaternion angles, BuildingGrade.Enum grade, float health, uint buildingID);
    private static void SpawnEntity(PlayerBuild bp, string prefabname, Vector3 pos, Quaternion angles);
    private static void DoDeploy(PlayerBuild buildplayer, BasePlayer player, Collider baseentity);
    private static void DoGrade(PlayerBuild buildplayer, BasePlayer player, Collider baseentity);
    private static void SetGrade(BuildingBlock block, BuildingGrade.Enum level);
    private static void DoRotation(PlayerBuild buildplayer, BasePlayer player, Collider baseentity);
    private static void SetRotation(BaseEntity baseentity, Quaternion rotation);
    [ConsoleCommand("build.select")]
    private void cmdBuildSelect(ConsoleSystem.Arg arg);
    private T[] GetAllPrefabs();
}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string parent, string panelName, string color, string aMin, string aMax, bool useCursor);
    static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateImage(CuiElementContainer container, string panel, string url, string name, string aMin, string aMax, bool cursor);
    static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
    static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
}

 class BuildLog
{
    public GameObject go;
    public PlayerBuildType e;
    public string svalue1;
    public float fvalue1;
    public int ivalue1;
    public Vector3 vvalue1;
    public Quaternion qvalue1;
    public BuildingGrade.Enum bvalue1;
    public BuildLog(GameObject go, PlayerBuildType e);
    public BuildLog(GameObject go, PlayerBuildType e, float value1);
    public BuildLog(GameObject go, PlayerBuildType e, int value1);
    public BuildLog(GameObject go, PlayerBuildType e, Vector3 value1);
    public BuildLog(GameObject go, PlayerBuildType e, Quaternion value1);
    public BuildLog(string value1, PlayerBuildType e, Vector3 value2, Quaternion value3, BuildingGrade.Enum value4);
}

 class PlayerBuild
{
    public bool crosshair;
    public int spawnpage;
    public int deploypage;
    public float height;
    public float rotation;
    public float lastClick;
    public string currentSpawn;
    public object closestEnt;
    public Vector3 closestHitpoint;
    public Quaternion currentRot;
    public Quaternion currentRotate;
    public Quaternion rotate;
    public BasePlayer player;
    public BaseNetworkable currentBaseNet;
    public Collider currentCollider;
    public Construction currentConstruction;
    public Building constructionBuild;
    public BuildingGrade.Enum grade;
    public Selection select;
    public Placement placement;
    public PlayerBuildType buildType;
    public List<List<BuildLog>> logs;
    public PlayerBuild(BasePlayer player);
    public void Execute();
}

 class VectorQuaternion
{
    public Vector3 vector3;
    public Quaternion quaternion;
    public VectorQuaternion(Vector3 vector3, Quaternion quaternion);
}

 class BuildingSocket
{
    public SocketType sock;
    public Dictionary<SocketType, List<VectorQuaternion>> sockets;
    public BuildingSocket(SocketType sock);
    public void AddTargetSock(SocketType s, Vector3 v, Quaternion q);
}

 class BuildingConstruction
{
    public string prefab;
    public BuildingSocket socket;
    public Building build;
    public BuildingConstruction(string prefab, BuildingSocket socket, Building build);
}


```

---

## BuildCost by Lincoln - Calculate the cost of your structure and its deployables.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("BuildCost", "Lincoln & ignignokt84", "1.0.4")]
[Description("Calculates the cost of building a structure and its deployables")]
 class BuildCost : CovalencePlugin
{
    const string PermCanUse;
    private static readonly int WOOD_ID;
    private static readonly int STONE_ID;
    private static readonly int METAL_ID;
    private static readonly int HQM_ID;
     CostAggregator aggregator;
     Dictionary<uint, int> deployableLookup;
     void Init();
     void OnServerInitialized();
     void BuildDeployableLookups();
     void CalculateCost(IPlayer player, string command, string[] args);
     bool GetRaycastTarget(BasePlayer player, BaseEntity closestEntity);
     bool GetStructure(BaseEntity initialBlock, HashSet<BuildingBlock> structure, HashSet<BaseEntity> deployables);
     void CalculateBuildingBlockCost(HashSet<BuildingBlock> blocks, bool includeTwigCost);
     void CalculateDeployableCost(HashSet<BaseEntity> deployables);
     class CostAggregator
    {
        public Dictionary<int, float> materialCosts;
        public void Reset();
        public void AddCosts(List<ItemAmount> costs);
        public string GetFormattedCost();
        public bool IsEmpty();
    }

}

 class CostAggregator
{
    public Dictionary<int, float> materialCosts;
    public void Reset();
    public void AddCosts(List<ItemAmount> costs);
    public string GetFormattedCost();
    public bool IsEmpty();
}


```

---

## BuildingActions by misticos - Rotate and demolish buildings when you want

```csharp
using System;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Building Actions", "Iv Misticos", "1.1.2")]
[Description("Rotate and demolish buildings when you want!")]
 class BuildingActions : RustPlugin
{
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Owner Can Demolish")]
        public bool DemolishOwner;
        [JsonProperty(PropertyName = "Owner Can Repair")]
        public bool RepairOwner;
        [JsonProperty(PropertyName = "Owner Can Rotate")]
        public bool RotateOwner;
        [JsonProperty(PropertyName = "Owner Can Upgrade")]
        public bool UpgradeOwner;
        [JsonProperty(PropertyName = "In-game Friend Can Demolish")]
        public bool DemolishFriend;
        [JsonProperty(PropertyName = "In-game Friend Can Repair")]
        public bool RepairFriend;
        [JsonProperty(PropertyName = "In-game Friend Can Rotate")]
        public bool RotateFriend;
        [JsonProperty(PropertyName = "In-game Friend Can Upgrade")]
        public bool UpgradeFriend;
        [JsonProperty(PropertyName = "Authorized Can Demolish")]
        public bool DemolishAuthorized;
        [JsonProperty(PropertyName = "Authorized Can Repair")]
        public bool RepairAuthorized;
        [JsonProperty(PropertyName = "Authorized Can Rotate")]
        public bool RotateAuthorized;
        [JsonProperty(PropertyName = "Authorized Can Upgrade")]
        public bool UpgradeAuthorized;
        [JsonProperty(PropertyName = "Admin Can Demolish")]
        public bool DemolishAdmin;
        [JsonProperty(PropertyName = "Admin Can Repair")]
        public bool RepairAdmin;
        [JsonProperty(PropertyName = "Admin Can Rotate")]
        public bool RotateAdmin;
        [JsonProperty(PropertyName = "Admin Can Upgrade")]
        public bool UpgradeAdmin;
        [JsonProperty(PropertyName = "Ignore settings")]
        public bool IgnoreSettings;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void OnEntitySpawned(BaseNetworkable entity);
    private object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player, bool immediate);
    private object OnStructureRepair(BaseCombatEntity entity, BasePlayer player);
    private object OnStructureRotate(BaseCombatEntity entity, BasePlayer player);
    private object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade);
    private void TryChangeProperties(BuildingBlock block);
    private bool AreRelationshipFriends(BasePlayer player, ulong target);
    private bool IsAuthorized(BasePlayer player, BaseEntity block);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Owner Can Demolish")]
    public bool DemolishOwner;
    [JsonProperty(PropertyName = "Owner Can Repair")]
    public bool RepairOwner;
    [JsonProperty(PropertyName = "Owner Can Rotate")]
    public bool RotateOwner;
    [JsonProperty(PropertyName = "Owner Can Upgrade")]
    public bool UpgradeOwner;
    [JsonProperty(PropertyName = "In-game Friend Can Demolish")]
    public bool DemolishFriend;
    [JsonProperty(PropertyName = "In-game Friend Can Repair")]
    public bool RepairFriend;
    [JsonProperty(PropertyName = "In-game Friend Can Rotate")]
    public bool RotateFriend;
    [JsonProperty(PropertyName = "In-game Friend Can Upgrade")]
    public bool UpgradeFriend;
    [JsonProperty(PropertyName = "Authorized Can Demolish")]
    public bool DemolishAuthorized;
    [JsonProperty(PropertyName = "Authorized Can Repair")]
    public bool RepairAuthorized;
    [JsonProperty(PropertyName = "Authorized Can Rotate")]
    public bool RotateAuthorized;
    [JsonProperty(PropertyName = "Authorized Can Upgrade")]
    public bool UpgradeAuthorized;
    [JsonProperty(PropertyName = "Admin Can Demolish")]
    public bool DemolishAdmin;
    [JsonProperty(PropertyName = "Admin Can Repair")]
    public bool RepairAdmin;
    [JsonProperty(PropertyName = "Admin Can Rotate")]
    public bool RotateAdmin;
    [JsonProperty(PropertyName = "Admin Can Upgrade")]
    public bool UpgradeAdmin;
    [JsonProperty(PropertyName = "Ignore settings")]
    public bool IgnoreSettings;
}


```

---

## BuildingBlocker by  - Fully prevents building in the building blocked zone

```csharp
using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using System.Reflection;
using System.Linq;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("BuildingBlocker", "Vlad-00003", "2.4.0", ResourceId = 2456)]
[Description("Blocks building in the building privilage zone. Deactivates raids update.")]
 class BuildingBlocker : RustPlugin
{
    private string BypassPrivilege;
    private string Prefix;
    private string PrefixColor;
    private bool LadderBuilding;
    private bool BlockBuildings;
    [PluginReference]
     Plugin NoEscape;
    private static float CupRadius;
     Collider[] colBuffer;
    private string BypassPrivilageCfg;
    private string PrefixCfg;
    private string PrefixColorCfg;
    private string LadderBuildingCfg;
    private string BlockBuildingsCfg;
     string GetMsg(string key, object userID);
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
     object CanBuild(Planner plan, Construction prefab);
    public object BuildingBlocked(Planner plan, Construction prefab);
    private void SendToChat(BasePlayer Player, string Message);
    private bool GetConfig(string Key, T var);
}


```

---

## BuildingBlockGUI by misticos - Displays GUI to player when he enters or leaves building block without need of Planner

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Building Block GUI", "Iv Misticos", "2.0.1")]
[Description("Displays GUI to player when he enters or leaves building block without need of Planner")]
public class BuildingBlockGUI : RustPlugin
{
    private GameObject _controller;
    private static BuildingBlockGUI _ins;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Use Image")]
        public bool UseImage;
        [JsonProperty(PropertyName = "Image URL")]
        public string ImageURL;
        [JsonProperty(PropertyName = "Use GameTips")]
        public bool UseGameTips;
        [JsonProperty(PropertyName = "Check Frequency")]
        public float CheckFrequency;
        [JsonProperty(PropertyName = "Background Color")]
        public string BackgroundColor;
        [JsonProperty(PropertyName = "Anchor Min")]
        public string AnchorMin;
        [JsonProperty(PropertyName = "Anchor Max")]
        public string AnchorMax;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerDisconnected(BasePlayer player);
    private class BuildingController : MonoBehaviour
    {
        private static List<BasePlayer> _activeUI;
        private void OnDestroy();
        private void Awake();
        private void OnControllerTick();
        private static void CreateUI(BasePlayer player);
        public static void DestroyUI(BasePlayer player);
    }

    private static string GetMsg(string key, string userId);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Use Image")]
    public bool UseImage;
    [JsonProperty(PropertyName = "Image URL")]
    public string ImageURL;
    [JsonProperty(PropertyName = "Use GameTips")]
    public bool UseGameTips;
    [JsonProperty(PropertyName = "Check Frequency")]
    public float CheckFrequency;
    [JsonProperty(PropertyName = "Background Color")]
    public string BackgroundColor;
    [JsonProperty(PropertyName = "Anchor Min")]
    public string AnchorMin;
    [JsonProperty(PropertyName = "Anchor Max")]
    public string AnchorMax;
}

private class BuildingController : MonoBehaviour
{
    private static List<BasePlayer> _activeUI;
    private void OnDestroy();
    private void Awake();
    private void OnControllerTick();
    private static void CreateUI(BasePlayer player);
    public static void DestroyUI(BasePlayer player);
}


```

---

## BuildingBlockSafeZone by Ryz0r - Completely disables the hot bar while a user is inside of a building blocked zone.

```csharp
using Oxide.Core.Libraries;
using UnityEngine;

Oxide.Plugins
[Info("Building Block Safe Zone", "Ryz0r", "1.0.3")]
[Description("Prevents access to items in the hotbar while in a safe zone.")]
public class BuildingBlockSafeZone : RustPlugin
{
    private GameObject _privController;
    private static BuildingBlockSafeZone _plugin;
    private const string BypassPerm;
    private void OnServerInitialized();
    private void Init();
    private void Unload();
    private class PrivilegeUpdater : MonoBehaviour
    {
        private void Awake();
        private void OnTick();
    }

}

private class PrivilegeUpdater : MonoBehaviour
{
    private void Awake();
    private void OnTick();
}


```

---

## BuildingGrades by VisEntities - Allows players to easily upgrade or downgrade an entire building

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("Building Grades", "Default/Arainrr", "1.0.13")]
[Description("Allows players to easily upgrade or downgrade an entire building")]
public class BuildingGrades : RustPlugin
{
    [PluginReference]
    private readonly Plugin Friends;
    private readonly Plugin Clans;
    private readonly Plugin NoEscape;
    private readonly Plugin RustTranslationAPI;
    private const string PermissionUpPrefix;
    private const string PermissionDownPrefx;
    private const string PermissionUse;
    private const string PermissionUpAll;
    private const string PermissionDownAll;
    private const string PermissionNoCost;
    private const string PermissionAdmin;
    private static BuildingGrades _instance;
    private BuildingGradeAssistant _assistant;
    private readonly Dictionary<string, HashSet<uint>> _categories;
    private static readonly List<BuildingGrade.Enum> ValidGrades;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnRaidBlock(BasePlayer player);
    private void OnCombatBlock(BasePlayer player);
    private void CmdUpgrade(BasePlayer player, string command, string[] args);
    private void CmdDowngrade(BasePlayer player, string command, string[] args);
    private void CmdUpgradeAll(BasePlayer player, string command, string[] args);
    private void CmdDowngradeAll(BasePlayer player, string command, string[] args);
    private void HandleCommand(BasePlayer player, string[] args, bool isUpgrade, bool isAll);
    private PermissionSettings GetPermissionSettings(BasePlayer player);
    private bool HasGradePermission(BasePlayer player, BuildingGrade.Enum grade, bool isUpgrade);
    private bool AreFriends(ulong playerId, ulong friendId);
    private static bool SameTeam(ulong playerId, ulong friendId);
    private bool HasFriend(ulong playerId, ulong friendId);
    private bool SameClan(ulong playerId, ulong friendId);
    private bool IsPlayerBlocked(BasePlayer player);
    private bool IsRaidBlocked(string playerId);
    private bool IsCombatBlocked(string playerId);
    private string GetItemTranslationByShortName(string language, string itemShortName);
    private string GetItemDisplayName(string language, ItemDefinition itemDefinition);
    private class BuildingGradeAssistant
    {
        private BuildingGrades Plugin { get; set; }
        private Coroutine _changeGradeCoroutine;
        private readonly Dictionary<ulong, bool> _tempFriends;
        private readonly HashSet<BuildingBlock> _allBuildingBlocks;
        private readonly List<BuildingGrade.Enum> _tempGrantedGrades;
        private readonly List<Item> _collect;
        private readonly Hash<int, float> _takeOutItems;
        private readonly Hash<ItemDefinition, int> _missingItems;
        private HashSet<ulong> _blockedPlayers;
        private readonly Dictionary<ulong, float> _cooldowns;
        private BuildingBlock _processingBuildingBlock;
        internal bool IsRunning();
        internal void Unload();
        internal void BlockPlayer(ulong playerId);
        internal bool IsProcessingBuildingBlock(BuildingBlock buildingBlock);
        internal void Run(BuildingBlock sourceEntity, BasePlayer player, BuildingGrade.Enum targetGrade, HashSet<uint> filter, PermissionSettings permissionSettings, bool isUpgrade, bool isAll, bool isAdmin);
        internal float GetCooldownLeft(ulong playerId, float cooldown);
        internal bool FindPlayerGrantedGrades(BasePlayer player, bool isUpgrade);
        private IEnumerator StartChangeBuildingGrade(BuildingBlock sourceEntity, BasePlayer player, BuildingGrade.Enum targetGrade, HashSet<uint> filter, PermissionSettings permissionSettings, bool isUpgrade, bool isAll, bool isAdmin);
        private bool ShouldInterrupt(ulong playerId);
        private IEnumerator UpgradeBuildingBlocks(BasePlayer player, BuildingGrade.Enum targetGrade, PermissionSettings permissionSettings, bool isAdmin);
        private bool TryUpgradeToGrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool pay, bool isAdmin);
        private bool CanUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool pay, bool isAdmin);
        public bool CanAffordUpgrade(BuildingBlock buildingBlock, ConstructionGrade constructionGrade, BasePlayer player, BuildingGrade.Enum grade);
        public void PayForUpgrade(BuildingBlock buildingBlock, ConstructionGrade constructionGrade, BasePlayer player);
        private IEnumerator DowngradeBuildingBlocks(BasePlayer player, BuildingGrade.Enum targetGrade, PermissionSettings permissionSettings, bool isAdmin);
        private bool TryDowngradeToGrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool refund, bool isAdmin);
        private bool CanDowngrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool refund, bool isAdmin);
        private bool HasAccess(BasePlayer player, BuildingBlock buildingBlock);
        private IEnumerator GetAllBuildingBlocks(BuildingBlock sourceEntity, HashSet<uint> filter, bool isAll);
    }

    private static BuildingBlock GetBuildingBlockLookingAt(BasePlayer player, PermissionSettings permissionSettings);
    private static bool CheckBuildingGrade(BuildingBlock buildingBlock, bool isUpgrade, BuildingGrade.Enum targetGrade);
    private static bool IsValidGrade(ConstructionGrade[] grades, int targetGrade);
    private static void SetBuildingBlockGrade(BuildingBlock buildingBlock, BuildingGrade.Enum targetGrade);
    private static IEnumerator GetNearbyEntities(T sourceEntity, HashSet<T> entities, int layers, Func<T, bool> filter);
    private bool IsProcessingBuildingBlock(BuildingBlock buildingBlock);
    private ConfigData _configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Settings")]
        public GlobalSettings Global { get; set; }
        [JsonProperty(PropertyName = "Chat Settings")]
        public ChatSettings Chat { get; set; }
        [JsonProperty(PropertyName = "Permission Settings")]
        public Dictionary<string, PermissionSettings> Permissions { get; set; }
        [JsonProperty(PropertyName = "Building Block Categories", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, HashSet<string>> Categories { get; set; }
    }

    private class GlobalSettings
    {
        [JsonProperty(PropertyName = "Use Teams")]
        public bool UseTeams { get; set; }
        [JsonProperty(PropertyName = "Use Clans")]
        public bool UseClans { get; set; }
        [JsonProperty(PropertyName = "Use Friends")]
        public bool UseFriends { get; set; }
        [JsonProperty(PropertyName = "Use Raid Blocker (Need NoEscape Plugin)")]
        public bool UseRaidBlocker { get; set; }
        [JsonProperty(PropertyName = "Use Combat Blocker (Need NoEscape Plugin)")]
        public bool UseCombatBlocker { get; set; }
        [JsonProperty(PropertyName = "Cooldown Exclude Admins")]
        public bool CooldownExclude { get; set; }
        [JsonProperty(PropertyName = "Upgrade/Downgrade Per Frame")]
        public int PerFrame { get; set; }
    }

    private class ChatSettings
    {
        [JsonProperty(PropertyName = "Upgrade Chat Command")]
        public string UpgradeCommand { get; set; }
        [JsonProperty(PropertyName = "Downgrade Chat Command")]
        public string DowngradeCommand { get; set; }
        [JsonProperty(PropertyName = "Upgrade All Chat Command")]
        public string UpgradeAllCommand { get; set; }
        [JsonProperty(PropertyName = "Downgrade All Chat Command")]
        public string DowngradeAllCommand { get; set; }
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string Prefix { get; set; }
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong SteamIdIcon { get; set; }
    }

    public class PermissionSettings
    {
        [JsonProperty(PropertyName = "Priority")]
        public int Priority { get; set; }
        [JsonProperty(PropertyName = "Distance")]
        public float Distance { get; set; }
        [JsonProperty(PropertyName = "Cooldown")]
        public float Cooldown { get; set; }
        [JsonProperty(PropertyName = "Pay")]
        public bool Pay { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Print(BasePlayer player, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

private class BuildingGradeAssistant
{
    private BuildingGrades Plugin { get; set; }
    private Coroutine _changeGradeCoroutine;
    private readonly Dictionary<ulong, bool> _tempFriends;
    private readonly HashSet<BuildingBlock> _allBuildingBlocks;
    private readonly List<BuildingGrade.Enum> _tempGrantedGrades;
    private readonly List<Item> _collect;
    private readonly Hash<int, float> _takeOutItems;
    private readonly Hash<ItemDefinition, int> _missingItems;
    private HashSet<ulong> _blockedPlayers;
    private readonly Dictionary<ulong, float> _cooldowns;
    private BuildingBlock _processingBuildingBlock;
    internal bool IsRunning();
    internal void Unload();
    internal void BlockPlayer(ulong playerId);
    internal bool IsProcessingBuildingBlock(BuildingBlock buildingBlock);
    internal void Run(BuildingBlock sourceEntity, BasePlayer player, BuildingGrade.Enum targetGrade, HashSet<uint> filter, PermissionSettings permissionSettings, bool isUpgrade, bool isAll, bool isAdmin);
    internal float GetCooldownLeft(ulong playerId, float cooldown);
    internal bool FindPlayerGrantedGrades(BasePlayer player, bool isUpgrade);
    private IEnumerator StartChangeBuildingGrade(BuildingBlock sourceEntity, BasePlayer player, BuildingGrade.Enum targetGrade, HashSet<uint> filter, PermissionSettings permissionSettings, bool isUpgrade, bool isAll, bool isAdmin);
    private bool ShouldInterrupt(ulong playerId);
    private IEnumerator UpgradeBuildingBlocks(BasePlayer player, BuildingGrade.Enum targetGrade, PermissionSettings permissionSettings, bool isAdmin);
    private bool TryUpgradeToGrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool pay, bool isAdmin);
    private bool CanUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool pay, bool isAdmin);
    public bool CanAffordUpgrade(BuildingBlock buildingBlock, ConstructionGrade constructionGrade, BasePlayer player, BuildingGrade.Enum grade);
    public void PayForUpgrade(BuildingBlock buildingBlock, ConstructionGrade constructionGrade, BasePlayer player);
    private IEnumerator DowngradeBuildingBlocks(BasePlayer player, BuildingGrade.Enum targetGrade, PermissionSettings permissionSettings, bool isAdmin);
    private bool TryDowngradeToGrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool refund, bool isAdmin);
    private bool CanDowngrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum targetGrade, bool refund, bool isAdmin);
    private bool HasAccess(BasePlayer player, BuildingBlock buildingBlock);
    private IEnumerator GetAllBuildingBlocks(BuildingBlock sourceEntity, HashSet<uint> filter, bool isAll);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Settings")]
    public GlobalSettings Global { get; set; }
    [JsonProperty(PropertyName = "Chat Settings")]
    public ChatSettings Chat { get; set; }
    [JsonProperty(PropertyName = "Permission Settings")]
    public Dictionary<string, PermissionSettings> Permissions { get; set; }
    [JsonProperty(PropertyName = "Building Block Categories", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, HashSet<string>> Categories { get; set; }
}

private class GlobalSettings
{
    [JsonProperty(PropertyName = "Use Teams")]
    public bool UseTeams { get; set; }
    [JsonProperty(PropertyName = "Use Clans")]
    public bool UseClans { get; set; }
    [JsonProperty(PropertyName = "Use Friends")]
    public bool UseFriends { get; set; }
    [JsonProperty(PropertyName = "Use Raid Blocker (Need NoEscape Plugin)")]
    public bool UseRaidBlocker { get; set; }
    [JsonProperty(PropertyName = "Use Combat Blocker (Need NoEscape Plugin)")]
    public bool UseCombatBlocker { get; set; }
    [JsonProperty(PropertyName = "Cooldown Exclude Admins")]
    public bool CooldownExclude { get; set; }
    [JsonProperty(PropertyName = "Upgrade/Downgrade Per Frame")]
    public int PerFrame { get; set; }
}

private class ChatSettings
{
    [JsonProperty(PropertyName = "Upgrade Chat Command")]
    public string UpgradeCommand { get; set; }
    [JsonProperty(PropertyName = "Downgrade Chat Command")]
    public string DowngradeCommand { get; set; }
    [JsonProperty(PropertyName = "Upgrade All Chat Command")]
    public string UpgradeAllCommand { get; set; }
    [JsonProperty(PropertyName = "Downgrade All Chat Command")]
    public string DowngradeAllCommand { get; set; }
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string Prefix { get; set; }
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong SteamIdIcon { get; set; }
}

public class PermissionSettings
{
    [JsonProperty(PropertyName = "Priority")]
    public int Priority { get; set; }
    [JsonProperty(PropertyName = "Distance")]
    public float Distance { get; set; }
    [JsonProperty(PropertyName = "Cooldown")]
    public float Cooldown { get; set; }
    [JsonProperty(PropertyName = "Pay")]
    public bool Pay { get; set; }
}


```

---

## BuildingHealth by Judess69er - Allows changing the maximum health of buildings

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Building Health", "Judess69er/Orange", "1.1.3")]
[Description("Allows you to change the maximum health of buildings")]
public class BuildingHealth : RustPlugin
{
    private Dictionary<ulong, float> data;
    private List<string> changed;
    private static readonly string[] buildingBlocks;
    private void OnServerInitialized();
    private void Unload();
    private void OnEntityBuilt(Planner plan, GameObject go);
    private void Update(bool unload);
    private void CheckEntity(BaseEntity entity);
    private void UpdateDB();
    private void ResetHP();
    private void ResetMultiplier(bool reset);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Building health in percents")]
        public Dictionary<string, int> percents;
    }

    protected override void LoadConfig();
    private static void ValidateConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Building health in percents")]
    public Dictionary<string, int> percents;
}


```

---

## BuildingInfo by misticos - Scan buildings and get their owners

```csharp
using System;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Building Info", "misticos", "1.0.7")]
[Description("Scan buildings and get their owners")]
 class BuildingInfo : RustPlugin
{
    private const string PermScan;
    private const string PermOwner;
    private const string PermAuthed;
    private const string PermBypass;
    private Configuration _config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Command Scan")]
        public string CommandScan;
        [JsonProperty(PropertyName = "Command Scan Owner")]
        public string CommandOwner;
        [JsonProperty(PropertyName = "Command Scan Authorized Players")]
        public string CommandAuthed;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void CommandChatScan(BasePlayer player, string command, string[] args);
    private void CommandChatOwner(BasePlayer player, string command, string[] args);
    private void CommandChatAuthed(BasePlayer player, string command, string[] args);
    protected override void LoadDefaultMessages();
    private void Init();
    private string GetMsg(string key, string userId);
    private BaseEntity GetBuilding(BasePlayer player);
}

public class Configuration
{
    [JsonProperty(PropertyName = "Command Scan")]
    public string CommandScan;
    [JsonProperty(PropertyName = "Command Scan Owner")]
    public string CommandOwner;
    [JsonProperty(PropertyName = "Command Scan Authorized Players")]
    public string CommandAuthed;
}


```

---

## BuildingRestriction by MrBlue - Restricts building height, building in water, and number of foundations

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Building Restriction", "Wulf/lukespragg", "1.5.8")]
[Description("Restricts building height, building in water, number of foundations, and more")]
public class BuildingRestriction : CovalencePlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Restrict build height (true/false)")]
        public bool RestrictBuildHeight { get; set; }
        [JsonProperty(PropertyName = "Maximum build height")]
        public int MaxBuildHeight { get; set; }
        [JsonProperty(PropertyName = "Restrict foundations (true/false)")]
        public bool RestrictFoundations { get; set; }
        [JsonProperty(PropertyName = "Maximum foundations")]
        public int MaxFoundations { get; set; }
        [JsonProperty(PropertyName = "Maximum triangle foundations")]
        public int MaxTriFoundations { get; set; }
        [JsonProperty(PropertyName = "Restrict tool cupboards (true/false)")]
        public bool RestrictToolCupboards { get; set; }
        [JsonProperty(PropertyName = "Maximum tool cupboards")]
        public int MaxToolCupboards { get; set; }
        [JsonProperty(PropertyName = "Restrict water depth (true/false)")]
        public bool RestrictWaterDepth { get; set; }
        [JsonProperty(PropertyName = "Maximum water depth")]
        public double MaxWaterDepth { get; set; }
        [JsonProperty(PropertyName = "Refund resources when restricted")]
        public bool RefundResources { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private const string foundation;
    private const string triFoundation;
    private const string permBypass;
    private readonly Dictionary<ulong, List<BuildingBlock>> buildingIds;
    private readonly Dictionary<ulong, List<PlayerNameID>> toolCupboards;
    private readonly List<string> allowedBuildingBlocks;
    private void OnServerInitialized();
    private void FindStructures();
    private void FindToolCupboards();
    private void RefundResources(BasePlayer player, BuildingBlock buildingBlock);
    private void OnEntityBuilt(Planner planner, GameObject go);
    private void HandleRemoval(BaseCombatEntity entity);
    private void OnStructureDemolish(BaseCombatEntity entity);
    private void OnItemDeployed(Deployer deployer, BaseEntity entity);
    private void OnEntityDeath(BaseCombatEntity entity);
    private int GetCountOf(List<BuildingBlock> ConnectingStructure, string buildingObject);
    private string Lang(string key, string id, object[] args);
    private void Message(IPlayer player, string key, object[] args);
}

public class Configuration
{
    [JsonProperty(PropertyName = "Restrict build height (true/false)")]
    public bool RestrictBuildHeight { get; set; }
    [JsonProperty(PropertyName = "Maximum build height")]
    public int MaxBuildHeight { get; set; }
    [JsonProperty(PropertyName = "Restrict foundations (true/false)")]
    public bool RestrictFoundations { get; set; }
    [JsonProperty(PropertyName = "Maximum foundations")]
    public int MaxFoundations { get; set; }
    [JsonProperty(PropertyName = "Maximum triangle foundations")]
    public int MaxTriFoundations { get; set; }
    [JsonProperty(PropertyName = "Restrict tool cupboards (true/false)")]
    public bool RestrictToolCupboards { get; set; }
    [JsonProperty(PropertyName = "Maximum tool cupboards")]
    public int MaxToolCupboards { get; set; }
    [JsonProperty(PropertyName = "Restrict water depth (true/false)")]
    public bool RestrictWaterDepth { get; set; }
    [JsonProperty(PropertyName = "Maximum water depth")]
    public double MaxWaterDepth { get; set; }
    [JsonProperty(PropertyName = "Refund resources when restricted")]
    public bool RefundResources { get; set; }
}


```

---

## BuildingScanner by  - Allows players to scan bases for boxes and etc.

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Building Scanner", "Orange", "1.1.0")]
[Description("Allow players to scan bases for boxes and etc")]
public class BuildingScanner : RustPlugin
{
    private const string permUse;
    private const string permNoCD;
    private ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Usage cooldown")]
        public int useCooldown;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Init();
    [ChatCommand("scan")]
    private void CmdScan(BasePlayer player);
    private Dictionary<string, string> EN;
    private void message(BasePlayer player, string key, object[] args);
    private void OnStart();
    private bool HasPerm(BasePlayer p, string perm);
    private Dictionary<ulong, double> cooldowns;
    private double Now();
    private double Passed(double value);
    private bool DoScan(BasePlayer p);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Usage cooldown")]
    public int useCooldown;
}


```

---

## BuildingSkins by Marat - Automatic application of DLC skins for building blocks

```csharp
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Building Skins", "Marat", "2.0.10")]
[Description("Automatic application of DLC skins for building blocks")]
 class BuildingSkins : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private const string InitialLayer;
    private const string CupboardLayer;
    private const string permissionUse;
    private const string permissionAll;
    private const string permissionBuild;
    private const string permissionTc;
    private const string permissionAdmin;
    private readonly Dictionary<ulong, Coroutine> runningCoroutines;
    private readonly Dictionary<BuildingGrade.Enum, List<ulong>> gradesSkin;
    private readonly Dictionary<uint, string> colors;
    private void OnServerInitialized();
    private void Unload();
    private void OnServerSave();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    private void OnHammerHit(BasePlayer player, HitInfo info);
    private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade, ulong skin);
    private void OnStructureGradeUpdated(BuildingBlock block, BasePlayer player, BuildingGrade.Enum oldGrade, BuildingGrade.Enum newGrade);
    private void OnLootEntity(BasePlayer player, BaseEntity entity);
    private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
    private static PluginConfig config;
    private class PluginConfig
    {
        [JsonProperty("Building skin change commands")]
        public string[] Commands;
        [JsonProperty("Block building skin in building blocked")]
        public bool BuildingBlocked;
        [JsonProperty("Changing skin from tool cupboard only by owner")]
        public bool ChangeSkinTC;
        [JsonProperty("Number of blocks updated per tick")]
        public int UpdatesPerTick;
        [JsonProperty("Use separate permissions for skins")]
        public bool SeparatePermissions;
        [JsonProperty("Image and description settings")]
        public Dictionary<int, List<BlockInfo>> BuildingImages;
        public Oxide.Core.VersionNumber Version;
    }

    protected override void LoadDefaultConfig();
    private class BlockInfo
    {
        public string Title;
        public string Url;
        public ulong SkinId;
        public BlockInfo(string title, string url, ulong skinId);
    }

    protected override void SaveConfig();
    protected override void LoadConfig();
    [ConsoleCommand("UI_BuildingController")]
    private void CmdConsoleHandler(ConsoleSystem.Arg arg);
    private void CmdChangeSkin(IPlayer ipPlayer, string command, string[] arg);
    private void StartCoroutine(BasePlayer player, IEnumerator routine);
    private void StopCoroutine(BasePlayer player);
    private IEnumerator UpgradeSkin(BasePlayer player, BuildingBlock[] blocks);
    private bool HasPermission(BasePlayer player, string name);
    private ulong GetPlayerSkinID(BasePlayer player, BuildingGrade.Enum grade);
    private BuildingBlock GetLookEntity(BasePlayer player);
    private static void SoundEffect(BasePlayer player, string effect);
    private string GetMessage(string key, BasePlayer player);
    private void InitializeLayers(BasePlayer player, bool update);
    private void ImageLayers(BasePlayer player, int index, int skinIndex);
    private void SettingsLayer(BasePlayer player);
    private void ColorLayer(BasePlayer player, int index);
    private void TCupboardLayer(BasePlayer player);
    private IEnumerator PreloadImages(BasePlayer player);
    protected override void LoadDefaultMessages();
    private StoredData storedData;
    private class StoredData
    {
        public Dictionary<ulong, Data> PlayerData;
    }

    private class Data
    {
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool ChangeHammer;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool NeedsRepair;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool EnableAnimation;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool RandomColor;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public uint Color;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ulong Wood;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ulong Stone;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ulong Metal;
        [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ulong TopTier;
    }

    private void SaveData();
    private void LoadData();
}

private class PluginConfig
{
    [JsonProperty("Building skin change commands")]
    public string[] Commands;
    [JsonProperty("Block building skin in building blocked")]
    public bool BuildingBlocked;
    [JsonProperty("Changing skin from tool cupboard only by owner")]
    public bool ChangeSkinTC;
    [JsonProperty("Number of blocks updated per tick")]
    public int UpdatesPerTick;
    [JsonProperty("Use separate permissions for skins")]
    public bool SeparatePermissions;
    [JsonProperty("Image and description settings")]
    public Dictionary<int, List<BlockInfo>> BuildingImages;
    public Oxide.Core.VersionNumber Version;
}

private class BlockInfo
{
    public string Title;
    public string Url;
    public ulong SkinId;
    public BlockInfo(string title, string url, ulong skinId);
}

private class StoredData
{
    public Dictionary<ulong, Data> PlayerData;
}

private class Data
{
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool ChangeHammer;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool NeedsRepair;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool EnableAnimation;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool RandomColor;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public uint Color;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public ulong Wood;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public ulong Stone;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public ulong Metal;
    [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)]
    public ulong TopTier;
}


```

---

## BuildingWorkbench by MJSU - Extends the range of the workbench to work inside the entire building

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

[Info("Building Workbench", "MJSU", "1.4.1")]
[Description("Extends the range of the workbench to work inside the entire building")]
public class BuildingWorkbench : RustPlugin
{
    [PluginReference]
    private readonly Plugin GameTipAPI;
    private PluginConfig _pluginConfig;
    private WorkbenchBehavior _wb;
    private GameObject _go;
    private BuildingWorkbenchTrigger _tb;
    private const string UsePermission;
    private const string CancelCraftPermission;
    private const string AccentColor;
    private readonly List<ulong> _notifiedPlayer;
    private readonly Hash<ulong, PlayerData> _playerData;
    private readonly Hash<uint, BuildingData> _buildingData;
    private float _scanRange;
    private float _halfScanRange;
    private PhysicsScene _physics;
    private void Init();
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private void OnServerInitialized();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void Unload();
    public void StartUpdatingWorkbench();
    public IEnumerator HandleWorkbenchUpdate();
    public void UpdatePlayerBuildings(BasePlayer player, PlayerData data);
    public void OnPlayerEnterBuilding(BasePlayer player, uint buildingId);
    public void OnPlayerLeftBuilding(BasePlayer player, uint buildingId);
    private void OnEntitySpawned(Workbench bench);
    private void OnEntityKill(Workbench bench);
    private void OnEntityKill(BuildingPrivlidge tc);
    private void OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player);
    private void OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player);
    private void OnCupboardClearList(BuildingPrivlidge privilege);
    private void OnEntityEnter(TriggerWorkbench trigger, BasePlayer player);
    private void OnEntityLeave(TriggerWorkbench trigger, BasePlayer player);
    private void OnEntityLeave(BuildingWorkbenchTrigger trigger, BasePlayer player);
    public void UpdateBuildingPlayers(BuildingData building);
    public void UpdatePlayerWorkbenchLevel(BasePlayer player);
    public PlayerData GetPlayerData(ulong playerId);
    public BuildingData GetBuildingData(uint buildingId);
    private readonly RaycastHit[] _hits;
    private readonly List<uint> _processedBuildings;
    public void GetNearbyAuthorizedBuildingsFast(BasePlayer player, List<uint> authorizedPrivs);
    public void GetNearbyAuthorizedBuildings(BasePlayer player, List<uint> authorizedPrivs);
    public void Chat(BasePlayer player, string message);
    public bool HasPermission(BasePlayer player, string perm);
    private string Lang(string key, BasePlayer player);
    private string Lang(string key, BasePlayer player, object[] args);
    public class BuildingData
    {
        public uint BuildingId { get; set; }
        public Workbench BestWorkbench { get; set; }
        public List<BasePlayer> Players { get; set; }
        public List<Workbench> Workbenches { get; set; }
        public BuildingData(uint buildingId);
        public void EnterBuilding(BasePlayer player);
        public void LeaveBuilding(BasePlayer player);
        public void OnBenchBuilt(Workbench workbench);
        public void OnBenchKilled(Workbench workbench);
        public byte GetBuildingLevel();
        private void UpdateBestBench();
    }

    private class PluginConfig
    {
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Display workbench built notification")]
        public bool BuiltNotification { get; set; }
        [DefaultValue(true)]
        [JsonProperty(PropertyName = "Display cancel craft notification")]
        public bool CancelCraftNotification { get; set; }
        [DefaultValue(3f)]
        [JsonProperty(PropertyName = "Inside building check frequency (Seconds)")]
        public float UpdateRate { get; set; }
        [DefaultValue(false)]
        [JsonProperty(PropertyName = "Enable Fast Building Check (Only checks above and below a player)")]
        public bool FastBuildingCheck { get; set; }
        [DefaultValue(16f)]
        [JsonProperty(PropertyName = "Distance from base to be considered inside building (Meters)")]
        public float BaseDistance { get; set; }
        [DefaultValue(5)]
        [JsonProperty(PropertyName = "Required distance from last update (Meters)")]
        public float RequiredDistance { get; set; }
    }

    public class PlayerData
    {
        public Vector3 Position { get; set; }
        public Hash<uint, BuildingData> BuildingData { get; set; }
    }

    private class LangKeys
    {
        public const string Chat;
        public const string Notification;
        public const string CraftCanceled;
    }

    public class WorkbenchBehavior : FacepunchBehaviour
    {
    }

    public class BuildingWorkbenchTrigger : TriggerBase
    {
    }

}

public class BuildingData
{
    public uint BuildingId { get; set; }
    public Workbench BestWorkbench { get; set; }
    public List<BasePlayer> Players { get; set; }
    public List<Workbench> Workbenches { get; set; }
    public BuildingData(uint buildingId);
    public void EnterBuilding(BasePlayer player);
    public void LeaveBuilding(BasePlayer player);
    public void OnBenchBuilt(Workbench workbench);
    public void OnBenchKilled(Workbench workbench);
    public byte GetBuildingLevel();
    private void UpdateBestBench();
}

private class PluginConfig
{
    [DefaultValue(true)]
    [JsonProperty(PropertyName = "Display workbench built notification")]
    public bool BuiltNotification { get; set; }
    [DefaultValue(true)]
    [JsonProperty(PropertyName = "Display cancel craft notification")]
    public bool CancelCraftNotification { get; set; }
    [DefaultValue(3f)]
    [JsonProperty(PropertyName = "Inside building check frequency (Seconds)")]
    public float UpdateRate { get; set; }
    [DefaultValue(false)]
    [JsonProperty(PropertyName = "Enable Fast Building Check (Only checks above and below a player)")]
    public bool FastBuildingCheck { get; set; }
    [DefaultValue(16f)]
    [JsonProperty(PropertyName = "Distance from base to be considered inside building (Meters)")]
    public float BaseDistance { get; set; }
    [DefaultValue(5)]
    [JsonProperty(PropertyName = "Required distance from last update (Meters)")]
    public float RequiredDistance { get; set; }
}

public class PlayerData
{
    public Vector3 Position { get; set; }
    public Hash<uint, BuildingData> BuildingData { get; set; }
}

private class LangKeys
{
    public const string Chat;
    public const string Notification;
    public const string CraftCanceled;
}

public class WorkbenchBehavior : FacepunchBehaviour
{
}

public class BuildingWorkbenchTrigger : TriggerBase
{
}


```

---

## BuildingWrapper by Spiikesan - Automatically wrap buildings in a zone

```csharp
using System.Collections.Generic;
using System;
using System.Reflection;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Facepunch;

Oxide.Plugins
[Info("Building Wrapper", "Spiikesan", "0.1.7")]
[Description("Utility to wrap zones around buildings neatly and efficiently")]
 class BuildingWrapper : RustPlugin
{
    private const string ZoneManagerPermZone;
    [PluginReference]
     Plugin ZoneManager;
    private int layerMasks;
    public string usageString;
    private const float yAdjust;
    private Collider[] colBuffer;
    const float previewTime;
    protected override void LoadDefaultMessages();
     string GetMessage(string key, string userId);
     void Loaded();
    private void OnServerInitialized();
    private void OnPluginLoaded(Plugin plugin);
    private void OnPluginUnloaded(Plugin plugin);
     void showUsage(BasePlayer player);
    static string wrapSize(int size, string input);
    static string wrapColor(string color, string input);
     void cmdChatDelegator(BasePlayer player, string command, string[] args);
     HashSet<BuildingBlock> getZoneEntities(BasePlayer player, string zoneId, Option zoneShape);
     bool GetRaycastTarget(BasePlayer player, BaseEntity closestEntity);
     bool GetStructure(HashSet<BuildingBlock> initialBlocks, HashSet<BuildingBlock> structure);
     bool WrapBuilding(BasePlayer player, string zoneId, Option shape, float buffer, Command cmd);
     bool WrapBox(BasePlayer player, string zoneId, HashSet<BuildingBlock> blocks, float buffer, Option shape);
     bool WrapSphere(BasePlayer player, string zoneId, HashSet<BuildingBlock> blocks, float buffer);
    private Vector2[] rotateAll(Vector2[] v, float angle, Vector2 center);
    private Vector2 rotate(Vector2 v, float angle, Vector2 center);
     float getAngle(Vector2 p0, Vector2 p1);
     Vector2[] constructHull(Vector2[] points);
     float isLeft(Vector2 p0, Vector2 p1, Vector2 p2);
     Vector2 getCenterFromHull(Vector2[] hull);
     void DrawHull(BasePlayer player, Vector2[] hull, Vector3 center);
    private static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation);
     void DrawPreviewBox(BasePlayer player, Vector3 box, Vector3 center, float r);
     void DrawLine(BasePlayer player, Vector3 from, Vector3 to, Color color, float duration);
     void DrawPreviewSphere(BasePlayer player, float radius, Vector3 center, float duration);
     void DrawText(BasePlayer player, Vector3 position, string text, float duration);
     void drawCenter(BasePlayer player, Vector3 center);
    private static bool isAdmin(BasePlayer player);
    private bool hasPermission(BasePlayer player, string permname);
     Vector3 parseVector3(string str);
    public void BoxColliders(Vector3 position, Vector3 halfExtents, Quaternion orientation, List<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
    public void BoxEntities(Vector3 position, Vector3 halfExtents, Quaternion orientation, List<T> list, int layerMask, QueryTriggerInteraction triggerInteraction);
}


```

---

## BuildRevert by nivex - Prevents building in blocked areas

```csharp
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("BuildRevert", "nivex", "1.2.2")]
[Description("Prevent building in blocked area.")]
public class BuildRevert : RustPlugin
{
    [PluginReference]
     Plugin RaidableBases;
     Plugin AbandonedBases;
     Plugin ZoneManager;
    private List<ZoneInfo> excludedZones { get; set; }
    private List<Construction> blocked;
    public class ZoneInfo
    {
        internal Vector3 origin;
        internal Vector3 extents;
        internal float distance;
        public ZoneInfo(object origin, object radius, object size);
        public bool IsPositionInZone(Vector3 point);
        private bool InRange2D(Vector3 a, Vector3 b, float distance);
    }

    private void Init();
    private void OnServerInitialized(bool isStartup);
    private object CanBuild(Planner planner, Construction construction, Construction.Target target);
    private bool EventTerritory(Vector3 buildPos);
    private void SetupExcludedZones(bool message);
    private bool IsExcluded(Vector3 position);
    private bool Changed;
    private List<string> allowedZones;
    protected override void LoadDefaultMessages();
    private bool useToasts;
    private GameTip.Styles toastStyle;
    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private string GetLang(string key, string id);
}

public class ZoneInfo
{
    internal Vector3 origin;
    internal Vector3 extents;
    internal float distance;
    public ZoneInfo(object origin, object radius, object size);
    public bool IsPositionInZone(Vector3 point);
    private bool InRange2D(Vector3 a, Vector3 b, float distance);
}


```

---

## BuildScanner by Mevent - Allows to scan entities (codelocks/autoturrets/cupboards and house)

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Build Scanner", "Mevent", "1.0.5")]
[Description("Allows to scan entities (codelocks/autoturrets/cupboards and house)")]
public class BuildScanner : CovalencePlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private const string Layer;
    private static BuildScanner _instance;
    private const string PermUse;
    private const string PermUnlimited;
    private const string PermCupboard;
    private const string PermCodeLock;
    private const string PermAutoTurret;
    private const string PermHome;
    private readonly Dictionary<BasePlayer, ScanData> _scanByPlayer;
    private class ScanData
    {
        public ScanPlayerData OwnerId;
        public List<ScanPlayerData> Members;
        public static ScanData Get(IPlayer player, BaseEntity entity);
    }

    private class ScanPlayerData
    {
        public readonly string Name;
        public readonly ulong UserID;
        public readonly bool Online;
        public ScanPlayerData(PlayerNameID data);
        public ScanPlayerData(ulong member);
    }

    private string _color1;
    private string _color2;
    private string _color3;
    private string _color4;
    private string _color5;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] Commands;
        [JsonProperty(PropertyName = "Cooldown between checks (seconds)")]
        public int Cooldown;
        [JsonProperty(PropertyName = "Colors")]
        public Colors Colors;
    }

    private class Colors
    {
        [JsonProperty(PropertyName = "Color 1")]
        public string Color1;
        [JsonProperty(PropertyName = "Color 2")]
        public string Color2;
        [JsonProperty(PropertyName = "Color 3")]
        public string Color3;
        [JsonProperty(PropertyName = "Color 4")]
        public string Color4;
        [JsonProperty(PropertyName = "Color 5")]
        public string Color5;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private PluginData _data;
    private void SaveData();
    private void LoadData();
    private class PluginData
    {
        [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<ulong, PlayerData> Players;
    }

    private class PlayerData
    {
        [JsonProperty(PropertyName = "Last Time")]
        public DateTime LastTime;
        public int GetTime();
    }

    private PlayerData GetPlayerData(BasePlayer player);
    private PlayerData GetPlayerData(ulong member);
    private bool HasCooldown(BasePlayer player);
    private void UpdateCooldown(BasePlayer player);
    private int GetLeftTime(BasePlayer player);
    private void Init();
    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void CmdChatOpen(IPlayer cov, string command, string[] args);
    [ConsoleCommand("UI_Scanner")]
    private void CmdConsole(ConsoleSystem.Arg arg);
    private void MainUi(BasePlayer player, int page, bool first);
    private void PlayerUi(CuiElementContainer container, BasePlayer player, ScanPlayerData playerData, string offMin, string offMax, bool isOwner);
    private static string HexToCuiColor(string hex, float alpha);
    private static bool? HasPermission(IPlayer player, BaseEntity entity);
    private void RegisterPermissions();
    private void LoadColors();
    private readonly Regex _regex;
    private void GetAvatar(ulong userId, Action<string> callback);
    private const string OwnerSecondTitle;
    private const string NextBtn;
    private const string BackBtn;
    private const string ListTitle;
    private const string OwnerTitle;
    private const string EntityNotFound;
    private const string CooldownMsg;
    private const string CloseButton;
    private const string TitleMenu;
    private const string NoPermission;
    protected override void LoadDefaultMessages();
    private string Msg(string key, string userid, object[] obj);
    private string Msg(BasePlayer player, string key, object[] obj);
    private string Msg(IPlayer player, string key, object[] obj);
    private void Reply(BasePlayer player, string key, object[] obj);
    private void Reply(IPlayer player, string key, object[] obj);
}

private class ScanData
{
    public ScanPlayerData OwnerId;
    public List<ScanPlayerData> Members;
    public static ScanData Get(IPlayer player, BaseEntity entity);
}

private class ScanPlayerData
{
    public readonly string Name;
    public readonly ulong UserID;
    public readonly bool Online;
    public ScanPlayerData(PlayerNameID data);
    public ScanPlayerData(ulong member);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] Commands;
    [JsonProperty(PropertyName = "Cooldown between checks (seconds)")]
    public int Cooldown;
    [JsonProperty(PropertyName = "Colors")]
    public Colors Colors;
}

private class Colors
{
    [JsonProperty(PropertyName = "Color 1")]
    public string Color1;
    [JsonProperty(PropertyName = "Color 2")]
    public string Color2;
    [JsonProperty(PropertyName = "Color 3")]
    public string Color3;
    [JsonProperty(PropertyName = "Color 4")]
    public string Color4;
    [JsonProperty(PropertyName = "Color 5")]
    public string Color5;
}

private class PluginData
{
    [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<ulong, PlayerData> Players;
}

private class PlayerData
{
    [JsonProperty(PropertyName = "Last Time")]
    public DateTime LastTime;
    public int GetTime();
}


```

---

## BulletImpact by birthdates - Give a more realistic impact of a bullet on death

```csharp
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Bullet Impact", "birthdates", "1.0.3")]
[Description("Give a more realistic impact of a bullet on death")]
public class BulletImpact : RustPlugin
{
    private readonly IDictionary<ulong, HitData> _directions;
    private void OnPlayerDeath(BasePlayer player, HitInfo info);
    private void OnPlayerCorpseSpawned(BasePlayer player, BaseCorpse corpse);
}


```

---

## BuoyantHelicopterCrates by Tacman - Helicopter crates will float instead of sinking to the bottom of the ocean.

```csharp
using UnityEngine;
using Rust;
using System;

Oxide.Plugins
[Info("Buoyant Helicopter Crates", "Tacman", "1.1.2")]
[Description("Makes helicopter crates buoyant")]
 class BuoyantHelicopterCrates : RustPlugin
{
    public PluginConfig _config;
    public PluginConfig GetDefaultConfig();
    public class PluginConfig
    {
        public int DetectionRate;
    }

    protected override void LoadDefaultConfig();
     void Init();
     void OnEntitySpawned(BaseEntity entity);
     class MakeBuoyant : MonoBehaviour
    {
        public float buoyancyScale;
        public int detectionRate;
        private BaseEntity _entity;
         void Awake();
         void FixedUpdate();
         void BuoyancyComponent();
    }

}

public class PluginConfig
{
    public int DetectionRate;
}

 class MakeBuoyant : MonoBehaviour
{
    public float buoyancyScale;
    public int detectionRate;
    private BaseEntity _entity;
     void Awake();
     void FixedUpdate();
     void BuoyancyComponent();
}


```

---

## BuoyantSupplyDrops by Bazz3l - Makes all supply drops buoyant and lootable in water

```csharp
using UnityEngine;

Oxide.Plugins
[Info("Buoyant Supply Drops", "Bazz3l", "1.0.2")]
[Description("Allows supply drops to float on water")]
 class BuoyantSupplyDrops : RustPlugin
{
    public PluginConfig _config;
    public PluginConfig GetDefaultConfig();
    public class PluginConfig
    {
        public int DetectionRate;
    }

    protected override void LoadDefaultConfig();
     void Init();
     void OnEntitySpawned(SupplyDrop supply);
     class MakeBuoyant : MonoBehaviour
    {
        public float buoyancyScale;
        public int detectionRate;
        private SupplyDrop _supplyDrop;
         void Awake();
         void FixedUpdate();
         void BuoyancyComponent();
    }

}

public class PluginConfig
{
    public int DetectionRate;
}

 class MakeBuoyant : MonoBehaviour
{
    public float buoyancyScale;
    public int detectionRate;
    private SupplyDrop _supplyDrop;
     void Awake();
     void FixedUpdate();
     void BuoyancyComponent();
}


```

---

## BurnIt by marcuzz - Makes all wooden items and any configured items usable as fuel in ovens.

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;
using VLB;

Oxide.Plugins
[Info("Burn It", "marcuzz", "1.1.2")]
[Description("Makes all wooden items burnable.")]
public class BurnIt : RustPlugin
{
    private static PluginConfig _config;
    private static readonly ItemDefinition _wood;
    private void OnServerInitialized();
    private void OnEntitySpawned(BaseOven oven);
    private void Unload();
    private Item OnFindBurnable(BaseOven oven);
    private object OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable);
    private object OnOvenCook(BaseOven oven, Item item);
    private void OnOvenCooked(BaseOven oven, Item fuel, BaseEntity slot);
    private void OnEntityBuilt(Planner plan, GameObject go);
    private static void ModifyWoodenItems();
    private static void ClearItemModBurnable(ItemDefinition definition);
    private static Item SetItemFuel(Item item, float maxFuel);
    private static Dictionary<int, ItemDefinition> GenerateBurnableItemList();
    private static int GetWoodAmount(ItemBlueprint blueprint);
    private static void AddBurnableWoodenItem(ItemDefinition definition);
    private static void AddCustomBurnable(CustomBurnable customBurnable);
    private static bool ContainsModBurnable(ItemDefinition definition);
    private static void AddItemModBurnable(ItemDefinition definition, ItemDefinition byproduct, int byproductAmount, float byproductChance, float fuelAmount);
    private static void UpdateItemMods(ItemDefinition definition, ItemModBurnIt burnable);
    private class ItemModBurnIt : ItemModBurnable
    {
    }

    private static PluginConfig GetDefaultConfig();
    private class WoodenItems
    {
        [JsonProperty("[a] Make wooden items burnable:")]
        public bool AllowWoodenItems;
        [JsonProperty("[b] Burnable wood ratio")]
        public float FuelAmountRatio;
        [JsonProperty("[c] Charcoal per burnable wood ratio")]
        public float CharcoalRatio;
        [JsonProperty("[d] Blacklisted shortnames")]
        public List<string> BlacklistedShortnames { get; set; }
    }

    private class CustomBurnable
    {
        [JsonProperty("[a] Item shortname")]
        public string Shortname;
        [JsonProperty("[b] Byproduct shortname")]
        public string ByproductShortname;
        [JsonProperty("[c] Byproduct amount")]
        public int ByproductAmount;
        [JsonProperty("[d] Byproduct loss chance")]
        public float ByproductChance;
        [JsonProperty("[e] Fuel amount (burn time)")]
        public float FuelAmount;
    }

    private class PluginConfig
    {
        [JsonProperty("[1] Condition loss feature (allow items with durability)")]
        public bool ConditionLoss { get; set; }
        [JsonProperty("[2] Allow lowgrade burning (disable oven fuel type check)")]
        public bool DisableOvenFuelTypeCheck { get; set; }
        [JsonProperty("[3] Wooden items")]
        public WoodenItems WoodenItems { get; set; }
        [JsonProperty("[4] Specified burnable items")]
        public List<CustomBurnable> SpecificBurnableItems { get; set; }
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
}

private class ItemModBurnIt : ItemModBurnable
{
}

private class WoodenItems
{
    [JsonProperty("[a] Make wooden items burnable:")]
    public bool AllowWoodenItems;
    [JsonProperty("[b] Burnable wood ratio")]
    public float FuelAmountRatio;
    [JsonProperty("[c] Charcoal per burnable wood ratio")]
    public float CharcoalRatio;
    [JsonProperty("[d] Blacklisted shortnames")]
    public List<string> BlacklistedShortnames { get; set; }
}

private class CustomBurnable
{
    [JsonProperty("[a] Item shortname")]
    public string Shortname;
    [JsonProperty("[b] Byproduct shortname")]
    public string ByproductShortname;
    [JsonProperty("[c] Byproduct amount")]
    public int ByproductAmount;
    [JsonProperty("[d] Byproduct loss chance")]
    public float ByproductChance;
    [JsonProperty("[e] Fuel amount (burn time)")]
    public float FuelAmount;
}

private class PluginConfig
{
    [JsonProperty("[1] Condition loss feature (allow items with durability)")]
    public bool ConditionLoss { get; set; }
    [JsonProperty("[2] Allow lowgrade burning (disable oven fuel type check)")]
    public bool DisableOvenFuelTypeCheck { get; set; }
    [JsonProperty("[3] Wooden items")]
    public WoodenItems WoodenItems { get; set; }
    [JsonProperty("[4] Specified burnable items")]
    public List<CustomBurnable> SpecificBurnableItems { get; set; }
}


```

---

## BypassQueue by misticos - Allows players to jump connection queue based on permission

```csharp
using Network;

Oxide.Plugins
[Info("Bypass Queue", "Orange", "1.0.4")]
public class BypassQueue : RustPlugin
{
    private const string permUse;
    private void Init();
    private object CanBypassQueue(Connection connection);
}


```

---

## CactusDamage by birthdates - Cacti deal damage to players harvesting/colliding with them.

```csharp
using Newtonsoft.Json;

Oxide.Plugins
[Info("Cactus Damage", "birthdates", "1.1.0")]
[Description("Cacti deal damage to players harvesting/colliding with them.")]
public class CactusDamage : RustPlugin
{
     void Init();
     void OnDispenserGather(ResourceDispenser dispenser, BasePlayer entity);
     void OnEntityTakeDamage(BasePlayer entity, HitInfo info);
     void Hurt(BasePlayer Player, Damage Damage, BaseEntity Initiator);
    public ConfigFile _config;
    public class Damage
    {
        [JsonProperty("Min Damage")]
        public float MinDamage;
        [JsonProperty("Max Damage")]
        public float MaxDamage;
    }

    public class ConfigFile
    {
        [JsonProperty("Harvesting Damage")]
        public Damage harvestingDamage;
        [JsonProperty("Collision Damage")]
        public Damage collisionDamage;
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class Damage
{
    [JsonProperty("Min Damage")]
    public float MinDamage;
    [JsonProperty("Max Damage")]
    public float MaxDamage;
}

public class ConfigFile
{
    [JsonProperty("Harvesting Damage")]
    public Damage harvestingDamage;
    [JsonProperty("Collision Damage")]
    public Damage collisionDamage;
    public static ConfigFile DefaultConfig();
}


```

---

## Cannibal by KrunghCrow - Cannibal GameMode turning players in Cannibals with a ranking system.

```csharp
using Rust;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;

Oxide.Plugins
[Info("Cannibal", "Krungh Crow", "2.0.2")]
[Description("Cannibal Game Mode")]
 class Cannibal : CovalencePlugin
{
    [PluginReference]
    private Plugin SimpleKillFeed;
     ulong SteamIDIcon;
     string cannibalicon;
    const string Admin_Perm;
    const string CPermanent_Perm;
    const string FXEatingSound;
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Prefix")]
        public string Prefix;
        [JsonProperty(PropertyName = "UI Settings")]
        public UISettings Settings;
        [JsonProperty(PropertyName = "FX Settings")]
        public FXSettings FX;
        [JsonProperty(PropertyName = "Cannibal Settings")]
        public CSettings CannibalS;
    }

     class UISettings
    {
        [JsonProperty(PropertyName = "Use Bloody background")]
        public bool UseBloody;
        [JsonProperty(PropertyName = "Hud Anchor Min")]
        public string Anchormin;
        [JsonProperty(PropertyName = "Hud Anchor Max")]
        public string Anchormax;
    }

     class CSettings
    {
        [JsonProperty(PropertyName = "Save frequency (seconds)")]
        public float TimerAdd;
        [JsonProperty(PropertyName = "Minimum Cannibal time (seconds)")]
        public float MinTime;
        [JsonProperty(PropertyName = "Cannibal Healing")]
        public CHSettings Heal;
        [JsonProperty(PropertyName = "Cannibal Eating")]
        public CESettings Eat;
        [JsonProperty(PropertyName = "Cannibal Gather")]
        public CGSettings Gather;
        [JsonProperty(PropertyName = "Cannibal Damage Dealt")]
        public CDSettings Dmg;
    }

     class FXSettings
    {
        [JsonProperty(PropertyName = "FX during Melee hits")]
        public string MeleeHit;
        [JsonProperty(PropertyName = "FX Turning Cannibal")]
        public string Turned;
        [JsonProperty(PropertyName = "FX Buff end notification")]
        public string BuffEnd;
    }

     class CHSettings
    {
        [JsonProperty(PropertyName = "Can heal self (bandages)")]
        public bool CanHealBandage;
        [JsonProperty(PropertyName = "Heal Bonus self (bandages)")]
        public int BonusBandage;
        [JsonProperty(PropertyName = "Can heal others (bandage)")]
        public bool CanHealOthersBandage;
        [JsonProperty(PropertyName = "Can heal self (syringe)")]
        public bool CanHealSyringe;
        [JsonProperty(PropertyName = "Heal Bonus self (syringe)")]
        public int BonusSyringe;
        [JsonProperty(PropertyName = "Can heal others (syringe)")]
        public bool CanHealOthersSyringe;
        [JsonProperty(PropertyName = "Can consume largemedkit")]
        public bool CanConsumeLmedkit;
        [JsonProperty(PropertyName = "Can consume antiradpill")]
        public bool CanConsumeRadpills;
    }

     class CESettings
    {
        [JsonProperty(PropertyName = "Buff on Human Meat")]
        public bool BuffHumMeat;
        [JsonProperty(PropertyName = "Buff Comfort duration (seconds)")]
        public int BuffDuration;
        [JsonProperty(PropertyName = "Buff Comfort (0-100)")]
        public float BuffComfort;
        [JsonProperty(PropertyName = "Extra nutrition (incl heal)")]
        public int BuffHunger;
        [JsonProperty(PropertyName = "Extra hydration")]
        public int BuffThirst;
        [JsonProperty(PropertyName = "Radiation penalty")]
        public int BuffRadiation;
        [JsonProperty(PropertyName = "Food items (shortname , true/false)")]
        public Dictionary<string , bool> FoodItems;
    }

     class CGSettings
    {
        [JsonProperty(PropertyName = "Wood Gather rate")]
        public float GWood;
        [JsonProperty(PropertyName = "Stone Gather rate")]
        public float GStone;
        [JsonProperty(PropertyName = "Sulfur Gather rate")]
        public float GSulfur;
        [JsonProperty(PropertyName = "Metal Gather rate")]
        public float GMetal;
        [JsonProperty(PropertyName = "HQM Gather rate")]
        public float GHQM;
    }

     class CDSettings
    {
        [JsonProperty(PropertyName = "Cannibal vs Cannibal Scale Boost")]
        public bool CanScaleBoost;
        [JsonProperty(PropertyName = "Melee Weapons (shortname , damagescale)")]
        public Dictionary<string , float> MeleeWeapons;
        [JsonProperty(PropertyName = "Ranged Weapons (shortname , damagescale)")]
        public Dictionary<string , float> RangedWeapons;
    }

    private bool LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConf();
    private DynamicConfigFile data;
     DataFile dataFile;
    private CannibalLifeTimeDataFile cannibalLifeTimeDataFile;
    private class CannibalLifeTimeDataFile
    {
        public Dictionary<string , CannibalLifeTimeData> CannibalLifeTime { get; set; }
    }

    private class CannibalLifeTimeData
    {
        [JsonProperty(PropertyName = "Name")]
        public string PlayerName { get; set; }
        [JsonProperty(PropertyName = "Total Time as Cannibal")]
        public double CannibalLifeTime { get; set; }
        [JsonProperty(PropertyName = "Total Human Meat Consumed")]
        public int HumanMeatConsumed { get; set; }
        [JsonProperty(PropertyName = "Total Humans Killed")]
        public int HumansKilled { get; set; }
        [JsonProperty(PropertyName = "Total Cannibals Killed")]
        public int CannibalsKilled { get; set; }
        [JsonProperty(PropertyName = "Total Npc Killed")]
        public int NpcKilled { get; set; }
        [JsonProperty(PropertyName = "Total Animals Killed")]
        public int AnimalsKilled { get; set; }
        [JsonProperty(PropertyName = "Total Wood Collected")]
        public int WoodCollected;
        [JsonProperty(PropertyName = "Total Stone Collected")]
        public int StoneCollected;
        [JsonProperty(PropertyName = "Total Sulfur Ore Collected")]
        public int SulfurCollected;
        [JsonProperty(PropertyName = "Total Metal Ore Collected")]
        public int MetalCollected;
        [JsonProperty(PropertyName = "Total Hqm Ore Collected")]
        public int HQMCollected;
    }

    private void LoadCannibalLifeTimeData();
    private void SaveCannibalLifeTimeData();
    private void SaveData();
    private void LoadData();
    private class DataFile
    {
        public Dictionary<string , PlayerData> Players;
    }

    private class PlayerData
    {
        [JsonProperty(PropertyName = "Name")]
        public string DisplayName;
        [JsonProperty(PropertyName = "Current Time as Cannibal")]
        public double TotalTimeAsCannibal;
        [JsonProperty(PropertyName = "Current Human Meat Consumed")]
        public int HumanMeatConsumed;
        [JsonProperty(PropertyName = "Current Humans Killed")]
        public int HumansKilled;
        [JsonProperty(PropertyName = "Current Cannibals Killed")]
        public int CannibalsKilled;
        [JsonProperty(PropertyName = "Current Npc Killed")]
        public int NpcKilled;
        [JsonProperty(PropertyName = "Current Animals Killed")]
        public int AnimalsKilled;
        [JsonProperty(PropertyName = "Wood Collected")]
        public int WoodCollected;
        [JsonProperty(PropertyName = "Stone Collected")]
        public int StoneCollected;
        [JsonProperty(PropertyName = "Sulfur Ore Collected")]
        public int SulfurCollected;
        [JsonProperty(PropertyName = "Metal Ore Collected")]
        public int MetalCollected;
        [JsonProperty(PropertyName = "Hqm Ore Collected")]
        public int HQMCollected;
    }

    private void AddPlayerData(IPlayer player);
    private void RemovePlayer(IPlayer player);
    protected override void LoadDefaultMessages();
    [Command("Cannibal")]
    private void CannibalCmd(IPlayer player, string command, string[] args);
    private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnEntityDeath(BaseAnimalNPC animal, HitInfo info);
    private void OnEntityDeath(BasePlayer victim, HitInfo info);
    private object OnPlayerDrink(BasePlayer player, LiquidContainer container);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private object OnHealingItemUse(MedicalTool tool, BasePlayer player);
     Dictionary<string , float> lastConsumedTimes;
    private object OnItemAction(Item item, string action, BasePlayer player);
    private void Init();
    private void Unload();
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnPlayerSleepEnded(BasePlayer player);
    private void OnPlayerDeath(BasePlayer player, HitInfo info);
     Dictionary<ulong , int> totalBoostDurations;
     Dictionary<ulong , Timer> boostTimers;
    private void GiveBoosts(BasePlayer player, float comfort, int radiation, int thirst, int hunger, int duration);
    private void SetupPlayer(IPlayer player);
    private Dictionary<string , Timer> playerTimers;
    private void StartCannibalTimer(IPlayer player);
    private void IncrementCannibalTime(IPlayer player);
    private void StopCannibalTimer(IPlayer player);
    private bool IsNotMeleeItem(string shortName);
    private void CheckAndAddBaseWeapons();
    private bool ExcludedFood(string shortName);
    private void CheckAndAddFoodItems();
    public T GetCannibalData(IPlayer player, string dataType);
    public T GetCannibalLifeTimeData(IPlayer player, string dataType);
    public bool IsCannibal(BasePlayer player);
    public bool IsCannibal(IPlayer player);
    public double GetTotalCannibalTime(IPlayer player);
    public double GetCannibalLifeTime(IPlayer player);
    public double GetCannibalTime(BasePlayer player);
    public double GetCannibalTime(IPlayer player);
    public int CountCannibals();
    public int CountOnlineCannibals();
    public void AddPlayerAsCannibal(BasePlayer player);
    public void AddPlayerAsCannibal(IPlayer player);
    public void RemovePlayerFromCannibals(IPlayer player);
    public void RemovePlayerFromCannibals(BasePlayer player);
     void DestroyCannibalHuds(BasePlayer player);
    [Command("CannibalHudClose")]
    private void CannibalHudClose(IPlayer player, string command, string[] args);
     void Cannibalhud(BasePlayer player);
     void AddTextElement(CuiElementContainer elements, string parent, string text, string offset);
     void AddIconElement(CuiElementContainer elements, string parent, string sprite, string offsetMin, string offsetMax, string color);
     void AddImageElement(CuiElementContainer elements, string parent, string png, string offsetMin, string offsetMax, string color);
    const float TimerInterval;
     Timer textRefreshTimer;
     bool isTimerActive;
     void ShowCannibalTimer(BasePlayer player);
     void StopCannibalTimer(BasePlayer player);
     void UpdateCannibalTimerText(BasePlayer player);
     void DestroyCannibalTimerPanel(BasePlayer player);
     string GetRemainingTime(ulong userID);
     int currentPage;
    private void CannibalinfoPanel(IPlayer iPlayer);
     void CreatePage1(CuiElementContainer container, string mainPanel, IPlayer player);
     void CreatePage2(CuiElementContainer container, string mainPanel, IPlayer player);
     void CreatePage3(CuiElementContainer container, string mainPanel, IPlayer player);
     void CreatePage4(CuiElementContainer container, string mainPanel, IPlayer player);
    private void AddRanking(CuiElementContainer container, string ranking, string Type, string image);
    private void AddChatCommandsText(CuiElementContainer container, string labelText, string valueText, double height, double heightLow);
    private void AddStatPanelWithText(CuiElementContainer container, string labelText, string valueText, string valueText2, double height, double heightLow);
     float spacing;
    private void CreateWeaponPanel(CuiElementContainer container, string title, Dictionary<string , float> weapons, int column, string parentPanel, IPlayer player);
    private void AddTextWithOutline(CuiElementContainer container, string text, int fontSize, string anchorMin, string anchorMax, TextAnchor align, string parentPanel);
    [Command("CPage1")]
    private void CPage1(IPlayer player, string command, string[] args);
    [Command("CPage2")]
    private void CPage2(IPlayer player, string command, string[] args);
    [Command("CPage3")]
    private void CPage3(IPlayer player, string command, string[] args);
    [Command("CPage4")]
    private void CPage4(IPlayer player, string command, string[] args);
    [Command("ui.close")]
    private void CloseUICommand(IPlayer iPlayer, string command, string[] args);
    private static bool IsZombieHorde(BasePlayer player);
    private float GetMultiplierForItem(string itemShortname);
    private void SendFX(BasePlayer player, string FXstring);
    private string Translate(IPlayer player, string key);
     bool IsMeleeWeapon(string itemShortName, BaseEntity weaponEntity);
     bool IsRangedWeapon(string itemShortName, BaseEntity weaponEntity);
    public string HexToCuiColor(string hex);
     bool HasPermission(IPlayer player, string perm);
     bool HasPerm(IPlayer player, string perm);
     void SendMessage(object playerObject, string messageKey);
    private TimeSpan FormatTime(double seconds);
    private string FormatTimeFilter(double seconds);
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Prefix")]
    public string Prefix;
    [JsonProperty(PropertyName = "UI Settings")]
    public UISettings Settings;
    [JsonProperty(PropertyName = "FX Settings")]
    public FXSettings FX;
    [JsonProperty(PropertyName = "Cannibal Settings")]
    public CSettings CannibalS;
}

 class UISettings
{
    [JsonProperty(PropertyName = "Use Bloody background")]
    public bool UseBloody;
    [JsonProperty(PropertyName = "Hud Anchor Min")]
    public string Anchormin;
    [JsonProperty(PropertyName = "Hud Anchor Max")]
    public string Anchormax;
}

 class CSettings
{
    [JsonProperty(PropertyName = "Save frequency (seconds)")]
    public float TimerAdd;
    [JsonProperty(PropertyName = "Minimum Cannibal time (seconds)")]
    public float MinTime;
    [JsonProperty(PropertyName = "Cannibal Healing")]
    public CHSettings Heal;
    [JsonProperty(PropertyName = "Cannibal Eating")]
    public CESettings Eat;
    [JsonProperty(PropertyName = "Cannibal Gather")]
    public CGSettings Gather;
    [JsonProperty(PropertyName = "Cannibal Damage Dealt")]
    public CDSettings Dmg;
}

 class FXSettings
{
    [JsonProperty(PropertyName = "FX during Melee hits")]
    public string MeleeHit;
    [JsonProperty(PropertyName = "FX Turning Cannibal")]
    public string Turned;
    [JsonProperty(PropertyName = "FX Buff end notification")]
    public string BuffEnd;
}

 class CHSettings
{
    [JsonProperty(PropertyName = "Can heal self (bandages)")]
    public bool CanHealBandage;
    [JsonProperty(PropertyName = "Heal Bonus self (bandages)")]
    public int BonusBandage;
    [JsonProperty(PropertyName = "Can heal others (bandage)")]
    public bool CanHealOthersBandage;
    [JsonProperty(PropertyName = "Can heal self (syringe)")]
    public bool CanHealSyringe;
    [JsonProperty(PropertyName = "Heal Bonus self (syringe)")]
    public int BonusSyringe;
    [JsonProperty(PropertyName = "Can heal others (syringe)")]
    public bool CanHealOthersSyringe;
    [JsonProperty(PropertyName = "Can consume largemedkit")]
    public bool CanConsumeLmedkit;
    [JsonProperty(PropertyName = "Can consume antiradpill")]
    public bool CanConsumeRadpills;
}

 class CESettings
{
    [JsonProperty(PropertyName = "Buff on Human Meat")]
    public bool BuffHumMeat;
    [JsonProperty(PropertyName = "Buff Comfort duration (seconds)")]
    public int BuffDuration;
    [JsonProperty(PropertyName = "Buff Comfort (0-100)")]
    public float BuffComfort;
    [JsonProperty(PropertyName = "Extra nutrition (incl heal)")]
    public int BuffHunger;
    [JsonProperty(PropertyName = "Extra hydration")]
    public int BuffThirst;
    [JsonProperty(PropertyName = "Radiation penalty")]
    public int BuffRadiation;
    [JsonProperty(PropertyName = "Food items (shortname , true/false)")]
    public Dictionary<string , bool> FoodItems;
}

 class CGSettings
{
    [JsonProperty(PropertyName = "Wood Gather rate")]
    public float GWood;
    [JsonProperty(PropertyName = "Stone Gather rate")]
    public float GStone;
    [JsonProperty(PropertyName = "Sulfur Gather rate")]
    public float GSulfur;
    [JsonProperty(PropertyName = "Metal Gather rate")]
    public float GMetal;
    [JsonProperty(PropertyName = "HQM Gather rate")]
    public float GHQM;
}

 class CDSettings
{
    [JsonProperty(PropertyName = "Cannibal vs Cannibal Scale Boost")]
    public bool CanScaleBoost;
    [JsonProperty(PropertyName = "Melee Weapons (shortname , damagescale)")]
    public Dictionary<string , float> MeleeWeapons;
    [JsonProperty(PropertyName = "Ranged Weapons (shortname , damagescale)")]
    public Dictionary<string , float> RangedWeapons;
}

private class CannibalLifeTimeDataFile
{
    public Dictionary<string , CannibalLifeTimeData> CannibalLifeTime { get; set; }
}

private class CannibalLifeTimeData
{
    [JsonProperty(PropertyName = "Name")]
    public string PlayerName { get; set; }
    [JsonProperty(PropertyName = "Total Time as Cannibal")]
    public double CannibalLifeTime { get; set; }
    [JsonProperty(PropertyName = "Total Human Meat Consumed")]
    public int HumanMeatConsumed { get; set; }
    [JsonProperty(PropertyName = "Total Humans Killed")]
    public int HumansKilled { get; set; }
    [JsonProperty(PropertyName = "Total Cannibals Killed")]
    public int CannibalsKilled { get; set; }
    [JsonProperty(PropertyName = "Total Npc Killed")]
    public int NpcKilled { get; set; }
    [JsonProperty(PropertyName = "Total Animals Killed")]
    public int AnimalsKilled { get; set; }
    [JsonProperty(PropertyName = "Total Wood Collected")]
    public int WoodCollected;
    [JsonProperty(PropertyName = "Total Stone Collected")]
    public int StoneCollected;
    [JsonProperty(PropertyName = "Total Sulfur Ore Collected")]
    public int SulfurCollected;
    [JsonProperty(PropertyName = "Total Metal Ore Collected")]
    public int MetalCollected;
    [JsonProperty(PropertyName = "Total Hqm Ore Collected")]
    public int HQMCollected;
}

private class DataFile
{
    public Dictionary<string , PlayerData> Players;
}

private class PlayerData
{
    [JsonProperty(PropertyName = "Name")]
    public string DisplayName;
    [JsonProperty(PropertyName = "Current Time as Cannibal")]
    public double TotalTimeAsCannibal;
    [JsonProperty(PropertyName = "Current Human Meat Consumed")]
    public int HumanMeatConsumed;
    [JsonProperty(PropertyName = "Current Humans Killed")]
    public int HumansKilled;
    [JsonProperty(PropertyName = "Current Cannibals Killed")]
    public int CannibalsKilled;
    [JsonProperty(PropertyName = "Current Npc Killed")]
    public int NpcKilled;
    [JsonProperty(PropertyName = "Current Animals Killed")]
    public int AnimalsKilled;
    [JsonProperty(PropertyName = "Wood Collected")]
    public int WoodCollected;
    [JsonProperty(PropertyName = "Stone Collected")]
    public int StoneCollected;
    [JsonProperty(PropertyName = "Sulfur Ore Collected")]
    public int SulfurCollected;
    [JsonProperty(PropertyName = "Metal Ore Collected")]
    public int MetalCollected;
    [JsonProperty(PropertyName = "Hqm Ore Collected")]
    public int HQMCollected;
}


```

---

## CapacityController by 2CHEVSKII - Allows capacity modification of certain containers.

```csharp
using Newtonsoft.Json;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Capacity Controller", "2CHEVSKII", "2.1.0")]
[Description("Allows capacity modification of certain containers.")]
 class CapacityController : CovalencePlugin
{
     Configuration config;
     IEnumerator routine;
     Dictionary<string, string> shortNameToDisplay;
     void Init();
     void OnServerInitialized();
     void OnEntitySpawned(StorageContainer entity);
     void OnItemAddedToContainer(ItemContainer _, Item item);
     void Unload();
     IEnumerator GetContainers(Action callback);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
     class Configuration
    {
        public static Configuration Default { get; set; }
        [JsonProperty("Weapons")]
        public Dictionary<string, int> weapons;
        [JsonProperty("Deployables")]
        public Dictionary<string, int> deployables;
        public void SetWeaponCapacity(string name, int capacity);
        public void SetDeployableCapacity(string name, int capacity);
        public int GetWeaponCapacity(string name);
        public int GetDeployableCapacity(string name);
    }

}

 class Configuration
{
    public static Configuration Default { get; set; }
    [JsonProperty("Weapons")]
    public Dictionary<string, int> weapons;
    [JsonProperty("Deployables")]
    public Dictionary<string, int> deployables;
    public void SetWeaponCapacity(string name, int capacity);
    public void SetDeployableCapacity(string name, int capacity);
    public int GetWeaponCapacity(string name);
    public int GetDeployableCapacity(string name);
}


```

---

## CapsNoCaps by LaserHydra - Converts messages written in CAPS to Sentence case

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Text;

Oxide.Plugins
[Info("CapsNoCaps", "LaserHydra", "2.0.0")]
 class CapsNoCaps : CovalencePlugin
{
    private Configuration _config;
    private const string IgnorePermission;
    private void Init();
    private void OnBetterChat(Dictionary<string, object> data);
    private static string ReplaceCapitalWords(string text, float captialLetterPercentageThreshold, int lengthThreshold);
    private bool CanWriteCaps(IPlayer player);
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class Configuration
    {
        [JsonProperty("Word Length Threshold")]
        public int WordLengthThreshold { get; set; }
        [JsonProperty("Capital Letter Percentage Threshold (between 0 and 1)")]
        public float CapitalLetterPercentageThreshold { get; set; }
    }

}

private class Configuration
{
    [JsonProperty("Word Length Threshold")]
    public int WordLengthThreshold { get; set; }
    [JsonProperty("Capital Letter Percentage Threshold (between 0 and 1)")]
    public float CapitalLetterPercentageThreshold { get; set; }
}


```

---

## CaptureTheFlag by k1lly0u - Capture the flag event mode for Event Manager

```csharp
using Newtonsoft.Json;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

Oxide.Plugins
[Info("CaptureTheFlag", "k1lly0u", "0.4.2"), Description("Capture the flag event mode for EventManager")]
 class CaptureTheFlag : RustPlugin, IEventPlugin
{
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private object CanUpdateSign(BasePlayer player, Signage sign);
    private void Unload();
    public bool InitializeEvent(EventManager.EventConfig config);
    public bool CanUseClassSelector { get; set; }
    public bool RequireTimeLimit { get; set; }
    public bool RequireScoreLimit { get; set; }
    public bool UseScoreLimit { get; set; }
    public bool UseTimeLimit { get; set; }
    public bool IsTeamEvent { get; set; }
    public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, string score1, string score2);
    public List<EventManager.EventParameter> AdditionalParameters { get; set; }
    public string ParameterIsValid(string fieldName, object value);
    public class CaptureTheFlagEvent : EventManager.BaseEventGame
    {
        public EventManager.Team winningTeam;
        internal int flagRespawnTime;
        private int teamAScore;
        private int teamBScore;
        internal FlagController TeamAFlag { get; set; }
        internal FlagController TeamBFlag { get; set; }
        internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config);
        internal override void PrestartEvent();
        protected override void StartEvent();
        internal override void EndEvent();
        protected override void OnDestroy();
        protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player);
        protected override EventManager.Team GetPlayerTeam(BasePlayer player);
        internal override int GetTeamScore(EventManager.Team team);
        internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo);
        internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker, HitInfo info);
        protected override void GetWinningPlayers(List<EventManager.BaseEventPlayer> winners);
        internal void OnFlagCaptured(CaptureTheFlagPlayer eventPlayer, EventManager.Team team);
        internal string GetTeamColor(EventManager.Team team);
        protected override void BuildScoreboard();
        protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer);
        protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer);
        protected override void SortScores(List<EventManager.ScoreEntry> list);
    }

    internal class CaptureTheFlagPlayer : EventManager.BaseEventPlayer
    {
        public int FlagCaptures { get; set; }
        public bool IsCarryingFlag { get; set; }
    }

    internal class FlagController : MonoBehaviour
    {
        private Signage primary;
        private Signage secondary;
        private Transform tr;
        private Vector3 basePosition;
        private BoxCollider boxCollider;
        private uint signImageCRC;
        private CaptureTheFlagEvent captureTheFlagEvent;
        internal EventManager.Team Team { get; set; }
        internal CaptureTheFlagPlayer FlagHolder { get; set; }
        internal bool IsAtBase { get; set; }
        private const string SIGN_PREFAB;
        private const float ROTATE_SPEED;
        internal static FlagController Create(CaptureTheFlagEvent captureTheFlagEvent, EventManager.Team team, Vector3 position);
        private static Signage Spawn(Vector3 position);
        private void Awake();
        private void Start();
        private void Update();
        private void OnDestroy();
        private void SetSignImages(Signage signage);
        private void OnTriggerEnter(Collider col);
        private void PickupFlag(CaptureTheFlagPlayer eventPlayer);
        internal void DropFlag(bool resetToBase);
        private void CaptureFlag(CaptureTheFlagPlayer eventPlayer);
        private void DroppedTimeExpired();
        private void ResetFlag();
    }

    private static ConfigData Configuration;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Respawn time (seconds)")]
        public int RespawnTime { get; set; }
        [JsonProperty(PropertyName = "Friendly fire damage modifier (0.0 is no damage, 1.0 is normal damage)")]
        public float FriendlyFireModifier { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    public string Message(string key, ulong playerId);
    private static Func<string, ulong, string> GetMessage;
    private readonly Dictionary<string, string> Messages;
}

public class CaptureTheFlagEvent : EventManager.BaseEventGame
{
    public EventManager.Team winningTeam;
    internal int flagRespawnTime;
    private int teamAScore;
    private int teamBScore;
    internal FlagController TeamAFlag { get; set; }
    internal FlagController TeamBFlag { get; set; }
    internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config);
    internal override void PrestartEvent();
    protected override void StartEvent();
    internal override void EndEvent();
    protected override void OnDestroy();
    protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player);
    protected override EventManager.Team GetPlayerTeam(BasePlayer player);
    internal override int GetTeamScore(EventManager.Team team);
    internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo);
    internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker, HitInfo info);
    protected override void GetWinningPlayers(List<EventManager.BaseEventPlayer> winners);
    internal void OnFlagCaptured(CaptureTheFlagPlayer eventPlayer, EventManager.Team team);
    internal string GetTeamColor(EventManager.Team team);
    protected override void BuildScoreboard();
    protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer);
    protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer);
    protected override void SortScores(List<EventManager.ScoreEntry> list);
}

internal class CaptureTheFlagPlayer : EventManager.BaseEventPlayer
{
    public int FlagCaptures { get; set; }
    public bool IsCarryingFlag { get; set; }
}

internal class FlagController : MonoBehaviour
{
    private Signage primary;
    private Signage secondary;
    private Transform tr;
    private Vector3 basePosition;
    private BoxCollider boxCollider;
    private uint signImageCRC;
    private CaptureTheFlagEvent captureTheFlagEvent;
    internal EventManager.Team Team { get; set; }
    internal CaptureTheFlagPlayer FlagHolder { get; set; }
    internal bool IsAtBase { get; set; }
    private const string SIGN_PREFAB;
    private const float ROTATE_SPEED;
    internal static FlagController Create(CaptureTheFlagEvent captureTheFlagEvent, EventManager.Team team, Vector3 position);
    private static Signage Spawn(Vector3 position);
    private void Awake();
    private void Start();
    private void Update();
    private void OnDestroy();
    private void SetSignImages(Signage signage);
    private void OnTriggerEnter(Collider col);
    private void PickupFlag(CaptureTheFlagPlayer eventPlayer);
    internal void DropFlag(bool resetToBase);
    private void CaptureFlag(CaptureTheFlagPlayer eventPlayer);
    private void DroppedTimeExpired();
    private void ResetFlag();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Respawn time (seconds)")]
    public int RespawnTime { get; set; }
    [JsonProperty(PropertyName = "Friendly fire damage modifier (0.0 is no damage, 1.0 is normal damage)")]
    public float FriendlyFireModifier { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}


```

---

## CarCollisionDamageScaler by Zugzwang - Scales collision damage on the new modular vehicles.

```csharp
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Car Collision Damage Scaler", "Zugzwang", "1.0.2")]
[Description("Scales collision damage on the new modular vehicles.")]
public class CarCollisionDamageScaler : CovalencePlugin
{
    private const string permissionGod;
    private const string permissionScale;
    private void Init();
    private PluginConfig config;
    private class PluginConfig
    {
        public bool requireDriver;
        public bool requirePermission;
        public float scale;
        public PluginConfig();
    }

    protected override void LoadDefaultConfig();
     void OnEntityTakeDamage(BaseVehicleModule entity, HitInfo info);
}

private class PluginConfig
{
    public bool requireDriver;
    public bool requirePermission;
    public float scale;
    public PluginConfig();
}


```

---

## CarCommanderLite by k1lly0u - Car spawner with added features

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;
using System.Linq;
using System.Globalization;

Oxide.Plugins
[Info("CarCommanderLite", "k1lly0u", "0.1.3")]
[Description("Car spawner with added features")]
 class CarCommanderLite : RustPlugin
{
    [PluginReference]
     Plugin Spawns;
    private List<uint> storedCars;
    private DynamicConfigFile data;
    static CarCommanderLite ins;
    private List<CarController> saveableCars;
    private bool initialized;
    private bool wipeData;
    const string carPrefab;
    const string heliExplosion;
    const string uiHealth;
    private void Loaded();
    private void OnServerInitialized();
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnEntityKill(BaseNetworkable networkable);
    private void OnNewSave(string filename);
    private void OnServerSave();
    private void Unload();
    private object CanMountEntity(BasePlayer player, BaseMountable mountable);
    private void OnEntityMounted(BaseMountable mountable, BasePlayer player);
    private void OnEntityDismounted(BaseMountable mountable, BasePlayer player);
    private bool HasPermission(BasePlayer player, string perm);
    private void RestoreVehicles();
    private BaseEntity SpawnAtLocation(Vector3 position, Quaternion rotation, bool enableSaving);
    private void CheckForSpawns();
    public class CarController : MonoBehaviour
    {
        public BasicCar entity;
        public BasePlayer player;
        public bool isDieing;
        private bool allowHeldItems;
        private string[] disallowedItems;
        private void Awake();
        private void Update();
        public void OnDriverEnter(BasePlayer player);
        public void OnDriverExit();
        public void ManageDamage(HitInfo info);
        private void NullifyDamage(HitInfo info);
        public void UpdateHeldItems();
        public void CheckWaterLevel();
        public void StopToDie();
        private void OnDeath();
    }

    public static class UI
    {
        static public CuiElementContainer ElementContainer(string panelName, string color, UI4 dimensions, bool useCursor, string parent);
        static public void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor);
        static public void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align);
        public static string Color(string hexColor, float alpha);
    }

    public class UI4
    {
        public float xMin;
        public float yMin;
        public float xMax;
        public float yMax;
        public UI4(float xMin, float yMin, float xMax, float yMax);
        public string GetMin();
        public string GetMax();
    }

    private void CreateHealthUI(BasePlayer player, CarController controller);
    private void DestroyUI(BasePlayer player);
    [ChatCommand("spawncar")]
     void cmdSpawnCar(BasePlayer player, string command, string[] args);
    [ChatCommand("clearcars")]
     void cmdClearCars(BasePlayer player, string command, string[] args);
    [ConsoleCommand("clearcars")]
     void ccmdClearCars(ConsoleSystem.Arg arg);
    [ConsoleCommand("spawncar")]
     void ccmdSpawnCar(ConsoleSystem.Arg arg);
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Spawnable Options")]
        public SpawnableOptions Spawnable { get; set; }
        [JsonProperty(PropertyName = "Active Item Options")]
        public ActiveItemOptions ActiveItems { get; set; }
        [JsonProperty(PropertyName = "UI Options")]
        public UIOptions UI { get; set; }
        public class SpawnableOptions
        {
            [JsonProperty(PropertyName = "Enable automatic vehicle spawning")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Spawnfile name")]
            public string Spawnfile { get; set; }
            [JsonProperty(PropertyName = "Maximum spawned vehicles at any time")]
            public int Max { get; set; }
            [JsonProperty(PropertyName = "Time between autospawns (seconds)")]
            public int Time { get; set; }
        }

        public class ActiveItemOptions
        {
            [JsonProperty(PropertyName = "Disable all held items")]
            public bool Disable { get; set; }
            [JsonProperty(PropertyName = "List of disallowed held items (item shortnames)")]
            public string[] BlackList { get; set; }
        }

        public class UIOptions
        {
            [JsonProperty(PropertyName = "Health settings")]
            public UICounter Health { get; set; }
            public class UICounter
            {
                [JsonProperty(PropertyName = "Display to player")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Position - X minimum")]
                public float Xmin { get; set; }
                [JsonProperty(PropertyName = "Position - X maximum")]
                public float XMax { get; set; }
                [JsonProperty(PropertyName = "Position - Y minimum")]
                public float YMin { get; set; }
                [JsonProperty(PropertyName = "Position - Y maximum")]
                public float YMax { get; set; }
                [JsonProperty(PropertyName = "Background color (hex)")]
                public string Color1 { get; set; }
                [JsonProperty(PropertyName = "Background alpha")]
                public float Color1A { get; set; }
                [JsonProperty(PropertyName = "Status color (hex)")]
                public string Color2 { get; set; }
                [JsonProperty(PropertyName = "Status alpha")]
                public float Color2A { get; set; }
            }

        }

    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     void SaveData();
     void LoadData();
     string msg(string key, string playerId);
     Dictionary<string, string> Messages;
}

public class CarController : MonoBehaviour
{
    public BasicCar entity;
    public BasePlayer player;
    public bool isDieing;
    private bool allowHeldItems;
    private string[] disallowedItems;
    private void Awake();
    private void Update();
    public void OnDriverEnter(BasePlayer player);
    public void OnDriverExit();
    public void ManageDamage(HitInfo info);
    private void NullifyDamage(HitInfo info);
    public void UpdateHeldItems();
    public void CheckWaterLevel();
    public void StopToDie();
    private void OnDeath();
}

public static class UI
{
    static public CuiElementContainer ElementContainer(string panelName, string color, UI4 dimensions, bool useCursor, string parent);
    static public void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor);
    static public void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align);
    public static string Color(string hexColor, float alpha);
}

public class UI4
{
    public float xMin;
    public float yMin;
    public float xMax;
    public float yMax;
    public UI4(float xMin, float yMin, float xMax, float yMax);
    public string GetMin();
    public string GetMax();
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Spawnable Options")]
    public SpawnableOptions Spawnable { get; set; }
    [JsonProperty(PropertyName = "Active Item Options")]
    public ActiveItemOptions ActiveItems { get; set; }
    [JsonProperty(PropertyName = "UI Options")]
    public UIOptions UI { get; set; }
    public class SpawnableOptions
    {
        [JsonProperty(PropertyName = "Enable automatic vehicle spawning")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Spawnfile name")]
        public string Spawnfile { get; set; }
        [JsonProperty(PropertyName = "Maximum spawned vehicles at any time")]
        public int Max { get; set; }
        [JsonProperty(PropertyName = "Time between autospawns (seconds)")]
        public int Time { get; set; }
    }

    public class ActiveItemOptions
    {
        [JsonProperty(PropertyName = "Disable all held items")]
        public bool Disable { get; set; }
        [JsonProperty(PropertyName = "List of disallowed held items (item shortnames)")]
        public string[] BlackList { get; set; }
    }

    public class UIOptions
    {
        [JsonProperty(PropertyName = "Health settings")]
        public UICounter Health { get; set; }
        public class UICounter
        {
            [JsonProperty(PropertyName = "Display to player")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Position - X minimum")]
            public float Xmin { get; set; }
            [JsonProperty(PropertyName = "Position - X maximum")]
            public float XMax { get; set; }
            [JsonProperty(PropertyName = "Position - Y minimum")]
            public float YMin { get; set; }
            [JsonProperty(PropertyName = "Position - Y maximum")]
            public float YMax { get; set; }
            [JsonProperty(PropertyName = "Background color (hex)")]
            public string Color1 { get; set; }
            [JsonProperty(PropertyName = "Background alpha")]
            public float Color1A { get; set; }
            [JsonProperty(PropertyName = "Status color (hex)")]
            public string Color2 { get; set; }
            [JsonProperty(PropertyName = "Status alpha")]
            public float Color2A { get; set; }
        }

    }

}

public class SpawnableOptions
{
    [JsonProperty(PropertyName = "Enable automatic vehicle spawning")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Spawnfile name")]
    public string Spawnfile { get; set; }
    [JsonProperty(PropertyName = "Maximum spawned vehicles at any time")]
    public int Max { get; set; }
    [JsonProperty(PropertyName = "Time between autospawns (seconds)")]
    public int Time { get; set; }
}

public class ActiveItemOptions
{
    [JsonProperty(PropertyName = "Disable all held items")]
    public bool Disable { get; set; }
    [JsonProperty(PropertyName = "List of disallowed held items (item shortnames)")]
    public string[] BlackList { get; set; }
}

public class UIOptions
{
    [JsonProperty(PropertyName = "Health settings")]
    public UICounter Health { get; set; }
    public class UICounter
    {
        [JsonProperty(PropertyName = "Display to player")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Position - X minimum")]
        public float Xmin { get; set; }
        [JsonProperty(PropertyName = "Position - X maximum")]
        public float XMax { get; set; }
        [JsonProperty(PropertyName = "Position - Y minimum")]
        public float YMin { get; set; }
        [JsonProperty(PropertyName = "Position - Y maximum")]
        public float YMax { get; set; }
        [JsonProperty(PropertyName = "Background color (hex)")]
        public string Color1 { get; set; }
        [JsonProperty(PropertyName = "Background alpha")]
        public float Color1A { get; set; }
        [JsonProperty(PropertyName = "Status color (hex)")]
        public string Color2 { get; set; }
        [JsonProperty(PropertyName = "Status alpha")]
        public float Color2A { get; set; }
    }

}

public class UICounter
{
    [JsonProperty(PropertyName = "Display to player")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Position - X minimum")]
    public float Xmin { get; set; }
    [JsonProperty(PropertyName = "Position - X maximum")]
    public float XMax { get; set; }
    [JsonProperty(PropertyName = "Position - Y minimum")]
    public float YMin { get; set; }
    [JsonProperty(PropertyName = "Position - Y maximum")]
    public float YMax { get; set; }
    [JsonProperty(PropertyName = "Background color (hex)")]
    public string Color1 { get; set; }
    [JsonProperty(PropertyName = "Background alpha")]
    public float Color1A { get; set; }
    [JsonProperty(PropertyName = "Status color (hex)")]
    public string Color2 { get; set; }
    [JsonProperty(PropertyName = "Status alpha")]
    public float Color2A { get; set; }
}


```

---

## CardReaderDoors by Razor - Creates card reader access doors.

```csharp
using System;
using System.Linq;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using UnityEngine;
using Oxide.Core;
using System.Globalization;

Oxide.Plugins
[Info("Card Reader Doors", "Ts3Hosting", "2.1.1")]
[Description("Create access doors with card readers")]
public class CardReaderDoors : RustPlugin
{
     PlayerEntity pcdData;
    private DynamicConfigFile PCDDATA;
    private bool Changed;
    private static string theadmin;
    public Dictionary<ulong, int> activate;
    public ulong CardskinID;
    public int close;
    public float damagetotal;
    public bool damage;
    public bool damageNo;
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
     void LoadVariables();
     void Init();
     object GetConfig(string menu, string datavalue, object defaultValue);
    private void RegisterPermissions();
     void LoadData();
     class Access
    {
        public string displayName;
        public ulong steamID;
    }

     class Reader
    {
    }

     class PlayerEntity
    {
        public Dictionary<string, PCDInfo> pEntity;
        public PlayerEntity();
    }

     class PCDInfo
    {
        public uint SpawnEntity;
        public ulong doorID;
        public string roomName;
        public string permission;
        public Dictionary<ulong, Reader> reader;
        public List<Access> access;
    }

     void SaveData();
    private void OnHammerHit(BasePlayer player, HitInfo info);
     void OnEntityBuilt(Planner plan, GameObject go);
    private string checkdoor(ulong netID);
     object OnCardSwipe(CardReader reader1, Keycard card1, BasePlayer player);
     void SpawnRefresh(BaseNetworkable entity1);
    [ChatCommand("lockdoor")]
    private void lockdoor(BasePlayer player, string command, string[] args);
    [ChatCommand("setlock")]
    private void setlock(BasePlayer player, string command, string[] args);
    private BaseEntity raydoor(BasePlayer player);
}

 class Access
{
    public string displayName;
    public ulong steamID;
}

 class Reader
{
}

 class PlayerEntity
{
    public Dictionary<string, PCDInfo> pEntity;
    public PlayerEntity();
}

 class PCDInfo
{
    public uint SpawnEntity;
    public ulong doorID;
    public string roomName;
    public string permission;
    public Dictionary<ulong, Reader> reader;
    public List<Access> access;
}


```

---

## CargoShipCCTV by  - Adds configurable CCTV to the Cargo Ship, along with onboard computer station for monitoring

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Cargo Ship CCTV", "GrumpyGordon", "1.2.3")]
[Description("Adds CCTV to the cargo ship including an onboard monitoring station.")]
public class CargoShipCCTV : RustPlugin
{
    private Configuration _config;
    const string _camPrefab;
    const string _computerStation;
    private class Configuration
    {
        [JsonProperty("Announce Cargo Ship Code")]
        public bool AnnounceCargoShipCode;
        [JsonProperty("Make Camera Names Unique")]
        public bool MakeCameraNamesUnique;
        public List<CCTV_Config> Cameras;
        public List<Station_Config> Stations;
    }

    private Configuration GetDefaultConfiguration();
    private class CCTV_Config
    {
        [JsonProperty("Camera Name")]
        public string Name;
        [JsonProperty("Camera Position")]
        public Vector3 Position;
        [JsonProperty("Camera Rotation")]
        public Vector3 Rotation;
        [JsonProperty("Camera Pitch")]
        public float Pitch;
        [JsonProperty("Camera Yaw")]
        public float Yaw;
        public CCTV_Config(string n, Vector3 p, Vector3? r, float pitch, float yaw);
        public CCTV_Config Get(string suffix);
    }

    private class Station_Config
    {
        [JsonProperty("Station Position")]
        public Vector3 Position;
        [JsonProperty("Station Rotation")]
        public Vector3 Rotation;
        public Station_Config(Vector3 p, Vector3? r);
    }

    private void Init();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnEntitySpawned(CargoShip cargo);
    private object CanPickupEntity(BasePlayer player, ComputerStation entity);
    protected override void LoadDefaultMessages();
    public void Setup(CargoShip cargo);
    private void AnnounceCargoShip(int code);
    public void RemoveCollidersFromEntity(BaseEntity colliderEntity);
    private void MakeComputerStation(BaseEntity obj, Station_Config config, List<CCTV_RC> cams);
     CCTV_RC MakeCamera(BaseEntity obj, CCTV_Config config, int code);
}

private class Configuration
{
    [JsonProperty("Announce Cargo Ship Code")]
    public bool AnnounceCargoShipCode;
    [JsonProperty("Make Camera Names Unique")]
    public bool MakeCameraNamesUnique;
    public List<CCTV_Config> Cameras;
    public List<Station_Config> Stations;
}

private class CCTV_Config
{
    [JsonProperty("Camera Name")]
    public string Name;
    [JsonProperty("Camera Position")]
    public Vector3 Position;
    [JsonProperty("Camera Rotation")]
    public Vector3 Rotation;
    [JsonProperty("Camera Pitch")]
    public float Pitch;
    [JsonProperty("Camera Yaw")]
    public float Yaw;
    public CCTV_Config(string n, Vector3 p, Vector3? r, float pitch, float yaw);
    public CCTV_Config Get(string suffix);
}

private class Station_Config
{
    [JsonProperty("Station Position")]
    public Vector3 Position;
    [JsonProperty("Station Rotation")]
    public Vector3 Rotation;
    public Station_Config(Vector3 p, Vector3? r);
}


```

---

## CargoWetnessFix by yetzt - Prevents players getting wetter when on the Cargo Ship

```csharp
using Oxide.Core.Plugins;
using Oxide.Core;
using Oxide.Plugins;
using Rust;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Cargo Wetness Fix", "yetzt", "1.0.2")]
[Description("Prevents players from getting wet on the Cargo Ship")]
public class CargoWetnessFix : RustPlugin
{
    private List<BasePlayer> onboard;
     Timer checker;
     int numships;
     void OnServerInitialized();
     void Unload();
     void OnEntitySpawned(CargoShip entity);
    private void OnEntityKill(CargoShip entity);
    private void OnRunPlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player, float delta);
     void OnEntityEnter(TriggerParent trigger, BasePlayer player);
     void OnEntityLeave(TriggerParent trigger, BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
     void OnPlayerSleepEnded(BasePlayer player);
     void RunChecker();
     void CheckPlayer(BasePlayer player);
     bool IsEmbarked(BasePlayer player);
     void Embark(BasePlayer player);
     void Disembark(BasePlayer player);
}


```

---

## CarHorn by  - Car Horn adds a simple horn to cars.

```csharp
using System.Collections.Generic;
using UnityEngine;
using System;

Oxide.Plugins
[Info("Car Horn", "dFxPhoeniX", "1.1.6")]
[Description("Adds an FX similar to that of a car horn to the driver in the sedan.")]
 class CarHorn : RustPlugin
{
    private bool Changed;
    private string hornPrefab;
    private const string permissionUse;
    protected override void LoadDefaultConfig();
    private void OnPlayerInput(BasePlayer player, InputState input, BaseEntity entity);
     void Init();
     void LoadVariables();
     object GetConfig(string menu, string datavalue, object defaultValue);
}


```

---

## CarLockUI by WhiteThunder - Adds a UI to deploy code locks to modular cars

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Car Lock UI", "WhiteThunder", "1.0.2")]
[Description("Adds a UI to add code locks to modular cars.")]
internal class CarLockUI : CovalencePlugin
{
    [PluginReference]
    private Plugin VehicleDeployedLocks;
    private static CarLockUI _pluginInstance;
    private Configuration _pluginConfig;
    private const string PermissionUseCodeLock;
    private const int CodeLockItemId;
    private readonly CarLiftTracker _liftTracker;
    private CodeLockUIManager UIManager;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnLootEntity(BasePlayer player, ModularCarGarage carLift);
    private void OnPlayerLootEnd(PlayerLoot inventory);
    private void OnEntitySpawned(VehicleModuleSeating seatingModule);
    private void OnEntityKill(VehicleModuleSeating seatingModule);
    private void OnEntityKill(CodeLock codeLock);
    private void OnVehicleLockDeployed(ModularCar car);
    [Command("carlockui.deploy.codelock")]
    private void UICommandDeploy(IPlayer player, string cmd, string[] args);
    [Command("carlockui.remove.codelock")]
    private void UICommandRemove(IPlayer player, string cmd, string[] args);
    private bool CanCarHaveLock(ModularCar car);
    private bool CanPlayerDeployCodeLock(BasePlayer player, ModularCar car);
    private BaseLock GetCarLock(ModularCar car);
    private VehicleModuleSeating FindFirstDriverModule(ModularCar car);
    private class CarLiftTracker
    {
        private readonly Dictionary<ModularCar, List<BasePlayer>> LootersOfCar;
        private readonly Dictionary<BasePlayer, ModularCar> LootingCar;
        public ModularCar GetCarPlayerIsLooting(BasePlayer player);
        public List<BasePlayer> GetPlayersLootingCar(ModularCar car);
        public void HandlePlayerLootCarLift(BasePlayer player, ModularCarGarage carLift);
        public void HandlePlayerLootEnd(BasePlayer player);
    }

    private class CodeLockUIManager
    {
        private const string CodeLockUIName;
        private readonly UISettings Settings;
        private readonly Dictionary<BasePlayer, UIState> PlayerUIStates;
        public CodeLockUIManager(UISettings settings);
        public void DestroyAllUIs();
        public void UpdateCarUI(ModularCar car);
        private void UpdatePlayerCarUI(BasePlayer player, ModularCar car, UIState desiredUIState);
        public void DestroyPlayerUI(BasePlayer player);
        private void SendPlayerUI(BasePlayer player, UIState uiState);
    }

    private Configuration GetDefaultConfig();
    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("UISettings")]
        public UISettings UISettings;
    }

    private class UISettings
    {
        [JsonProperty("AnchorMin")]
        public string AnchorMin;
        [JsonProperty("AnchorMax")]
        public string AnchorMax;
        [JsonProperty("OffsetMin")]
        public string OffsetMin;
        [JsonProperty("OffsetMax")]
        public string OffsetMax;
        [JsonProperty("AddButtonColor")]
        public string AddButtonColor;
        [JsonProperty("RemoveButtonColor")]
        public string RemoveButtonColor;
        [JsonProperty("ButtonTextColor")]
        public string ButtonTextColor;
    }

    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(IPlayer player, string messageName, object[] args);
    protected override void LoadDefaultMessages();
}

private class CarLiftTracker
{
    private readonly Dictionary<ModularCar, List<BasePlayer>> LootersOfCar;
    private readonly Dictionary<BasePlayer, ModularCar> LootingCar;
    public ModularCar GetCarPlayerIsLooting(BasePlayer player);
    public List<BasePlayer> GetPlayersLootingCar(ModularCar car);
    public void HandlePlayerLootCarLift(BasePlayer player, ModularCarGarage carLift);
    public void HandlePlayerLootEnd(BasePlayer player);
}

private class CodeLockUIManager
{
    private const string CodeLockUIName;
    private readonly UISettings Settings;
    private readonly Dictionary<BasePlayer, UIState> PlayerUIStates;
    public CodeLockUIManager(UISettings settings);
    public void DestroyAllUIs();
    public void UpdateCarUI(ModularCar car);
    private void UpdatePlayerCarUI(BasePlayer player, ModularCar car, UIState desiredUIState);
    public void DestroyPlayerUI(BasePlayer player);
    private void SendPlayerUI(BasePlayer player, UIState uiState);
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("UISettings")]
    public UISettings UISettings;
}

private class UISettings
{
    [JsonProperty("AnchorMin")]
    public string AnchorMin;
    [JsonProperty("AnchorMax")]
    public string AnchorMax;
    [JsonProperty("OffsetMin")]
    public string OffsetMin;
    [JsonProperty("OffsetMax")]
    public string OffsetMax;
    [JsonProperty("AddButtonColor")]
    public string AddButtonColor;
    [JsonProperty("RemoveButtonColor")]
    public string RemoveButtonColor;
    [JsonProperty("ButtonTextColor")]
    public string ButtonTextColor;
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## CarRadio by TCM420G - Allows players to install a boombox/radio into your modular vehicle cockpit

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust.Instruments;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using static InstrumentKeyController;

Oxide.Plugins
[Info("Car Radio", "TCM420G", "1.0.70")]
[Description("Allows players to attach radios to vehicles")]
 class CarRadio : CovalencePlugin
{
    private const string PERMISSION_ATTACHRADIO;
    private const string PERMISSION_DETACHRADIO;
    private const string PERMISSION_ATTACHRADIO_GLOBAL;
    private const string PERMISSION_DETACHRADIO_GLOBAL;
    private const string I18N_MISSING_SIREN;
    private const string I18N_COULD_NOT_ATTACH;
    private const string I18N_NOT_SUPPORTED;
    private const string I18N_ATTACHED;
    private const string I18N_ATTACHED_GLOBAL;
    private const string I18N_DETACHED;
    private const string I18N_DETACHED_GLOBAL;
    private const string I18N_NOT_A_VEHICLE;
    private const string I18N_RADIO;
    private const string I18N_PLAYERS_ONLY;
    private const string PREFAB_COCKPIT;
    private const string PREFAB_COCKPIT_ARMORED;
    private const string PREFAB_COCKPIT_WITH_ENGINE;
    private const string PREFAB_FLASHERLIGHT;
    private const string PREFAB_SIRENLIGHT;
    private const string PREFAB_SPOTLIGHT;
    private const string PREFAB_RADIO;
    private const string PREFAB_KAYAK;
    private const string PREFAB_TUGBOAT;
    private const string PREFAB_ROWBOAT;
    private const string PREFAB_RHIB;
    private const string PREFAB_SEDAN;
    private const string PREFAB_SEDANRAIL;
    private const string PREFAB_MINICOPTER;
    private const string PREFAB_ATTACKHELI;
    private const string PREFAB_TRANSPORTHELI;
    private const string PREFAB_CHINOOK;
    private const string PREFAB_MAGNETCRANE;
    private const string PREFAB_SUBMARINESOLO;
    private const string PREFAB_SUBMARINEDUO;
    private const string PREFAB_SNOWMOBILE;
    private const string PREFAB_SNOWMOBILETOMAHA;
    private const string PREFAB_WORKCART;
    private const string PREFAB_TRAINENGINE;
    private const string PREFAB_TRAINENGINE_COVERED;
    private const string PREFAB_TRAINENGINE_LOCOMOTIVE;
    private const string PREFAB_HORSE;
    private const string PREFAB_HOTAIRBALLOON;
    private const string KEY_MODULAR_CAR;
    private const string DATAPATH_RADIO;
    private static readonly Radio SIREN_DEFAULT;
    private static readonly Radio SIREN_SILENT;
    private class DataContainer
    {
        public Dictionary<ulong, VehicleContainer> VehicleRadioMap;
    }

    private class VehicleContainer
    {
        public string RadioName;
        public RadioController.States State;
        public HashSet<ulong> NetIDs;
        public VehicleContainer();
        public VehicleContainer(string aRadioName, RadioController.States aState, IEnumerable<ulong> someNetIDs);
    }

    private Configuration config;
    private IDictionary<string, Radio> RadioDictionary { get; set; }
    private class Configuration
    {
        [JsonProperty("MountNeeded")]
        public bool MountNeeded;
        [JsonProperty("SoundEnabled")]
        public bool SoundEnabled;
        [JsonProperty("RadioSpawnProbability")]
        public Dictionary<string, float> RadioSpawnProbability;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty("DefaultState")]
        public RadioController.States DefaultState;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private class Tone
    {
        public Tone(Notes aNote, NoteType aNoteType, int anOctave, float aDuration);
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty("Note")]
        public Notes Note;
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty("NoteType")]
        public NoteType NoteType;
        [JsonProperty("Octave")]
        public int Octave;
        [JsonProperty("Duration")]
        public float Duration;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private class Radio
    {
        public Radio(string aName, Dictionary<string, Attachment[]> someModules, Dictionary<string, Attachment[]> someVehicles, Tone[] someTones);
        [JsonProperty("Name")]
        public string Name;
        [JsonProperty("Tones")]
        public Tone[] Tones;
        [JsonProperty("Modules")]
        public Dictionary<string, Attachment[]> Modules;
        [JsonProperty("Vehicles")]
        public Dictionary<string, Attachment[]> Vehicles;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private class Attachment
    {
        public Attachment(string aPrefab, Vector3 aPosition, Vector3 anAngle, string aBone);
        [JsonProperty("Prefab")]
        public string Prefab;
        [JsonProperty("Position")]
        public Vector3 Position;
        [JsonProperty("Angle")]
        public Vector3 Angle;
        [JsonProperty("Bone")]
        public string Bone;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    [Command("attachradio"), Permission(PERMISSION_ATTACHRADIO)]
    private void AttachCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs);
    [Command("removeradio"), Permission(PERMISSION_DETACHRADIO)]
    private void DetachCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs);
    [Command("attachallcarradio"), Permission(PERMISSION_ATTACHRADIO_GLOBAL)]
    private void AttachAllCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs);
    [Command("detachallcarradio"), Permission(PERMISSION_DETACHRADIO_GLOBAL)]
    private void DetachAllCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs);
    [Command("togglecarradio")]
    private void ToggleRadios(IPlayer aPlayer, string aCommand, string[] someArgs);
    private void Unload();
    private void OnServerSave();
    private void OnServerInitialized(bool anInitialFlag);
    private void OnEntitySpawned(BaseVehicle aVehicle);
    private void AttachRadios(BaseVehicle aVehicle, Radio aRadio, RadioController.States anInitialState, IPlayer aPlayer);
    private bool SpawnAttachments(IDictionary<string, Attachment[]> someAttachments, IPlayer aPlayer, RadioController theController, BaseEntity aParent);
    private RadioController CreateRadioController(BaseVehicle aVehicle, Radio aRadio, IEnumerable<ulong> someNetIDs);
    private bool DetachRadios(BaseVehicle aVehicle);
    private static void Destroy(BaseEntity anEntity);
    private BaseEntity AttachEntity(BaseEntity aParent, string aPrefab, Vector3 aPosition, Vector3 anAngle, string aBone);
    private static void ToogleRadios(IOEntity anIOEntity, bool theEnabledFlag);
    private BaseVehicle RaycastVehicle(IPlayer aPlayer);
    private Radio FindRadioForName(string aName, IPlayer aPlayer);
    private string GetText(string aKey, string aPlayerId, object[] someArgs);
    private void Message(IPlayer aPlayer, string anI18nKey, object[] someArgs);
    private void Message(BasePlayer aPlayer, string anI18nKey, object[] someArgs);
    private class RadioController : FacepunchBehaviour
    {
        private BaseVehicle vehicle;
        private InstrumentTool trumpet;
        public Configuration Config { get; set; }
        public States State { get; set; }
        public Radio Radio { get; set; }
        public ISet<ulong> NetIDs { get; set; }
        public States ChangeState();
        public void SetState(States aState);
        public void RefreshRadioState();
        private InstrumentTool GetTrumpet();
        private BaseVehicle GetVehicle();
        private void PlayTone(int anIndex);
    }

}

private class DataContainer
{
    public Dictionary<ulong, VehicleContainer> VehicleRadioMap;
}

private class VehicleContainer
{
    public string RadioName;
    public RadioController.States State;
    public HashSet<ulong> NetIDs;
    public VehicleContainer();
    public VehicleContainer(string aRadioName, RadioController.States aState, IEnumerable<ulong> someNetIDs);
}

private class Configuration
{
    [JsonProperty("MountNeeded")]
    public bool MountNeeded;
    [JsonProperty("SoundEnabled")]
    public bool SoundEnabled;
    [JsonProperty("RadioSpawnProbability")]
    public Dictionary<string, float> RadioSpawnProbability;
    [JsonConverter(typeof(StringEnumConverter))]
    [JsonProperty("DefaultState")]
    public RadioController.States DefaultState;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class Tone
{
    public Tone(Notes aNote, NoteType aNoteType, int anOctave, float aDuration);
    [JsonConverter(typeof(StringEnumConverter))]
    [JsonProperty("Note")]
    public Notes Note;
    [JsonConverter(typeof(StringEnumConverter))]
    [JsonProperty("NoteType")]
    public NoteType NoteType;
    [JsonProperty("Octave")]
    public int Octave;
    [JsonProperty("Duration")]
    public float Duration;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class Radio
{
    public Radio(string aName, Dictionary<string, Attachment[]> someModules, Dictionary<string, Attachment[]> someVehicles, Tone[] someTones);
    [JsonProperty("Name")]
    public string Name;
    [JsonProperty("Tones")]
    public Tone[] Tones;
    [JsonProperty("Modules")]
    public Dictionary<string, Attachment[]> Modules;
    [JsonProperty("Vehicles")]
    public Dictionary<string, Attachment[]> Vehicles;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class Attachment
{
    public Attachment(string aPrefab, Vector3 aPosition, Vector3 anAngle, string aBone);
    [JsonProperty("Prefab")]
    public string Prefab;
    [JsonProperty("Position")]
    public Vector3 Position;
    [JsonProperty("Angle")]
    public Vector3 Angle;
    [JsonProperty("Bone")]
    public string Bone;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private class RadioController : FacepunchBehaviour
{
    private BaseVehicle vehicle;
    private InstrumentTool trumpet;
    public Configuration Config { get; set; }
    public States State { get; set; }
    public Radio Radio { get; set; }
    public ISet<ulong> NetIDs { get; set; }
    public States ChangeState();
    public void SetState(States aState);
    public void RefreshRadioState();
    private InstrumentTool GetTrumpet();
    private BaseVehicle GetVehicle();
    private void PlayTone(int anIndex);
}


```

---

## CarSetup by misticos - Manage car options easily

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Car Setup", "misticos", "1.0.1")]
[Description("Manage car options easily")]
 class CarSetup : CovalencePlugin
{
    private static CarSetup _ins;
    private Dictionary<NetworkableId, BaseController> _controllers;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Sedan")]
        public SedanConfiguration BasicCar;
        [JsonProperty(PropertyName = "Modular Cars", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ModularCarConfiguration> ModularCars;
        public class ModularCarConfiguration : BaseConfiguration
        {
            [JsonProperty(PropertyName = "Selector")]
            public ModularCarSelector Selector;
            public class ModularCarSelector
            {
                [JsonProperty(PropertyName = "Modules Available",
                        ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public HashSet<int> Modules;
                public bool Fits(ModularCar car);
            }

        }

        public class SedanConfiguration : BaseConfiguration
        {
            [JsonProperty(PropertyName = "Steering Angle")]
            public float Steering;
        }

        public class BaseConfiguration
        {
            [JsonProperty(PropertyName = "Mass Multiplier")]
            public float MassMultiplier;
            [JsonProperty(PropertyName = "Wheel Colliders")]
            public WheelColliderData WheelColliders;
            [JsonProperty(PropertyName = "Movement")]
            public MovementData Movement;
            [JsonProperty(PropertyName = "Flipping")]
            public FlipData Flip;
            public class FlipData
            {
                [JsonProperty(PropertyName = "Minimum Rotation")]
                public float MinimumRotation;
                [JsonProperty(PropertyName = "Torque Applied")]
                public float Torque;
            }

            public class MovementData
            {
                [JsonProperty(PropertyName = "Forward Force")]
                public float ForceForward;
                [JsonProperty(PropertyName = "Backward Force")]
                public float ForceBackward;
            }

            public class WheelColliderData
            {
                [JsonProperty(PropertyName = "Mass Multiplier")]
                public float WheelMass;
                [JsonProperty(PropertyName = "Damping Rate Multiplier")]
                public float DampingRate;
                [JsonProperty(PropertyName = "Motor Torque")]
                public float TorqueMotor;
                [JsonProperty(PropertyName = "Brake Torque")]
                public float TorqueBrake;
                [JsonProperty(PropertyName = "Suspension")]
                public SuspensionData Suspension;
                public class SuspensionData
                {
                    [JsonProperty(PropertyName = "Extension Distance Multiplier")]
                    public float ExtensionDistance;
                    [JsonProperty(PropertyName = "Damper Force Multiplier")]
                    public float DamperForce;
                    [JsonProperty(PropertyName = "Sprint Force Multiplier")]
                    public float SpringForce;
                }

                public void Apply(WheelCollider wheel);
                public void Undo(WheelCollider wheel);
            }

        }

    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private void Init();
    private void OnServerInitialized();
    private void OnEntitySpawned(BasicCar vehicle);
    private void OnEntitySpawned(ModularCar vehicle);
    private void Unload();
    private void OnEntityMounted(BaseMountable mountable, BasePlayer player);
    private void OnEntityDismounted(BaseMountable mountable, BasePlayer player);
    [DefaultExecutionOrder(10000)]
    private abstract class BaseController : FacepunchBehaviour
    {
        protected WheelCollider[] Wheels;
        protected Rigidbody Rigidbody;
        public BasePlayer Driver;
    }

    private abstract class BaseController : BaseController
    {
        protected TVehicle Car;
        protected TConfig Base;
        private NetworkableId _netId;
        protected virtual void Awake();
        protected virtual void Start();
        protected void OnDestroy();
        protected virtual void FixedUpdate();
        protected void ApplyFlip();
        protected virtual void ApplyWheelTorque();
        protected abstract void ApplyWheelTorque(WheelCollider wheel);
        protected void ApplyMovement();
    }

    private class ModularCarController : BaseController<ModularCar, Configuration.ModularCarConfiguration>
    {
        private VisualCarWheel[] _modularWheels;
        protected override void Awake();
        protected override void Start();
        protected override void ApplyWheelTorque(WheelCollider wheel);
    }

    private class BasicCarController : BaseController<BasicCar, Configuration.SedanConfiguration>
    {
        protected override void Awake();
        protected override void Start();
        protected override void FixedUpdate();
        protected override void ApplyWheelTorque(WheelCollider wheel);
    }

}

private class Configuration
{
    [JsonProperty(PropertyName = "Sedan")]
    public SedanConfiguration BasicCar;
    [JsonProperty(PropertyName = "Modular Cars", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ModularCarConfiguration> ModularCars;
    public class ModularCarConfiguration : BaseConfiguration
    {
        [JsonProperty(PropertyName = "Selector")]
        public ModularCarSelector Selector;
        public class ModularCarSelector
        {
            [JsonProperty(PropertyName = "Modules Available",
                        ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public HashSet<int> Modules;
            public bool Fits(ModularCar car);
        }

    }

    public class SedanConfiguration : BaseConfiguration
    {
        [JsonProperty(PropertyName = "Steering Angle")]
        public float Steering;
    }

    public class BaseConfiguration
    {
        [JsonProperty(PropertyName = "Mass Multiplier")]
        public float MassMultiplier;
        [JsonProperty(PropertyName = "Wheel Colliders")]
        public WheelColliderData WheelColliders;
        [JsonProperty(PropertyName = "Movement")]
        public MovementData Movement;
        [JsonProperty(PropertyName = "Flipping")]
        public FlipData Flip;
        public class FlipData
        {
            [JsonProperty(PropertyName = "Minimum Rotation")]
            public float MinimumRotation;
            [JsonProperty(PropertyName = "Torque Applied")]
            public float Torque;
        }

        public class MovementData
        {
            [JsonProperty(PropertyName = "Forward Force")]
            public float ForceForward;
            [JsonProperty(PropertyName = "Backward Force")]
            public float ForceBackward;
        }

        public class WheelColliderData
        {
            [JsonProperty(PropertyName = "Mass Multiplier")]
            public float WheelMass;
            [JsonProperty(PropertyName = "Damping Rate Multiplier")]
            public float DampingRate;
            [JsonProperty(PropertyName = "Motor Torque")]
            public float TorqueMotor;
            [JsonProperty(PropertyName = "Brake Torque")]
            public float TorqueBrake;
            [JsonProperty(PropertyName = "Suspension")]
            public SuspensionData Suspension;
            public class SuspensionData
            {
                [JsonProperty(PropertyName = "Extension Distance Multiplier")]
                public float ExtensionDistance;
                [JsonProperty(PropertyName = "Damper Force Multiplier")]
                public float DamperForce;
                [JsonProperty(PropertyName = "Sprint Force Multiplier")]
                public float SpringForce;
            }

            public void Apply(WheelCollider wheel);
            public void Undo(WheelCollider wheel);
        }

    }

}

public class ModularCarConfiguration : BaseConfiguration
{
    [JsonProperty(PropertyName = "Selector")]
    public ModularCarSelector Selector;
    public class ModularCarSelector
    {
        [JsonProperty(PropertyName = "Modules Available",
                        ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public HashSet<int> Modules;
        public bool Fits(ModularCar car);
    }

}

public class ModularCarSelector
{
    [JsonProperty(PropertyName = "Modules Available",
                        ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public HashSet<int> Modules;
    public bool Fits(ModularCar car);
}

public class SedanConfiguration : BaseConfiguration
{
    [JsonProperty(PropertyName = "Steering Angle")]
    public float Steering;
}

public class BaseConfiguration
{
    [JsonProperty(PropertyName = "Mass Multiplier")]
    public float MassMultiplier;
    [JsonProperty(PropertyName = "Wheel Colliders")]
    public WheelColliderData WheelColliders;
    [JsonProperty(PropertyName = "Movement")]
    public MovementData Movement;
    [JsonProperty(PropertyName = "Flipping")]
    public FlipData Flip;
    public class FlipData
    {
        [JsonProperty(PropertyName = "Minimum Rotation")]
        public float MinimumRotation;
        [JsonProperty(PropertyName = "Torque Applied")]
        public float Torque;
    }

    public class MovementData
    {
        [JsonProperty(PropertyName = "Forward Force")]
        public float ForceForward;
        [JsonProperty(PropertyName = "Backward Force")]
        public float ForceBackward;
    }

    public class WheelColliderData
    {
        [JsonProperty(PropertyName = "Mass Multiplier")]
        public float WheelMass;
        [JsonProperty(PropertyName = "Damping Rate Multiplier")]
        public float DampingRate;
        [JsonProperty(PropertyName = "Motor Torque")]
        public float TorqueMotor;
        [JsonProperty(PropertyName = "Brake Torque")]
        public float TorqueBrake;
        [JsonProperty(PropertyName = "Suspension")]
        public SuspensionData Suspension;
        public class SuspensionData
        {
            [JsonProperty(PropertyName = "Extension Distance Multiplier")]
            public float ExtensionDistance;
            [JsonProperty(PropertyName = "Damper Force Multiplier")]
            public float DamperForce;
            [JsonProperty(PropertyName = "Sprint Force Multiplier")]
            public float SpringForce;
        }

        public void Apply(WheelCollider wheel);
        public void Undo(WheelCollider wheel);
    }

}

public class FlipData
{
    [JsonProperty(PropertyName = "Minimum Rotation")]
    public float MinimumRotation;
    [JsonProperty(PropertyName = "Torque Applied")]
    public float Torque;
}

public class MovementData
{
    [JsonProperty(PropertyName = "Forward Force")]
    public float ForceForward;
    [JsonProperty(PropertyName = "Backward Force")]
    public float ForceBackward;
}

public class WheelColliderData
{
    [JsonProperty(PropertyName = "Mass Multiplier")]
    public float WheelMass;
    [JsonProperty(PropertyName = "Damping Rate Multiplier")]
    public float DampingRate;
    [JsonProperty(PropertyName = "Motor Torque")]
    public float TorqueMotor;
    [JsonProperty(PropertyName = "Brake Torque")]
    public float TorqueBrake;
    [JsonProperty(PropertyName = "Suspension")]
    public SuspensionData Suspension;
    public class SuspensionData
    {
        [JsonProperty(PropertyName = "Extension Distance Multiplier")]
        public float ExtensionDistance;
        [JsonProperty(PropertyName = "Damper Force Multiplier")]
        public float DamperForce;
        [JsonProperty(PropertyName = "Sprint Force Multiplier")]
        public float SpringForce;
    }

    public void Apply(WheelCollider wheel);
    public void Undo(WheelCollider wheel);
}

public class SuspensionData
{
    [JsonProperty(PropertyName = "Extension Distance Multiplier")]
    public float ExtensionDistance;
    [JsonProperty(PropertyName = "Damper Force Multiplier")]
    public float DamperForce;
    [JsonProperty(PropertyName = "Sprint Force Multiplier")]
    public float SpringForce;
}

[DefaultExecutionOrder(10000)]
private abstract class BaseController : FacepunchBehaviour
{
    protected WheelCollider[] Wheels;
    protected Rigidbody Rigidbody;
    public BasePlayer Driver;
}

private abstract class BaseController : BaseController
{
    protected TVehicle Car;
    protected TConfig Base;
    private NetworkableId _netId;
    protected virtual void Awake();
    protected virtual void Start();
    protected void OnDestroy();
    protected virtual void FixedUpdate();
    protected void ApplyFlip();
    protected virtual void ApplyWheelTorque();
    protected abstract void ApplyWheelTorque(WheelCollider wheel);
    protected void ApplyMovement();
}

private class ModularCarController : BaseController<ModularCar, Configuration.ModularCarConfiguration>
{
    private VisualCarWheel[] _modularWheels;
    protected override void Awake();
    protected override void Start();
    protected override void ApplyWheelTorque(WheelCollider wheel);
}

private class BasicCarController : BaseController<BasicCar, Configuration.SedanConfiguration>
{
    protected override void Awake();
    protected override void Start();
    protected override void FixedUpdate();
    protected override void ApplyWheelTorque(WheelCollider wheel);
}


```

---

## CarSpawnSettings by WhiteThunder - Allows modular cars to spawn with configurable modules, health, fuel, and engine parts

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust.Modular;

Oxide.Plugins
[Info("Car Spawn Settings", "WhiteThunder", "2.3.1")]
[Description("Allows modular cars to spawn with configurable modules, health, fuel, and engine parts.")]
internal class CarSpawnSettings : CovalencePlugin
{
    private readonly object False;
    private Configuration _config;
    private VanillaPresetCache _vanillaPresetCache;
    private void Init();
    private object OnVehicleModulesAssign(ModularCar car);
    [Command("carspawnsettings.fillcars")]
    private void CommandFillCars(IPlayer player);
    private bool BootstrapWasBlocked(ModularCar car);
    private void ProcessCar(ModularCar car);
    private void AddCarModules(ModularCar car, IList<IModuleDefinition> modulePreset);
    private void BootstrapAfterModules(ModularCar car);
    private void MaybeAddFuel(ModularCar car);
    private void MaybeAddEngineParts(ModularCar car);
    private void AddPartsToEngineStorage(EngineStorage engineStorage);
    private bool TryAddEngineItem(EngineStorage engineStorage, int slot, int tier);
    private class VanillaModuleDefinition : IModuleDefinition
    {
        public int NumSockets { get; set; }
        private ItemDefinition _itemDefinition;
        public VanillaModuleDefinition(ItemModVehicleModule socketItemDefinition);
        public Item Create();
    }

    private class VanillaPresetCache
    {
        private Dictionary<ModularCarPresetConfig, IList<IModuleDefinition>> _cache;
        public IList<IModuleDefinition> GetModulePreset(ModularCarPresetConfig presetConfig);
    }

    private Configuration GetDefaultConfig();
    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("EnginePartsTier")]
        private int DeprecatedEnginePartsTier { get; set; }
        [JsonProperty("FuelAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
        private int DeprecatedFuelAmount;
        [JsonProperty("Engine parts")]
        public EnginePartConfiguration EngineParts;
        [JsonProperty("EngineParts")]
        public EnginePartConfiguration DeprecatedEngineParts { get; set; }
        [JsonProperty("Min fuel amount")]
        public int MinFuelAmount;
        [JsonProperty("MinFuelAmount")]
        public int DeprecatedMinFuelAmount { get; set; }
        [JsonProperty("Max fuel amount")]
        public int MaxFuelAmount;
        [JsonProperty("MaxFuelAmount")]
        private int DeprecatedMaxFuelAmount { get; set; }
        [JsonProperty("Min health percent")]
        public float MinHealthPercent;
        [JsonProperty("MinHealthPercent")]
        private float DeprecatedMinHealthPercent { get; set; }
        [JsonProperty("Max health percent")]
        public float MaxHealthPercent;
        [JsonProperty("MaxHealthPercent")]
        private float DeprecatedMaxHealthPercent { get; set; }
        [JsonProperty("HealthPercentage")]
        private float DeprecatedHealthPercentage { get; set; }
        [JsonProperty("Module presets")]
        public ModulePresetMap ModulePresetMap;
        [JsonProperty("ModulePresets")]
        private ModulePresetMap DeprecatedModulePresetMap { get; set; }
        public void Init(CarSpawnSettings plugin);
        public float RandomizeModuleCondition();
        public int RandomizeFuelAmount();
        public bool CanHaveEngineParts();
        public int RandomizeEnginePartTier();
        public float RandomizePartCondition();
        private float RandomizeCondition(float minPercent, float maxPercent);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class EnginePartConfiguration
    {
        [JsonProperty("Tier 1 chance")]
        public int Tier1Chance;
        [JsonProperty("Tier1Chance")]
        private int DeprecatedTier1Chance { get; set; }
        [JsonProperty("Tier 2 chance")]
        public int Tier2Chance;
        [JsonProperty("Tier2Chance")]
        private int DeprecatedTier2Chance { get; set; }
        [JsonProperty("Tier 3 chance")]
        public int Tier3Chance;
        [JsonProperty("Tier3Chance")]
        private int DeprecatedTier3Chance { get; set; }
        [JsonProperty("Min condition percent")]
        public float MinConditionPercent;
        [JsonProperty("MinConditionPercent")]
        private float DeprecatedMinConditionPercent { get; set; }
        [JsonProperty("Max condition percent")]
        public float MaxConditionPercent;
        [JsonProperty("MaxConditionPercent")]
        private float DeprecatedMaxConditionPercent { get; set; }
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class ModulePresetMap
    {
        [JsonProperty("2 sockets")]
        public ModulePresetConfiguration PresetsFor2Sockets;
        [JsonProperty("2Sockets")]
        private ModulePresetConfiguration DeprecatedPresetsFor2Sockets { get; set; }
        [JsonProperty("3 sockets")]
        public ModulePresetConfiguration PresetsFor3Sockets;
        [JsonProperty("3Sockets")]
        private ModulePresetConfiguration DeprecatedPresetsFor3Sockets { get; set; }
        [JsonProperty("4 sockets")]
        public ModulePresetConfiguration PresetsFor4Sockets;
        [JsonProperty("4Sockets")]
        private ModulePresetConfiguration DeprecatedPresetsFor4Sockets { get; set; }
        public void Init(CarSpawnSettings plugin);
        public ModulePresetConfiguration GetPresetConfigurationForSockets(int totalSockets);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class ModuleDefinition : IModuleDefinition
    {
        [JsonProperty("Item short name")]
        public string ItemShortName;
        [JsonProperty("Item skin ID")]
        public ulong SkinId;
        [JsonIgnore]
        public int NumSockets { get; set; }
        [JsonIgnore]
        private ItemDefinition _itemDefinition;
        public void Init(CarSpawnSettings plugin);
        public Item Create();
    }

    private class ModulePresetConfiguration
    {
        [JsonProperty("Use vanilla presets")]
        public bool UseVanillaPresets;
        [JsonProperty("UseVanillaPresets")]
        private bool DeprecatedUseVanillaPresets { get; set; }
        [JsonProperty("Custom presets")]
        public ModuleDefinition[][] CustomPresets;
        [JsonProperty("CustomPresets")]
        private object[][] DeprecatedCustomPresets { get; set; }
        public void Init(CarSpawnSettings plugin);
        private ModuleDefinition[][] ParseLegacyPresets(object[][] legacyPresetList);
        private ModuleDefinition ParseLegacyModuleDefinition(object moduleIdentifier);
    }

    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(string userId, string messageName, object[] args);
    private static class Lang
    {
        public const string FillSuccess;
    }

    protected override void LoadDefaultMessages();
}

private class VanillaModuleDefinition : IModuleDefinition
{
    public int NumSockets { get; set; }
    private ItemDefinition _itemDefinition;
    public VanillaModuleDefinition(ItemModVehicleModule socketItemDefinition);
    public Item Create();
}

private class VanillaPresetCache
{
    private Dictionary<ModularCarPresetConfig, IList<IModuleDefinition>> _cache;
    public IList<IModuleDefinition> GetModulePreset(ModularCarPresetConfig presetConfig);
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("EnginePartsTier")]
    private int DeprecatedEnginePartsTier { get; set; }
    [JsonProperty("FuelAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
    private int DeprecatedFuelAmount;
    [JsonProperty("Engine parts")]
    public EnginePartConfiguration EngineParts;
    [JsonProperty("EngineParts")]
    public EnginePartConfiguration DeprecatedEngineParts { get; set; }
    [JsonProperty("Min fuel amount")]
    public int MinFuelAmount;
    [JsonProperty("MinFuelAmount")]
    public int DeprecatedMinFuelAmount { get; set; }
    [JsonProperty("Max fuel amount")]
    public int MaxFuelAmount;
    [JsonProperty("MaxFuelAmount")]
    private int DeprecatedMaxFuelAmount { get; set; }
    [JsonProperty("Min health percent")]
    public float MinHealthPercent;
    [JsonProperty("MinHealthPercent")]
    private float DeprecatedMinHealthPercent { get; set; }
    [JsonProperty("Max health percent")]
    public float MaxHealthPercent;
    [JsonProperty("MaxHealthPercent")]
    private float DeprecatedMaxHealthPercent { get; set; }
    [JsonProperty("HealthPercentage")]
    private float DeprecatedHealthPercentage { get; set; }
    [JsonProperty("Module presets")]
    public ModulePresetMap ModulePresetMap;
    [JsonProperty("ModulePresets")]
    private ModulePresetMap DeprecatedModulePresetMap { get; set; }
    public void Init(CarSpawnSettings plugin);
    public float RandomizeModuleCondition();
    public int RandomizeFuelAmount();
    public bool CanHaveEngineParts();
    public int RandomizeEnginePartTier();
    public float RandomizePartCondition();
    private float RandomizeCondition(float minPercent, float maxPercent);
}

[JsonObject(MemberSerialization.OptIn)]
private class EnginePartConfiguration
{
    [JsonProperty("Tier 1 chance")]
    public int Tier1Chance;
    [JsonProperty("Tier1Chance")]
    private int DeprecatedTier1Chance { get; set; }
    [JsonProperty("Tier 2 chance")]
    public int Tier2Chance;
    [JsonProperty("Tier2Chance")]
    private int DeprecatedTier2Chance { get; set; }
    [JsonProperty("Tier 3 chance")]
    public int Tier3Chance;
    [JsonProperty("Tier3Chance")]
    private int DeprecatedTier3Chance { get; set; }
    [JsonProperty("Min condition percent")]
    public float MinConditionPercent;
    [JsonProperty("MinConditionPercent")]
    private float DeprecatedMinConditionPercent { get; set; }
    [JsonProperty("Max condition percent")]
    public float MaxConditionPercent;
    [JsonProperty("MaxConditionPercent")]
    private float DeprecatedMaxConditionPercent { get; set; }
}

[JsonObject(MemberSerialization.OptIn)]
private class ModulePresetMap
{
    [JsonProperty("2 sockets")]
    public ModulePresetConfiguration PresetsFor2Sockets;
    [JsonProperty("2Sockets")]
    private ModulePresetConfiguration DeprecatedPresetsFor2Sockets { get; set; }
    [JsonProperty("3 sockets")]
    public ModulePresetConfiguration PresetsFor3Sockets;
    [JsonProperty("3Sockets")]
    private ModulePresetConfiguration DeprecatedPresetsFor3Sockets { get; set; }
    [JsonProperty("4 sockets")]
    public ModulePresetConfiguration PresetsFor4Sockets;
    [JsonProperty("4Sockets")]
    private ModulePresetConfiguration DeprecatedPresetsFor4Sockets { get; set; }
    public void Init(CarSpawnSettings plugin);
    public ModulePresetConfiguration GetPresetConfigurationForSockets(int totalSockets);
}

[JsonObject(MemberSerialization.OptIn)]
private class ModuleDefinition : IModuleDefinition
{
    [JsonProperty("Item short name")]
    public string ItemShortName;
    [JsonProperty("Item skin ID")]
    public ulong SkinId;
    [JsonIgnore]
    public int NumSockets { get; set; }
    [JsonIgnore]
    private ItemDefinition _itemDefinition;
    public void Init(CarSpawnSettings plugin);
    public Item Create();
}

private class ModulePresetConfiguration
{
    [JsonProperty("Use vanilla presets")]
    public bool UseVanillaPresets;
    [JsonProperty("UseVanillaPresets")]
    private bool DeprecatedUseVanillaPresets { get; set; }
    [JsonProperty("Custom presets")]
    public ModuleDefinition[][] CustomPresets;
    [JsonProperty("CustomPresets")]
    private object[][] DeprecatedCustomPresets { get; set; }
    public void Init(CarSpawnSettings plugin);
    private ModuleDefinition[][] ParseLegacyPresets(object[][] legacyPresetList);
    private ModuleDefinition ParseLegacyModuleDefinition(object moduleIdentifier);
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private static class Lang
{
    public const string FillSuccess;
}


```

---

## CarTurrets by WhiteThunder - Allows players to deploy auto turrets onto modular cars

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust.Modular;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Car Turrets", "WhiteThunder", "1.6.3")]
[Description("Allows players to deploy auto turrets onto modular cars.")]
internal class CarTurrets : CovalencePlugin
{
    [PluginReference]
    private readonly Plugin VehicleDeployedLocks;
    private Configuration _config;
    private const string PermissionDeployCommand;
    private const string PermissionDeployInventory;
    private const string PermissionFree;
    private const string PermissionControl;
    private const string PermissionRemoveAll;
    private const string PermissionLimit2;
    private const string PermissionLimit3;
    private const string PermissionLimit4;
    private const string PermissionSpawnWithCar;
    private const string PermissionAllModules;
    private const string PermissionModuleFormat;
    private const string PrefabEntityAutoTurret;
    private const string PrefabEntityElectricSwitch;
    private const string PrefabEffectDeployAutoTurret;
    private const string PrefabEffectCodeLockDenied;
    private const int ItemIdAutoTurret;
    private static readonly Vector3 TurretSwitchPosition;
    private static readonly Quaternion TurretBackwardRotation;
    private static readonly Quaternion TurretSwitchRotation;
    private readonly object False;
    private DynamicHookSubscriber<NetworkableId> _carTurretTracker;
    private ProtectionProperties ImmortalProtection;
    private void Init();
    private void Unload();
    private void OnServerInitialized();
    private void OnEntitySpawned(ModularCar car);
    private object CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId targetContainerId, int targetSlot, int amount);
    private object HandleAddTurret(BasePlayer basePlayer, Item item, ModularCar car, ItemContainer targetContainer, int targetSlot);
    private object HandleRemoveTurret(BasePlayer basePlayer, Item moduleItem, ModularCar car, ItemContainer targetContainer);
    private void OnItemDropped(Item item, BaseEntity itemEntity);
    private void OnEntityKill(BaseVehicleModule vehicleModule);
    private void OnEntityKill(AutoTurret turret);
    private object OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer player);
    private void OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer player);
    private object OnTurretTarget(AutoTurret turret, BaseCombatEntity target);
    private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, AutoTurret turret);
    private object CanPickupEntity(BasePlayer player, AutoTurret turret);
    private object canRemove(BasePlayer player, AutoTurret turret);
    private void OnEngineStartFinished(ModularCar car);
    private void OnEngineStopped(ModularCar car);
    private object OnTurretStartup(AutoTurret turret);
    [HookMethod(nameof(API_DeployAutoTurret))]
    public AutoTurret API_DeployAutoTurret(BaseVehicleModule vehicleModule, BasePlayer basePlayer);
    [Command("carturret")]
    private void CommandDeploy(IPlayer player, string cmd, string[] args);
    [Command("carturrets.removeall")]
    private void CommandRemoveAllCarTurrets(IPlayer player, string cmd, string[] args);
    private bool VerifyPermissionAny(IPlayer player, string[] permissionNames);
    private bool VerifyCanBuild(IPlayer player);
    private bool VerifyVehicleModuleFound(IPlayer player, ModularCar car, BaseVehicleModule vehicleModule);
    private bool VerifyCarHasAutoTurretCapacity(IPlayer player, ModularCar car, bool replyInChat);
    private bool VerifyPermissionToModule(IPlayer player, BaseVehicleModule vehicleModule);
    private static class RCUtils
    {
        public static bool HasController(IRemoteControllable controllable, BasePlayer player);
        public static void RemoveController(IRemoteControllable controllable);
        public static bool AddViewer(IRemoteControllable controllable, BasePlayer player);
        public static bool AddFakeViewer(IRemoteControllable controllable);
    }

    private static bool DeployWasBlocked(BaseVehicleModule vehicleModule, BasePlayer basePlayer, bool automatedDeployment);
    private static BaseVehicleModule FindClosestModuleToAim(ModularCar car, BasePlayer basePlayer);
    private static void UseItem(BasePlayer basePlayer, Item item, int amountToConsume);
    private static float GetItemConditionFraction(Item item);
    private static Item FindPlayerAutoTurretItem(BasePlayer basePlayer);
    private static Item CreateItemFromAutoTurret(AutoTurret autoTurret);
    private static string GetAutoTurretPermissionForModule(BaseVehicleModule vehicleModule);
    private static string GetAutoTurretPermission(string moduleItemShortName);
    private static int GetCarTurretCount(ModularCar car);
    private static T GetChildOfType(BaseEntity entity);
    private static AutoTurret GetModuleAutoTurret(BaseVehicleModule vehicleModule);
    private static ElectricSwitch GetTurretSwitch(AutoTurret turret);
    private static bool IsNaturalCarSpawn(ModularCar car);
    private static BaseVehicleModule GetParentVehicleModule(BaseEntity entity);
    private static AutoTurret GetParentTurret(BaseEntity entity);
    private static void RunOnEntityBuilt(Item turretItem, AutoTurret autoTurret);
    private static void HideInputsAndOutputs(IOEntity ioEntity);
    private static Quaternion GetIdealTurretRotation(ModularCar car, BaseVehicleModule vehicleModule);
    private static void RemoveColliders(BaseEntity entity);
    private static void RemoveGroundWatch(BaseEntity entity);
    private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance);
    private static BasePlayer FindEntityOwner(BaseEntity entity);
    private bool HasPermissionToControl(BasePlayer player);
    private void SetupCarTurret(AutoTurret turret);
    private AutoTurret DeployAutoTurret(ModularCar car, BaseVehicleModule vehicleModule, Vector3 position, float conditionFraction, ulong ownerId);
    private void RefreshCarTurret(AutoTurret turret);
    private ElectricSwitch AttachTurretSwitch(AutoTurret autoTurret);
    private void SetupTurretSwitch(ElectricSwitch electricSwitch);
    private bool CanAccessVehicle(BaseVehicle vehicle, BasePlayer basePlayer, bool provideFeedback);
    private int FindFirstSuitableSocketIndex(ModularCar car, BasePlayer basePlayer);
    private int GetCarAutoTurretLimit(ModularCar car);
    private bool HasPermissionToVehicleModule(string userId, BaseVehicleModule vehicleModule);
    private bool ShouldSpawnTurretsWithCar(ModularCar car);
    private bool TryGetAutoTurretPositionForModule(BaseVehicleModule vehicleModule, Vector3 position);
    private int GetAutoTurretChanceForModule(BaseVehicleModule vehicleModule);
    private AutoTurret DeployAutoTurretForPlayer(ModularCar car, BaseVehicleModule vehicleModule, Vector3 position, BasePlayer basePlayer, float conditionFraction);
    private class DynamicHookSubscriber
    {
        private CarTurrets _plugin;
        private HashSet<T> _list;
        private string[] _hookNames;
        public DynamicHookSubscriber(CarTurrets plugin, string[] hookNames);
        public void Add(T item);
        public void Remove(T item);
        public void SubscribeAll();
        public void UnsubscribeAll();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class SpawnWithCarConfig
    {
        [JsonProperty("NaturalCarSpawns")]
        public NaturalCarSpawnsConfig NaturalCarSpawns;
        [JsonProperty("OtherCarSpawns")]
        public OtherCarSpawnsConfig OtherCarSpawns;
        [JsonProperty("SpawnChanceByModule")]
        public Dictionary<string, int> SpawnChanceByModule;
        public bool Enabled { get; set; }
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class NaturalCarSpawnsConfig
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class OtherCarSpawnsConfig
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
        [JsonProperty("RequirePermission")]
        public bool RequirePermission;
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : BaseConfiguration
    {
        [JsonProperty("RequirePermissionToControlCarTurrets")]
        public bool RequirePermissionToControl;
        [JsonProperty("DefaultLimitPerCar")]
        public int DefaultLimitPerCar;
        [JsonProperty("EnableTurretPickup")]
        public bool EnableTurretPickup;
        [JsonProperty("OnlyPowerTurretsWhileEngineIsOn")]
        public bool OnlyPowerTurretsWhileEngineIsOn;
        [JsonProperty("TargetPlayers")]
        public bool TargetPlayers;
        [JsonProperty("TargetNPCs")]
        public bool TargetNPCs;
        [JsonProperty("TargetAnimals")]
        public bool TargetAnimals;
        [JsonProperty("SpawnWithCar")]
        public SpawnWithCarConfig SpawnWithCarConfig;
        [JsonProperty("AutoTurretPositionByModule")]
        public Dictionary<string, Vector3> ModulePositions;
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(string userId, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    private void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    private void ChatMessage(BasePlayer basePlayer, string messageName, object[] args);
    private class Lang
    {
        public const string GenericErrorNoPermission;
        public const string GenericErrorBuildingBlocked;
        public const string DeployErrorNoCarFound;
        public const string DeployErrorNoModules;
        public const string DeployErrorNoPermissionToModule;
        public const string DeployErrorModuleAlreadyHasTurret;
        public const string DeployErrorUnsupportedModule;
        public const string DeployErrorTurretLimit;
        public const string DeployErrorNoSuitableModule;
        public const string DeployErrorNoTurret;
        public const string RemoveErrorTurretHasItems;
        public const string RemoveAllSuccess;
        public const string InfoPowerRequiresEngine;
    }

    protected override void LoadDefaultMessages();
}

private static class RCUtils
{
    public static bool HasController(IRemoteControllable controllable, BasePlayer player);
    public static void RemoveController(IRemoteControllable controllable);
    public static bool AddViewer(IRemoteControllable controllable, BasePlayer player);
    public static bool AddFakeViewer(IRemoteControllable controllable);
}

private class DynamicHookSubscriber
{
    private CarTurrets _plugin;
    private HashSet<T> _list;
    private string[] _hookNames;
    public DynamicHookSubscriber(CarTurrets plugin, string[] hookNames);
    public void Add(T item);
    public void Remove(T item);
    public void SubscribeAll();
    public void UnsubscribeAll();
}

[JsonObject(MemberSerialization.OptIn)]
private class SpawnWithCarConfig
{
    [JsonProperty("NaturalCarSpawns")]
    public NaturalCarSpawnsConfig NaturalCarSpawns;
    [JsonProperty("OtherCarSpawns")]
    public OtherCarSpawnsConfig OtherCarSpawns;
    [JsonProperty("SpawnChanceByModule")]
    public Dictionary<string, int> SpawnChanceByModule;
    public bool Enabled { get; set; }
}

[JsonObject(MemberSerialization.OptIn)]
private class NaturalCarSpawnsConfig
{
    [JsonProperty("Enabled")]
    public bool Enabled;
}

[JsonObject(MemberSerialization.OptIn)]
private class OtherCarSpawnsConfig
{
    [JsonProperty("Enabled")]
    public bool Enabled;
    [JsonProperty("RequirePermission")]
    public bool RequirePermission;
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : BaseConfiguration
{
    [JsonProperty("RequirePermissionToControlCarTurrets")]
    public bool RequirePermissionToControl;
    [JsonProperty("DefaultLimitPerCar")]
    public int DefaultLimitPerCar;
    [JsonProperty("EnableTurretPickup")]
    public bool EnableTurretPickup;
    [JsonProperty("OnlyPowerTurretsWhileEngineIsOn")]
    public bool OnlyPowerTurretsWhileEngineIsOn;
    [JsonProperty("TargetPlayers")]
    public bool TargetPlayers;
    [JsonProperty("TargetNPCs")]
    public bool TargetNPCs;
    [JsonProperty("TargetAnimals")]
    public bool TargetAnimals;
    [JsonProperty("SpawnWithCar")]
    public SpawnWithCarConfig SpawnWithCarConfig;
    [JsonProperty("AutoTurretPositionByModule")]
    public Dictionary<string, Vector3> ModulePositions;
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private class Lang
{
    public const string GenericErrorNoPermission;
    public const string GenericErrorBuildingBlocked;
    public const string DeployErrorNoCarFound;
    public const string DeployErrorNoModules;
    public const string DeployErrorNoPermissionToModule;
    public const string DeployErrorModuleAlreadyHasTurret;
    public const string DeployErrorUnsupportedModule;
    public const string DeployErrorTurretLimit;
    public const string DeployErrorNoSuitableModule;
    public const string DeployErrorNoTurret;
    public const string RemoveErrorTurretHasItems;
    public const string RemoveAllSuccess;
    public const string InfoPowerRequiresEngine;
}


```

---

## CashSystem by misticos - Rich economics system and API

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Cash System", "Iv Misticos", "1.0.5")]
[Description("Rich economics system")]
 class CashSystem : CovalencePlugin
{
    private static CashSystem _ins;
    private static PluginData _data;
    private static Time _time;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Currency List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<Currency> Currencies;
        [JsonProperty(PropertyName = "Purge Old Data")]
        public bool Purge;
        [JsonProperty(PropertyName = "Time Between Latest Update And Purge")]
        public uint PurgeTime;
    }

    private class Currency
    {
        [JsonProperty(PropertyName = "Abbreviation")]
        public string Abbreviation;
        [JsonProperty(PropertyName = "Start Amount")]
        public double StartAmount;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void SaveData();
    private void LoadData();
    private class PluginData
    {
        [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<PlayerData> Players;
    }

    private class PlayerData
    {
        [JsonProperty(PropertyName = "SteamID")]
        public string Id;
        [JsonProperty(PropertyName = "Last Update")]
        public uint LastUpdate;
        [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<CurrencyData> Currencies;
        public static PlayerData Find(string id);
        public CurrencyData FindCurrency(string abbreviation);
        public void UpdateCurrencies();
        public void Update();
    }

    private class CurrencyData
    {
        public string Abbreviation;
        [JsonIgnore]
        public double Balance;
        [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<TransactionData> Transactions;
        public void Add(double amount, string description);
        public void RecalculateBalance();
    }

    private class TransactionData
    {
        public double Amount;
        public string Description;
        public uint Timestamp;
    }

    protected override void LoadDefaultMessages();
    private void Loaded();
    private void OnServerSave();
    private void Unload();
    private void OnUserConnected(IPlayer player);
    private bool TransferBalance(string idFrom, string idTo, string currencyFrom, string currencyTo, double changeFrom, double changeTo, string descriptionFrom, string descriptionTo);
    private List<string> GetCurrencies(string id);
    private List<string> GetCurrencies();
    private double GetBalance(string id, string currency);
    private bool AddTransaction(string id, string currency, double amount, string description);
    private JObject GetTransactions(string id, string currency);
    private static string GetMsg(string key, string userId);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Currency List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<Currency> Currencies;
    [JsonProperty(PropertyName = "Purge Old Data")]
    public bool Purge;
    [JsonProperty(PropertyName = "Time Between Latest Update And Purge")]
    public uint PurgeTime;
}

private class Currency
{
    [JsonProperty(PropertyName = "Abbreviation")]
    public string Abbreviation;
    [JsonProperty(PropertyName = "Start Amount")]
    public double StartAmount;
}

private class PluginData
{
    [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<PlayerData> Players;
}

private class PlayerData
{
    [JsonProperty(PropertyName = "SteamID")]
    public string Id;
    [JsonProperty(PropertyName = "Last Update")]
    public uint LastUpdate;
    [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<CurrencyData> Currencies;
    public static PlayerData Find(string id);
    public CurrencyData FindCurrency(string abbreviation);
    public void UpdateCurrencies();
    public void Update();
}

private class CurrencyData
{
    public string Abbreviation;
    [JsonIgnore]
    public double Balance;
    [JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<TransactionData> Transactions;
    public void Add(double amount, string description);
    public void RecalculateBalance();
}

private class TransactionData
{
    public double Amount;
    public string Description;
    public uint Timestamp;
}


```

---

## CCTVUtilities by GrumpyGordon - Allows players to easily control the newly implemented CCTV system

```csharp
using Oxide.Core.Libraries;
using System;
using System.IO;
using UnityEngine;
using UnityEngine.Networking;
using System.Collections;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using Oxide.Core;

Oxide.Plugins
[Info("CCTV Utilities", "GrumpyGordon","1.5.1")]
[Description("Allows players to quickly add all their cameras to a computer station in Rust. With additional permissions they can add all the servers cameras to their CCTV setup.")]
public class CCTVUtilities : RustPlugin
{
     void Init();
    protected override void LoadDefaultMessages();
     void EnsureCustomConfigExists();
    private void SendHelpText(BasePlayer ply);
     void SendLangMsg(BasePlayer ply, string key);
     void SendLangMsg(BasePlayer ply, string key, string arg0);
     void SendLangMsg(BasePlayer ply, string key, string arg0, string arg1);
     void SendLangMsgConsole(BasePlayer ply, string key);
     void SendLangMsgConsole(BasePlayer ply, string key, string arg0);
     void SendLangMsgConsole(BasePlayer ply, string key, string arg0, string arg1, string arg2);
    public void SendHelpChat(BasePlayer ply);
    [ChatCommand("cctv")]
     void CCTVCommand(BasePlayer ply, string cctv, string[] args);
     CCTV_RC FindCCTVByRay(BasePlayer ply);
     ComputerStation FindCCTVStationByRay(BasePlayer ply);
     CCTV_RC[] GetCCTVs();
     CCTV_RC[] GetPlayerCCTVs(BasePlayer ply);
     CCTV_RC[] GetServerCCTVs();
     CCTV_RC[] GetCustomCCTVs();
     string[] GetCustomCCTVNames();
     CCTV_RC FindCCTV(string id);
     CCTV_RC GetCCTVAuth(string id, BasePlayer ply);
     CCTV_RC GetCCTVAuth(CCTV_RC cam, BasePlayer ply);
     bool IsCCTVOwner(CCTV_RC cctv, BasePlayer ply);
     string GetPlyName(ulong id);
     void SetCCTVAutoname(BasePlayer ply, string arg);
     void SetCCTVAutopowered(BasePlayer ply, string arg);
     void SetCCTVAutoadd(BasePlayer ply, string arg);
     void OnEntityBuilt(Planner plan, GameObject go);
     string RandomString(int length);
     void OnEntitySpawned(CCTV_RC cam);
}


```

---

## CH47AndMiniCopterSpawner by austinv900 - Spawn Mini Helicopter and/or CH47 at saved point(s)

```csharp
using UnityEngine;
using System.Collections.Generic;
using Oxide.Core;
using Convert = System.Convert;
using System.Linq;
using Oxide.Game.Rust.Cui;
using System;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;
using Newtonsoft.Json.Linq;

Oxide.Plugins
[Info("CH47 And MiniCopter Spawner", "BuzZ[PHOQUE]", "1.0.4")]
[Description("Spawn CH47 and/or MiniCopter at saved point(s)")]
public class CH47AndMiniCopterSpawner : RustPlugin
{
     bool debug;
     bool loaded;
     string Prefix;
     ulong SteamIDIcon;
    const string chprefab;
    const string miniprefab;
    const string SpawnerAdmin;
     class StoredData
    {
        public Dictionary<string, Vector3> SpawnSpots;
        public List<ulong> SpawnerCH47;
        public List<ulong> SpawnerMinicopters;
        public StoredData();
    }

    private StoredData storedData;
     void Init();
     void Loaded();
     void Unload();
    protected override void LoadDefaultMessages();
    [ChatCommand("cms")]
    private void CH47AndMiniCopterSpawnerNoUnderscore(BasePlayer player, string command, string[] args);
     bool DoesThisPlayerHasPermission(BasePlayer player);
     void SpawnOneHelicopterThere(Vector3 spot, string what);
     void OnEntityKill(BaseNetworkable entity);
}

 class StoredData
{
    public Dictionary<string, Vector3> SpawnSpots;
    public List<ulong> SpawnerCH47;
    public List<ulong> SpawnerMinicopters;
    public StoredData();
}


```

---

## CH47Keeper by Homi - Restores personal CH47 vehicles at their last position/rotation each server restart

```csharp
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;

Oxide.Plugins
[Info("CH47 Keeper", "Homi", "0.1.1")]
[Description("Restore position and rotation of CH47 own by user when the server restarts.")]
public class CH47Keeper : RustPlugin
{
     class CH47Data
    {
        public ulong ownerid;
        public Vector3 pos;
        public float rotX;
        public float rotY;
        public float rotZ;
        public float rotW;
    }

    private void OnServerInitialized();
     void Unload();
    private void OnServerSave();
    private readonly DynamicConfigFile dataFile1;
    private List<CH47Data> ch47_Data;
    private void SaveCH47();
    private void RestoreCH47();
    private bool CheckIsWipe();
}

 class CH47Data
{
    public ulong ownerid;
    public Vector3 pos;
    public float rotX;
    public float rotY;
    public float rotZ;
    public float rotW;
}


```

---

## ChainsawOptions by  - Control player's chainsaws

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

Oxide.Plugins
[Info("Chainsaw Options", "Arainrr", "1.1.1")]
[Description("Control player's chainsaws")]
public class ChainsawOptions : RustPlugin
{
    private const string PREFAB_CHAINSAW;
    private int defaultMaxAmmo;
    private float defaultFuelPerSec;
    private float defaultEngineStartChance;
    private void Init();
    private void OnServerInitialized();
    private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem);
    private ConfigData.PermissionS GetPermissionS(BasePlayer player);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Permission List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<PermissionS> permissionList;
        public class PermissionS
        {
            [JsonProperty(PropertyName = "Permission")]
            public string permission;
            [JsonProperty(PropertyName = "Priority")]
            public int priority;
            [JsonProperty(PropertyName = "Engine Start Chance")]
            public float chance;
            [JsonProperty(PropertyName = "Max Ammo")]
            public int maxAmmo;
            [JsonProperty(PropertyName = "Fuel Per Seconds")]
            public float fuelPerSec;
        }

    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Permission List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<PermissionS> permissionList;
    public class PermissionS
    {
        [JsonProperty(PropertyName = "Permission")]
        public string permission;
        [JsonProperty(PropertyName = "Priority")]
        public int priority;
        [JsonProperty(PropertyName = "Engine Start Chance")]
        public float chance;
        [JsonProperty(PropertyName = "Max Ammo")]
        public int maxAmmo;
        [JsonProperty(PropertyName = "Fuel Per Seconds")]
        public float fuelPerSec;
    }

}

public class PermissionS
{
    [JsonProperty(PropertyName = "Permission")]
    public string permission;
    [JsonProperty(PropertyName = "Priority")]
    public int priority;
    [JsonProperty(PropertyName = "Engine Start Chance")]
    public float chance;
    [JsonProperty(PropertyName = "Max Ammo")]
    public int maxAmmo;
    [JsonProperty(PropertyName = "Fuel Per Seconds")]
    public float fuelPerSec;
}


```

---

## ChatClear by MrBlue - Clears the chat for player(s) when joining the server or on command

```csharp
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Chat Clear", "Wulf", "2.0.0")]
[Description("Clears the chat for player(s) when joining the server or on command")]
 class ChatClear : CovalencePlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("Clear chat on connect")]
        public bool ClearOnConnect;
        [JsonProperty("Exclude admin from clearing")]
        public bool ExcludeAdmin;
        [JsonProperty("Number of lines to clear (ex. 300)")]
        public int NumberOfLines;
        [JsonProperty("Show chat cleared message")]
        public bool ShowMessage;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private const string permAll;
    private const string permSelf;
    private void Init();
    private void ClearChat(IPlayer player);
    private void CommandClearAll(IPlayer player, string command);
    private void CommandClearSelf(IPlayer player, string command);
    private void OnUserConnected(IPlayer player);
    private void AddLocalizedCommand(string command);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string langKey, object[] args);
    private void MigratePermission(string oldPerm, string newPerm);
}

public class Configuration
{
    [JsonProperty("Clear chat on connect")]
    public bool ClearOnConnect;
    [JsonProperty("Exclude admin from clearing")]
    public bool ExcludeAdmin;
    [JsonProperty("Number of lines to clear (ex. 300)")]
    public int NumberOfLines;
    [JsonProperty("Show chat cleared message")]
    public bool ShowMessage;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## ChatCommandPrefix by Clearshot - Add prefix for all chat commands

```csharp
using System.Collections.Generic;
using ConVar;
using Oxide.Core;

Oxide.Plugins
[Info("Chat Command Prefix", "Clearshot", "1.0.0")]
[Description("Add prefix for all chat commands")]
 class ChatCommandPrefix : CovalencePlugin
{
    private PluginConfig _config;
    private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    private Dictionary<string, object> OnBetterChat(Dictionary<string, object> data);
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadConfig();
    private class PluginConfig
    {
        public char[] prefixes;
    }

}

private class PluginConfig
{
    public char[] prefixes;
}


```

---

## ChatHead by  - Displays chat messages above player to other players in range

```csharp
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Drawing;
using UnityEngine;

Oxide.Plugins
[Info("Chat Head", "Ujiou", "1.4.2")]
[Description("Displays chat messages above player to other players in range.")]
 class ChatHead : RustPlugin
{
     ChatHeadConfig config;
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadConfig();
    private ChatHeadConfig LoadBaseConfig();
    public class ChatHeadConfig
    {
        [JsonProperty(PropertyName = "Settings: ")]
        public Settings settings { get; set; }
        [JsonProperty(PropertyName = "Vanish Settings: ")]
        public VanishSettings vanishS { get; set; }
        public class Settings
        {
            [JsonProperty(PropertyName = "Text Color")]
            public string textColor { get; set; }
            [JsonProperty(PropertyName = "Text Height")]
            public float textHeight { get; set; }
            [JsonProperty(PropertyName = "Text Size")]
            public int textSize { get; set; }
            [JsonProperty(PropertyName = "Hide Team Chat")]
            public bool hideTeamChat { get; set; }
        }

        public class VanishSettings
        {
            [JsonProperty(PropertyName = "Hide Text")]
            public bool vanishHideAdmins { get; set; }
        }

        [JsonProperty(PropertyName = "Version: ")]
        public Core.VersionNumber Version { get; set; }
    }

    readonly Dictionary<string, string> lastMessage;
     void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
     void DrawChat(BasePlayer target, BasePlayer player);
    [PluginReference]
    private Plugin Vanish;
    private void Loaded();
    public bool isInvisible(BasePlayer player);
    private void GiveFlag(BasePlayer player, BasePlayer.PlayerFlags flag, bool value);
}

public class ChatHeadConfig
{
    [JsonProperty(PropertyName = "Settings: ")]
    public Settings settings { get; set; }
    [JsonProperty(PropertyName = "Vanish Settings: ")]
    public VanishSettings vanishS { get; set; }
    public class Settings
    {
        [JsonProperty(PropertyName = "Text Color")]
        public string textColor { get; set; }
        [JsonProperty(PropertyName = "Text Height")]
        public float textHeight { get; set; }
        [JsonProperty(PropertyName = "Text Size")]
        public int textSize { get; set; }
        [JsonProperty(PropertyName = "Hide Team Chat")]
        public bool hideTeamChat { get; set; }
    }

    public class VanishSettings
    {
        [JsonProperty(PropertyName = "Hide Text")]
        public bool vanishHideAdmins { get; set; }
    }

    [JsonProperty(PropertyName = "Version: ")]
    public Core.VersionNumber Version { get; set; }
}

public class Settings
{
    [JsonProperty(PropertyName = "Text Color")]
    public string textColor { get; set; }
    [JsonProperty(PropertyName = "Text Height")]
    public float textHeight { get; set; }
    [JsonProperty(PropertyName = "Text Size")]
    public int textSize { get; set; }
    [JsonProperty(PropertyName = "Hide Team Chat")]
    public bool hideTeamChat { get; set; }
}

public class VanishSettings
{
    [JsonProperty(PropertyName = "Hide Text")]
    public bool vanishHideAdmins { get; set; }
}


```

---

## ChatImpersonator by LaserHydra - Impersonate another player in chat

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Chat Impersonator", "LaserHydra", "3.0.0")]
[Description("Allows you to impersonate another player in chat")]
public class ChatImpersonator : CovalencePlugin
{
    private const string Permission;
    protected override void LoadDefaultMessages();
    [Command("ci"), Permission(Permission)]
    private void Cmd_Impersonate(IPlayer player, string command, string[] args);
    private void ForcePlayerChat(BasePlayer target, string message);
    private void SendLocalizedReply(IPlayer player, string key);
    private BasePlayer FindPlayer(string nameOrId);
}


```

---

## ChatNotice by  - Plays a sound effect for the receiver on player chat

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Chat Notice", "Tricky", "0.0.3")]
[Description("Plays a sound effect for the receiver on player chat")]
public class ChatNotice : CovalencePlugin
{
    [PluginReference]
    private Plugin PrivateMessages;
    private Plugin Clans;
     Configuration config;
     class Configuration
    {
        [JsonProperty(PropertyName = "Require Permission")]
        public bool RequirePermission;
        [JsonProperty(PropertyName = "Sound Prefab")]
        public string SoundPrefab;
        [JsonProperty(PropertyName = "Use Cooldown")]
        public bool UseCooldown;
        [JsonProperty(PropertyName = "Cooldown (seconds)")]
        public int Cooldown;
        [JsonProperty(PropertyName = "Use PM")]
        public bool PM;
        [JsonProperty(PropertyName = "Use Clan Chat")]
        public bool ClanChat;
        [JsonProperty(PropertyName = "Use Global Chat")]
        public bool GlobalChat;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private const string perm;
    private Cooldown cooldown;
    private class Cooldown
    {
        public List<ulong> PM;
        public List<ulong> Clan;
        public List<ulong> Global;
        public Cooldown();
    }

    private void OnServerInitialized();
    private void OnPMProcessed(IPlayer player, IPlayer target, string message);
    private void OnClanChat(IPlayer player, string message);
    private void OnPlayerChat(BasePlayer player, string message);
    private void RunEffect(IPlayer iplayer, ChatType type);
    private JObject GetClanOf(IPlayer player);
}

 class Configuration
{
    [JsonProperty(PropertyName = "Require Permission")]
    public bool RequirePermission;
    [JsonProperty(PropertyName = "Sound Prefab")]
    public string SoundPrefab;
    [JsonProperty(PropertyName = "Use Cooldown")]
    public bool UseCooldown;
    [JsonProperty(PropertyName = "Cooldown (seconds)")]
    public int Cooldown;
    [JsonProperty(PropertyName = "Use PM")]
    public bool PM;
    [JsonProperty(PropertyName = "Use Clan Chat")]
    public bool ClanChat;
    [JsonProperty(PropertyName = "Use Global Chat")]
    public bool GlobalChat;
}

private class Cooldown
{
    public List<ulong> PM;
    public List<ulong> Clan;
    public List<ulong> Global;
    public Cooldown();
}


```

---

## ChatPrefix by DevGonzi - Chat Prefix allows adding a colored name and a prefix/tag in front of the name using a permission.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Chat Prefix", "Gonzi", "1.2.1")]
[Description("Chat Prefix per Permission")]
public class ChatPrefix : RustPlugin
{
    [PluginReference]
     Plugin ColouredChat;
    [PluginReference]
     Plugin Quests;
    [PluginReference]
     Plugin BetterChat;
    private Dictionary<ulong, PlayerPrefix> playerPrefixData;
    private class PlayerPrefix
    {
        public string Prefix { get; set; }
        public string Color { get; set; }
        public bool active { get; set; }
    }

    private class PrefixConfig
    {
        public bool Disabled { get; set; }
        public int Priority { get; set; }
        public string Prefix { get; set; }
        public string Color { get; set; }
        public string Permission { get; set; }
        public string GroupName { get; set; }
    }

    private static ConfigData config;
    private class ConfigData
    {
        public bool debug;
        [JsonProperty("Use Groupname instead of Permission")]
        public bool useGroup;
        public Dictionary<string, PrefixConfig> Prefixes { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private object GetConfig(string menu, string datavalue, object defaultValue);
     ConfigData DefaultConfig();
    private string ColChat_GetColName(IPlayer player);
    private string ColChat_GetColMessage(IPlayer player, string message);
    private void OnPlayerConnected(BasePlayer player);
    private void OnUserPermissionGranted(string id, string permName);
    private void OnUserPermissionRevoked(string id, string permName);
    private void OnGroupPermissionGranted(string name, string perm);
    private void OnGroupPermissionRevoked(string name, string perm);
    private void OnUserGroupAdded(string id, string groupName);
    private void OnUserGroupRemoved(string id, string groupName);
    private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    private object OnBetterChat(Dictionary<string, object> dict);
    private object OnColouredChat(Dictionary<string, object> dict);
    private object SendChatMessage(BasePlayer player, string pColor, string prefix, string displayname, string message, Chat.ChatChannel channel);
    private void RegPerm(string name);
    private object ReloadPrefix(BasePlayer player);
    private bool QuestsActv();
    private bool ColouredChatActv();
    private bool BetterChatActv();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private string API_GetPrefixedMessageForPlayer(BasePlayer player, string messageText);
    private bool API_ReloadPrefixForPlayer(BasePlayer player);
    private bool API_ReloadPrefixForAllPlayers();
}

private class PlayerPrefix
{
    public string Prefix { get; set; }
    public string Color { get; set; }
    public bool active { get; set; }
}

private class PrefixConfig
{
    public bool Disabled { get; set; }
    public int Priority { get; set; }
    public string Prefix { get; set; }
    public string Color { get; set; }
    public string Permission { get; set; }
    public string GroupName { get; set; }
}

private class ConfigData
{
    public bool debug;
    [JsonProperty("Use Groupname instead of Permission")]
    public bool useGroup;
    public Dictionary<string, PrefixConfig> Prefixes { get; set; }
}


```

---

## ChatToConsole by aristocratos - Copies the in-game chat to the console

```csharp
using System;
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Chat To Console", "Purples", "1.1.1")]
[Description("Copies the in-game chat to the console.")]
internal class ChatToConsole : RustPlugin
{
    private void CmdToggle(IPlayer player, string command, string[] args);
    private class ChatFormat
    {
        private readonly Chat.ChatChannel? _channel;
        private readonly string _formattedMessage;
        private readonly string _formattedPrefixes;
        private readonly string _formattedUsername;
        private readonly BasePlayer _sender;
        private ChatFormat(BasePlayer sender, string formattedUsername, string formattedPrefixes, string formattedMessage, Chat.ChatChannel? channel);
        public string ChatLang { get; set; }
        private static string GetFormattedText(string text, string color);
        public static ChatFormat FromRust(BasePlayer player, string message, Chat.ChatChannel channel);
        public static ChatFormat FromBetterChat(Dictionary<string, object> data);
        public static ChatFormat FromChatPlus(Dictionary<string, object> data);
        public bool ShouldSee(ulong playerid);
        public string GetFormatted();
    }

    private string _permission;
    private string _permissionAdmin;
    private static string _command;
    private static string _format;
    private static string _pmFormat;
    private static bool _enabledByDefault;
    [PluginReference]
    private Plugin ChatPlus;
    private Plugin BetterChat;
    private List<string> _listedUsers;
    private void LoadData();
    private void SaveData();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private void Init();
    private string GetMsg(string key);
    private string GetMsg(string key, string playerId);
    protected override void LoadDefaultMessages();
    private void OnPlayerChat(BasePlayer sender, string message, Chat.ChatChannel channel);
    private void OnBetterChat(Dictionary<string, object> data);
    private void OnChatPlusMessage(Dictionary<string, object> data);
    [HookMethod("OnPMProcessed")]
    private void OnPrivateMessage(IPlayer sender, IPlayer receiver, string message);
    private void SendChatToConsole(ChatFormat message);
    private void SendPmToConsole(string message, string[] participants);
    private bool CheckEnabled(string id);
    private bool CanUse(string id);
    private bool CanAdmin(string id);
    private bool GetConfig(string key, T var);
}

private class ChatFormat
{
    private readonly Chat.ChatChannel? _channel;
    private readonly string _formattedMessage;
    private readonly string _formattedPrefixes;
    private readonly string _formattedUsername;
    private readonly BasePlayer _sender;
    private ChatFormat(BasePlayer sender, string formattedUsername, string formattedPrefixes, string formattedMessage, Chat.ChatChannel? channel);
    public string ChatLang { get; set; }
    private static string GetFormattedText(string text, string color);
    public static ChatFormat FromRust(BasePlayer player, string message, Chat.ChatChannel channel);
    public static ChatFormat FromBetterChat(Dictionary<string, object> data);
    public static ChatFormat FromChatPlus(Dictionary<string, object> data);
    public bool ShouldSee(ulong playerid);
    public string GetFormatted();
}


```

---

## ChatToDiscord by Psystec - Forward chat to Discord via Webhooks.

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System;
using ConVar;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Chat to Discord Relay", "Psystec", "1.0.9")]
[Description("Relay chat to Discord")]
public class ChatToDiscord : CovalencePlugin
{
     Dictionary<string, SteamPlayerInfo> _steamPlayerInfoCache;
    public const string AdminPermission;
    private Configuration _configuration;
    private class Configuration
    {
        public string SteamApiKey { get; set; }
        public string GlobalChatWebhook { get; set; }
        public string TeamChatWebhook { get; set; }
        public string ConnectionWebhook { get; set; }
        public bool AllowMentions { get; set; }
        public bool AllowSpecialCharacters { get; set; }
        public string GlobalChatFormat { get; set; }
        public string TeamChatFormat { get; set; }
        public string ConnectionFormat { get; set; }
        public string DateFormat { get; set; }
    }

    protected override void LoadDefaultMessages();
    protected override void SaveConfig();
    private void LoadNewConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private void Init();
    private void Loaded();
    private void OnUserConnected(IPlayer player);
    private void OnUserDisconnected(IPlayer player);
    private void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    [Command("chattodiscord")]
    private void ChatToDiscordCommands(IPlayer player, string command, string[] args);
    private string Lang(string key, string id, object[] args);
    private bool HasPermission(IPlayer player, string permission);
    public static string RemoveSpecialCharacters(string message);
    private void SendToDiscord(string Webhook, string PlayerName, string PlayerID, string message);
    private void CheckSubscribsions();
    public class DiscordMessage
    {
        public string username { get; set; }
        public string avatar_url { get; set; }
        public string content { get; set; }
        public Embed[] embeds { get; set; }
    }

    public class Embed
    {
        public Author author { get; set; }
        public string title { get; set; }
        public string url { get; set; }
        public string description { get; set; }
        public int color { get; set; }
        public Field[] fields { get; set; }
        public Thumbnail thumbnail { get; set; }
        public Image image { get; set; }
        public Footer footer { get; set; }
    }

    public class Author
    {
        public string name { get; set; }
        public string url { get; set; }
        public string icon_url { get; set; }
    }

    public class Thumbnail
    {
        public string url { get; set; }
    }

    public class Image
    {
        public string url { get; set; }
    }

    public class Footer
    {
        public string text { get; set; }
        public string icon_url { get; set; }
    }

    public class Field
    {
        public string name { get; set; }
        public string value { get; set; }
        public bool inline { get; set; }
    }

    public class SteamPlayerInfo
    {
        public Response response { get; set; }
    }

    public class Response
    {
        public Player[] players { get; set; }
    }

    public class Player
    {
        public string steamid { get; set; }
        public int communityvisibilitystate { get; set; }
        public int profilestate { get; set; }
        public string personaname { get; set; }
        public string profileurl { get; set; }
        public string avatar { get; set; }
        public string avatarmedium { get; set; }
        public string avatarfull { get; set; }
        public string avatarhash { get; set; }
        public int lastlogoff { get; set; }
        public int personastate { get; set; }
        public string primaryclanid { get; set; }
        public int timecreated { get; set; }
        public int personastateflags { get; set; }
        public string gameserverip { get; set; }
        public string gameserversteamid { get; set; }
        public string gameextrainfo { get; set; }
        public string gameid { get; set; }
        public string loccountrycode { get; set; }
    }

}

private class Configuration
{
    public string SteamApiKey { get; set; }
    public string GlobalChatWebhook { get; set; }
    public string TeamChatWebhook { get; set; }
    public string ConnectionWebhook { get; set; }
    public bool AllowMentions { get; set; }
    public bool AllowSpecialCharacters { get; set; }
    public string GlobalChatFormat { get; set; }
    public string TeamChatFormat { get; set; }
    public string ConnectionFormat { get; set; }
    public string DateFormat { get; set; }
}

public class DiscordMessage
{
    public string username { get; set; }
    public string avatar_url { get; set; }
    public string content { get; set; }
    public Embed[] embeds { get; set; }
}

public class Embed
{
    public Author author { get; set; }
    public string title { get; set; }
    public string url { get; set; }
    public string description { get; set; }
    public int color { get; set; }
    public Field[] fields { get; set; }
    public Thumbnail thumbnail { get; set; }
    public Image image { get; set; }
    public Footer footer { get; set; }
}

public class Author
{
    public string name { get; set; }
    public string url { get; set; }
    public string icon_url { get; set; }
}

public class Thumbnail
{
    public string url { get; set; }
}

public class Image
{
    public string url { get; set; }
}

public class Footer
{
    public string text { get; set; }
    public string icon_url { get; set; }
}

public class Field
{
    public string name { get; set; }
    public string value { get; set; }
    public bool inline { get; set; }
}

public class SteamPlayerInfo
{
    public Response response { get; set; }
}

public class Response
{
    public Player[] players { get; set; }
}

public class Player
{
    public string steamid { get; set; }
    public int communityvisibilitystate { get; set; }
    public int profilestate { get; set; }
    public string personaname { get; set; }
    public string profileurl { get; set; }
    public string avatar { get; set; }
    public string avatarmedium { get; set; }
    public string avatarfull { get; set; }
    public string avatarhash { get; set; }
    public int lastlogoff { get; set; }
    public int personastate { get; set; }
    public string primaryclanid { get; set; }
    public int timecreated { get; set; }
    public int personastateflags { get; set; }
    public string gameserverip { get; set; }
    public string gameserversteamid { get; set; }
    public string gameextrainfo { get; set; }
    public string gameid { get; set; }
    public string loccountrycode { get; set; }
}


```

---

## ChatTranslator by MrBlue - Translates chat messages to each player's language preference or server default

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using ProtoBuf;

Oxide.Plugins
[Info("Chat Translator", "Mr. Blue", "2.2.2")]
[Description("Translates chat messages to each player's language preference or server default")]
public class ChatTranslator : CovalencePlugin
{
    private Configuration config;
    private class Configuration
    {
        [JsonProperty("Force default server language")]
        public bool ForceServerDefault;
        [JsonProperty("Log translated chat messages")]
        public bool LogChatMessages;
        [JsonProperty("Show original and translation")]
        public bool ShowBothMessages;
        [JsonProperty("Translate message for sender")]
        public bool TranslateForSender;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    [PluginReference]
    private readonly Plugin TranslationAPI;
    private readonly Plugin BetterChat;
    private readonly Plugin BetterChatFilter;
    private readonly Plugin BetterChatMute;
    private readonly Plugin ChatFilter;
    private void Translate(string message, string targetId, string senderId, Action<string> callback);
    private void TranslateChat(IPlayer target, IPlayer sender, string message, int channel);
    private void ProcessMessage(IPlayer target, IPlayer sender, string translation, string original, int channel);
    private object HandleChat(IPlayer sender, string message, int channel, List<string> blockedReceivers);
    private object OnBetterChat(Dictionary<string, object> data);
    private object OnUserChat(IPlayer player, string message);
}

private class Configuration
{
    [JsonProperty("Force default server language")]
    public bool ForceServerDefault;
    [JsonProperty("Log translated chat messages")]
    public bool LogChatMessages;
    [JsonProperty("Show original and translation")]
    public bool ShowBothMessages;
    [JsonProperty("Translate message for sender")]
    public bool TranslateForSender;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## Checkpoints by Ryan - Restore points for players to teleport to when the server restarts

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Checkpoints", "Ryan", "1.0.1")]
[Description("Restore points for players to teleport to when the server restarts")]
 class Checkpoints : RustPlugin
{
    private string Lang(string key, string id, object[] args);
    private static StoredData sData;
    private static Checkpoints Instance;
    private const string Perm;
    private class StoredData
    {
        public Dictionary<ulong, PlayerData> Players;
    }

    private class PlayerData
    {
        public float PosX { get; set; }
        public float PosY { get; set; }
        public float PosZ { get; set; }
        public uint ID { get; set; }
        public PlayerData();
        public PlayerData(SleepingBag bag);
    }

    private class Data
    {
        public static void Add(BasePlayer player, PlayerData data);
        public static void Remove(ulong id);
        public static bool Exists(ulong id);
        private static void Save();
    }

    private new void LoadDefaultMessages();
    private class Checks
    {
        public static bool HasPermission(string id);
        public static bool CanUseSleepingBag(BasePlayer player, SleepingBag bag);
    }

    private SleepingBag FindBag(BasePlayer player);
    private void Init();
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnEntityKill(BaseNetworkable networkable);
    [ChatCommand("checkpoint")]
    private void checkpointCmd(BasePlayer player, string command, string[] args);
}

private class StoredData
{
    public Dictionary<ulong, PlayerData> Players;
}

private class PlayerData
{
    public float PosX { get; set; }
    public float PosY { get; set; }
    public float PosZ { get; set; }
    public uint ID { get; set; }
    public PlayerData();
    public PlayerData(SleepingBag bag);
}

private class Data
{
    public static void Add(BasePlayer player, PlayerData data);
    public static void Remove(ulong id);
    public static bool Exists(ulong id);
    private static void Save();
}

private class Checks
{
    public static bool HasPermission(string id);
    public static bool CanUseSleepingBag(BasePlayer player, SleepingBag bag);
}


```

---

## ChestStackMultiplier by MONaH - Higher stack sizes in storage containers, keeping normal stack sizes your inventory.

```csharp
using System.Collections.Generic;
using System.ComponentModel;
using Newtonsoft.Json;
using UnityEngine;
using Pool = Facepunch.Pool;

Oxide.Plugins
[Info("Chest Stack Multiplier", "MON@H", "1.6.1")]
[Description("Higher stack sizes in storage containers.")]
public class ChestStackMultiplier : RustPlugin
{
    private const string PermissionUseShift;
    private static readonly object _true;
    private readonly Hash<ulong, float> _cacheMultipliers;
    private readonly HashSet<ulong> _cacheBackpackContainers;
    private readonly HashSet<ulong> _cacheBackpackEntities;
    private ItemContainer _targetContainer;
    private uint _backpackPrefabID;
    private uint _playerPrefabID;
    private void Init();
    private void OnServerInitialized();
    private PluginConfig _pluginConfig;
    public class PluginConfig
    {
        [JsonProperty(PropertyName = "Default Multiplier for new containers")]
        [DefaultValue(1f)]
        public float DefaultMultiplier { get; set; }
        [JsonProperty(PropertyName = "Containers list (PrefabName: multiplier)")]
        public SortedDictionary<string, float> ContainerMultipliers { get; set; }
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    public PluginConfig AdditionalConfig(PluginConfig config);
    private object OnMaxStackable(Item item);
    private object CanMoveItem(Item movedItem, PlayerInventory playerInventory, ItemContainerId targetContainerID, int targetSlot, int amount);
    private void OnItemDropped(Item item, BaseEntity entity);
    private void OnBackpackOpened(BasePlayer player, ulong backpackOwnerID, ItemContainer backpackContainer);
    public void CachePrefabIDs();
    public void CacheMultipliers();
    public void CacheAddBackpack(ItemContainer itemContainer);
    public bool IsExcluded(BaseEntity entity, BasePlayer player);
    public bool IsUsingShift(BasePlayer player);
    public class ItemHelper
    {
        public static bool SplitMoveItem(Item item, int amount, ItemContainer targetContainer, int targetSlot);
        public static bool SplitMoveItem(Item item, int amount, PlayerInventory inventory);
        public static void SwapItems(Item item1, Item item2);
    }

    public float GetStackMultiplier(BaseEntity entity);
    public void HooksUnsubscribe();
    public void HooksSubscribe();
    public void RegisterPermissions();
}

public class PluginConfig
{
    [JsonProperty(PropertyName = "Default Multiplier for new containers")]
    [DefaultValue(1f)]
    public float DefaultMultiplier { get; set; }
    [JsonProperty(PropertyName = "Containers list (PrefabName: multiplier)")]
    public SortedDictionary<string, float> ContainerMultipliers { get; set; }
}

public class ItemHelper
{
    public static bool SplitMoveItem(Item item, int amount, ItemContainer targetContainer, int targetSlot);
    public static bool SplitMoveItem(Item item, int amount, PlayerInventory inventory);
    public static void SwapItems(Item item1, Item item2);
}


```

---

## ChestWarp by CEbbinghaus - Create warp between two chests

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Newtonsoft.Json;
using UnityEngine;
using Facepunch;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("Chest Warp", "CEbbinghaus", "1.2.1")]
[Description("Create warp between two chests")]
 class ChestWarp : RustPlugin
{
    public class Warp
    {
        [JsonProperty("User")]
        public ulong User;
        [JsonProperty("First chest")]
        public uint FirstPoint;
        [JsonProperty("Second chest")]
        public uint SecondPoint;
        public Warp();
        public Warp(ulong uid);
    }

    public class setup
    {
        public bool isActive;
        public string id;
        public Warp warp;
        public setup(ulong id);
    }

    [JsonProperty("Settings")]
     Dictionary<string, Dictionary<string, bool>> settings;
    public Dictionary<string, Warp> chestWarps;
     Dictionary<ulong, setup> activeBinds;
     void Unload();
     void LoadDefaultMessages();
     void Init();
     void OnServerSave();
     void OnLootEntity(BasePlayer player, BaseEntity entity);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    [ChatCommand("cw")]
     void cmdWarp(BasePlayer player, string command, string[] args);
     void Clean();
     void Teleport(BasePlayer player, Vector3 pos);
    private string Lang(string key, string id, object[] args);
}

public class Warp
{
    [JsonProperty("User")]
    public ulong User;
    [JsonProperty("First chest")]
    public uint FirstPoint;
    [JsonProperty("Second chest")]
    public uint SecondPoint;
    public Warp();
    public Warp(ulong uid);
}

public class setup
{
    public bool isActive;
    public string id;
    public Warp warp;
    public setup(ulong id);
}


```

---

## ChillDiving by Thisha - Audiovisual support for divers

```csharp
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System;
using Rust;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Chill Diving", "Thisha", "1.4.0")]
[Description("Audiovisual support for divers")]
public class ChillDiving : RustPlugin
{
    private const string inviteNoticeMsg;
    private const string divingTankShortName;
    private const string defaultPictureURL;
    private float pictureOffset;
    public DateTime lastCleanUp;
    private new void LoadDefaultMessages();
    private Dictionary<ulong, PlayerData> playerData;
    private class PlayerData
    {
        public bool Enabled;
        public string ShowInfo;
        public DateTime LastChange;
        public DateTime LastOnline;
        public Dictionary<uint, SimpleRangeData> ColorRanges;
        public Dictionary<uint, bool> Alerts;
        public PlayerData();
    }

    private ConfigData config;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Lower Range Color Value")]
        public SimpleRangeData LowerRange;
        [JsonProperty(PropertyName = "Middle Range")]
        public FullRangeData MiddleRange;
        [JsonProperty(PropertyName = "Higher Range")]
        public FullRangeData HigherRange;
        [JsonProperty(PropertyName = "Alert 1")]
        public uint Alert1;
        [JsonProperty(PropertyName = "Alert 2")]
        public uint Alert2;
        [JsonProperty(PropertyName = "Continous alert")]
        public uint ContAlert;
        [JsonProperty(PropertyName = "Show picture")]
        public bool ShowPicture;
        [JsonProperty(PropertyName = "Picture URL")]
        public string PictureURL;
        [JsonProperty(PropertyName = "Show info (All, Bar, Value)")]
        public string ShowInfo;
        [JsonProperty(PropertyName = "Postition")]
        public AnchorPosition Position;
        [JsonProperty(PropertyName = "Maximum Player Alerts")]
        public uint MaxAlerts;
        [JsonProperty(PropertyName = "Remove after offline days")]
        public uint OffDays;
    }

    private class FullRangeData
    {
        [JsonProperty(PropertyName = "Starting Value")]
        public uint StartValue;
        [JsonProperty(PropertyName = "Bar Color")]
        public string BarColorValue;
        [JsonProperty(PropertyName = "Font Color")]
        public string FontColorValue;
    }

    private class AnchorPosition
    {
        [JsonProperty(PropertyName = "X-axis")]
        public float XAxis;
        [JsonProperty(PropertyName = "Y-axis")]
        public float YAxis;
    }

    private class SimpleRangeData
    {
        [JsonProperty(PropertyName = "Bar Color")]
        public string BarColorValue;
        [JsonProperty(PropertyName = "Font Color")]
        public string FontColorValue;
        public SimpleRangeData();
        public SimpleRangeData(string barcolor, string fontcolor);
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    [ChatCommand("Diving")]
     void HandleChatcommand(BasePlayer player, string command, string[] args);
    private void Init();
     void OnServerInitialized();
     void OnServerSave();
    private void Unload();
     void OnPlayerConnected(BasePlayer player);
    private void OnPlayerSleepEnded(BasePlayer player);
     void OnPlayerDeath(BasePlayer player, HitInfo info);
     void OnItemAddedToContainer(ItemContainer cont, Item item);
     void OnItemRemovedFromContainer(ItemContainer cont, Item item);
     void OnEntityTakeDamage(BasePlayer player, HitInfo info);
     void OnLoseCondition(Item item, float amount);
     void OnItemAction(Item item, string action, BasePlayer player);
     void RemoveOldData();
     void InitPlayer(ulong userID, bool reset);
     void HideOxygen(BasePlayer player);
     void ShowOxygen(BasePlayer player);
     string GetAlerts(ulong userID);
     string GetDefaultAlerts();
     string AddAlert(ulong userID, string args);
     string RemoveAlert(ulong userID, string args);
     bool MustDoEffect(float condition, ulong userID);
     string GetRanges(ulong userID);
     string GetDefaultRanges();
     string AddRange(ulong userID, string[] args, bool doUpdate);
     string RemoveRange(ulong userID, string args, bool doUpdate);
     void GetRGBValues(ulong userID, uint condition, string barRGB, string fontRGB);
     void ChangeView(ulong userID, string show, bool doUpdate);
     bool ShouldHandleUI(ItemContainer cont, Item item);
     void UpdatePanels(BasePlayer player, float condition, float maxCondition, bool doPicture);
     void DestroyUI(BasePlayer player, bool updatePicture);
     void DrawUI(BasePlayer player, string color, string valueText, string barText, string fontColor, bool updatePicture);
    private bool MustShowBar(ulong userID);
    private bool MustShowValue(ulong userID);
    private string GetAnchorMax(ulong userID);
     CuiElementContainer Generate_Menu(BasePlayer player, string barColor, string valueText, string barText, string fontColor, bool updatePicture);
     void LoadData();
     void SaveData();
    protected override void SaveConfig();
    private static string ColorFromHex(string hexColor, int alpha);
    private string Lang(string key, string userId, object[] args);
    private bool IsWearablesContainer(ItemContainer cont);
    private bool IsWearingdivingTank(BasePlayer player, Item item);
    private bool PlayerSignedUp(BasePlayer player);
    private bool IsValidColor(string value, string RGB);
    private bool IsValidRGBValue(string value);
     void ShowCommandHelp(BasePlayer player);
     string ColorList();
     string ColorToRGB(string namedColor);
}

private class PlayerData
{
    public bool Enabled;
    public string ShowInfo;
    public DateTime LastChange;
    public DateTime LastOnline;
    public Dictionary<uint, SimpleRangeData> ColorRanges;
    public Dictionary<uint, bool> Alerts;
    public PlayerData();
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Lower Range Color Value")]
    public SimpleRangeData LowerRange;
    [JsonProperty(PropertyName = "Middle Range")]
    public FullRangeData MiddleRange;
    [JsonProperty(PropertyName = "Higher Range")]
    public FullRangeData HigherRange;
    [JsonProperty(PropertyName = "Alert 1")]
    public uint Alert1;
    [JsonProperty(PropertyName = "Alert 2")]
    public uint Alert2;
    [JsonProperty(PropertyName = "Continous alert")]
    public uint ContAlert;
    [JsonProperty(PropertyName = "Show picture")]
    public bool ShowPicture;
    [JsonProperty(PropertyName = "Picture URL")]
    public string PictureURL;
    [JsonProperty(PropertyName = "Show info (All, Bar, Value)")]
    public string ShowInfo;
    [JsonProperty(PropertyName = "Postition")]
    public AnchorPosition Position;
    [JsonProperty(PropertyName = "Maximum Player Alerts")]
    public uint MaxAlerts;
    [JsonProperty(PropertyName = "Remove after offline days")]
    public uint OffDays;
}

private class FullRangeData
{
    [JsonProperty(PropertyName = "Starting Value")]
    public uint StartValue;
    [JsonProperty(PropertyName = "Bar Color")]
    public string BarColorValue;
    [JsonProperty(PropertyName = "Font Color")]
    public string FontColorValue;
}

private class AnchorPosition
{
    [JsonProperty(PropertyName = "X-axis")]
    public float XAxis;
    [JsonProperty(PropertyName = "Y-axis")]
    public float YAxis;
}

private class SimpleRangeData
{
    [JsonProperty(PropertyName = "Bar Color")]
    public string BarColorValue;
    [JsonProperty(PropertyName = "Font Color")]
    public string FontColorValue;
    public SimpleRangeData();
    public SimpleRangeData(string barcolor, string fontcolor);
}


```

---

## ChillFuel by Thisha - Displays the fuel quantity for minicopter, rowboat, rhib, scraptransport and modular car.

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using UnityEngine;

Oxide.Plugins
[Info("Chill Fuel", "Thisha", "0.3.2")]
[Description("Simple visualisation of vehicle fuel amount")]
public class ChillFuel : RustPlugin
{
    private const string minicopterShortName;
    private const string rowboatShortName;
    private const string RHIBShortName;
    private const string fuelpermissionName;
    private const string fuelmodpermissionName;
    private const string inviteNoticeMsg;
    private const string dplnMinicopter;
    private const string dplnScrapTransport;
    private const string dplnMotorboat;
    private const string dplnRHIB;
    private const string dplnCar;
    private const string dplnShowValue;
    private const string lblClose;
    private const string noModPerm;
    protected override void LoadDefaultMessages();
    private ConfigData config;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Postition")]
        public AnchorPosition Position;
        [JsonProperty(PropertyName = "Width")]
        public float Width;
        [JsonProperty(PropertyName = "Minicopter alert")]
        public int MiniAlert;
        [JsonProperty(PropertyName = "Scrap heli alert")]
        public int ScrapAlert;
        [JsonProperty(PropertyName = "Motorboat alert")]
        public int BoatAlert;
        [JsonProperty(PropertyName = "RHIB alert")]
        public int RHIBAlert;
        [JsonProperty(PropertyName = "Car alert")]
        public int CarAlert;
    }

    private class AnchorPosition
    {
        [JsonProperty(PropertyName = "X-axis")]
        public float XAxis;
        [JsonProperty(PropertyName = "Y-axis")]
        public float YAxis;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private Dictionary<ulong, PlayerData> playerData;
     class PlayerData
    {
        public bool Enabled;
        public int MiniAlert;
        public int ScrapAlert;
        public int BoatAlert;
        public int RHIBAlert;
        public int CarAlert;
    }

     void InitPlayer(ulong userID, bool reset);
     void LoadData();
     void SaveData();
    [ChatCommand("Fuel")]
     void HandleChatcommand(BasePlayer player, string command, string[] args);
    [ConsoleCommand("fuel.add")]
    private void DeltaAlarm(ConsoleSystem.Arg arg);
    [ConsoleCommand("playerdatafuelclose")]
    private void CloseInfo(ConsoleSystem.Arg arg);
    [ConsoleCommand("playerdatatoggleshowfuel")]
    private void ToggleShowFuel(ConsoleSystem.Arg arg);
    private void Init();
    private void Unload();
     void OnPlayerDeath(BasePlayer player, HitInfo info);
     void OnEntityMounted(BaseMountable entity, BasePlayer player);
     void OnEntityDismounted(BaseMountable entity, BasePlayer player);
     void DoPlayerTime(BasePlayer player, bool updatePicture);
     void CheckAction(BasePlayer player, bool updatePicture);
     void UpdateState(BasePlayer player, bool newState);
     void UpdatePanels(BasePlayer player, float condition, bool doPicture);
     void DestroyUI(BasePlayer player, bool updatePicture);
     void DrawUI(BasePlayer player, string color, string valueText, bool updatePicture);
     CuiElementContainer Generate_Menu(BasePlayer player, string color, string valueText, bool updatePicture);
    private const string playerLabelPanel;
    private const string playerDataPanel;
    private const string playerButtonPanel;
    private void ShowPlayerPanel(BasePlayer player);
    private void ShowValuePanel(BasePlayer player);
    private void ShowButtonPanel(BasePlayer player);
    private static CuiButton CreateToggleButton(string mainPanelName, bool toggleOn, string anchorMin, string anchorMax);
    private static CuiButton CreateUpDownButton(string mainPanelName, string vehicle, bool up, string anchorMin, string anchorMax);
    private static CuiButton CreateCloseButton(string mainPanelName, string lblText);
    private static CuiLabel AddLabel(string labelText, string anchorMin, string anchorMax);
    private static CuiLabel AddValueLabel(string labelText, string anchorMin, string anchorMax);
    private static CuiPanel AddValueBackground(string anchorMin, string anchorMax);
    private bool PlayerSignedUp(BasePlayer player);
    private string GetStringValue(int value);
    private string Lang(string key, string userId, object[] args);
    public static class ColorExtensions
    {
        public static string ToRustFormatString(Color color);
        public static string ToHexStringRGB(Color col);
        public static string ToHexStringRGBA(Color col);
        public static bool TryParseHexString(string hexString, Color color);
        private static Color FromHexString(string hexString);
        public static string ColorFromHex(string hexColor, int alpha);
    }

}

 class ConfigData
{
    [JsonProperty(PropertyName = "Postition")]
    public AnchorPosition Position;
    [JsonProperty(PropertyName = "Width")]
    public float Width;
    [JsonProperty(PropertyName = "Minicopter alert")]
    public int MiniAlert;
    [JsonProperty(PropertyName = "Scrap heli alert")]
    public int ScrapAlert;
    [JsonProperty(PropertyName = "Motorboat alert")]
    public int BoatAlert;
    [JsonProperty(PropertyName = "RHIB alert")]
    public int RHIBAlert;
    [JsonProperty(PropertyName = "Car alert")]
    public int CarAlert;
}

private class AnchorPosition
{
    [JsonProperty(PropertyName = "X-axis")]
    public float XAxis;
    [JsonProperty(PropertyName = "Y-axis")]
    public float YAxis;
}

 class PlayerData
{
    public bool Enabled;
    public int MiniAlert;
    public int ScrapAlert;
    public int BoatAlert;
    public int RHIBAlert;
    public int CarAlert;
}

public static class ColorExtensions
{
    public static string ToRustFormatString(Color color);
    public static string ToHexStringRGB(Color col);
    public static string ToHexStringRGBA(Color col);
    public static bool TryParseHexString(string hexString, Color color);
    private static Color FromHexString(string hexString);
    public static string ColorFromHex(string hexColor, int alpha);
}


```

---

## ChillNightVision by Thisha - Visual support for night vision goggles.

```csharp
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System;
using Rust;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Chill Night Vision", "Thisha", "0.0.1")]
[Description("Visual support for night goggles")]
public class ChillNightVision : RustPlugin
{
    private const string usePermission;
    private const string modifyPermission;
    private const string inviteNoticeMsg;
    private const string gogglesShortName;
    private const string defaultPictureURL;
    private float pictureOffset;
    public DateTime lastCleanUp;
    private new void LoadDefaultMessages();
    private Dictionary<ulong, PlayerData> playerData;
    private class PlayerData
    {
        public bool Enabled;
        public string ShowInfo;
        public DateTime LastChange;
        public DateTime LastOnline;
        public Dictionary<uint, SimpleRangeData> ColorRanges;
        public List<uint> Alerts;
        public PlayerData();
    }

    private ConfigData config;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Lower Range Color Value")]
        public SimpleRangeData LowerRange;
        [JsonProperty(PropertyName = "Middle Range")]
        public FullRangeData MiddleRange;
        [JsonProperty(PropertyName = "Higher Range")]
        public FullRangeData HigherRange;
        [JsonProperty(PropertyName = "Alert 1")]
        public uint Alert1;
        [JsonProperty(PropertyName = "Show picture")]
        public bool ShowPicture;
        [JsonProperty(PropertyName = "Picture URL")]
        public string PictureURL;
        [JsonProperty(PropertyName = "Show info (All, Bar, Value)")]
        public string ShowInfo;
        [JsonProperty(PropertyName = "Postition")]
        public AnchorPosition Position;
        [JsonProperty(PropertyName = "Maximum Player Alerts")]
        public uint MaxAlerts;
        [JsonProperty(PropertyName = "Remove after offline days")]
        public uint OffDays;
    }

    private class FullRangeData
    {
        [JsonProperty(PropertyName = "Starting Value")]
        public uint StartValue;
        [JsonProperty(PropertyName = "Bar Color")]
        public string BarColorValue;
        [JsonProperty(PropertyName = "Font Color")]
        public string FontColorValue;
    }

    private class AnchorPosition
    {
        [JsonProperty(PropertyName = "X-axis")]
        public float XAxis;
        [JsonProperty(PropertyName = "Y-axis")]
        public float YAxis;
    }

    private class SimpleRangeData
    {
        [JsonProperty(PropertyName = "Bar Color")]
        public string BarColorValue;
        [JsonProperty(PropertyName = "Font Color")]
        public string FontColorValue;
        public SimpleRangeData();
        public SimpleRangeData(string barcolor, string fontcolor);
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    [ChatCommand("cnv")]
     void HandleChatcommand(BasePlayer player, string command, string[] args);
    private void Init();
     void OnServerInitialized();
     void OnServerSave();
    private void Unload();
     void OnPlayerConnected(BasePlayer player);
    private void OnPlayerSleepEnded(BasePlayer player);
     void OnPlayerDeath(BasePlayer player, HitInfo info);
     void OnItemAddedToContainer(ItemContainer cont, Item item);
     void OnItemRemovedFromContainer(ItemContainer cont, Item item);
     void OnEntityTakeDamage(BasePlayer player, HitInfo info);
     void OnLoseCondition(Item item, float amount);
     void OnItemAction(Item item, string action, BasePlayer player);
     void RemoveOldData();
     void InitPlayer(ulong userID, bool reset);
     void HideOxygen(BasePlayer player);
     void ShowOxygen(BasePlayer player);
     string GetAlerts(ulong userID);
     string GetDefaultAlerts();
     string AddAlert(ulong userID, string args);
     string RemoveAlert(ulong userID, string args);
     bool MustDoEffect(float condition, ulong userID);
     string GetRanges(ulong userID);
     string GetDefaultRanges();
     string AddRange(ulong userID, string[] args, bool doUpdate);
     string RemoveRange(ulong userID, string args, bool doUpdate);
     void GetRGBValues(ulong userID, uint condition, string barRGB, string fontRGB);
     void ChangeView(ulong userID, string show, bool doUpdate);
     bool ShouldHandleUI(ItemContainer cont, Item item);
     void UpdatePanels(BasePlayer player, float condition, float maxCondition, bool doPicture);
     void DestroyUI(BasePlayer player, bool updatePicture);
     void DrawUI(BasePlayer player, string color, string valueText, string barText, string fontColor, bool updatePicture);
    private bool MustShowBar(ulong userID);
    private bool MustShowValue(ulong userID);
    private string GetAnchorMax(ulong userID);
     CuiElementContainer Generate_Menu(BasePlayer player, string barColor, string valueText, string barText, string fontColor, bool updatePicture);
     void LoadData();
     void SaveData();
    protected override void SaveConfig();
    private static string ColorFromHex(string hexColor, int alpha);
    private string Lang(string key, string userId, object[] args);
    private bool IsWearablesContainer(ItemContainer cont);
    private bool IsWearingGoggles(BasePlayer player, Item item);
    private bool PlayerSignedUp(BasePlayer player);
    private bool IsValidColor(string value, string RGB);
    private bool IsValidRGBValue(string value);
     void ShowCommandHelp(BasePlayer player);
     string ColorList();
     string ColorToRGB(string namedColor);
}

private class PlayerData
{
    public bool Enabled;
    public string ShowInfo;
    public DateTime LastChange;
    public DateTime LastOnline;
    public Dictionary<uint, SimpleRangeData> ColorRanges;
    public List<uint> Alerts;
    public PlayerData();
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Lower Range Color Value")]
    public SimpleRangeData LowerRange;
    [JsonProperty(PropertyName = "Middle Range")]
    public FullRangeData MiddleRange;
    [JsonProperty(PropertyName = "Higher Range")]
    public FullRangeData HigherRange;
    [JsonProperty(PropertyName = "Alert 1")]
    public uint Alert1;
    [JsonProperty(PropertyName = "Show picture")]
    public bool ShowPicture;
    [JsonProperty(PropertyName = "Picture URL")]
    public string PictureURL;
    [JsonProperty(PropertyName = "Show info (All, Bar, Value)")]
    public string ShowInfo;
    [JsonProperty(PropertyName = "Postition")]
    public AnchorPosition Position;
    [JsonProperty(PropertyName = "Maximum Player Alerts")]
    public uint MaxAlerts;
    [JsonProperty(PropertyName = "Remove after offline days")]
    public uint OffDays;
}

private class FullRangeData
{
    [JsonProperty(PropertyName = "Starting Value")]
    public uint StartValue;
    [JsonProperty(PropertyName = "Bar Color")]
    public string BarColorValue;
    [JsonProperty(PropertyName = "Font Color")]
    public string FontColorValue;
}

private class AnchorPosition
{
    [JsonProperty(PropertyName = "X-axis")]
    public float XAxis;
    [JsonProperty(PropertyName = "Y-axis")]
    public float YAxis;
}

private class SimpleRangeData
{
    [JsonProperty(PropertyName = "Bar Color")]
    public string BarColorValue;
    [JsonProperty(PropertyName = "Font Color")]
    public string FontColorValue;
    public SimpleRangeData();
    public SimpleRangeData(string barcolor, string fontcolor);
}


```

---

## ChinookCrateToBag by Waggy - Chinook crates drop loot in a bag a configurable amount of time after hacking finishes

```csharp
using Newtonsoft.Json;

Oxide.Plugins
[Info( "Chinook Crate To Bag", "Waggy", "1.0.1" )]
[Description( "Chinook crates drop loot in a bag a configurable amount of time after hacking finishes" )]
 class ChinookCrateToBag : CovalencePlugin
{
     void OnCrateHackEnd(HackableLockedCrate crate);
    private ConfigData config;
    protected override void LoadDefaultConfig();
    private void Init();
    private new void SaveConfig();
    public class ConfigData
    {
        [JsonProperty( "Time to Wait Before Dropping Bag (in minutes)" )]
        public float timeToWait;
    }

}

public class ConfigData
{
    [JsonProperty( "Time to Wait Before Dropping Bag (in minutes)" )]
    public float timeToWait;
}


```

---

## ChinookDropRandomizer by  - Make the chinook crate drop location more random

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Chinook Drop Randomizer", "shinnova/Arainrr", "1.5.1")]
[Description("Make the chinook drop location more random")]
public class ChinookDropRandomizer : RustPlugin
{
    private bool initialized;
    private readonly static int GROUND_LAYER;
    private Dictionary<string, List<MonumentInfo>> monumentList;
    private readonly Dictionary<string, float> defaultMonumentSizes;
    private void OnServerInitialized();
    private void UpdateConfig();
    private void OnEntitySpawned(CH47HelicopterAIController chinook);
    private object CanHelicopterDropCrate(CH47HelicopterAIController chinook);
    private Vector3 GetGroundPosition(Vector3 position);
    private bool AboveWater(Vector3 location);
    private bool AboveMonument(Vector3 location);
    private void TryDropCrate(CH47HelicopterAIController chinook);
    private ConfigData configData;
    public class ConfigData
    {
        [JsonProperty(PropertyName = "Prevent the game from handling chinook drops")]
        public bool blockDefaultDrop;
        [JsonProperty(PropertyName = "Time before chinook starts trying to drop (seconds)")]
        public float dropDelay;
        [JsonProperty(PropertyName = "Minimum time until drop (seconds)")]
        public float minTime;
        [JsonProperty(PropertyName = "Maximum time until drop (seconds)")]
        public float maxTime;
        [JsonProperty(PropertyName = "Minimum number of online players to drop")]
        public int minPlayers;
        [JsonProperty(PropertyName = "Don't drop above water")]
        public bool checkWater;
        [JsonProperty(PropertyName = "Don't drop above monuments")]
        public bool checkMonument;
        [JsonProperty(PropertyName = "What monuments to check (only works if monument checking is enabled)")]
        public Dictionary<string, Monument> monumentsSettings;
        public class Monument
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool enabled;
            [JsonProperty(PropertyName = "Monument size")]
            public float monumentSize;
        }

    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class ConfigData
{
    [JsonProperty(PropertyName = "Prevent the game from handling chinook drops")]
    public bool blockDefaultDrop;
    [JsonProperty(PropertyName = "Time before chinook starts trying to drop (seconds)")]
    public float dropDelay;
    [JsonProperty(PropertyName = "Minimum time until drop (seconds)")]
    public float minTime;
    [JsonProperty(PropertyName = "Maximum time until drop (seconds)")]
    public float maxTime;
    [JsonProperty(PropertyName = "Minimum number of online players to drop")]
    public int minPlayers;
    [JsonProperty(PropertyName = "Don't drop above water")]
    public bool checkWater;
    [JsonProperty(PropertyName = "Don't drop above monuments")]
    public bool checkMonument;
    [JsonProperty(PropertyName = "What monuments to check (only works if monument checking is enabled)")]
    public Dictionary<string, Monument> monumentsSettings;
    public class Monument
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool enabled;
        [JsonProperty(PropertyName = "Monument size")]
        public float monumentSize;
    }

}

public class Monument
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool enabled;
    [JsonProperty(PropertyName = "Monument size")]
    public float monumentSize;
}


```

---

## ChinookSpawner by ziptie - Spawn and despawn chinooks on command.

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Chinook Spawner", "ziptie", 1.1)]
[Description("Spawn and despawn chinooks on command.")]
public class ChinookSpawner : CovalencePlugin
{
    public Dictionary<ulong, bool> hasChinook;
    private PluginConfig config;
    protected override void LoadDefaultMessages();
    private void Init();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    [Command("chinook"), Permission("chinookspawner.spawn")]
    private void SpawnChinook(IPlayer player, string command, string[] args);
    [Command("nochinook"), Permission("chinookspawner.despawn")]
    private void NoChinook(IPlayer player, string command, string[] args);
     void OnEntityKill(CH47Helicopter entity);
    private bool CreateChinook(BasePlayer player);
    private bool? DespawnChinook(BasePlayer playerBP);
}

public class ChinookIdentifier : MonoBehaviour
{
    public ulong ownerID;
}

public class PluginConfig
{
    public bool SpawnFireOnCrash;
    public bool SpawnGibsOnCrash;
    public float SpawnDistance;
    public bool BlockSpawningInBuildingBlock;
}


```

---

## ChopperSurvival by k1lly0u - Helicopter survival event for Event Manager

```csharp
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins.EventManagerEx;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UI = Oxide.Plugins.EMInterface.UI;
using UI4 = Oxide.Plugins.EMInterface.UI4;

Oxide.Plugins
[Info("ChopperSurvival", "k1lly0u", "3.0.2"), Description("Chopper survival event mode for EventManager")]
 class ChopperSurvival : RustPlugin, IEventPlugin
{
    private const string HELICOPTER_PREFAB;
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private void OnEntityTakeDamage(PatrolHelicopter baseHelicopter, HitInfo hitInfo);
    private void Unload();
    public bool InitializeEvent(EventManager.EventConfig config);
    public bool CanUseClassSelector { get; set; }
    public bool RequireTimeLimit { get; set; }
    public bool RequireScoreLimit { get; set; }
    public bool UseScoreLimit { get; set; }
    public bool UseTimeLimit { get; set; }
    public bool IsTeamEvent { get; set; }
    public void FormatScoreEntry(EventManager.ScoreEntry scoreEntry, ulong langUserId, string score1, string score2);
    public List<EventManager.EventParameter> AdditionalParameters { get; set; }
    public string ParameterIsValid(string fieldName, object value);
    private static string ToOrdinal(int i);
    public class ChopperSurvivalEvent : EventManager.BaseEventGame
    {
        public List<EventManager.BaseEventPlayer> winners;
        private int playerLives;
        private int rounds;
        private int maxHelicopters;
        private int heliHealth;
        private float damageScaler;
        private int currentRound;
        private List<EventHelicopter> eventHelicopters;
        private Color COLOR_GREEN;
        private Color COLOR_RED;
        internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config);
        protected override void OnDestroy();
        internal override void PrestartEvent();
        protected override void StartEvent();
        internal override void EndEvent();
        protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player);
        protected override void OnPlayerSpawned(EventManager.BaseEventPlayer eventPlayer);
        internal override bool CanDealEntityDamage(EventManager.BaseEventPlayer attacker, BaseEntity entity, HitInfo hitInfo);
        internal void OnHelicopterKilled(EventHelicopter eventHelicopter);
        internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo);
        internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker, HitInfo info);
        protected override void DisplayKillToChat(EventManager.BaseEventPlayer victim, string attackerName);
        private int GetPlayersRemainingCount();
        protected override void GetWinningPlayers(List<EventManager.BaseEventPlayer> winners);
        private void StartRound();
        private void EndRound();
        private IEnumerator ResetPlayers();
        private IEnumerator SpawnRoundHelicopters();
        protected override void BuildScoreboard();
        private void CreateHealthBar(CuiElementContainer container, string text, float health, int index);
        private string GetInterpolatedColor(float delta, float alpha);
        protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer);
        protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer);
        protected override void SortScores(List<EventManager.ScoreEntry> list);
        internal override void GetAdditionalEventDetails(List<KeyValuePair<string, object>> list, ulong playerId);
    }

    private class ChopperSurvivalPlayer : EventManager.BaseEventPlayer
    {
        internal int LivesRemaining { get; set; }
        internal int HitPoints { get; set; }
        internal override void OnPlayerDeath(EventManager.BaseEventPlayer attacker, float respawnTime);
    }

    internal class EventHelicopter : MonoBehaviour
    {
        internal PatrolHelicopter Entity { get; set; }
        internal PatrolHelicopterAI AI { get; set; }
        internal ChopperSurvivalEvent Event { get; set; }
        internal int ID { get; set; }
        private Transform tr;
        private Vector3 centerDestination;
        private RaycastHit raycastHit;
        private uint tailRotorBone;
        private uint mainRotorBone;
        private List<PatrolHelicopterAI.targetinfo> _targets;
        private const string HELIEXPLOSION_EFFECT;
        private void Awake();
        internal void OnHelicopterSpawned(ChopperSurvivalEvent chopperSurvivalEvent, int id);
        private void Update();
        private void OnDestroy();
        internal void SetPositionDestination(Vector3 position, Vector3 destination);
        private void UpdateTargetList();
        private bool PlayerVisible(BasePlayer player);
        private bool ValidStrafeTarget(BasePlayer player);
        private bool CanStrafe();
        private bool CanUseNapalm();
        internal bool DealDamage(HitInfo hitInfo, int hitPoints);
        private void KillHelicopter();
    }

    private static ConfigData Configuration;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Respawn time (seconds)")]
        public int RespawnTime { get; set; }
        [JsonProperty(PropertyName = "Maximum distance helicopters can travel away from the arena")]
        public float MaxTravelDistance { get; set; }
        [JsonProperty(PropertyName = "Amount of points given to players when they shoot a rotor")]
        public int RotorHitPoints { get; set; }
        [JsonProperty(PropertyName = "Amount of points given to players when they shoot the heli")]
        public int HeliHitPoints { get; set; }
        [JsonProperty(PropertyName = "Amount of time between rounds (seconds)")]
        public int TimeBetweenRounds { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    public string Message(string key, ulong playerId);
    private static Func<string, ulong, string> GetMessage;
    private readonly Dictionary<string, string> Messages;
}

public class ChopperSurvivalEvent : EventManager.BaseEventGame
{
    public List<EventManager.BaseEventPlayer> winners;
    private int playerLives;
    private int rounds;
    private int maxHelicopters;
    private int heliHealth;
    private float damageScaler;
    private int currentRound;
    private List<EventHelicopter> eventHelicopters;
    private Color COLOR_GREEN;
    private Color COLOR_RED;
    internal override void InitializeEvent(IEventPlugin plugin, EventManager.EventConfig config);
    protected override void OnDestroy();
    internal override void PrestartEvent();
    protected override void StartEvent();
    internal override void EndEvent();
    protected override EventManager.BaseEventPlayer AddPlayerComponent(BasePlayer player);
    protected override void OnPlayerSpawned(EventManager.BaseEventPlayer eventPlayer);
    internal override bool CanDealEntityDamage(EventManager.BaseEventPlayer attacker, BaseEntity entity, HitInfo hitInfo);
    internal void OnHelicopterKilled(EventHelicopter eventHelicopter);
    internal override void OnPlayerTakeDamage(EventManager.BaseEventPlayer eventPlayer, HitInfo hitInfo);
    internal override void OnEventPlayerDeath(EventManager.BaseEventPlayer victim, EventManager.BaseEventPlayer attacker, HitInfo info);
    protected override void DisplayKillToChat(EventManager.BaseEventPlayer victim, string attackerName);
    private int GetPlayersRemainingCount();
    protected override void GetWinningPlayers(List<EventManager.BaseEventPlayer> winners);
    private void StartRound();
    private void EndRound();
    private IEnumerator ResetPlayers();
    private IEnumerator SpawnRoundHelicopters();
    protected override void BuildScoreboard();
    private void CreateHealthBar(CuiElementContainer container, string text, float health, int index);
    private string GetInterpolatedColor(float delta, float alpha);
    protected override float GetFirstScoreValue(EventManager.BaseEventPlayer eventPlayer);
    protected override float GetSecondScoreValue(EventManager.BaseEventPlayer eventPlayer);
    protected override void SortScores(List<EventManager.ScoreEntry> list);
    internal override void GetAdditionalEventDetails(List<KeyValuePair<string, object>> list, ulong playerId);
}

private class ChopperSurvivalPlayer : EventManager.BaseEventPlayer
{
    internal int LivesRemaining { get; set; }
    internal int HitPoints { get; set; }
    internal override void OnPlayerDeath(EventManager.BaseEventPlayer attacker, float respawnTime);
}

internal class EventHelicopter : MonoBehaviour
{
    internal PatrolHelicopter Entity { get; set; }
    internal PatrolHelicopterAI AI { get; set; }
    internal ChopperSurvivalEvent Event { get; set; }
    internal int ID { get; set; }
    private Transform tr;
    private Vector3 centerDestination;
    private RaycastHit raycastHit;
    private uint tailRotorBone;
    private uint mainRotorBone;
    private List<PatrolHelicopterAI.targetinfo> _targets;
    private const string HELIEXPLOSION_EFFECT;
    private void Awake();
    internal void OnHelicopterSpawned(ChopperSurvivalEvent chopperSurvivalEvent, int id);
    private void Update();
    private void OnDestroy();
    internal void SetPositionDestination(Vector3 position, Vector3 destination);
    private void UpdateTargetList();
    private bool PlayerVisible(BasePlayer player);
    private bool ValidStrafeTarget(BasePlayer player);
    private bool CanStrafe();
    private bool CanUseNapalm();
    internal bool DealDamage(HitInfo hitInfo, int hitPoints);
    private void KillHelicopter();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Respawn time (seconds)")]
    public int RespawnTime { get; set; }
    [JsonProperty(PropertyName = "Maximum distance helicopters can travel away from the arena")]
    public float MaxTravelDistance { get; set; }
    [JsonProperty(PropertyName = "Amount of points given to players when they shoot a rotor")]
    public int RotorHitPoints { get; set; }
    [JsonProperty(PropertyName = "Amount of points given to players when they shoot the heli")]
    public int HeliHitPoints { get; set; }
    [JsonProperty(PropertyName = "Amount of time between rounds (seconds)")]
    public int TimeBetweenRounds { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}


```

---

## Christmas by FastBurst - Christmas regardless of the month!

```csharp
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Christmas", "FastBurst", "2.0.6")]
[Description("Christmas regardless of the month!")]
public class Christmas : RustPlugin
{
    private const string PLAYER_PERM;
    private static Christmas Instance { get; set; }
     System.Random rand;
    private void OnServerInitialized();
    private void Unload();
    private void StartTimedEvent();
    public bool RefillPresents();
    [ChatCommand("gift")]
    private void GiftsCommand(BasePlayer player, string command, string[] args);
    [ConsoleCommand("gift")]
    private void GiftsConsole(ConsoleSystem.Arg arg);
    private static ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Event Automation Settings")]
        public AutomationOptions Automation { get; set; }
        [JsonProperty(PropertyName = "Authorized Calling Settings")]
        public ManualOptions ManualSettings { get; set; }
        public class AutomationOptions
        {
            [JsonProperty(PropertyName = "Enable Christmas Gifts Event Plugin")]
            public bool enabled { get; set; }
            [JsonProperty(PropertyName = "Enable random autospawn Christmas Gifts Events on random timer")]
            public bool EnableTimedEvents { get; set; }
            [JsonProperty(PropertyName = "Minimum required players to start events")]
            public int MinRequiredPlayers { get; set; }
            [JsonProperty(PropertyName = "Minimum time in-between presents and stocking refills (seconds)")]
            public int RandomTimerMin { get; set; }
            [JsonProperty(PropertyName = "Maximum time in-between presents and stocking refills (seconds)")]
            public int RandomTimerMax { get; set; }
            [JsonProperty(PropertyName = "Distance a player in which to spawn")]
            public int playerDistance { get; set; }
            [JsonProperty(PropertyName = "Gifts per player")]
            public int giftsPerPlayer { get; set; }
            [JsonProperty(PropertyName = "Broadcast Message enabled to players when gifts sent (true/false)")]
            public bool messagesEnabled { get; set; }
        }

        public class ManualOptions
        {
            [JsonProperty(PropertyName = "Allow Admin to bypass required items to call gift command")]
            public bool AdminBypass { get; set; }
            [JsonProperty(PropertyName = "How many CCTV's needed")]
            public int cctv { get; set; }
            [JsonProperty(PropertyName = "How many Targeting Computer's needed")]
            public int computer { get; set; }
            [JsonProperty(PropertyName = "Require Santa Hat (true/false)")]
            public bool santahat { get; set; }
        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private static void SendChatMessage(string key, object[] args);
    private static string msg(string key, string playerId);
    private Dictionary<string, string> Messages;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Event Automation Settings")]
    public AutomationOptions Automation { get; set; }
    [JsonProperty(PropertyName = "Authorized Calling Settings")]
    public ManualOptions ManualSettings { get; set; }
    public class AutomationOptions
    {
        [JsonProperty(PropertyName = "Enable Christmas Gifts Event Plugin")]
        public bool enabled { get; set; }
        [JsonProperty(PropertyName = "Enable random autospawn Christmas Gifts Events on random timer")]
        public bool EnableTimedEvents { get; set; }
        [JsonProperty(PropertyName = "Minimum required players to start events")]
        public int MinRequiredPlayers { get; set; }
        [JsonProperty(PropertyName = "Minimum time in-between presents and stocking refills (seconds)")]
        public int RandomTimerMin { get; set; }
        [JsonProperty(PropertyName = "Maximum time in-between presents and stocking refills (seconds)")]
        public int RandomTimerMax { get; set; }
        [JsonProperty(PropertyName = "Distance a player in which to spawn")]
        public int playerDistance { get; set; }
        [JsonProperty(PropertyName = "Gifts per player")]
        public int giftsPerPlayer { get; set; }
        [JsonProperty(PropertyName = "Broadcast Message enabled to players when gifts sent (true/false)")]
        public bool messagesEnabled { get; set; }
    }

    public class ManualOptions
    {
        [JsonProperty(PropertyName = "Allow Admin to bypass required items to call gift command")]
        public bool AdminBypass { get; set; }
        [JsonProperty(PropertyName = "How many CCTV's needed")]
        public int cctv { get; set; }
        [JsonProperty(PropertyName = "How many Targeting Computer's needed")]
        public int computer { get; set; }
        [JsonProperty(PropertyName = "Require Santa Hat (true/false)")]
        public bool santahat { get; set; }
    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class AutomationOptions
{
    [JsonProperty(PropertyName = "Enable Christmas Gifts Event Plugin")]
    public bool enabled { get; set; }
    [JsonProperty(PropertyName = "Enable random autospawn Christmas Gifts Events on random timer")]
    public bool EnableTimedEvents { get; set; }
    [JsonProperty(PropertyName = "Minimum required players to start events")]
    public int MinRequiredPlayers { get; set; }
    [JsonProperty(PropertyName = "Minimum time in-between presents and stocking refills (seconds)")]
    public int RandomTimerMin { get; set; }
    [JsonProperty(PropertyName = "Maximum time in-between presents and stocking refills (seconds)")]
    public int RandomTimerMax { get; set; }
    [JsonProperty(PropertyName = "Distance a player in which to spawn")]
    public int playerDistance { get; set; }
    [JsonProperty(PropertyName = "Gifts per player")]
    public int giftsPerPlayer { get; set; }
    [JsonProperty(PropertyName = "Broadcast Message enabled to players when gifts sent (true/false)")]
    public bool messagesEnabled { get; set; }
}

public class ManualOptions
{
    [JsonProperty(PropertyName = "Allow Admin to bypass required items to call gift command")]
    public bool AdminBypass { get; set; }
    [JsonProperty(PropertyName = "How many CCTV's needed")]
    public int cctv { get; set; }
    [JsonProperty(PropertyName = "How many Targeting Computer's needed")]
    public int computer { get; set; }
    [JsonProperty(PropertyName = "Require Santa Hat (true/false)")]
    public bool santahat { get; set; }
}


```

---

## ChristmasTreePresents by Wrecks - Spawns Christmas Presents under Trees on Interval, With the option of overriding Vanilla loot.

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Christmas Tree Presents", "redBDGR / Wrecks", "2.0.0")]
[Description("Spawns Christmas presents under Christmas trees")]
public class ChristmasTreePresents : RustPlugin
{
    private const string Gift;
    private readonly HashSet<ChristmasTree> _christmasTrees;
    private Timer _spawnTimer;
    public class Settings
    {
        [JsonProperty("How Often to Spawn Presents in Minutes")]
        public int SpawnTimer;
        [JsonProperty("Minimum number of presents per tree")]
        public int MinNumOfPresents;
        [JsonProperty("Maximum number of presents per tree")]
        public int MaxNumOfPresents;
        [JsonProperty("Tree needs all ornaments?")]
        public bool TreeNeedsAllOrnaments;
        [JsonProperty("Tree needs to be on foundation?")]
        public bool TreeNeedsToBeOnFoundation;
        [JsonProperty("Send Custom Gifts?(Clears Vanilla and Adds Your Own)")]
        public bool SendCustomGifts;
        [JsonProperty("Minimum number of Custom Gifts per Present")]
        public int MinNumOfCustomGifts;
        [JsonProperty("Maximum number of Custom Gifts per Present")]
        public int MaxNumOfCustomGifts;
    }

    public class Items
    {
        [JsonProperty("Shortname")]
        public string Shortname { get; set; }
        [JsonProperty("SkinID")]
        public ulong SkinId { get; set; }
        [JsonProperty("Probability (0-1)")]
        public float Probability { get; set; }
        [JsonProperty("Custom Name")]
        public string CustomName { get; set; }
        [JsonProperty("Minimum Amount")]
        public int MinimumAmount { get; set; }
        [JsonProperty("Maximum Amount")]
        public int MaximumAmount { get; set; }
    }

    private static Configuration _config;
    public class Configuration
    {
        [JsonProperty("Settings")]
        public Settings Settings;
        [JsonProperty("Items")]
        public List<Items> ItemsList;
        public static Configuration DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void Unload();
    private void OnEntitySpawned(BaseEntity entity);
    private void OnEntityKill(BaseEntity entity);
    private void Clear();
    private void StartTimer();
    private void CacheTrees();
    private void TrySpawn();
    private void SendMessage();
    private void SpawnPresents(ChristmasTree tree);
    private void CreatePresent(Vector3 pos, Quaternion rot);
    private void AddCustomLoot(ItemContainer inventory);
    private static bool CheckOrnaments(ChristmasTree tree);
    private static bool CheckBuilding(ChristmasTree tree);
}

public class Settings
{
    [JsonProperty("How Often to Spawn Presents in Minutes")]
    public int SpawnTimer;
    [JsonProperty("Minimum number of presents per tree")]
    public int MinNumOfPresents;
    [JsonProperty("Maximum number of presents per tree")]
    public int MaxNumOfPresents;
    [JsonProperty("Tree needs all ornaments?")]
    public bool TreeNeedsAllOrnaments;
    [JsonProperty("Tree needs to be on foundation?")]
    public bool TreeNeedsToBeOnFoundation;
    [JsonProperty("Send Custom Gifts?(Clears Vanilla and Adds Your Own)")]
    public bool SendCustomGifts;
    [JsonProperty("Minimum number of Custom Gifts per Present")]
    public int MinNumOfCustomGifts;
    [JsonProperty("Maximum number of Custom Gifts per Present")]
    public int MaxNumOfCustomGifts;
}

public class Items
{
    [JsonProperty("Shortname")]
    public string Shortname { get; set; }
    [JsonProperty("SkinID")]
    public ulong SkinId { get; set; }
    [JsonProperty("Probability (0-1)")]
    public float Probability { get; set; }
    [JsonProperty("Custom Name")]
    public string CustomName { get; set; }
    [JsonProperty("Minimum Amount")]
    public int MinimumAmount { get; set; }
    [JsonProperty("Maximum Amount")]
    public int MaximumAmount { get; set; }
}

public class Configuration
{
    [JsonProperty("Settings")]
    public Settings Settings;
    [JsonProperty("Items")]
    public List<Items> ItemsList;
    public static Configuration DefaultConfig();
}


```

---

## Chute by ColonBlow - Players can parachute / paraglide using realistic flight physics for a smooth and fun ride !!

```csharp
using Rust;
using System;
using GameTips;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Chute", "Colon Blow", "3.0.1")]
 class Chute : CovalencePlugin
{
    [PluginReference]
     Plugin NoEscape;
    static Chute _instance;
    private const string permAllowed;
    private const string permAllowedUp;
    private const string permNoCooldown;
    private const string permVIPCooldown;
    private static List<ulong> coolDownList;
    static int layerMask;
    private void Loaded();
    private void LoadMessages();
    private static PluginConfig config;
    private class PluginConfig
    {
        public ChuteSettings chuteSettings { get; set; }
        public class ChuteSettings
        {
            [JsonProperty(PropertyName = "Parachute - Speed - Max Forward speed allowed : ")]
            public float MaxParachuteFWDSpeed { get; set; }
            [JsonProperty(PropertyName = "Parachute - Lift - Max up lift force allowed : ")]
            public float MaxParachteLift { get; set; }
            [JsonProperty(PropertyName = "Drop Height - Altitude at which Chuteup moves player to : ")]
            public float ChuteDropHeight { get; set; }
            [JsonProperty(PropertyName = "Cooldown - Enable Cooldown on using any Chute command ? ")]
            public bool UseCooldown { get; set; }
            [JsonProperty(PropertyName = "Cooldown - Chute Command Cooldown Time (seconds) : ")]
            public float ChuteCoolDown { get; set; }
            [JsonProperty(PropertyName = "Cooldown - Chute Up Command Cooldown Time (seconds) : ")]
            public float ChuteUpCoolDown { get; set; }
            [JsonProperty(PropertyName = "Cooldown - VIP Chute Command Cooldown Time (Seconds) : ")]
            public float VIPChuteCoolDown { get; set; }
            [JsonProperty(PropertyName = "Cooldown - VIP Chute Up Command Cooldown Time (Seconds) : ")]
            public float VIPChuteUpCoolDown { get; set; }
            [JsonProperty(PropertyName = "Global - Map size offset - Moves the spawn locations farther inland so Chute and Player dont spawn at edge of map : ")]
            public float GlobalMapOffset { get; set; }
            [JsonProperty(PropertyName = "NoEspace - Raid Blocked  - Prevent Chute Up command if players are Raid Blocked with No Escape Plugin ? ")]
            public bool BlockOnRaid { get; set; }
            [JsonProperty(PropertyName = "NoEspace - Combat Blocked  - Prevent Chute Up command if players are Combat Blocked with No Escape Plugin ? ")]
            public bool BlockOnCombat { get; set; }
        }

        public static PluginConfig DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    [Command("Chute")]
    private void cmdChute(IPlayer iPlayer, string command, string[] args);
    [Command("Chuteup")]
    private void cmdChuteUp(IPlayer iPlayer, string command, string[] args);
    private bool PlayerOnGround(BasePlayer player);
    private object CanDismountEntity(BasePlayer player, BaseMountable entity);
    private bool IsRaidBlocked(BasePlayer player);
    private bool IsCombatBlocked(BasePlayer player);
    private Vector3 FindRandomLocation();
    private IEnumerator ChuteProcessing(BasePlayer player, bool isRandom);
    private void RespawnAtRandom(BasePlayer player);
    private void MovePlayerToPosition(BasePlayer player, Vector3 position, Quaternion rotation);
    private static void DestroyAll();
    private void SendInfoMessage(BasePlayer player, string message, float time);
    private void Unload();
    private void ExternalAddPlayerChute(BasePlayer player, bool isRandom);
    public void OpenParachute(BasePlayer player);
    private void AttachParachuteEntity(BasePlayer player, float fwdVel);
    public class ParachuteEntity : MonoBehaviour
    {
         Chute _instance;
        private DroppedItem worldItem;
        private Rigidbody myRigidbody;
        private BaseEntity chair;
        private BaseMountable chairMount;
        private BaseEntity parachute;
        private BasePlayer player;
        private InputState input;
        public float fwdForce;
        public float upForce;
        private float counter;
        private bool enabled;
        public bool wantsDismount;
        private bool forceDismount;
        private void Awake();
        private void OnCollisionEnter(Collision collision);
        public void SetPlayer(BasePlayer player);
        private void SendInfoMessage(BasePlayer player, string message, float time);
        public void SetInput(InputState input);
        private void FixedUpdate();
        public void Release();
        public void OnDestroy();
    }

    public class CooldownTimer : MonoBehaviour
    {
        private BasePlayer player;
        public float cooldownTimer;
        public float waitTime;
        private bool enabled;
        private void Awake();
        public void EnableTimer(bool isChuteUp);
        private void SendInfoMessage(BasePlayer player, string message, float time);
        private void FixedUpdate();
        public void OnDestroy();
    }

}

private class PluginConfig
{
    public ChuteSettings chuteSettings { get; set; }
    public class ChuteSettings
    {
        [JsonProperty(PropertyName = "Parachute - Speed - Max Forward speed allowed : ")]
        public float MaxParachuteFWDSpeed { get; set; }
        [JsonProperty(PropertyName = "Parachute - Lift - Max up lift force allowed : ")]
        public float MaxParachteLift { get; set; }
        [JsonProperty(PropertyName = "Drop Height - Altitude at which Chuteup moves player to : ")]
        public float ChuteDropHeight { get; set; }
        [JsonProperty(PropertyName = "Cooldown - Enable Cooldown on using any Chute command ? ")]
        public bool UseCooldown { get; set; }
        [JsonProperty(PropertyName = "Cooldown - Chute Command Cooldown Time (seconds) : ")]
        public float ChuteCoolDown { get; set; }
        [JsonProperty(PropertyName = "Cooldown - Chute Up Command Cooldown Time (seconds) : ")]
        public float ChuteUpCoolDown { get; set; }
        [JsonProperty(PropertyName = "Cooldown - VIP Chute Command Cooldown Time (Seconds) : ")]
        public float VIPChuteCoolDown { get; set; }
        [JsonProperty(PropertyName = "Cooldown - VIP Chute Up Command Cooldown Time (Seconds) : ")]
        public float VIPChuteUpCoolDown { get; set; }
        [JsonProperty(PropertyName = "Global - Map size offset - Moves the spawn locations farther inland so Chute and Player dont spawn at edge of map : ")]
        public float GlobalMapOffset { get; set; }
        [JsonProperty(PropertyName = "NoEspace - Raid Blocked  - Prevent Chute Up command if players are Raid Blocked with No Escape Plugin ? ")]
        public bool BlockOnRaid { get; set; }
        [JsonProperty(PropertyName = "NoEspace - Combat Blocked  - Prevent Chute Up command if players are Combat Blocked with No Escape Plugin ? ")]
        public bool BlockOnCombat { get; set; }
    }

    public static PluginConfig DefaultConfig();
}

public class ChuteSettings
{
    [JsonProperty(PropertyName = "Parachute - Speed - Max Forward speed allowed : ")]
    public float MaxParachuteFWDSpeed { get; set; }
    [JsonProperty(PropertyName = "Parachute - Lift - Max up lift force allowed : ")]
    public float MaxParachteLift { get; set; }
    [JsonProperty(PropertyName = "Drop Height - Altitude at which Chuteup moves player to : ")]
    public float ChuteDropHeight { get; set; }
    [JsonProperty(PropertyName = "Cooldown - Enable Cooldown on using any Chute command ? ")]
    public bool UseCooldown { get; set; }
    [JsonProperty(PropertyName = "Cooldown - Chute Command Cooldown Time (seconds) : ")]
    public float ChuteCoolDown { get; set; }
    [JsonProperty(PropertyName = "Cooldown - Chute Up Command Cooldown Time (seconds) : ")]
    public float ChuteUpCoolDown { get; set; }
    [JsonProperty(PropertyName = "Cooldown - VIP Chute Command Cooldown Time (Seconds) : ")]
    public float VIPChuteCoolDown { get; set; }
    [JsonProperty(PropertyName = "Cooldown - VIP Chute Up Command Cooldown Time (Seconds) : ")]
    public float VIPChuteUpCoolDown { get; set; }
    [JsonProperty(PropertyName = "Global - Map size offset - Moves the spawn locations farther inland so Chute and Player dont spawn at edge of map : ")]
    public float GlobalMapOffset { get; set; }
    [JsonProperty(PropertyName = "NoEspace - Raid Blocked  - Prevent Chute Up command if players are Raid Blocked with No Escape Plugin ? ")]
    public bool BlockOnRaid { get; set; }
    [JsonProperty(PropertyName = "NoEspace - Combat Blocked  - Prevent Chute Up command if players are Combat Blocked with No Escape Plugin ? ")]
    public bool BlockOnCombat { get; set; }
}

public class ParachuteEntity : MonoBehaviour
{
     Chute _instance;
    private DroppedItem worldItem;
    private Rigidbody myRigidbody;
    private BaseEntity chair;
    private BaseMountable chairMount;
    private BaseEntity parachute;
    private BasePlayer player;
    private InputState input;
    public float fwdForce;
    public float upForce;
    private float counter;
    private bool enabled;
    public bool wantsDismount;
    private bool forceDismount;
    private void Awake();
    private void OnCollisionEnter(Collision collision);
    public void SetPlayer(BasePlayer player);
    private void SendInfoMessage(BasePlayer player, string message, float time);
    public void SetInput(InputState input);
    private void FixedUpdate();
    public void Release();
    public void OnDestroy();
}

public class CooldownTimer : MonoBehaviour
{
    private BasePlayer player;
    public float cooldownTimer;
    public float waitTime;
    private bool enabled;
    private void Awake();
    public void EnableTimer(bool isChuteUp);
    private void SendInfoMessage(BasePlayer player, string message, float time);
    private void FixedUpdate();
    public void OnDestroy();
}


```

---

## ClaimRewards by DutchKingCobra - Reward players for kills, give rewards or add rewards to a claim list

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Claim Rewards", "DutchKingCobra", "2.0.9")]
[Description("Claim rewards after certain amount of kills.")]
 class ClaimRewards : RustPlugin
{
    private PluginConfig config;
    private Dictionary<ulong, Dictionary<string, string>> PlayerData;
     Dictionary<string, string> PData;
    readonly Dictionary<string, string> items;
    private void Init();
     void OnServerInitialized();
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     object OnPlayerDeath(BasePlayer player);
     void OnServerSave();
    private void Unload();
    public void Registerpermissions();
    public bool HasPerm(BasePlayer player);
    private void IncKillsAndCheckIfReward(BasePlayer player);
    private void AddReward(ulong userID, string atKill, string TheReward);
    private void RemoveReward(ulong userID, string atKill);
    private void Listrewards(BasePlayer player);
    public void GiveReward(BasePlayer player, string reward, string str);
    public void GiveClaimedReward(BasePlayer player, string reward, string kills);
    public Tuple<string, string, string> Getitemdetails(string sname);
    protected override void LoadDefaultConfig();
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Config")]
        public ConfigSettings conf;
        [JsonProperty(PropertyName = "ChatCommand")]
        public chatSettings chatcommands;
        public class ConfigSettings
        {
            [JsonProperty(PropertyName = "OneLife")]
            public bool oneLife;
            [JsonProperty(PropertyName = "AutoGiveRewardsUnlessFullInventory")]
            public bool autoGiveRewards;
            [JsonProperty(PropertyName = "MaxKillsBeforeReset")]
            public int maxKills;
        }

        public class chatSettings
        {
            [JsonProperty(PropertyName = "Rewards")]
            public string chatcmdreward;
            [JsonProperty(PropertyName = "Claim")]
            public string chatcmdclaim;
            [JsonProperty(PropertyName = "Discard")]
            public string chatcmddiscard;
            [JsonProperty(PropertyName = "Nextreward")]
            public string chatcmdnextreward;
        }

    }

    private void SaveData();
    private string msg(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
    private void Cmdrw(BasePlayer player, string command, string[] args);
    private void Cmdclaim(BasePlayer player, string command, string[] args);
    private void Cmddiscard(BasePlayer player, string command, string[] args);
    private void Cmdnextreward(BasePlayer player);
    [ConsoleCommand("vcr")]
     void vcrConsole(ConsoleSystem.Arg arg);
}

private class PluginConfig
{
    [JsonProperty(PropertyName = "Config")]
    public ConfigSettings conf;
    [JsonProperty(PropertyName = "ChatCommand")]
    public chatSettings chatcommands;
    public class ConfigSettings
    {
        [JsonProperty(PropertyName = "OneLife")]
        public bool oneLife;
        [JsonProperty(PropertyName = "AutoGiveRewardsUnlessFullInventory")]
        public bool autoGiveRewards;
        [JsonProperty(PropertyName = "MaxKillsBeforeReset")]
        public int maxKills;
    }

    public class chatSettings
    {
        [JsonProperty(PropertyName = "Rewards")]
        public string chatcmdreward;
        [JsonProperty(PropertyName = "Claim")]
        public string chatcmdclaim;
        [JsonProperty(PropertyName = "Discard")]
        public string chatcmddiscard;
        [JsonProperty(PropertyName = "Nextreward")]
        public string chatcmdnextreward;
    }

}

public class ConfigSettings
{
    [JsonProperty(PropertyName = "OneLife")]
    public bool oneLife;
    [JsonProperty(PropertyName = "AutoGiveRewardsUnlessFullInventory")]
    public bool autoGiveRewards;
    [JsonProperty(PropertyName = "MaxKillsBeforeReset")]
    public int maxKills;
}

public class chatSettings
{
    [JsonProperty(PropertyName = "Rewards")]
    public string chatcmdreward;
    [JsonProperty(PropertyName = "Claim")]
    public string chatcmdclaim;
    [JsonProperty(PropertyName = "Discard")]
    public string chatcmddiscard;
    [JsonProperty(PropertyName = "Nextreward")]
    public string chatcmdnextreward;
}


```

---

## ClaimVehicle by WhiteThunder - Allows players to claim ownership of unowned vehicles

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Claim Vehicle", "WhiteThunder", "1.8.0")]
[Description("Allows players to claim ownership of unowned vehicles.")]
internal class ClaimVehicle : CovalencePlugin
{
    private Configuration _config;
    private const string Permission_Unclaim;
    private const string Permission_NoClaimCooldown;
    private const string Permission_Claim_AllVehicles;
    private readonly VehicleInfoManager _vehicleInfoManager;
    private CooldownManager _cooldownManager;
    public ClaimVehicle();
    private void Init();
    private void OnServerInitialized();
    private static class ExposedHooks
    {
        public static object OnVehicleClaim(BasePlayer player, BaseCombatEntity vehicle);
        public static object OnVehicleUnclaim(BasePlayer player, BaseCombatEntity vehicle);
        public static void OnVehicleOwnershipChanged(BaseCombatEntity vehicle);
    }

    private void ClaimVehicleCommand(IPlayer player, string cmd, string[] args);
    private void UnclaimVehicleCommand(IPlayer player, string cmd, string[] args);
    private static bool ClaimWasBlocked(BasePlayer player, BaseCombatEntity vehicle);
    private static bool UnclaimWasBlocked(BasePlayer player, BaseCombatEntity vehicle);
    private static RidableHorse2 GetClosestHorse(HitchTrough hitchTrough, BasePlayer player);
    private static BaseEntity GetLookEntity(BasePlayer player, float maxDistance);
    private static void ChangeVehicleOwnership(BaseCombatEntity vehicle, ulong userId);
    private static string FormatDuration(double seconds);
    private static string[] FindPrefabsOfType();
    private static BaseCombatEntity GetAppropriateVehicle(BaseEntity entity, BasePlayer player);
    private bool VerifySupportedVehicleFound(IPlayer player, BasePlayer basePlayer, BaseEntity entity, BaseCombatEntity vehicle, IVehicleInfo vehicleInfo);
    private bool VerifyPermissionAny(IPlayer player, string[] permissionNames);
    private bool VerifyVehicleIsNotDead(IPlayer player, BaseCombatEntity vehicle);
    private bool VerifyNotOwned(IPlayer player, BaseEntity vehicle);
    private bool VerifyOffCooldown(IPlayer player);
    private bool VerifyCanBuild(IPlayer player);
    private bool VerifyNoLockRestriction(IPlayer player, BaseCombatEntity vehicle);
    private bool VerifyNotMounted(IPlayer player, BaseCombatEntity entity);
    private bool VerifyCurrentlyOwned(IPlayer player, BaseCombatEntity vehicle);
    private class CooldownManager
    {
        private readonly Dictionary<ulong, float> _cooldownMap;
        private readonly float _cooldownDuration;
        public CooldownManager(float duration);
        public void UpdateLastUsedForPlayer(ulong userId);
        public float GetSecondsRemaining(ulong userId);
    }

    private class VehicleInfo : IVehicleInfo
    {
        public uint[] PrefabIds { get; set; }
        public string Permission { get; set; }
        public string VehicleName { get; set; }
        public string[] PrefabPaths { get; set; }
        public void OnServerInitialized(ClaimVehicle plugin);
        public bool IsCorrectType(BaseEntity entity);
    }

    private class VehicleInfoManager
    {
        private readonly ClaimVehicle _plugin;
        private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo;
        private IVehicleInfo[] _allVehicles;
        public VehicleInfoManager(ClaimVehicle plugin);
        public void OnServerInitialized();
        public IVehicleInfo GetVehicleInfo(BaseEntity entity);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("ClaimCooldownSeconds")]
        private float DeprecatedClaimCooldownSeconds { get; set; }
        [JsonProperty("Claim cooldown (seconds)")]
        public float ClaimCooldownSeconds;
        [JsonProperty("Claim commands")]
        public string[] ClaimCommands;
        [JsonProperty("Unclaim commands")]
        public string[] UnclaimCommands;
        public void Init(ClaimVehicle plugin);
    }

    private Configuration GetDefaultConfig();
    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    protected override void LoadDefaultMessages();
}

private static class ExposedHooks
{
    public static object OnVehicleClaim(BasePlayer player, BaseCombatEntity vehicle);
    public static object OnVehicleUnclaim(BasePlayer player, BaseCombatEntity vehicle);
    public static void OnVehicleOwnershipChanged(BaseCombatEntity vehicle);
}

private class CooldownManager
{
    private readonly Dictionary<ulong, float> _cooldownMap;
    private readonly float _cooldownDuration;
    public CooldownManager(float duration);
    public void UpdateLastUsedForPlayer(ulong userId);
    public float GetSecondsRemaining(ulong userId);
}

private class VehicleInfo : IVehicleInfo
{
    public uint[] PrefabIds { get; set; }
    public string Permission { get; set; }
    public string VehicleName { get; set; }
    public string[] PrefabPaths { get; set; }
    public void OnServerInitialized(ClaimVehicle plugin);
    public bool IsCorrectType(BaseEntity entity);
}

private class VehicleInfoManager
{
    private readonly ClaimVehicle _plugin;
    private readonly Dictionary<uint, IVehicleInfo> _prefabIdToVehicleInfo;
    private IVehicleInfo[] _allVehicles;
    public VehicleInfoManager(ClaimVehicle plugin);
    public void OnServerInitialized();
    public IVehicleInfo GetVehicleInfo(BaseEntity entity);
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : SerializableConfiguration
{
    [JsonProperty("ClaimCooldownSeconds")]
    private float DeprecatedClaimCooldownSeconds { get; set; }
    [JsonProperty("Claim cooldown (seconds)")]
    public float ClaimCooldownSeconds;
    [JsonProperty("Claim commands")]
    public string[] ClaimCommands;
    [JsonProperty("Unclaim commands")]
    public string[] UnclaimCommands;
    public void Init(ClaimVehicle plugin);
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## ClanBan by ctv - Bans an entire clan with one command

```csharp
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("ClanBan", "Slut", "1.3.0")]
internal class ClanBan : CovalencePlugin
{
    [PluginReference]
    private Plugin Clans;
    private Plugin DiscordMessages;
    private Plugin EnhancedBanSystem;
    private Plugin BetterChatMute;
    private bool AnnounceToServer;
    private int type;
    private void Init();
    private void LoadConfiguration();
    protected override void LoadDefaultConfig();
    private void RegisterPermissions();
    private void CheckCfg(string Key, T var);
    protected override void LoadDefaultMessages();
    [Command("clanban", "cb"), Permission("clanban.ban")]
    private void ClanBanCommand(IPlayer player, string command, string[] args);
    private JObject GetClan(string tag, IPlayer player);
    private void ProcessBan(IPlayer player, JObject clan, string reason);
    private void ProcessUnban(IPlayer player, JObject clan);
     string FormatTime(TimeSpan time);
    private bool TryParseTimeSpan(string source, TimeSpan timeSpan);
    private void ProcessMute(IPlayer player, JObject clan, string time);
    private void ProcessUnmute(IPlayer player, JObject clan);
    private void ProcessKick(IPlayer player, JObject clan, string reason);
    private void SendMessage(IPlayer player, string message);
    private string GetLang(string key, string id, object[] args);
}


```

---

## ClanInfo by Bazz3l - List clan members in a given clan

```csharp
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core;
using System.Linq;
using System.Collections.Generic;

Oxide.Plugins
[Info("Clan Info", "Bazz3l", "1.0.5")]
[Description("List all clan members in a given clan")]
 class ClanInfo : CovalencePlugin
{
    [PluginReference]
     Plugin Clans;
    private const string Perm;
    protected override void LoadDefaultMessages();
    private void Init();
    public JObject GetClan(string tag);
    public JArray GetClanMembers(string tag);
    [Command("cinfo")]
    private void cmdCinfo(IPlayer player, string command, string[] args);
    private string Lang(string key, string id, object[] args);
}


```

---

## Clans by k1lly0u - Universal clans with alliance support

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using ClansEx;

Oxide.Plugins
[Info("Clans", "k1lly0u", "0.2.8")]
public class Clans : CovalencePlugin
{
    private bool isInitialized;
    private Regex hexFilter;
    public static Clans Instance { get; set; }
    private static readonly DateTime Epoch;
    private static readonly double MaxUnixSeconds;
    private const string COLORED_LABEL;
    private void Loaded();
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void OnPluginLoaded(Plugin plugin);
    private void OnUserConnected(IPlayer player);
    private void OnUserDisconnected(IPlayer player);
    private void Unload();
    private void InitializeClans();
    private bool ClanTagExists(string tag);
    private string FormatTime(double time);
    private string BetterChat_FormattedClanTag(IPlayer player);
    private static int UnixTimeStampUTC();
    private static DateTime UnixTimeStampToDateTime(double unixTimeStamp);
    [HookMethod("CreateClan")]
    public void CreateClan(IPlayer player, string tag, string description);
    [HookMethod("InvitePlayer")]
    public bool InvitePlayer(IPlayer inviter, string targetId);
    [HookMethod("InvitePlayer")]
    public bool InvitePlayer(IPlayer inviter, IPlayer invitee);
    [HookMethod("WithdrawInvite")]
    public bool WithdrawInvite(IPlayer player, string partialNameOrID);
    [HookMethod("RejectInvite")]
    public bool RejectInvite(IPlayer player, string tag);
    [HookMethod("JoinClan")]
    public bool JoinClan(IPlayer player, string tag);
    [HookMethod("LeaveClan")]
    public bool LeaveClan(IPlayer player);
    [HookMethod("KickPlayer")]
    public bool KickPlayer(IPlayer player, string playerId);
    [HookMethod("PromotePlayer")]
    public bool PromotePlayer(IPlayer promoter, string targetId);
    [HookMethod("DemotePlayer")]
    public bool DemotePlayer(IPlayer demoter, string targetId);
    [HookMethod("DisbandClan")]
    public bool DisbandClan(IPlayer player);
    [HookMethod("OfferAlliance")]
    public bool OfferAlliance(IPlayer player, string tag);
    [HookMethod("WithdrawAlliance")]
    public bool WithdrawAlliance(IPlayer player, string tag);
    [HookMethod("AcceptAlliance")]
    public bool AcceptAlliance(IPlayer player, string tag);
    [HookMethod("RejectAlliance")]
    public bool RejectAlliance(IPlayer player, string tag);
    [HookMethod("RevokeAlliance")]
    public bool RevokeAlliance(IPlayer player, string tag);
    private void ClanChat(IPlayer player, string message);
    private void AllianceChat(IPlayer player, string message);
    [Command("a")]
    private void cmdAllianceChat(IPlayer player, string command, string[] args);
    [Command("c")]
    private void cmdClanChat(IPlayer player, string command, string[] args);
    [Command("cinfo")]
    private void cmdChatClanInfo(IPlayer player, string command, string[] args);
    [Command("clanhelp")]
    private void cmdChatClanHelp(IPlayer player, string command, string[] args);
    [Command("ally")]
    private void cmdChatClanAlly(IPlayer player, string command, string[] args);
    [Command("clan")]
    private void cmdChatClan(IPlayer player, string command, string[] args);
    private JObject GetClan(string tag);
    private JArray GetAllClans();
    private string GetClanOf(string playerId);
    private string GetClanOf(ulong playerId);
    private string GetClanOf(IPlayer player);
    private List<string> GetClanMembers(ulong playerId);
    private List<string> GetClanMembers(string playerId);
    private object HasFriend(ulong ownerId, ulong playerId);
    private object HasFriend(string ownerId, string playerId);
    private bool IsClanMember(ulong playerId, ulong otherId);
    private bool IsClanMember(string playerId, string otherId);
    private bool IsMemberOrAlly(ulong playerId, ulong otherId);
    private bool IsMemberOrAlly(string playerId, string otherId);
    private bool IsAllyPlayer(ulong playerId, ulong otherId);
    private bool IsAllyPlayer(string playerId, string otherId);
    private List<string> GetClanAlliances(ulong playerId);
    private List<string> GetClanAlliances(string playerId);
    [Serializable]
    public class Clan
    {
        public string Tag { get; set; }
        public string Description { get; set; }
        public string OwnerID { get; set; }
        public double CreationTime { get; set; }
        public double LastOnlineTime { get; set; }
        public Hash<string, Member> ClanMembers { get; set; }
        public Hash<string, MemberInvite> MemberInvites { get; set; }
        public HashSet<string> Alliances { get; set; }
        public Hash<string, double> AllianceInvites { get; set; }
        public HashSet<string> IncomingAlliances { get; set; }
        public string TagColor { get; set; }
        [JsonIgnore]
        public int OnlineCount { get; set; }
        [JsonIgnore]
        public int ModeratorCount { get; set; }
        [JsonIgnore]
        public int MemberCount { get; set; }
        [JsonIgnore]
        public int MemberInviteCount { get; set; }
        [JsonIgnore]
        public int AllianceCount { get; set; }
        [JsonIgnore]
        public int AllianceInviteCount { get; set; }
        public Clan();
        public Clan(IPlayer player, string tag, string description);
        internal void OnPlayerConnected(IPlayer player);
        internal void OnPlayerDisconnected(IPlayer player);
        internal bool InvitePlayer(IPlayer inviter, IPlayer invitee);
        internal bool JoinClan(IPlayer player);
        internal bool LeaveClan(IPlayer player);
        internal bool KickMember(IPlayer player, string targetId);
        internal bool PromotePlayer(IPlayer promoter, string targetId);
        internal bool DemotePlayer(IPlayer demoter, string targetId);
        internal void DisbandClan();
        internal void OnClanDisbanded(string tag);
        internal void OnUnload();
        internal bool IsAlliedClan(string otherClan);
        internal void MarkDirty();
        internal void Broadcast(string message);
        internal void Broadcast(string key, object[] args);
        [JsonIgnore]
        private string cachedClanInfo;
        [JsonIgnore]
        private string membersOnline;
        internal void PrintClanInfo(IPlayer player);
        internal string GetMembersOnline();
        public bool IsOwner(ulong playerId);
        public bool IsOwner(string playerId);
        public bool IsModerator(ulong playerId);
        public bool IsModerator(string playerId);
        public bool IsCouncil(ulong playerId);
        public bool IsMember(ulong playerId);
        public bool IsMember(string playerId);
        public Member GetOwner();
        public string GetRoleColor(string Id);
        public string GetRoleColor(Member.MemberRole role);
        [Serializable]
        public class Member
        {
            [JsonIgnore]
            public IPlayer Player { get; set; }
            [JsonProperty("Name")]
            public string DisplayName { get; set; }
            public MemberRole Role { get; set; }
            [JsonIgnore]
            public bool IsConnected { get; set; }
            [JsonIgnore]
            public bool MemberFFEnabled { get; set; }
            [JsonIgnore]
            public bool AllyFFEnabled { get; set; }
            public Member();
            public Member(MemberRole role, string name);
        }

        [Serializable]
        public class MemberInvite
        {
            [JsonProperty("Name")]
            public string DisplayName { get; set; }
            public double ExpiryTime { get; set; }
            public MemberInvite();
            public MemberInvite(IPlayer player);
            public MemberInvite(string name);
        }

        [JsonIgnore]
        private JObject serializedClanObject;
        internal JObject ToJObject();
        internal string FindPlayer(string partialNameOrID);
    }

    public static ConfigData configData;
    public class ConfigData
    {
        [JsonProperty(PropertyName = "Clan Options")]
        public ClanOptions Clans { get; set; }
        [JsonProperty(PropertyName = "Role Colors")]
        public ColorOptions Colors { get; set; }
        [JsonProperty(PropertyName = "Clan Tag Options")]
        public TagOptions Tags { get; set; }
        [JsonProperty(PropertyName = "Purge Options")]
        public PurgeOptions Purge { get; set; }
        [JsonProperty(PropertyName = "Settings")]
        public OtherOptions Options { get; set; }
        public class ClanOptions
        {
            [JsonProperty(PropertyName = "Member limit")]
            public int MemberLimit { get; set; }
            [JsonProperty(PropertyName = "Moderator limit")]
            public int ModeratorLimit { get; set; }
            [JsonProperty(PropertyName = "Alliance Options")]
            public AllianceOptions Alliance { get; set; }
            [JsonProperty(PropertyName = "Invite Options")]
            public InviteOptions Invites { get; set; }
            [JsonIgnore]
            public bool MemberFF { get; set; }
            [JsonIgnore]
            public bool OwnerFF { get; set; }
            public class AllianceOptions
            {
                [JsonProperty(PropertyName = "Enable clan alliances")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Alliance limit")]
                public int AllianceLimit { get; set; }
                [JsonIgnore]
                public bool AllyFF { get; set; }
                [JsonIgnore]
                public bool OwnerFF { get; set; }
            }

            public class InviteOptions
            {
                [JsonProperty(PropertyName = "Maximum allowed member invites at any given time")]
                public int MemberInviteLimit { get; set; }
                [JsonProperty(PropertyName = "Member invite expiry time (seconds)")]
                public int MemberInviteExpireTime { get; set; }
                [JsonProperty(PropertyName = "Maximum allowed alliance invites at any given time")]
                public int AllianceInviteLimit { get; set; }
                [JsonProperty(PropertyName = "Alliance invite expiry time (seconds)")]
                public int AllianceInviteExpireTime { get; set; }
            }

        }

        public class ColorOptions
        {
            [JsonProperty(PropertyName = "Clan owner color (hex)")]
            public string Owner { get; set; }
            [JsonProperty(PropertyName = "Clan moderator color (hex)")]
            public string Moderator { get; set; }
            [JsonProperty(PropertyName = "Clan member color (hex)")]
            public string Member { get; set; }
            [JsonProperty(PropertyName = "General text color (hex)")]
            public string TextColor { get; set; }
        }

        public class TagOptions
        {
            [JsonProperty(PropertyName = "Enable clan tags (requires BetterChat)")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Tag opening character")]
            public string TagOpen { get; set; }
            [JsonProperty(PropertyName = "Tag closing character")]
            public string TagClose { get; set; }
            [JsonProperty(PropertyName = "Tag color (hex)")]
            public string TagColor { get; set; }
            [JsonProperty(PropertyName = "Allow clan leaders to set custom tag colors (BetterChat only)")]
            public bool CustomColors { get; set; }
            [JsonProperty(PropertyName = "Tag size")]
            public int TagSize { get; set; }
            [JsonProperty(PropertyName = "Tag character limits")]
            public Range TagLength { get; set; }
        }

        public class PurgeOptions
        {
            [JsonProperty(PropertyName = "Enable clan purging")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Purge clans that havent been online for x amount of day")]
            public int OlderThanDays { get; set; }
            [JsonProperty(PropertyName = "List purged clans in console when purging")]
            public bool ListPurgedClans { get; set; }
        }

        public class OtherOptions
        {
            [JsonProperty(PropertyName = "Log clan and member changes")]
            public bool LogChanges { get; set; }
            [JsonProperty(PropertyName = "Data save interval (seconds)")]
            public int SaveInterval { get; set; }
        }

        public class Range
        {
            public int Minimum { get; set; }
            public int Maximum { get; set; }
            public Range();
            public Range(int minimum, int maximum);
        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    public StoredData storedData;
    private DynamicConfigFile data;
    private void TimedSaveData();
    private void SaveData();
    private void LoadData();
    private void RestoreClanData(Dictionary<string, OldClan> clanData);
    [Serializable]
    public class StoredData
    {
        public Hash<string, Clan> clans;
        public Hash<string, List<string>> playerInvites;
        [JsonIgnore]
        private Hash<string, string> playerLookup;
        public Clan FindClan(string tag);
        public Clan FindClanByID(ulong playerId);
        public Clan FindClanByID(string playerId);
        public Clan.Member FindMemberByID(ulong playerId);
        public Clan.Member FindMemberByID(string playerId);
        internal void RegisterPlayer(string playerId, string tag);
        internal void UnregisterPlayer(string playerId);
        internal void AddPlayerInvite(string target, string tag);
        internal void RevokePlayerInvite(string target, string tag);
        internal void OnInviteAccepted(string target, string tag);
        internal void OnInviteRejected(string target, string tag);
    }

    public class OldClan
    {
        public string clanTag;
        public string ownerID;
        public List<string> moderators;
        public Dictionary<string, string> members;
        public List<string> clanAlliances;
        public Dictionary<string, string> invitedPlayers;
        public List<string> invitedAllies;
        public List<string> pendingInvites;
    }

    private static string Message(string key, string playerId);
    private readonly Dictionary<string, string> Messages;
}

[Serializable]
public class Clan
{
    public string Tag { get; set; }
    public string Description { get; set; }
    public string OwnerID { get; set; }
    public double CreationTime { get; set; }
    public double LastOnlineTime { get; set; }
    public Hash<string, Member> ClanMembers { get; set; }
    public Hash<string, MemberInvite> MemberInvites { get; set; }
    public HashSet<string> Alliances { get; set; }
    public Hash<string, double> AllianceInvites { get; set; }
    public HashSet<string> IncomingAlliances { get; set; }
    public string TagColor { get; set; }
    [JsonIgnore]
    public int OnlineCount { get; set; }
    [JsonIgnore]
    public int ModeratorCount { get; set; }
    [JsonIgnore]
    public int MemberCount { get; set; }
    [JsonIgnore]
    public int MemberInviteCount { get; set; }
    [JsonIgnore]
    public int AllianceCount { get; set; }
    [JsonIgnore]
    public int AllianceInviteCount { get; set; }
    public Clan();
    public Clan(IPlayer player, string tag, string description);
    internal void OnPlayerConnected(IPlayer player);
    internal void OnPlayerDisconnected(IPlayer player);
    internal bool InvitePlayer(IPlayer inviter, IPlayer invitee);
    internal bool JoinClan(IPlayer player);
    internal bool LeaveClan(IPlayer player);
    internal bool KickMember(IPlayer player, string targetId);
    internal bool PromotePlayer(IPlayer promoter, string targetId);
    internal bool DemotePlayer(IPlayer demoter, string targetId);
    internal void DisbandClan();
    internal void OnClanDisbanded(string tag);
    internal void OnUnload();
    internal bool IsAlliedClan(string otherClan);
    internal void MarkDirty();
    internal void Broadcast(string message);
    internal void Broadcast(string key, object[] args);
    [JsonIgnore]
    private string cachedClanInfo;
    [JsonIgnore]
    private string membersOnline;
    internal void PrintClanInfo(IPlayer player);
    internal string GetMembersOnline();
    public bool IsOwner(ulong playerId);
    public bool IsOwner(string playerId);
    public bool IsModerator(ulong playerId);
    public bool IsModerator(string playerId);
    public bool IsCouncil(ulong playerId);
    public bool IsMember(ulong playerId);
    public bool IsMember(string playerId);
    public Member GetOwner();
    public string GetRoleColor(string Id);
    public string GetRoleColor(Member.MemberRole role);
    [Serializable]
    public class Member
    {
        [JsonIgnore]
        public IPlayer Player { get; set; }
        [JsonProperty("Name")]
        public string DisplayName { get; set; }
        public MemberRole Role { get; set; }
        [JsonIgnore]
        public bool IsConnected { get; set; }
        [JsonIgnore]
        public bool MemberFFEnabled { get; set; }
        [JsonIgnore]
        public bool AllyFFEnabled { get; set; }
        public Member();
        public Member(MemberRole role, string name);
    }

    [Serializable]
    public class MemberInvite
    {
        [JsonProperty("Name")]
        public string DisplayName { get; set; }
        public double ExpiryTime { get; set; }
        public MemberInvite();
        public MemberInvite(IPlayer player);
        public MemberInvite(string name);
    }

    [JsonIgnore]
    private JObject serializedClanObject;
    internal JObject ToJObject();
    internal string FindPlayer(string partialNameOrID);
}

[Serializable]
public class Member
{
    [JsonIgnore]
    public IPlayer Player { get; set; }
    [JsonProperty("Name")]
    public string DisplayName { get; set; }
    public MemberRole Role { get; set; }
    [JsonIgnore]
    public bool IsConnected { get; set; }
    [JsonIgnore]
    public bool MemberFFEnabled { get; set; }
    [JsonIgnore]
    public bool AllyFFEnabled { get; set; }
    public Member();
    public Member(MemberRole role, string name);
}

[Serializable]
public class MemberInvite
{
    [JsonProperty("Name")]
    public string DisplayName { get; set; }
    public double ExpiryTime { get; set; }
    public MemberInvite();
    public MemberInvite(IPlayer player);
    public MemberInvite(string name);
}

public class ConfigData
{
    [JsonProperty(PropertyName = "Clan Options")]
    public ClanOptions Clans { get; set; }
    [JsonProperty(PropertyName = "Role Colors")]
    public ColorOptions Colors { get; set; }
    [JsonProperty(PropertyName = "Clan Tag Options")]
    public TagOptions Tags { get; set; }
    [JsonProperty(PropertyName = "Purge Options")]
    public PurgeOptions Purge { get; set; }
    [JsonProperty(PropertyName = "Settings")]
    public OtherOptions Options { get; set; }
    public class ClanOptions
    {
        [JsonProperty(PropertyName = "Member limit")]
        public int MemberLimit { get; set; }
        [JsonProperty(PropertyName = "Moderator limit")]
        public int ModeratorLimit { get; set; }
        [JsonProperty(PropertyName = "Alliance Options")]
        public AllianceOptions Alliance { get; set; }
        [JsonProperty(PropertyName = "Invite Options")]
        public InviteOptions Invites { get; set; }
        [JsonIgnore]
        public bool MemberFF { get; set; }
        [JsonIgnore]
        public bool OwnerFF { get; set; }
        public class AllianceOptions
        {
            [JsonProperty(PropertyName = "Enable clan alliances")]
            public bool Enabled { get; set; }
            [JsonProperty(PropertyName = "Alliance limit")]
            public int AllianceLimit { get; set; }
            [JsonIgnore]
            public bool AllyFF { get; set; }
            [JsonIgnore]
            public bool OwnerFF { get; set; }
        }

        public class InviteOptions
        {
            [JsonProperty(PropertyName = "Maximum allowed member invites at any given time")]
            public int MemberInviteLimit { get; set; }
            [JsonProperty(PropertyName = "Member invite expiry time (seconds)")]
            public int MemberInviteExpireTime { get; set; }
            [JsonProperty(PropertyName = "Maximum allowed alliance invites at any given time")]
            public int AllianceInviteLimit { get; set; }
            [JsonProperty(PropertyName = "Alliance invite expiry time (seconds)")]
            public int AllianceInviteExpireTime { get; set; }
        }

    }

    public class ColorOptions
    {
        [JsonProperty(PropertyName = "Clan owner color (hex)")]
        public string Owner { get; set; }
        [JsonProperty(PropertyName = "Clan moderator color (hex)")]
        public string Moderator { get; set; }
        [JsonProperty(PropertyName = "Clan member color (hex)")]
        public string Member { get; set; }
        [JsonProperty(PropertyName = "General text color (hex)")]
        public string TextColor { get; set; }
    }

    public class TagOptions
    {
        [JsonProperty(PropertyName = "Enable clan tags (requires BetterChat)")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Tag opening character")]
        public string TagOpen { get; set; }
        [JsonProperty(PropertyName = "Tag closing character")]
        public string TagClose { get; set; }
        [JsonProperty(PropertyName = "Tag color (hex)")]
        public string TagColor { get; set; }
        [JsonProperty(PropertyName = "Allow clan leaders to set custom tag colors (BetterChat only)")]
        public bool CustomColors { get; set; }
        [JsonProperty(PropertyName = "Tag size")]
        public int TagSize { get; set; }
        [JsonProperty(PropertyName = "Tag character limits")]
        public Range TagLength { get; set; }
    }

    public class PurgeOptions
    {
        [JsonProperty(PropertyName = "Enable clan purging")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Purge clans that havent been online for x amount of day")]
        public int OlderThanDays { get; set; }
        [JsonProperty(PropertyName = "List purged clans in console when purging")]
        public bool ListPurgedClans { get; set; }
    }

    public class OtherOptions
    {
        [JsonProperty(PropertyName = "Log clan and member changes")]
        public bool LogChanges { get; set; }
        [JsonProperty(PropertyName = "Data save interval (seconds)")]
        public int SaveInterval { get; set; }
    }

    public class Range
    {
        public int Minimum { get; set; }
        public int Maximum { get; set; }
        public Range();
        public Range(int minimum, int maximum);
    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class ClanOptions
{
    [JsonProperty(PropertyName = "Member limit")]
    public int MemberLimit { get; set; }
    [JsonProperty(PropertyName = "Moderator limit")]
    public int ModeratorLimit { get; set; }
    [JsonProperty(PropertyName = "Alliance Options")]
    public AllianceOptions Alliance { get; set; }
    [JsonProperty(PropertyName = "Invite Options")]
    public InviteOptions Invites { get; set; }
    [JsonIgnore]
    public bool MemberFF { get; set; }
    [JsonIgnore]
    public bool OwnerFF { get; set; }
    public class AllianceOptions
    {
        [JsonProperty(PropertyName = "Enable clan alliances")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Alliance limit")]
        public int AllianceLimit { get; set; }
        [JsonIgnore]
        public bool AllyFF { get; set; }
        [JsonIgnore]
        public bool OwnerFF { get; set; }
    }

    public class InviteOptions
    {
        [JsonProperty(PropertyName = "Maximum allowed member invites at any given time")]
        public int MemberInviteLimit { get; set; }
        [JsonProperty(PropertyName = "Member invite expiry time (seconds)")]
        public int MemberInviteExpireTime { get; set; }
        [JsonProperty(PropertyName = "Maximum allowed alliance invites at any given time")]
        public int AllianceInviteLimit { get; set; }
        [JsonProperty(PropertyName = "Alliance invite expiry time (seconds)")]
        public int AllianceInviteExpireTime { get; set; }
    }

}

public class AllianceOptions
{
    [JsonProperty(PropertyName = "Enable clan alliances")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Alliance limit")]
    public int AllianceLimit { get; set; }
    [JsonIgnore]
    public bool AllyFF { get; set; }
    [JsonIgnore]
    public bool OwnerFF { get; set; }
}

public class InviteOptions
{
    [JsonProperty(PropertyName = "Maximum allowed member invites at any given time")]
    public int MemberInviteLimit { get; set; }
    [JsonProperty(PropertyName = "Member invite expiry time (seconds)")]
    public int MemberInviteExpireTime { get; set; }
    [JsonProperty(PropertyName = "Maximum allowed alliance invites at any given time")]
    public int AllianceInviteLimit { get; set; }
    [JsonProperty(PropertyName = "Alliance invite expiry time (seconds)")]
    public int AllianceInviteExpireTime { get; set; }
}

public class ColorOptions
{
    [JsonProperty(PropertyName = "Clan owner color (hex)")]
    public string Owner { get; set; }
    [JsonProperty(PropertyName = "Clan moderator color (hex)")]
    public string Moderator { get; set; }
    [JsonProperty(PropertyName = "Clan member color (hex)")]
    public string Member { get; set; }
    [JsonProperty(PropertyName = "General text color (hex)")]
    public string TextColor { get; set; }
}

public class TagOptions
{
    [JsonProperty(PropertyName = "Enable clan tags (requires BetterChat)")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Tag opening character")]
    public string TagOpen { get; set; }
    [JsonProperty(PropertyName = "Tag closing character")]
    public string TagClose { get; set; }
    [JsonProperty(PropertyName = "Tag color (hex)")]
    public string TagColor { get; set; }
    [JsonProperty(PropertyName = "Allow clan leaders to set custom tag colors (BetterChat only)")]
    public bool CustomColors { get; set; }
    [JsonProperty(PropertyName = "Tag size")]
    public int TagSize { get; set; }
    [JsonProperty(PropertyName = "Tag character limits")]
    public Range TagLength { get; set; }
}

public class PurgeOptions
{
    [JsonProperty(PropertyName = "Enable clan purging")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Purge clans that havent been online for x amount of day")]
    public int OlderThanDays { get; set; }
    [JsonProperty(PropertyName = "List purged clans in console when purging")]
    public bool ListPurgedClans { get; set; }
}

public class OtherOptions
{
    [JsonProperty(PropertyName = "Log clan and member changes")]
    public bool LogChanges { get; set; }
    [JsonProperty(PropertyName = "Data save interval (seconds)")]
    public int SaveInterval { get; set; }
}

public class Range
{
    public int Minimum { get; set; }
    public int Maximum { get; set; }
    public Range();
    public Range(int minimum, int maximum);
}

[Serializable]
public class StoredData
{
    public Hash<string, Clan> clans;
    public Hash<string, List<string>> playerInvites;
    [JsonIgnore]
    private Hash<string, string> playerLookup;
    public Clan FindClan(string tag);
    public Clan FindClanByID(ulong playerId);
    public Clan FindClanByID(string playerId);
    public Clan.Member FindMemberByID(ulong playerId);
    public Clan.Member FindMemberByID(string playerId);
    internal void RegisterPlayer(string playerId, string tag);
    internal void UnregisterPlayer(string playerId);
    internal void AddPlayerInvite(string target, string tag);
    internal void RevokePlayerInvite(string target, string tag);
    internal void OnInviteAccepted(string target, string tag);
    internal void OnInviteRejected(string target, string tag);
}

public class OldClan
{
    public string clanTag;
    public string ownerID;
    public List<string> moderators;
    public Dictionary<string, string> members;
    public List<string> clanAlliances;
    public Dictionary<string, string> invitedPlayers;
    public List<string> invitedAllies;
    public List<string> pendingInvites;
}

public static class StringExtensions
{
    public static bool Contains(string haystack, string needle, CompareOptions options);
}

public static class ListPool
{
    public static Dictionary<Type, object> directory;
    public static void CreateCollection(int capacity);
    public static ListCollection<T> FindCollection();
    public static List<T> Get();
    public static List<T> Get(int capacity);
    private static T GetList();
    public static void Free(List<T> list);
    private static void FreeList(T t);
    public static void ClearPool();
    public class ListCollection
    {
        public Stack<T> stack;
        private readonly int maximumSize;
        public bool HasSpace { get; set; }
        public ListCollection(int maximumSize);
    }

}

public class ListCollection
{
    public Stack<T> stack;
    private readonly int maximumSize;
    public bool HasSpace { get; set; }
    public ListCollection(int maximumSize);
}

ClansEx
public static class StringExtensions
{
    public static bool Contains(string haystack, string needle, CompareOptions options);
}

public static class ListPool
{
    public static Dictionary<Type, object> directory;
    public static void CreateCollection(int capacity);
    public static ListCollection<T> FindCollection();
    public static List<T> Get();
    public static List<T> Get(int capacity);
    private static T GetList();
    public static void Free(List<T> list);
    private static void FreeList(T t);
    public static void ClearPool();
    public class ListCollection
    {
        public Stack<T> stack;
        private readonly int maximumSize;
        public bool HasSpace { get; set; }
        public ListCollection(int maximumSize);
    }

}

public class ListCollection
{
    public Stack<T> stack;
    private readonly int maximumSize;
    public bool HasSpace { get; set; }
    public ListCollection(int maximumSize);
}


```

---

## ClanTags by klauz24 - Adds support for clan tags in chat plugins such as Better Chat

```csharp
using System;
using Oxide.Core;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Clan Tags", "klauz24", "1.0.2"), Description("Adds clan tag support for Better Chat")]
internal class ClanTags : CovalencePlugin
{
    [PluginReference]
    readonly Plugin BetterChat;
    readonly Plugin Clans;
    readonly Plugin HWClans;
    private Configuration _config;
    private Dictionary<string, string> _customClanTagColors;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Permission")]
        public string Permission;
        [JsonProperty(PropertyName = "Default clan tag color")]
        public string DefaultClanTagColor;
        [JsonProperty(PropertyName = "Formatting")]
        public string Formatting;
        [JsonProperty(PropertyName = "Incompatible plugins (Plugin name, Author)")]
        public Dictionary<string, string> IncompatiblePlugins;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    [Command("clancol")]
    private void ClanColorCommand(IPlayer player, string command, string[] args);
    private void Init();
    private void OnPluginLoaded();
    private bool IsIncompatiblePlugin(Plugin plugin);
    private string GetClanTag(IPlayer player);
    private string GetClanTagColor(string id);
    private string GetFormattedTag(string id, string clanTag);
    private string GetClansTag(string id);
    private string GetLang(IPlayer player, string str);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Permission")]
    public string Permission;
    [JsonProperty(PropertyName = "Default clan tag color")]
    public string DefaultClanTagColor;
    [JsonProperty(PropertyName = "Formatting")]
    public string Formatting;
    [JsonProperty(PropertyName = "Incompatible plugins (Plugin name, Author)")]
    public Dictionary<string, string> IncompatiblePlugins;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## ClanTeam by Chepzz - Adds clan members to the same team

```csharp
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using System.Collections.Generic;

Oxide.Plugins
[Info("Clan Team", "deivismac", "1.0.6")]
[Description("Adds clan members to the same team")]
 class ClanTeam : CovalencePlugin
{
    [PluginReference]
    private Plugin Clans;
    private readonly Dictionary<string, List<ulong>> clans;
    private bool CompareTeams(List<ulong> currentIds, List<ulong> clanIds);
    private void GenerateClanTeam(List<ulong> memberIds);
    private bool IsAnOwner(BasePlayer player);
    private string ClanTag(ulong memberId);
    private List<ulong> ClanPlayers(BasePlayer player);
    private List<ulong> ClanPlayersTag(string tag);
    private void OnClanCreate(string tag);
    private void OnClanUpdate(string tag);
    private void OnClanDestroy(string tag);
    private void OnPlayerSleepEnded(BasePlayer player);
}


```

---

## Claymore by wazzzup - Converts land mines to claymore anti-personnel mines

```csharp
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

Oxide.Plugins
[Info("Claymore", "wazzzup", "1.0.0")]
[Description("Converts land mines to Claymore antipersonnel mines")]
public class Claymore : RustPlugin
{
    [PluginReference]
     Plugin Friends;
    public static Claymore instance;
    protected override void LoadDefaultConfig();
    private float playerDetectRadius;
    private float minExplosionDistance;
    private float maxExplosionDistance;
    private bool configChanged;
     void LoadVariables();
    private object GetConfig(string dataValue, object defaultValue);
    public class ClaymoreTrigger : MonoBehaviour
    {
         ulong ownerID;
         void Awake();
        private void OnTriggerEnter(Collider col);
    }

     void Init();
     void OnServerInitialized();
    private void Unload();
     void OnEntityBuilt(Planner plan, GameObject obj);
     object OnTrapTrigger(BaseTrap trap, GameObject obj);
}

public class ClaymoreTrigger : MonoBehaviour
{
     ulong ownerID;
     void Awake();
    private void OnTriggerEnter(Collider col);
}


```

---

## ClearNight by Clearshot - Always bright nights

```csharp
using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Clear Night", "Clearshot", "2.3.6")]
[Description("Always bright nights")]
 class ClearNight : CovalencePlugin
{
    private PluginConfig _config;
    private EnvSync _envSync;
    private List<DateTime> _fullMoonDates;
    private Dictionary<string, string> _weatherSync;
    private DateTime _date;
    private Climate _climate;
    private int _current;
    private bool _playSound;
    private bool IsDay;
    private bool IsNight;
    [PluginReference("NightVision")]
     Plugin NightVisionRef;
     VersionNumber NightVisionMinVersion;
     void OnServerInitialized();
     void Unload();
     void OnDay();
     void OnSunset();
    private void UpdatePlayerDateTime(Connection connection, DateTime date);
    private void UpdatePlayerWeather(Dictionary<string, string> weatherVars);
    private void UpdateCelestials();
    private void SyncWeather();
    [Command("clearnight.debug")]
    private void DebugCommand(Core.Libraries.Covalence.IPlayer player, string command, string[] args);
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadConfig();
    private class PluginConfig
    {
        public string[] fullMoonDates;
        public Dictionary<string, string> weatherAtNight;
        public bool syncWeather;
        public bool randomizeDates;
        public bool freezeMoon;
        public bool playSoundAtSunset;
        public string sound;
        public float syncInterval;
    }

}

private class PluginConfig
{
    public string[] fullMoonDates;
    public Dictionary<string, string> weatherAtNight;
    public bool syncWeather;
    public bool randomizeDates;
    public bool freezeMoon;
    public bool playSoundAtSunset;
    public string sound;
    public float syncInterval;
}


```

---

## ClearRepair by Clearshot - Display insufficient resources required to repair an item, building or vehicle

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Clear Repair", "Clearshot", "1.3.0")]
[Description("Display insufficient resources required to repair with hammer or toolgun")]
 class ClearRepair : CovalencePlugin
{
    private PluginConfig _config;
    private Game.Rust.Libraries.Player _rustPlayer;
    private StringBuilder _sb;
    private readonly Dictionary<string, string> _shortPrefabNameToBuilding;
    private void SendChatMsg(BasePlayer pl, string msg, string prefix);
    private void Init();
    private void OnServerInitialized();
    private object OnStructureRepair(BaseCombatEntity ent, BasePlayer pl);
    private string GetEntityItemName(BaseCombatEntity ent, string UserID);
    private string GetItemName(ItemDefinition item, string UserID);
    [Command("clearrepair.generate_lang")]
    private void GenerateLangCommand(IPlayer player, string command, string[] args);
    [Command("clearrepair.check_lang")]
    private void CheckLangCommand(IPlayer player, string command, string[] args);
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadConfig();
    private class PluginConfig
    {
        public bool usePermission;
        public bool defaultChatNotification;
        public bool showShortname;
        public string chatIconID;
        public string itemFoundColor;
        public string itemNotFoundColor;
    }

}

private class PluginConfig
{
    public bool usePermission;
    public bool defaultChatNotification;
    public bool showShortname;
    public string chatIconID;
    public string itemFoundColor;
    public string itemNotFoundColor;
}


```

---

## ClearWeather by Rick6 - Always clear weather

```csharp
using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("Clear Weather", "Rick", "1.1.0")]
[Description("Always clear weather")]
public class ClearWeather : RustPlugin
{
     void OnServerInitialized();
     void Unload();
}


```

---

## ClosestMinicopter by GigaBit - A plugin that allows the player to quickly locate the closest minicopter.

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("ClosestMinicopter", "GigaBit", "1.3.2")]
[Description("Tells a player where the closest minicopter is and on what bearing")]
 class ClosestMinicopter : RustPlugin
{
    private Dictionary<string, RaycastHit> playerData;
    private Dictionary<string, DateTime> cooldowns;
    private float searchDistance;
    private int defaultCooldown;
    protected override void LoadDefaultConfig();
    private void Init();
    private void SetCooldown(BasePlayer player);
    private bool HasCooldown(BasePlayer player);
    private TimeSpan GetRemainingCooldown(BasePlayer player);
    private T GetConfigValue(string key, T defaultValue);
    [ChatCommand("cmini")]
    private void FindClosestMinicopter(BasePlayer player);
    private bool FindClosestMinicopter(BasePlayer player, RaycastHit closestMinicopter);
    private float GetBearing(Vector3 origin, Vector3 target);
}


```

---

## ClothedMurderers by Substrata - Puts the default clothing back on murderer NPCs

```csharp
using System;
using Oxide.Core;

Oxide.Plugins
[Info("Clothed Murderers", "Substrata", "1.0.1")]
[Description("Puts the default clothing back on murderer NPCs")]
 class ClothedMurderers : RustPlugin
{
     void OnEntitySpawned(NPCMurderer murderer);
}


```

---

## ClothingSlots by Flames - Available inventory slots depending on clothing worn

```csharp
using System;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using System.Collections.Generic;

Oxide.Plugins
[Info("ClothingSlots", "Jake_Rich", "1.1.4")]
[Description("Available Inventory Slots Depends On Clothing Worn")]
public partial class ClothingSlots : RustPlugin
{
    public static ClothingSlots _plugin;
    public static JSONFile<ConfigData> _settingsFile;
    public static ConfigData Settings { get; set; }
    public PlayerDataController<SlotPlayerData> PlayerData;
     void Init();
     void Loaded();
     void OnServerInitialized();
     void Unload();
     void OnPlayerConnected(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void OnPlayerRespawned(BasePlayer player);
     void OnPlayerDeath(BasePlayer player);
     object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainer, int targetSlot, int amount);
     void OnItemAddedToContainer(ItemContainer container, Item item);
     void OnItemRemovedFromContainer(ItemContainer container, Item item);
    public class ClothingSetting
    {
        [JsonProperty(PropertyName = "Available inventory slots (Main)")]
        public int Slots;
        public ClothingSetting();
        public ClothingSetting(ItemDefinition clothing);
    }

    public class ConfigData
    {
        [JsonProperty(PropertyName = "Available inventory slots (Belt)")]
        public int DefaultSlots;
        [JsonProperty(PropertyName = "Clothing settings (item shortname) and (available inventory slots)")]
        public Dictionary<string, ClothingSetting> Clothing;
        public void Setup();
    }

     bool ItemNotClothing(string shortname);
    public class SlotPlayerData : BasePlayerData
    {
        public void SetSlots(int slots);
        private void UpdateInventory(ItemContainer container);
        private void UpdateInventories();
        public void UpdateSlots();
    }

    public Dictionary<string, string> lang_en;
    public static string GetLangMessage(string key, BasePlayer player);
    public static string GetLangMessage(string key, ulong player);
    public static string GetLangMessage(string key, string player);
    public class BasePlayerData
    {
        [JsonIgnore]
        public BasePlayer Player { get; set; }
        public string userID { get; set; }
        public BasePlayerData();
        public BasePlayerData(BasePlayer player);
    }

    public class PlayerDataController
    {
        [JsonPropertyAttribute(Required = Required.Always)]
        private Dictionary<string, T> playerData { get; set; }
        private JSONFile<Dictionary<string, T>> _file;
        private Timer _timer;
        public IEnumerable<T> All { get; set; }
        public PlayerDataController();
        public PlayerDataController(string filename);
        public void Unload();
        public T Get(string identifer);
        public T Get(ulong userID);
        public T Get(BasePlayer player);
        public bool Has(ulong userID);
        public void Set(string userID, T data);
        public bool Remove(string userID);
        public void Update(T data);
    }

    public class JSONFile
    {
        private DynamicConfigFile _file;
        public string _name { get; set; }
        public Type Instance { get; set; }
        private ConfigLocation _location { get; set; }
        private string _path { get; set; }
        public JSONFile(string name, ConfigLocation location, string path, string extension);
        public virtual void Init();
        public virtual void Load();
        public virtual void Save();
        public virtual void Reload();
        private void Unload(Plugin sender, PluginManager manager);
    }

}

public class ClothingSetting
{
    [JsonProperty(PropertyName = "Available inventory slots (Main)")]
    public int Slots;
    public ClothingSetting();
    public ClothingSetting(ItemDefinition clothing);
}

public class ConfigData
{
    [JsonProperty(PropertyName = "Available inventory slots (Belt)")]
    public int DefaultSlots;
    [JsonProperty(PropertyName = "Clothing settings (item shortname) and (available inventory slots)")]
    public Dictionary<string, ClothingSetting> Clothing;
    public void Setup();
}

public class SlotPlayerData : BasePlayerData
{
    public void SetSlots(int slots);
    private void UpdateInventory(ItemContainer container);
    private void UpdateInventories();
    public void UpdateSlots();
}

public class BasePlayerData
{
    [JsonIgnore]
    public BasePlayer Player { get; set; }
    public string userID { get; set; }
    public BasePlayerData();
    public BasePlayerData(BasePlayer player);
}

public class PlayerDataController
{
    [JsonPropertyAttribute(Required = Required.Always)]
    private Dictionary<string, T> playerData { get; set; }
    private JSONFile<Dictionary<string, T>> _file;
    private Timer _timer;
    public IEnumerable<T> All { get; set; }
    public PlayerDataController();
    public PlayerDataController(string filename);
    public void Unload();
    public T Get(string identifer);
    public T Get(ulong userID);
    public T Get(BasePlayer player);
    public bool Has(ulong userID);
    public void Set(string userID, T data);
    public bool Remove(string userID);
    public void Update(T data);
}

public class JSONFile
{
    private DynamicConfigFile _file;
    public string _name { get; set; }
    public Type Instance { get; set; }
    private ConfigLocation _location { get; set; }
    private string _path { get; set; }
    public JSONFile(string name, ConfigLocation location, string path, string extension);
    public virtual void Init();
    public virtual void Load();
    public virtual void Save();
    public virtual void Reload();
    private void Unload(Plugin sender, PluginManager manager);
}


```

---

## CodeCommander by Hougan - Executes commands when a player interacting with code-locked objects (doors, etc)

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Code Commander", "Hougan", "0.0.3")]
[Description("Allow customize executable commands when interacting with code-lock")]
public class CodeCommander : RustPlugin
{
    private class CodeCommand
    {
        public class Condition
        {
            [JsonProperty("Action type (Open - on object interact with code, Unlock - on enter code)")]
            public string Action;
            [JsonProperty("If object type is door (true - only door, false - all objects)")]
            public bool OnlyOnDoor;
            [JsonProperty("If code is same with (None - to not check code)")]
            public string Code;
            [JsonProperty("If already authed players amount smaller then (-1 - to not check authed)")]
            public int MaxAuthed;
            [JsonProperty("If already authed players amount bigger then (-1 - to not check authed)")]
            public int MinAuthed;
        }

        [JsonProperty("Execute command (vars: %STEAMID%, %NAME%")]
        public string Command;
        [JsonProperty("Message on executing command (vars: %STEAMID%, %NAME%")]
        public string Message;
        [JsonProperty("Conditions to execute command")]
        public Condition Conditions;
    }

    private class Configuration
    {
        [JsonProperty("List of doors with commands")]
        public HashSet<CodeCommand> DoorCommands;
        public static Configuration Generate();
    }

    private static Configuration Settings;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void CanUseLockedEntity(BasePlayer player, BaseLock baseLock);
    private void CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode);
    private void OnCodeEntered(CodeLock codeLock, BasePlayer player, string code);
    private string PrepareString(BasePlayer player, string input);
}

private class CodeCommand
{
    public class Condition
    {
        [JsonProperty("Action type (Open - on object interact with code, Unlock - on enter code)")]
        public string Action;
        [JsonProperty("If object type is door (true - only door, false - all objects)")]
        public bool OnlyOnDoor;
        [JsonProperty("If code is same with (None - to not check code)")]
        public string Code;
        [JsonProperty("If already authed players amount smaller then (-1 - to not check authed)")]
        public int MaxAuthed;
        [JsonProperty("If already authed players amount bigger then (-1 - to not check authed)")]
        public int MinAuthed;
    }

    [JsonProperty("Execute command (vars: %STEAMID%, %NAME%")]
    public string Command;
    [JsonProperty("Message on executing command (vars: %STEAMID%, %NAME%")]
    public string Message;
    [JsonProperty("Conditions to execute command")]
    public Condition Conditions;
}

public class Condition
{
    [JsonProperty("Action type (Open - on object interact with code, Unlock - on enter code)")]
    public string Action;
    [JsonProperty("If object type is door (true - only door, false - all objects)")]
    public bool OnlyOnDoor;
    [JsonProperty("If code is same with (None - to not check code)")]
    public string Code;
    [JsonProperty("If already authed players amount smaller then (-1 - to not check authed)")]
    public int MaxAuthed;
    [JsonProperty("If already authed players amount bigger then (-1 - to not check authed)")]
    public int MinAuthed;
}

private class Configuration
{
    [JsonProperty("List of doors with commands")]
    public HashSet<CodeCommand> DoorCommands;
    public static Configuration Generate();
}


```

---

## CodeEntry by MrBlue - Makes code locks always require code input for entry

```csharp

Oxide.Plugins
[Info("Code Entry", "Wulf", "1.1.0")]
[Description("Makes code locks always require code input for entry")]
 class CodeEntry : CovalencePlugin
{
    private void CanUseLockedEntity(BasePlayer basePlayer, CodeLock codeLock);
    private void OnCodeEntered(CodeLock codeLock, BasePlayer basePlayer, string code);
}


```

---

## CodeLockAuthAPI by 2CHEVSKII - API for checking player authorization in building's code locks.

```csharp
using System.Linq;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("CodeLock Auth API", "2CHEVSKII", "0.1.1")]
[Description("API for checking player authorization to code locks in building")]
 class CodeLockAuthAPI : CovalencePlugin
{
     bool IsCodeLocksAuthorized(ulong userid, BuildingManager.Building building, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
     bool IsCodeLocksAuthorized(string userIDString, BuildingManager.Building building, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
     bool IsCodeLocksAuthorized(IPlayer player, BuildingManager.Building building, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
     bool IsCodeLocksAuthorized(BasePlayer player, BuildingManager.Building building, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
     bool IsCodeLocksAuthorized(ulong userid, BaseEntity entity, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
     bool IsCodeLocksAuthorized(string userIDString, BaseEntity entity, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
     bool IsCodeLocksAuthorized(IPlayer player, BaseEntity entity, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
     bool IsCodeLocksAuthorized(BasePlayer player, BaseEntity entity, bool acceptGuest, bool noLockBehaviour, bool acceptAny);
    public BuildingManager.Building GetEntityBuilding(BaseEntity entity);
    public bool Authed(ulong userid, BuildingManager.Building building, bool guest, bool noLock, bool any);
}


```

---

## CodeReset by  - Resets codelock code on the targeted door

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Code Reset", "Default", "1.0.3")]
[Description("Resets codelock code on the targeted door")]
 class CodeReset : RustPlugin
{
    public bool Changed;
    private readonly string usePerm;
    private string codecommand;
    private string setcodecommand;
    private float autodisable;
    private bool clearusers;
    private System.Random _random;
    private HashSet<ulong> _coding;
    static CodeReset _pluginInstance;
     SavedData _pluginData;
    private void CmdResetCode(BasePlayer player, string command, string[] args);
     void CmdSetCode(BasePlayer player, string command, string[] args);
     void Init();
     void Unload();
    private void OnPlayerInput(BasePlayer player, InputState input);
     void handleCodeLock(BasePlayer player);
    public string GenerateRandomNo();
    private void Log(string filename, string text);
    private static BasePlayer FindPlayer(ulong userId);
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
     Dictionary<string, string> Messages;
     class SavedData
    {
        [JsonProperty("PlayerNumbers")]
        public Dictionary<ulong, string> PlayerNumbers;
        public static SavedData Load();
        public void Save();
        public void addCode(ulong a, string b);
        public void removeCode(ulong a);
    }

}

 class SavedData
{
    [JsonProperty("PlayerNumbers")]
    public Dictionary<ulong, string> PlayerNumbers;
    public static SavedData Load();
    public void Save();
    public void addCode(ulong a, string b);
    public void removeCode(ulong a);
}


```

---

## CodeSync by 0x89A - Automatically allows players access to code locks based on tool cupboard lock/auth

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("Code Sync", "Wulf", "2.0.4")]
[Description("Automatically allows players access to code locks based on tool cupboard authorization")]
public class CodeSync : CovalencePlugin
{
    protected override void LoadDefaultMessages();
    private BuildingManager.Building GetBuilding(BaseEntity entity);
    private CodeLock GetCupboardLock(BuildingManager.Building building);
    private void CanChangeCode(BasePlayer basePlayer, CodeLock codeLock);
    private object CanUseLockedEntity(BasePlayer basePlayer, CodeLock codeLock);
    private void OnCodeEntered(CodeLock codeLock, BasePlayer basePlayer, string code);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(BasePlayer basePlayer, string langKey, object[] args);
}


```

---

## CoinFlip by Gachl - Try your luck by challenging players to a coin flip and betting on it using Economics

```csharp
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Coin Flip", "Gachl", "1.0.7")]
[Description("Try your luck by challenging players to a coin flip and betting on it using Economics")]
 class CoinFlip : CovalencePlugin
{
    private static Random RNG;
    private const string CONFIG_MINIMUM_AMOUNT;
    private const string CONFIG_TIMEOUT;
    private const string CONFIG_ANNOUNCE_EVERYBODY;
    private const string CONFIG_PREFIX;
    private const string PERMISSION_CREATE;
    private const string PERMISSION_JOIN;
    private int MinimumAmount { get; set; }
    private int Timeout { get; set; }
    private bool AnnounceEverybody { get; set; }
    private string Prefix { get; set; }
    [PluginReference]
    private Plugin Economics;
    private Dictionary<string, CoinFlipParams> coinFlips;
    protected override void LoadDefaultMessages();
    protected override void LoadDefaultConfig();
    private void Unload();
    private void sendLocalisedMessage(IPlayer player, Messages message, object[] args);
    private bool sendConditionalLocalisedMessage(IPlayer player, bool condition, Messages message, object[] args);
    private IPlayer findPlayer(IPlayer requester, string targetPlayerNameOrId);
    [Command("coinflip"), Permission(CoinFlip.PERMISSION_CREATE)]
    private void coinFlipChatCommand(IPlayer player, string command, string[] args);
    [Command("joinflip"), Permission(CoinFlip.PERMISSION_JOIN)]
    private void joinFlipChatCommand(IPlayer player, string command, string[] args);
    [Command("cancelflip"), Permission(CoinFlip.PERMISSION_CREATE)]
    private void cancelFlipChatCommand(IPlayer player, string command, string[] args);
    private void flip(IPlayer initiator, IPlayer player, CoinFlipParams coinFlipParams);
    private void cancelCoinFlip(string userID);
}


```

---

## ColliderCount by  - Use a chat/console command to check current collider count and the *estimated* days to wipe!

```csharp
using System;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Collider Count", "Cheeze", "0.0.4", ResourceId = 1306)]
 class ColliderCount : RustPlugin
{
    private const string ChatPrefix;
    private const string ChatPrefixColor;
    private readonly DateTime epoch;
    private DateTime wipeDate;
     IFormatProvider culture;
    protected override void LoadDefaultConfig();
     void Loaded();
    [ChatCommand("wipeinfo")]
    private void WipeInfoChat(BasePlayer player, string command, string[] args);
    [ConsoleCommand("wipeinfo")]
    private void WipeInfoConsole(ConsoleSystem.Arg arg);
    private int GetColliderCount();
    private int GetMaxColliders();
    private string GetColor1();
    private string GetColor2();
    private string GetTimeToWipe();
    private static void SendMessage(BasePlayer player, string message, object[] args);
    private long GetTimestamp(DateTime date);
}


```

---

## ColouredChat by collectvood - Allows players to change their name & message colour in chat

```csharp
using System;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using ConVar;
using UnityEngine;
using CompanionServer;
using Pool = Facepunch.Pool;
using Random = System.Random;

Oxide.Plugins
[Info("Coloured Chat", "collect_vood", "2.2.87")]
[Description("Allows players to change their name & message colour in chat")]
 class ColouredChat : CovalencePlugin
{
    [PluginReference]
    private Plugin BetterChat;
    private Plugin BetterChatMute;
    private Plugin ZoneManager;
    private readonly StringBuilder _sharedStringBuilder;
    private const string ColourRegex;
    private const string ChatFormat;
    protected override void LoadDefaultMessages();
    private Configuration _configuration;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Player Inactivity Data Removal (days)")]
        public int InactivityRemovalTime;
        [JsonProperty(PropertyName = "Block messages of muted players (requires BetterChatMute)")]
        public bool BlockChatMute;
        [JsonProperty(PropertyName = "Rainbow Colours")]
        public string[] RainbowColours;
        [JsonProperty(PropertyName = "Blocked Characters")]
        public string[] BlockedValues;
        [JsonProperty(PropertyName = "Name colour commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] NameColourCommands;
        [JsonProperty(PropertyName = "Name colour commands (Help)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] NameColoursCommands;
        [JsonProperty(PropertyName = "Name show colour permission")]
        public string NamePermShow;
        [JsonProperty(PropertyName = "Name use permission")]
        public string NamePermUse;
        [JsonProperty(PropertyName = "Name use gradient permission")]
        public string NamePermGradient;
        [JsonProperty(PropertyName = "Name default rainbow name permission")]
        public string NamePermRainbow;
        [JsonProperty(PropertyName = "Name bypass restrictions permission")]
        public string NamePermBypass;
        [JsonProperty(PropertyName = "Name set others colour permission")]
        public string NamePermSetOthers;
        [JsonProperty(PropertyName = "Name get random colour permission")]
        public string NamePermRandomColour;
        [JsonProperty(PropertyName = "Name use blacklist")]
        public bool NameUseBlacklist;
        [JsonProperty(PropertyName = "Name blocked colour hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> NameBlockColoursHex;
        [JsonProperty(PropertyName = "Name blocked colours range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ColourRange> NameBlacklistedRangeColoursHex;
        [JsonProperty(PropertyName = "Name use whitelist")]
        public bool NameUseWhitelist;
        [JsonProperty(PropertyName = "Name whitelisted colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> NameWhitelistedColoursHex;
        [JsonProperty(PropertyName = "Name whitelisted colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ColourRange> NameWhitelistedRangeColoursHex;
        [JsonProperty(PropertyName = "Message colour commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] MessageColourCommands;
        [JsonProperty(PropertyName = "Message colour commands (Help)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] MessageColoursCommands;
        [JsonProperty(PropertyName = "Message show colour permission")]
        public string MessagePermShow;
        [JsonProperty(PropertyName = "Message use permission")]
        public string MessagePermUse;
        [JsonProperty(PropertyName = "Message use gradient permission")]
        public string MessagePermGradient;
        [JsonProperty(PropertyName = "Message default rainbow name permission")]
        public string MessagePermRainbow;
        [JsonProperty(PropertyName = "Message bypass restrictions permission")]
        public string MessagePermBypass;
        [JsonProperty(PropertyName = "Message set others colour permission")]
        public string MessagePermSetOthers;
        [JsonProperty(PropertyName = "Message get random colour permission")]
        public string MessagePermRandomColour;
        [JsonProperty(PropertyName = "Message use blacklist")]
        public bool MessageUseBlacklist;
        [JsonProperty(PropertyName = "Message blocked colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> MessageBlockColoursHex;
        [JsonProperty(PropertyName = "Message blocked colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ColourRange> MessageBlacklistedRangeColoursHex;
        [JsonProperty(PropertyName = "Message use whitelist")]
        public bool MessageUseWhitelist;
        [JsonProperty(PropertyName = "Message whitelisted colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> MessageWhitelistedColoursHex;
        [JsonProperty(PropertyName = "Message whitelisted colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ColourRange> MessageWhitelistedRangeColoursHex;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    public class ColourRange
    {
        [JsonProperty(PropertyName = "From")]
        public string _from;
        [JsonProperty(PropertyName = "To")]
        public string _to;
        public ColourRange(string from, string to);
    }

    private Dictionary<string, CachePlayerData> cachedData;
    private StoredData storedData;
    private Dictionary<string, PlayerData> allColourData { get; set; }
    private class StoredData
    {
        public Dictionary<string, PlayerData> AllColourData { get; set; }
    }

    private class PlayerData
    {
        [JsonProperty("Name Colour")]
        public string NameColour;
        [JsonProperty("Name Gradient Args")]
        public string[] NameGradientArgs;
        [JsonProperty("Message Colour")]
        public string MessageColour;
        [JsonProperty("Message Gradient Args")]
        public string[] MessageGradientArgs;
        [JsonProperty("Last active")]
        public long LastActive;
        public PlayerData();
        public PlayerData(string nameColour, string[] nameGradientArgs, string messageColour, string[] messageGradientArgs);
        public PlayerData(bool isGroup);
    }

    private class CachePlayerData
    {
        public string NameColourGradient;
        public string PrimaryGroup;
        public CachePlayerData(string nameColourGradient, string primaryGroup);
    }

    private void SaveData();
    private void OnServerSave();
    private void Unload();
    private void ChangeNameColour(string key, string colour, string[] colourArgs);
    private void ChangeMessageColour(string key, string colour, string[] colourArgs);
    private void Init();
    private void OnUserConnected(IPlayer player);
    private void OnUserDisconnected(IPlayer player);
    private void OnUserNameUpdated(string id, string oldName, string newName);
    private void OnUserGroupAdded(string id, string groupName);
    private void OnUserGroupRemoved(string id, string groupName);
    private void OnGroupDeleted(string name);
    private void OnGroupPermissionGranted(string name, string perm);
    private void OnGroupPermissionRevoked(string name, string perm);
    private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    private Dictionary<string, object> OnBetterChat(Dictionary<string, object> dict);
     void cmdNameColour(IPlayer player, string cmd, string[] args);
     void cmdNameColours(IPlayer player, string cmd, string[] args);
     void cmdMessageColour(IPlayer player, string cmd, string[] args);
     void cmdMessageColours(IPlayer player, string cmd, string[] args);
    private bool BetterChatIns();
    private bool BetterChatMuteIns();
    private bool ZoneManagerIns();
    private bool IsValidColour(string input);
    private string GetMessage(string key, IPlayer player, string[] args);
    private bool HasNameShowPerm(IPlayer player);
    private bool HasNamePerm(IPlayer player);
    private bool HasNameRainbow(IPlayer player);
    private bool CanNameGradient(IPlayer player);
    private bool CanNameBypass(IPlayer player);
    private bool CanNameSetOthers(IPlayer player);
    private bool CanNameRandomColour(IPlayer player);
    private bool HasMessageShowPerm(IPlayer player);
    private bool HasMessagePerm(IPlayer player);
    private bool HasMessageRainbow(IPlayer player);
    private bool CanMessageGradient(IPlayer player);
    private bool CanMessageBypass(IPlayer player);
    private bool CanMessageSetOthers(IPlayer player);
    private bool CanMessageRandomColour(IPlayer player);
    private bool IsValidName(string input, IPlayer iPlayer);
    private bool IsValidMessage(string input, IPlayer iPlayer);
    private void SendMessage(ColouredChatMessage colouredChatMessage);
    private void ProcessColourCommand(IPlayer player, string cmd, string[] args, bool isMessage);
    private void ProcessColoursCommand(IPlayer player, string cmd, string[] args, bool isMessage);
    private string ProcessColourMessage(string message, string colour);
    private void ProcessColour(IPlayer player, IPlayer target, string colLower, string[] colours, bool isMessage, string groupName);
    private string ProcessGradient(string name, string[] colourArgs, bool isMessage, IPlayer iPlayer);
    private void GetAndAddGradients(Color start, Color end, int steps, List<Color> results);
    private readonly Random _random;
    private string GetRndColour();
    private string IsInvalidCharacter(string input);
    private void ClearUpData();
    private void ClearCache();
    private void ClearCache(string Id);
    private string GetCorrectLang(bool isGroup, bool isMessage, string key);
    private string GetPrimaryUserGroup(string Id);
    private ColouredChatMessage FromMessage(IPlayer player, Chat.ChatChannel channel, string message);
    private ColouredChatMessage GetColouredName(IPlayer player, PlayerData playerData);
    private string GetColouredMessage(IPlayer player, PlayerData playerData, string message);
    private bool IsInHexRange(string hexCode, string rangeHexCode1, string rangeHexCode2);
    private string API_GetNameColourHex(IPlayer player);
    private string API_GetColouredName(IPlayer player);
    private string API_GetColouredMessage(IPlayer player, string message);
    private string API_GetColouredChatMessage(IPlayer iPlayer, Chat.ChatChannel channel, string message);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Player Inactivity Data Removal (days)")]
    public int InactivityRemovalTime;
    [JsonProperty(PropertyName = "Block messages of muted players (requires BetterChatMute)")]
    public bool BlockChatMute;
    [JsonProperty(PropertyName = "Rainbow Colours")]
    public string[] RainbowColours;
    [JsonProperty(PropertyName = "Blocked Characters")]
    public string[] BlockedValues;
    [JsonProperty(PropertyName = "Name colour commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] NameColourCommands;
    [JsonProperty(PropertyName = "Name colour commands (Help)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] NameColoursCommands;
    [JsonProperty(PropertyName = "Name show colour permission")]
    public string NamePermShow;
    [JsonProperty(PropertyName = "Name use permission")]
    public string NamePermUse;
    [JsonProperty(PropertyName = "Name use gradient permission")]
    public string NamePermGradient;
    [JsonProperty(PropertyName = "Name default rainbow name permission")]
    public string NamePermRainbow;
    [JsonProperty(PropertyName = "Name bypass restrictions permission")]
    public string NamePermBypass;
    [JsonProperty(PropertyName = "Name set others colour permission")]
    public string NamePermSetOthers;
    [JsonProperty(PropertyName = "Name get random colour permission")]
    public string NamePermRandomColour;
    [JsonProperty(PropertyName = "Name use blacklist")]
    public bool NameUseBlacklist;
    [JsonProperty(PropertyName = "Name blocked colour hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> NameBlockColoursHex;
    [JsonProperty(PropertyName = "Name blocked colours range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ColourRange> NameBlacklistedRangeColoursHex;
    [JsonProperty(PropertyName = "Name use whitelist")]
    public bool NameUseWhitelist;
    [JsonProperty(PropertyName = "Name whitelisted colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> NameWhitelistedColoursHex;
    [JsonProperty(PropertyName = "Name whitelisted colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ColourRange> NameWhitelistedRangeColoursHex;
    [JsonProperty(PropertyName = "Message colour commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] MessageColourCommands;
    [JsonProperty(PropertyName = "Message colour commands (Help)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] MessageColoursCommands;
    [JsonProperty(PropertyName = "Message show colour permission")]
    public string MessagePermShow;
    [JsonProperty(PropertyName = "Message use permission")]
    public string MessagePermUse;
    [JsonProperty(PropertyName = "Message use gradient permission")]
    public string MessagePermGradient;
    [JsonProperty(PropertyName = "Message default rainbow name permission")]
    public string MessagePermRainbow;
    [JsonProperty(PropertyName = "Message bypass restrictions permission")]
    public string MessagePermBypass;
    [JsonProperty(PropertyName = "Message set others colour permission")]
    public string MessagePermSetOthers;
    [JsonProperty(PropertyName = "Message get random colour permission")]
    public string MessagePermRandomColour;
    [JsonProperty(PropertyName = "Message use blacklist")]
    public bool MessageUseBlacklist;
    [JsonProperty(PropertyName = "Message blocked colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> MessageBlockColoursHex;
    [JsonProperty(PropertyName = "Message blocked colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ColourRange> MessageBlacklistedRangeColoursHex;
    [JsonProperty(PropertyName = "Message use whitelist")]
    public bool MessageUseWhitelist;
    [JsonProperty(PropertyName = "Message whitelisted colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> MessageWhitelistedColoursHex;
    [JsonProperty(PropertyName = "Message whitelisted colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ColourRange> MessageWhitelistedRangeColoursHex;
}

public class ColourRange
{
    [JsonProperty(PropertyName = "From")]
    public string _from;
    [JsonProperty(PropertyName = "To")]
    public string _to;
    public ColourRange(string from, string to);
}

private class StoredData
{
    public Dictionary<string, PlayerData> AllColourData { get; set; }
}

private class PlayerData
{
    [JsonProperty("Name Colour")]
    public string NameColour;
    [JsonProperty("Name Gradient Args")]
    public string[] NameGradientArgs;
    [JsonProperty("Message Colour")]
    public string MessageColour;
    [JsonProperty("Message Gradient Args")]
    public string[] MessageGradientArgs;
    [JsonProperty("Last active")]
    public long LastActive;
    public PlayerData();
    public PlayerData(string nameColour, string[] nameGradientArgs, string messageColour, string[] messageGradientArgs);
    public PlayerData(bool isGroup);
}

private class CachePlayerData
{
    public string NameColourGradient;
    public string PrimaryGroup;
    public CachePlayerData(string nameColourGradient, string primaryGroup);
}


```

---

## CombatLogDb by mvrb - Translates CombatLog IDs into player names and lookup combat logs

```csharp
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Combat Log DB", "mvrb", "1.1.1")]
[Description("Translate CombatLog IDs into playernames and lookup players' combat logs.")]
 class CombatLogDb : RustPlugin
{
    private StoredData storedData;
    private string permissionUse;
    private void Init();
    private void OnServerInitialized();
    new private void LoadDefaultMessages();
    [ChatCommand("cid")]
    private void CmdCombatLogId(BasePlayer player, string cmd, string[] args);
    [ConsoleCommand("combatlogdb.get")]
    private void ConsoleCmdCombatLog(ConsoleSystem.Arg conArgs);
    [ChatCommand("combatlog")]
    private void ChatCmdCombatLog(BasePlayer player, string cmd, string[] args);
    private string GetCombatLog(ulong steamid, int count);
    private void OnNewSave(string s);
    private void OnPlayerConnected(BasePlayer player);
    private void LoadData();
    private void SaveData();
    private string GetNameFromId(string id);
    private string Lang(string key, string id, object[] args);
    private class StoredData
    {
        public Dictionary<uint, ulong> Players;
    }

}

private class StoredData
{
    public Dictionary<uint, ulong> Players;
}


```

---

## CombatLogger by RocketMyrr - Logs everything related to combat

```csharp
using Rust;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Combat Logger", "Tori1157/RocketMyrr", "2.0.3")]
[Description("Logs everything related to combat.")]
 class CombatLogger : RustPlugin
{
    private readonly List<string> DamageTypes;
    private void OnServerInitialized();
    private void Init();
    private void OnHealingItemUse(MedicalTool item, BasePlayer target);
    private void OnItemUse(Item item, int amountToUse);
    private void OnEntityTakeDamage(BaseEntity entity, HitInfo info);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private void OnPlayerWound(BasePlayer victimPlayer, HitInfo info);
    private void OnPlayerRespawned(BasePlayer player);
    private string CleanName(BasePlayer entity);
    private string CheckDamage(BasePlayer entity);
    private bool CheckDamageBL(BasePlayer entity);
    private string CheckSleeping(BasePlayer player);
    private string FireCheck(HitInfo info);
    private void Log(string text);
    private string GetDistance(BaseEntity entity, HitInfo info);
    private string GetDistanceAttacker(BaseEntity entity, BaseEntity info);
    private string GetBodypartName(HitInfo hitInfo);
    private string Lang(string key, object[] args);
    protected override void LoadDefaultMessages();
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Combat Logging Main")]
        public LoggingMain LogMain { get; set; }
        public class LoggingMain
        {
            [JsonProperty(PropertyName = "Log Combat Damage (Will Override All)")]
            public Options Damage { get; set; }
            [JsonProperty(PropertyName = "Log Combat Death (Will Override All)")]
            public Options Death { get; set; }
            [JsonProperty(PropertyName = "Log Healing Items")]
            public Options Healing { get; set; }
            [JsonProperty(PropertyName = "Log Player Downed")]
            public Options Wound { get; set; }
            [JsonProperty(PropertyName = "Show if Player is Sleeping in Log (Only for Attacking not Death)")]
            public bool Sleeping { get; set; }
            [JsonProperty(PropertyName = "Log Players Getting Attacked while Sleeping")]
            public bool LogSleeping { get; set; }
            [JsonProperty(PropertyName = "Show Body Part Hit")]
            public bool BodyPart { get; set; }
            [JsonProperty(PropertyName = "Log Respawns")]
            public Options Respawns { get; set; }
            public class Options
            {
                [JsonProperty(PropertyName = "Log to File")]
                public bool Log { get; set; }
                [JsonProperty(PropertyName = "Log to Console")]
                public bool Put { get; set; }
            }

        }

        [JsonProperty(PropertyName = "Combat Hurt Logging")]
        public HurtLogging HurtLog { get; set; }
        public class HurtLogging
        {
            [JsonProperty(PropertyName = "Log Player Attacking Player")]
            public Options PvP { get; set; }
            [JsonProperty(PropertyName = "Log Animal Attacking Player")]
            public Options AvP { get; set; }
            [JsonProperty(PropertyName = "Log NPC Attacking Player")]
            public Options NvP { get; set; }
            [JsonProperty(PropertyName = "Log Player Attacking NPC")]
            public Options PvN { get; set; }
            [JsonProperty(PropertyName = "Log Player Attacking Animal")]
            public Options PvA { get; set; }
            [JsonProperty(PropertyName = "Log Entity Attacking Player")]
            public Options EvP { get; set; }
            public class Options
            {
                [JsonProperty(PropertyName = "Log to File")]
                public bool Log { get; set; }
                [JsonProperty(PropertyName = "Log to Console")]
                public bool Put { get; set; }
            }

        }

        [JsonProperty(PropertyName = "Combat Death Logging")]
        public DeathLogging DeathLog { get; set; }
        public class DeathLogging
        {
            [JsonProperty(PropertyName = "Log Player killing Player")]
            public Options PvPD { get; set; }
            [JsonProperty(PropertyName = "Log Animal killing Player")]
            public Options AvPD { get; set; }
            [JsonProperty(PropertyName = "Log NPC killing Player")]
            public Options NvPD { get; set; }
            [JsonProperty(PropertyName = "Log Player killing NPC")]
            public Options PvND { get; set; }
            [JsonProperty(PropertyName = "Log Player killing Animal")]
            public Options PvAD { get; set; }
            [JsonProperty(PropertyName = "Log Entity killing Player")]
            public Options EvPD { get; set; }
            [JsonProperty(PropertyName = "Log Other Player Death")]
            public Options OtherDeath { get; set; }
            public class Options
            {
                [JsonProperty(PropertyName = "Log to File")]
                public bool Log { get; set; }
                [JsonProperty(PropertyName = "Log to Console")]
                public bool Put { get; set; }
            }

        }

        [JsonProperty(PropertyName = "Print Debug Info To Console (Dev)")]
        public bool Debug { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Combat Logging Main")]
    public LoggingMain LogMain { get; set; }
    public class LoggingMain
    {
        [JsonProperty(PropertyName = "Log Combat Damage (Will Override All)")]
        public Options Damage { get; set; }
        [JsonProperty(PropertyName = "Log Combat Death (Will Override All)")]
        public Options Death { get; set; }
        [JsonProperty(PropertyName = "Log Healing Items")]
        public Options Healing { get; set; }
        [JsonProperty(PropertyName = "Log Player Downed")]
        public Options Wound { get; set; }
        [JsonProperty(PropertyName = "Show if Player is Sleeping in Log (Only for Attacking not Death)")]
        public bool Sleeping { get; set; }
        [JsonProperty(PropertyName = "Log Players Getting Attacked while Sleeping")]
        public bool LogSleeping { get; set; }
        [JsonProperty(PropertyName = "Show Body Part Hit")]
        public bool BodyPart { get; set; }
        [JsonProperty(PropertyName = "Log Respawns")]
        public Options Respawns { get; set; }
        public class Options
        {
            [JsonProperty(PropertyName = "Log to File")]
            public bool Log { get; set; }
            [JsonProperty(PropertyName = "Log to Console")]
            public bool Put { get; set; }
        }

    }

    [JsonProperty(PropertyName = "Combat Hurt Logging")]
    public HurtLogging HurtLog { get; set; }
    public class HurtLogging
    {
        [JsonProperty(PropertyName = "Log Player Attacking Player")]
        public Options PvP { get; set; }
        [JsonProperty(PropertyName = "Log Animal Attacking Player")]
        public Options AvP { get; set; }
        [JsonProperty(PropertyName = "Log NPC Attacking Player")]
        public Options NvP { get; set; }
        [JsonProperty(PropertyName = "Log Player Attacking NPC")]
        public Options PvN { get; set; }
        [JsonProperty(PropertyName = "Log Player Attacking Animal")]
        public Options PvA { get; set; }
        [JsonProperty(PropertyName = "Log Entity Attacking Player")]
        public Options EvP { get; set; }
        public class Options
        {
            [JsonProperty(PropertyName = "Log to File")]
            public bool Log { get; set; }
            [JsonProperty(PropertyName = "Log to Console")]
            public bool Put { get; set; }
        }

    }

    [JsonProperty(PropertyName = "Combat Death Logging")]
    public DeathLogging DeathLog { get; set; }
    public class DeathLogging
    {
        [JsonProperty(PropertyName = "Log Player killing Player")]
        public Options PvPD { get; set; }
        [JsonProperty(PropertyName = "Log Animal killing Player")]
        public Options AvPD { get; set; }
        [JsonProperty(PropertyName = "Log NPC killing Player")]
        public Options NvPD { get; set; }
        [JsonProperty(PropertyName = "Log Player killing NPC")]
        public Options PvND { get; set; }
        [JsonProperty(PropertyName = "Log Player killing Animal")]
        public Options PvAD { get; set; }
        [JsonProperty(PropertyName = "Log Entity killing Player")]
        public Options EvPD { get; set; }
        [JsonProperty(PropertyName = "Log Other Player Death")]
        public Options OtherDeath { get; set; }
        public class Options
        {
            [JsonProperty(PropertyName = "Log to File")]
            public bool Log { get; set; }
            [JsonProperty(PropertyName = "Log to Console")]
            public bool Put { get; set; }
        }

    }

    [JsonProperty(PropertyName = "Print Debug Info To Console (Dev)")]
    public bool Debug { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}

public class LoggingMain
{
    [JsonProperty(PropertyName = "Log Combat Damage (Will Override All)")]
    public Options Damage { get; set; }
    [JsonProperty(PropertyName = "Log Combat Death (Will Override All)")]
    public Options Death { get; set; }
    [JsonProperty(PropertyName = "Log Healing Items")]
    public Options Healing { get; set; }
    [JsonProperty(PropertyName = "Log Player Downed")]
    public Options Wound { get; set; }
    [JsonProperty(PropertyName = "Show if Player is Sleeping in Log (Only for Attacking not Death)")]
    public bool Sleeping { get; set; }
    [JsonProperty(PropertyName = "Log Players Getting Attacked while Sleeping")]
    public bool LogSleeping { get; set; }
    [JsonProperty(PropertyName = "Show Body Part Hit")]
    public bool BodyPart { get; set; }
    [JsonProperty(PropertyName = "Log Respawns")]
    public Options Respawns { get; set; }
    public class Options
    {
        [JsonProperty(PropertyName = "Log to File")]
        public bool Log { get; set; }
        [JsonProperty(PropertyName = "Log to Console")]
        public bool Put { get; set; }
    }

}

public class Options
{
    [JsonProperty(PropertyName = "Log to File")]
    public bool Log { get; set; }
    [JsonProperty(PropertyName = "Log to Console")]
    public bool Put { get; set; }
}

public class HurtLogging
{
    [JsonProperty(PropertyName = "Log Player Attacking Player")]
    public Options PvP { get; set; }
    [JsonProperty(PropertyName = "Log Animal Attacking Player")]
    public Options AvP { get; set; }
    [JsonProperty(PropertyName = "Log NPC Attacking Player")]
    public Options NvP { get; set; }
    [JsonProperty(PropertyName = "Log Player Attacking NPC")]
    public Options PvN { get; set; }
    [JsonProperty(PropertyName = "Log Player Attacking Animal")]
    public Options PvA { get; set; }
    [JsonProperty(PropertyName = "Log Entity Attacking Player")]
    public Options EvP { get; set; }
    public class Options
    {
        [JsonProperty(PropertyName = "Log to File")]
        public bool Log { get; set; }
        [JsonProperty(PropertyName = "Log to Console")]
        public bool Put { get; set; }
    }

}

public class Options
{
    [JsonProperty(PropertyName = "Log to File")]
    public bool Log { get; set; }
    [JsonProperty(PropertyName = "Log to Console")]
    public bool Put { get; set; }
}

public class DeathLogging
{
    [JsonProperty(PropertyName = "Log Player killing Player")]
    public Options PvPD { get; set; }
    [JsonProperty(PropertyName = "Log Animal killing Player")]
    public Options AvPD { get; set; }
    [JsonProperty(PropertyName = "Log NPC killing Player")]
    public Options NvPD { get; set; }
    [JsonProperty(PropertyName = "Log Player killing NPC")]
    public Options PvND { get; set; }
    [JsonProperty(PropertyName = "Log Player killing Animal")]
    public Options PvAD { get; set; }
    [JsonProperty(PropertyName = "Log Entity killing Player")]
    public Options EvPD { get; set; }
    [JsonProperty(PropertyName = "Log Other Player Death")]
    public Options OtherDeath { get; set; }
    public class Options
    {
        [JsonProperty(PropertyName = "Log to File")]
        public bool Log { get; set; }
        [JsonProperty(PropertyName = "Log to Console")]
        public bool Put { get; set; }
    }

}

public class Options
{
    [JsonProperty(PropertyName = "Log to File")]
    public bool Log { get; set; }
    [JsonProperty(PropertyName = "Log to Console")]
    public bool Put { get; set; }
}


```

---

## CombatLogInfo by Pho3niX90 - All your servers combatlogs are streamed realtime to a simplistic screen

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;

Oxide.Plugins
[Info("CombatLog Info", "Pho3niX90", "1.0.13")]
[Description("Collects combat log entries, and submits them to SA for analysis.")]
 class CombatLogInfo : RustPlugin
{
    const bool debug;
    [PluginReference]
     Plugin ServerArmour;
     List<int> usedHashes;
     DateTime logsSince;
     int totalLogs;
     int totalLogsUploaded;
     int pendingGeneration;
     int failedUploads;
     void OnServerInitialized(bool first);
     void OnServerSave();
    private void GenCombatLog(BasePlayer forPlayer);
    [ConsoleCommand("clog.stats")]
     void printStats(ConsoleSystem.Arg arg);
    [ConsoleCommand("combatlog")]
     void printCombatLog(ConsoleSystem.Arg arg);
     string GetUsername(BasePlayer player, string id);
     void processingTask();
     object OnPlayerDeath(BasePlayer player, HitInfo info);
    private void UploadLogs(Dictionary<int, CLogEntry> logs);
    private void AddEntries(BasePlayer forPlayer, Queue<CombatLog.Event> cLog);
     void cleanupHashes();
    private CLogEntry CreateEntry(BasePlayer forPlayer, CombatLog.Event evt);
    private void LogDebug(string txt);
    static private PInfo UintFind(ulong netId);
    static public void RoundOrLimitFloat(float value);
    public class PInfo
    {
        public string Name;
        public string SteamId;
    }

    public class CLogEntry
    {
        public int EventHash;
        public float EventTime;
        public string AttackerSteamId;
        public string TargetSteamId;
        public string Weapon;
        public string Ammo;
        public string Area;
        public float Distance;
        public float HealthOld;
        public float HealthNew;
        public string EventInfo;
        public int ProjectileHits;
        public float ProjectileIntegrity;
        public float ProjectileTravelTime;
        public float ProjectileTrajectoryMismatch;
        public int Desync;
        public static CLogEntry from(BasePlayer forPlayer, CombatLog.Event evt);
    }

    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Advanced Logs")]
        public bool advancedLogs;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class PInfo
{
    public string Name;
    public string SteamId;
}

public class CLogEntry
{
    public int EventHash;
    public float EventTime;
    public string AttackerSteamId;
    public string TargetSteamId;
    public string Weapon;
    public string Ammo;
    public string Area;
    public float Distance;
    public float HealthOld;
    public float HealthNew;
    public string EventInfo;
    public int ProjectileHits;
    public float ProjectileIntegrity;
    public float ProjectileTravelTime;
    public float ProjectileTrajectoryMismatch;
    public int Desync;
    public static CLogEntry from(BasePlayer forPlayer, CombatLog.Event evt);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Advanced Logs")]
    public bool advancedLogs;
}


```

---

## CommandBlock by MrBlue - Blocks configured commands from being executed on the server

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Command Block", "Wulf", "0.5.3")]
[Description("Blocks configured commands from being executed on the server")]
public class CommandBlock : CovalencePlugin
{
    private Configuration config;
    private class Configuration
    {
        [JsonProperty("Block commands sent by players")]
        public bool BlockPlayers;
        [JsonProperty("Block commands sent by server")]
        public bool BlockServer;
        [JsonProperty("List of commands to block", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlockedCommands;
        [JsonProperty("Blocked commands (full or short commands)")]
        private List<string> BlockedCommandsOld { get; set; }
        [JsonProperty("Log blocked command attempts")]
        public bool LogAttempts;
        [JsonProperty("Log blocked command attempts (true/false)")]
        private bool LogAttemptsOld { get; set; }
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private const string permAdmin;
    private const string permBypass;
    private void Init();
    private bool IsValidSubCommand(string subCommand, IPlayer player);
    private void BlockCommand(IPlayer player, string command, string[] args);
    private bool IsCommandBlocked(string command, string[] args);
    private object OnServerCommand(string command, string[] args);
    private object OnUserCommand(IPlayer player, string command, string[] args);
    private void ShowHelp(IPlayer player, string command, string subCommand);
    private void SendHelpText(object obj);
    private void AddLocalizedCommand(string command);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string textOrLang, object[] args);
    private void MessageBlock(IPlayer player, Dictionary<string, string[]> textsOrLang);
}

private class Configuration
{
    [JsonProperty("Block commands sent by players")]
    public bool BlockPlayers;
    [JsonProperty("Block commands sent by server")]
    public bool BlockServer;
    [JsonProperty("List of commands to block", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlockedCommands;
    [JsonProperty("Blocked commands (full or short commands)")]
    private List<string> BlockedCommandsOld { get; set; }
    [JsonProperty("Log blocked command attempts")]
    public bool LogAttempts;
    [JsonProperty("Log blocked command attempts (true/false)")]
    private bool LogAttemptsOld { get; set; }
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## CommandRateLimiter by Calytic - Prevents command and key bind abuse

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("CommandRateLimiter", "Calytic", "0.1.2", ResourceId = 1812)]
public class CommandRateLimiter : CovalencePlugin
{
    private int KickAfter;
    private int CooldownMS;
    private int ClearRateCountSeconds;
    private bool LogExcessiveUsage;
    private bool SendPlayerMessage;
     Dictionary<string, DateTime> lastRun;
     Dictionary<string, Timer> rateTimer;
     Dictionary<string, int> rateCount;
     List<object> commandWhitelist;
    private Dictionary<string, Dictionary<string, int>> spamLog;
     void OnServerInitialized();
     List<object> GetDefaultWhitelist();
     void LoadMessages();
     void LoadDefaultConfig();
    private T GetConfig(string name, T defaultValue);
     object OnServerCommand(ConsoleSystem.Arg arg);
     void OnUserDisconnected(IPlayer player);
     string GetMsg(string key, object userID);
}


```

---

## CommandsOnly by varygoode - Only allow chat messages that are commands

```csharp
using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Commands Only", "varygoode", "1.0.2")]
[Description("Only allow chat messages that are commands")]
 class CommandsOnly : CovalencePlugin
{
    private const string PermBypass;
    private void Init();
    private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    private Dictionary<string, object> OnBetterChat(Dictionary<string, object> data);
    protected override void LoadDefaultMessages();
}


```

---

## CommandSplitter by birthdates - Split one client command into multiple

```csharp
using System;
using Network;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Command Splitter", "birthdates", "1.0.1")]
[Description("Split one client command into multiple")]
public class CommandSplitter : CovalencePlugin
{
    private const string UsePermission;
    private static void SendReply(Connection connection, string reply);
    private object OnClientCommand(Connection connection, string command);
    private void Init();
    private ConfigFile _config;
    public class ConfigFile
    {
        [JsonProperty("Command Separator")]
        public string Separator { get; set; }
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class ConfigFile
{
    [JsonProperty("Command Separator")]
    public string Separator { get; set; }
    public static ConfigFile DefaultConfig();
}


```

---

## CommitFeed by  - Displays new Rust commits to chat

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Commit Feed", "Jacob", "1.0.0")]
[Description("Displays new Rust commits to chat.")]
internal class CommitFeed : RustPlugin
{
    private const string Url;
    private Commit? _latestCommit;
    private IEnumerable<Commit> ParseCommits(string xml);
    private void UpdateLatestCommit(IEnumerable<Commit> commits);
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
}


```

---

## CommunityVigilance by PinguinNordpol - Start a vote to kick someone from the server

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Community Vigilance", "PinguinNordpol", "0.2.2")]
[Description("Adds the possibility to start votes to kick players from the server")]
 class CommunityVigilance : CovalencePlugin
{
    private List<string> ReceivedVotes;
    private bool IsVoteOpen;
    private IPlayer TargetPlayer;
    private bool DisplayCountEveryVote;
    private int TimeRemaining;
    private int CooldownTime;
    private int RequiredVotes;
    private string TimeRemMSG;
    private Timer VotingTimer;
    private Timer CountTimer;
    private Timer CooldownTimer;
     void Init();
     void Loaded();
     void OnServerInitialized();
     void Unload();
     void OnUserDisconnected(IPlayer player);
    private void OpenVote(IPlayer player, string playerNameOrId);
    private void VoteTimer();
    private void ShowCountTimer();
    private void VoteEnd(bool success, VoteEndReason reason);
    private bool AlreadyVoted(string player);
    private IPlayer FindPlayer(IPlayer player, string playerNameOrId);
    private uint GetPlayerAuthlevel(IPlayer player);
    private string ColorizeText(string msg);
    private void cmdVoteKick(IPlayer player, string command, string[] args);
    private void cmdVoteKickCancel(IPlayer player, string command, string[] args);
    private ConfigData configData;
     class Messaging
    {
        public int DisplayCountEvery { get; set; }
        public string MainColor { get; set; }
        public string MsgColor { get; set; }
        public string ErrColor { get; set; }
    }

     class Timers
    {
        public int VoteOpenSecs { get; set; }
        public int VoteCooldownSecs { get; set; }
    }

     class Options
    {
        public float RequiredVotePercentage { get; set; }
        public int RequiredMinPlayers { get; set; }
    }

     class Commands
    {
        public string CommandVoteKick { get; set; }
        public string CommandVoteKickCancel { get; set; }
    }

     class ConfigData
    {
        public Messaging Messaging { get; set; }
        public Timers Timers { get; set; }
        public Options Options { get; set; }
        public Commands Commands { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
    private string GetMSG(string key, string userid);
     Dictionary<string, string> Messages;
}

 class Messaging
{
    public int DisplayCountEvery { get; set; }
    public string MainColor { get; set; }
    public string MsgColor { get; set; }
    public string ErrColor { get; set; }
}

 class Timers
{
    public int VoteOpenSecs { get; set; }
    public int VoteCooldownSecs { get; set; }
}

 class Options
{
    public float RequiredVotePercentage { get; set; }
    public int RequiredMinPlayers { get; set; }
}

 class Commands
{
    public string CommandVoteKick { get; set; }
    public string CommandVoteKickCancel { get; set; }
}

 class ConfigData
{
    public Messaging Messaging { get; set; }
    public Timers Timers { get; set; }
    public Options Options { get; set; }
    public Commands Commands { get; set; }
}


```

---

## CompassGUI by  - Shows which direction the player is facing with a GUI

```csharp
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Linq;
using System.Data;
using Oxide.Core;

Oxide.Plugins
[Info("Compass GUI", "PaiN", "1.2.1", ResourceId = 1231)]
[Description("This plugin shows which direction is the player facing in a GUI.")]
public class CompassGUI : RustPlugin
{
     List<BasePlayer> gui;
    private Timer _timer;
    private bool Changed;
    private bool displaycoords;
    private string xmin;
    private string xmax;
    private string ymin;
    private string ymax;
    private bool enableonconnect;
     void Loaded();
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
    static string Title;
     string json;
     string GetEyesPosition(BasePlayer player);
     void Test();
    [ChatCommand("showpos")]
     void cmdCopyPos(BasePlayer player, string cmd, string[] args);
    [ChatCommand("compass")]
     void cmdCompass(BasePlayer player, string cmd, string[] args);
     void OnPlayerInit(BasePlayer player);
     void Unload();
     void OnPlayerDisconnected(BasePlayer player);
}


```

---

## ComponentBlocker by Calytic - Removes items or entities entirely from the game

```csharp
using System;
using System.Text;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Component Blocker", "Calytic", "0.1.9")]
 class ComponentBlocker : RustPlugin
{
    [PluginReference]
     Plugin RaidableBases;
     List<string> blockList;
     List<string> blockCache;
     bool enabled;
     bool craftRefund;
    private bool sendMessages;
    private Dictionary<string, string> messages;
    private List<string> texts;
     void OnServerInitialized();
     void LoadData();
    protected override void LoadDefaultConfig();
    protected void ReloadConfig();
    private void SendHelpText(BasePlayer player);
    [ChatCommand("listinv")]
    private void cmdListInv(BasePlayer player, string command, string[] args);
    [ChatCommand("clearblocklist")]
    private void cmdClearBlockList(BasePlayer player, string command, string[] args);
    [ChatCommand("blocklist")]
    private void cmdBlockList(BasePlayer player, string command, string[] args);
    [ChatCommand("blocker")]
    private void cmdBlock(BasePlayer player, string command, string[] args);
    [ConsoleCommand("blocker")]
     void ccBlock(ConsoleSystem.Arg arg);
     void AddBlock(string name);
     void RemoveBlock(string name);
     bool IsBlocking(string name);
     T GetConfig(string key, T defaultValue);
     void OnPlayerConnected(BasePlayer player);
     object OnItemCraft(ItemCraftTask task, BasePlayer player, Item fromTempBlueprint);
    private void RefundIngredients(ItemBlueprint bp, BasePlayer player, int amount);
     void OnEntitySpawned(BaseNetworkable networkable);
     void OnItemAddedToContainer(ItemContainer container, Item item);
     void OnItemDeployed(Deployer deployer, BaseEntity entity);
     object OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player);
     void OnGrowableGather(GrowableEntity growable, Item item, BasePlayer player);
     void OnQuarryGather(MiningQuarry quarry, Item item);
    private bool CheckItem(Item item);
    private bool CheckItem(ItemDefinition info);
    private bool CheckNetworkable(BaseNetworkable networkable);
     object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade);
    private bool isBlocked(string[] names);
    private bool EventTerritory(Vector3 pos);
}


```

---

## CompostStacks by Tacman - Toggles full stacks being composted inside of a composter

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using System.IO;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Security;
using Newtonsoft.Json;
using System;

Oxide.Plugins
[Info("Compost Stacks", "Tacman", "2.1.1")]
[Description("Toggle the CompostEntireStack boolean on load and for new Composter entities, which will compost entire stacks of all compostable items.")]
public class CompostStacks : RustPlugin
{
    private bool CompostEntireStack;
    private const string permissionName;
    private Dictionary<ulong, bool> composterData;
    private const string dataFileName;
    private void OnServerInitialized();
    private void OnEntitySpawned(BaseNetworkable entity);
    private void UpdateComposters();
    private void OnUserPermissionGranted(string id, string permission);
    private void OnUserPermissionRevoked(string id, string permission);
    private void OnGroupPermissionGranted(string id, string permission);
    private void OnGroupPermissionRevoked(string id, string permission);
    private bool HasPermission(IPlayer player);
    static Configuration config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Debug")]
        public bool debug;
        public static Configuration DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class Configuration
{
    [JsonProperty(PropertyName = "Debug")]
    public bool debug;
    public static Configuration DefaultConfig();
}


```

---

## CompoundOptions by FastBurst - Configure Compound & Bandit Camp monuments options and vending machines located there

```csharp
using System.Collections.Generic;
using System.Linq;
using Rust.Ai;
using Oxide.Core;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Compound Options", "FastBurst", "1.2.6")]
[Description("Compound monument options")]
 class CompoundOptions : RustPlugin
{
    private bool dataChanged;
    private StorageData data;
    private StorageData defaultOrders;
    private void Loaded();
    private void Unload();
    private void Init();
    private void OnServerInitialized();
    private void OnEntityEnter(TriggerBase trigger, BaseEntity entity);
    private void OnEntitySpawned(BaseNetworkable entity);
    private void KillNPCPlayer(NPCPlayer npcPlayer);
    private void ProcessNPCTurret(NPCAutoTurret npcAutoTurret);
    private void AddVendingOrders(NPCVendingMachine vending, bool def);
    private void UpdateVending(NPCVendingMachine vending);
    private NPCVendingOrder.Entry[] GetDefaultOrders(NPCVendingMachine vending);
    private NPCVendingOrder.Entry[] GetNewOrders(NPCVendingMachine vending);
    [ChatCommand("compreset")]
    private void cmdCompReset(BasePlayer player, string command, string[] args);
    [ConsoleCommand("compreset")]
    private void ccmdCompReset(ConsoleSystem.Arg arg);
    private class StorageData
    {
        public Dictionary<string, Order[]> VendingMachinesOrders { get; set; }
    }

    private class Order
    {
        public string _comment;
        public int sellId;
        public int sellAmount;
        public bool sellAsBP;
        public int currencyId;
        public int currencyAmount;
        public bool currencyAsBP;
        public int weight;
        public int refillAmount;
        public float refillDelay;
    }

    private void SaveData();
    private static ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "General Settings")]
        public GeneralSettings General { get; set; }
        public class GeneralSettings
        {
            [JsonProperty(PropertyName = "Allow console status outputs")]
            public bool allowConsoleOutput { get; set; }
            [JsonProperty(PropertyName = "Allow custom sell list for Compound vending machines (see in data)")]
            public bool allowCustomCompoundVendingMachines { get; set; }
            [JsonProperty(PropertyName = "Disallow Bandit NPC")]
            public bool disallowBanditNPC { get; set; }
            [JsonProperty(PropertyName = "Disallow Compound NPC")]
            public bool disallowCompoundNPC { get; set; }
            [JsonProperty(PropertyName = "Disable Compound Turrets")]
            public bool disableCompoundTurrets { get; set; }
            [JsonProperty(PropertyName = "Disable Compound SafeZone trigger")]
            public bool disableCompoundTrigger { get; set; }
            [JsonProperty(PropertyName = "Disable Compound Vending Machines")]
            public bool disableCompoundVendingMachines { get; set; }
        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
}

private class StorageData
{
    public Dictionary<string, Order[]> VendingMachinesOrders { get; set; }
}

private class Order
{
    public string _comment;
    public int sellId;
    public int sellAmount;
    public bool sellAsBP;
    public int currencyId;
    public int currencyAmount;
    public bool currencyAsBP;
    public int weight;
    public int refillAmount;
    public float refillDelay;
}

 class ConfigData
{
    [JsonProperty(PropertyName = "General Settings")]
    public GeneralSettings General { get; set; }
    public class GeneralSettings
    {
        [JsonProperty(PropertyName = "Allow console status outputs")]
        public bool allowConsoleOutput { get; set; }
        [JsonProperty(PropertyName = "Allow custom sell list for Compound vending machines (see in data)")]
        public bool allowCustomCompoundVendingMachines { get; set; }
        [JsonProperty(PropertyName = "Disallow Bandit NPC")]
        public bool disallowBanditNPC { get; set; }
        [JsonProperty(PropertyName = "Disallow Compound NPC")]
        public bool disallowCompoundNPC { get; set; }
        [JsonProperty(PropertyName = "Disable Compound Turrets")]
        public bool disableCompoundTurrets { get; set; }
        [JsonProperty(PropertyName = "Disable Compound SafeZone trigger")]
        public bool disableCompoundTrigger { get; set; }
        [JsonProperty(PropertyName = "Disable Compound Vending Machines")]
        public bool disableCompoundVendingMachines { get; set; }
    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class GeneralSettings
{
    [JsonProperty(PropertyName = "Allow console status outputs")]
    public bool allowConsoleOutput { get; set; }
    [JsonProperty(PropertyName = "Allow custom sell list for Compound vending machines (see in data)")]
    public bool allowCustomCompoundVendingMachines { get; set; }
    [JsonProperty(PropertyName = "Disallow Bandit NPC")]
    public bool disallowBanditNPC { get; set; }
    [JsonProperty(PropertyName = "Disallow Compound NPC")]
    public bool disallowCompoundNPC { get; set; }
    [JsonProperty(PropertyName = "Disable Compound Turrets")]
    public bool disableCompoundTurrets { get; set; }
    [JsonProperty(PropertyName = "Disable Compound SafeZone trigger")]
    public bool disableCompoundTrigger { get; set; }
    [JsonProperty(PropertyName = "Disable Compound Vending Machines")]
    public bool disableCompoundVendingMachines { get; set; }
}


```

---

## CompoundTeleport by kwamaking - Teleport through the death screen to Bandit Camp, Outpost, or any configured monument.

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Compound Teleport", "kwamaking", "2.0.2")]
[Description("Teleport through the death screen to Bandit Camp, Outpost, or any configured monument.")]
 class CompoundTeleport : RustPlugin
{
    private const string UsePermission;
    private const string OutPostPrefab;
    private const string BanditTownPrefab;
    private const int TeleportLayer;
    private const int TeleportRadius;
    private const int Timer;
    private const int MaxAttemptsToFindTeleportLocation;
    private const float MaxDistance;
    private const float MaxDistanceFromGround;
    private readonly string[] ValidTeleportColliders;
    private Dictionary<ulong, List<SleepingBag>> playerTeleportLocations;
    private CompoundTeleportConfiguration pluginConfiguration;
    private void Init();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnPlayerRespawn(BasePlayer player, SleepingBag bag);
     void Unload();
    private void RemoveHostility(BasePlayer player);
    private void CreateTeleportLocationsForActivePlayers();
    private void CreateTeleportLocations(BasePlayer player);
    private void DestroyTeleportLocations(BasePlayer player);
    private Vector3 FindMonumentPosition(string monumentPrefab);
    private Vector3 AttemptToFindTeleportPosition(BasePlayer player, Vector3 monumentLocation);
    private SleepingBag CreateTeleportLocation(BasePlayer player, TeleportLocation teleportLocation, Vector3 position);
    private class CompoundTeleportConfiguration
    {
        [JsonProperty("removeHostility")]
        public bool removeHostility { get; set; }
        [JsonProperty("teleportLocations")]
        public List<TeleportLocation> teleportLocations { get; set; }
        public static CompoundTeleportConfiguration BuildDefaultConfiguration();
    }

    private class TeleportLocation
    {
        [JsonProperty("name")]
        public string name { get; set; }
        [JsonProperty("timer")]
        public int timer { get; set; }
        [JsonProperty("monumentPrefab")]
        public string monumentPrefab { get; set; }
        [JsonProperty("enabled")]
        public bool enabled { get; set; }
        public static List<TeleportLocation> BuildDefaultTeleportLocations();
    }

    private bool umodversion();
}

private class CompoundTeleportConfiguration
{
    [JsonProperty("removeHostility")]
    public bool removeHostility { get; set; }
    [JsonProperty("teleportLocations")]
    public List<TeleportLocation> teleportLocations { get; set; }
    public static CompoundTeleportConfiguration BuildDefaultConfiguration();
}

private class TeleportLocation
{
    [JsonProperty("name")]
    public string name { get; set; }
    [JsonProperty("timer")]
    public int timer { get; set; }
    [JsonProperty("monumentPrefab")]
    public string monumentPrefab { get; set; }
    [JsonProperty("enabled")]
    public bool enabled { get; set; }
    public static List<TeleportLocation> BuildDefaultTeleportLocations();
}


```

---

## ComputersPlus by mr01sam - Adds a GUI with apps to the computer station to extend its functionality

```csharp
using Oxide.Core.Plugins;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Text;
using Oxide.Core.Libraries;
using Oxide.Game.Rust.Cui;
using System.Linq;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("Computers Plus", "mr01sam", "1.0.6")]
[Description("Adds new functionality to the computer stations.")]
partial class ComputersPlus : CovalencePlugin
{
    private static ComputersPlus PLUGIN;
    [PluginReference]
    private Plugin ImageLibrary;
    private static Dictionary<string, string> Language;
    private static Dictionary<string, ComputersPlusApp> RegisteredApps;
    private static Dictionary<string, string> AppsInUse;
    internal EZUI.Component AppComponent { get; set; }
    private bool Success { get; set; }
    private const string PermissionAdmin;
     void CreateApps();
     void Init();
     void Unload();
     void OnServerSave();
     void OnServerInitialized(bool initial);
     void UnsubscribeAll();
     void SubscribeAll();
     void NullifyStaticVariables();
     void CleanupUI();
     void InitApps();
     void SaveApps();
     void UnloadApps();
     void OnEntityMounted(ComputerStation entity, BasePlayer basePlayer);
     void OnEntityDismounted(ComputerStation entity, BasePlayer basePlayer);
     object CanDismountEntity(BasePlayer player, ComputerStation computerStation);
     object OnBookmarkControl(ComputerStation computerStation, BasePlayer basePlayer, string bookmarkName, IRemoteControllable remoteControllable);
     object OnBookmarkControlEnd(ComputerStation computerStation, BasePlayer basePlayer, BaseEntity controlledEntity);
     void RegisterApp(ComputersPlusApp newApp);
     void LoadImages();
     bool IsUsingComputer(BasePlayer basePlayer);
     bool IsUsingApp(BasePlayer player, string appId);
     bool UserHasAnyPermission(BasePlayer basePlayer);
    private readonly string BASE_UI_ID;
    private readonly string HOME_UI_ID;
    private readonly string APP_UI_ID;
     void CloseUi(BasePlayer basePlayer);
     void CloseHomeUi(BasePlayer basePlayer);
     void CloseAppUi(BasePlayer basePlayer);
     EZUI.Component CreateAppGrid(EZUI.Component home, BasePlayer basePlayer);
     void ShowHomeUi(BasePlayer basePlayer);
     void ShowAppUi(BasePlayer basePlayer, ComputersPlusApp app);
    [Command("app.launch")]
    private void cmd_app_launch(IPlayer player, string command, string[] args);
    [Command("app.close")]
    private void cmd_app_close(IPlayer player, string command, string[] args);
    [Command("pc.leave")]
    private void cmd_pc_leave(IPlayer player, string command, string[] args);
}

Oxide.Plugins
partial class ComputersPlus
{
     class ComputersPlusApp
    {
        private string _id;
        private string _name;
        private string _iconUrl;
        private string _permission;
        public ComputersPlusApp(string id, string name, string iconUrl, string permission);
        public string Id { get; set; }
        public string Name { get; set; }
        public string IconUrl { get; set; }
        public string Permission { get; set; }
        public string LaunchMethod { get; set; }
        public string SaveMethod { get; set; }
        public string CreateMethod { get; set; }
        public string InitMethod { get; set; }
        public string UnloadMethod { get; set; }
        public override string ToString();
    }

}

 class ComputersPlusApp
{
    private string _id;
    private string _name;
    private string _iconUrl;
    private string _permission;
    public ComputersPlusApp(string id, string name, string iconUrl, string permission);
    public string Id { get; set; }
    public string Name { get; set; }
    public string IconUrl { get; set; }
    public string Permission { get; set; }
    public string LaunchMethod { get; set; }
    public string SaveMethod { get; set; }
    public string CreateMethod { get; set; }
    public string InitMethod { get; set; }
    public string UnloadMethod { get; set; }
    public override string ToString();
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    private Configuration config;
    private partial class Configuration
    {
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
}

private partial class Configuration
{
}

Oxide.Plugins
partial class ComputersPlus
{
     class DoubleDictionary
    {
        private Dictionary<TkeyA, Dictionary<TkeyB, Tvalue>> a2b;
        private Dictionary<TkeyB, Dictionary<TkeyA, Tvalue>> b2a;
        public DoubleDictionary();
        public void Set(TkeyA keyA, TkeyB keyB, Tvalue value);
        public Tvalue Get(TkeyA keyA, TkeyB keyB);
        public Dictionary<TkeyB, Tvalue> GetA(TkeyA keyA);
        public Dictionary<TkeyA, Tvalue> GetB(TkeyB keyB);
        public bool ContainsKey(TkeyA keyA, TkeyB keyB);
        public bool ContainsKey(TkeyA keyA);
        public void Delete(TkeyA keyA, TkeyB keyB);
        public void DeleteA(TkeyA keyA);
        public void DeleteB(TkeyB keyB);
        public int Count(TkeyA keyA);
    }

}

 class DoubleDictionary
{
    private Dictionary<TkeyA, Dictionary<TkeyB, Tvalue>> a2b;
    private Dictionary<TkeyB, Dictionary<TkeyA, Tvalue>> b2a;
    public DoubleDictionary();
    public void Set(TkeyA keyA, TkeyB keyB, Tvalue value);
    public Tvalue Get(TkeyA keyA, TkeyB keyB);
    public Dictionary<TkeyB, Tvalue> GetA(TkeyA keyA);
    public Dictionary<TkeyA, Tvalue> GetB(TkeyB keyB);
    public bool ContainsKey(TkeyA keyA, TkeyB keyB);
    public bool ContainsKey(TkeyA keyA);
    public void Delete(TkeyA keyA, TkeyB keyB);
    public void DeleteA(TkeyA keyA);
    public void DeleteB(TkeyB keyB);
    public int Count(TkeyA keyA);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
    private string Lang(string key, BasePlayer basePlayer, object[] args);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static readonly string SFX_LAUNCH;
    public static readonly string SFX_CLICK;
    public static readonly string SFX_SUBMIT;
}

Oxide.Plugins
partial class ComputersPlus
{
    private T LoadDataFile(string fileName);
    private void SaveDataFile(string fileName, T data);
    private void PlaySfx(BasePlayer player, string sound);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    private readonly ComputersPlusApp EMAIL_APP;
     void CreateEmailApp(string userIdString);
     void InitEmailApp();
     void LaunchEmailApp(string userIdString);
     void SaveEmailApp();
     void UnloadEmailApp();
    private partial class Configuration
    {
        [JsonProperty(PropertyName = "Email Config")]
        public EmailConfiguration Email;
    }

    private class EmailConfiguration
    {
        [JsonProperty(PropertyName = "Max Inbox Size")]
        public int MaxInboxSize { get; set; }
    }

    private void AddEmailAppImages();
    private void RegisterEmailLanguage();
    private void RegisterEmailFunctions();
    private void LoadEmails();
    private void SaveEmails();
    private void DeleteEmail(string userIdString, string emailGuid);
    private void SendEmail(string userIdString);
    private void RenderEmailCompose(string userIdString);
    private void RenderEmailView(string userIdString, string emailGuid);
    private EZUI.Component CreateEmailEntryComponent(BasePlayer basePlayer, EmailMessage email, EZUI.Component list);
     EZUI.LayoutComponent UpdateInbox(BasePlayer basePlayer, EZUI.Component inbox);
    private string StatusText(BasePlayer basePlayer);
     void UpdateStatusText(BasePlayer basePlayer);
     void UpdateInfoText(BasePlayer basePlayer, string newText);
     void RenderEmailApp(BasePlayer basePlayer);
    [Command("email.clear"), Permission(PermissionAdmin)]
    private void cmd_email_clear(IPlayer player, string command, string[] args);
}

private partial class Configuration
{
    [JsonProperty(PropertyName = "Email Config")]
    public EmailConfiguration Email;
}

private class EmailConfiguration
{
    [JsonProperty(PropertyName = "Max Inbox Size")]
    public int MaxInboxSize { get; set; }
}

Oxide.Plugins
partial class ComputersPlus
{
    private static class EmailManager
    {
        private static Dictionary<string, List<EmailMessage>> EmailMessages;
        public static int MaxInboxSize { get; set; }
        public static int SendEmail(EmailMessage email);
        public static void SetAllEmails(Dictionary<string, List<EmailMessage>> emailMessages);
        public static Dictionary<string, List<EmailMessage>> GetAllEmails();
        public static EmailMessage[] GetPlayerInbox(string userIdString);
        public static int GetPlayerInboxCount(string userIdString);
        public static void ClearPlayerInbox(string userIdString);
        public static void DeleteEmail(string userIdString, Guid emailGuid);
        public static EmailMessage GetEmail(string userIdString, Guid emailGuid);
    }

}

private static class EmailManager
{
    private static Dictionary<string, List<EmailMessage>> EmailMessages;
    public static int MaxInboxSize { get; set; }
    public static int SendEmail(EmailMessage email);
    public static void SetAllEmails(Dictionary<string, List<EmailMessage>> emailMessages);
    public static Dictionary<string, List<EmailMessage>> GetAllEmails();
    public static EmailMessage[] GetPlayerInbox(string userIdString);
    public static int GetPlayerInboxCount(string userIdString);
    public static void ClearPlayerInbox(string userIdString);
    public static void DeleteEmail(string userIdString, Guid emailGuid);
    public static EmailMessage GetEmail(string userIdString, Guid emailGuid);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    [Serializable]
    private class EmailMessage
    {
        public EmailMessage(string composerStringId, string recipientStringId, string subject, string text);
        public Guid Guid { get; set; }
        public bool Unread { get; set; }
        public string Subject { get; set; }
        public string ComposerStringId { get; set; }
        public string RecipientStringId { get; set; }
        public long Timestamp { get; set; }
        public string Text { get; set; }
        [JsonIgnore]
        public string ComposerDisplayName { get; set; }
        [JsonIgnore]
        public string RecipientDisplayName { get; set; }
        public void MarkAsRead();
        public string ElapsedTimeString(BasePlayer basePlayer);
    }

}

[Serializable]
private class EmailMessage
{
    public EmailMessage(string composerStringId, string recipientStringId, string subject, string text);
    public Guid Guid { get; set; }
    public bool Unread { get; set; }
    public string Subject { get; set; }
    public string ComposerStringId { get; set; }
    public string RecipientStringId { get; set; }
    public long Timestamp { get; set; }
    public string Text { get; set; }
    [JsonIgnore]
    public string ComposerDisplayName { get; set; }
    [JsonIgnore]
    public string RecipientDisplayName { get; set; }
    public void MarkAsRead();
    public string ElapsedTimeString(BasePlayer basePlayer);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static partial class EZUI
    {
        public class BasicComponent : Component
        {
            public BasicComponent(string id);
            protected override Component CreateHelper();
            public override Component Inherit(Component from, bool recursive);
        }

    }

}

public static partial class EZUI
{
    public class BasicComponent : Component
    {
        public BasicComponent(string id);
        protected override Component CreateHelper();
        public override Component Inherit(Component from, bool recursive);
    }

}

public class BasicComponent : Component
{
    public BasicComponent(string id);
    protected override Component CreateHelper();
    public override Component Inherit(Component from, bool recursive);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static partial class EZUI
    {
        public class BoxComponent : Component, IBoxComponent
        {
            public BoxComponent(string id);
            public override Color BackgroundColor { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            protected override Component CreateHelper();
            public override Component Inherit(Component from, bool recursive);
        }

    }

}

public static partial class EZUI
{
    public class BoxComponent : Component, IBoxComponent
    {
        public BoxComponent(string id);
        public override Color BackgroundColor { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        protected override Component CreateHelper();
        public override Component Inherit(Component from, bool recursive);
    }

}

public class BoxComponent : Component, IBoxComponent
{
    public BoxComponent(string id);
    public override Color BackgroundColor { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    protected override Component CreateHelper();
    public override Component Inherit(Component from, bool recursive);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    [Command("button.click")]
    private void cmd_button_click(IPlayer player, string command, string[] args);
    public static partial class EZUI
    {
        public class ButtonComponent : Component, IButtonComponent, IBoxComponent, ITextComponent, IImageComponent
        {
            public ButtonComponent(string id);
            public override Color BackgroundColor { get; set; }
            public string Command { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            public string Text { get; set; }
            public string FontType { get; set; }
            public int FontSize { get; set; }
            public Color FontColor { get; set; }
            public TextAnchor TextAlign { get; set; }
            public string ImageKey { get; set; }
            public string ClickSfx { get; set; }
            public bool ImageHidden { get; set; }
            public bool AutoSizeHeight { get; set; }
            public bool AutoSizeWidth { get; set; }
            public Color ImageColor { get; set; }
            public override Component Init(Component parent);
            protected override Component CreateHelper();
            public override Component Inherit(Component from, bool recursive);
        }

    }

}

public static partial class EZUI
{
    public class ButtonComponent : Component, IButtonComponent, IBoxComponent, ITextComponent, IImageComponent
    {
        public ButtonComponent(string id);
        public override Color BackgroundColor { get; set; }
        public string Command { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        public string Text { get; set; }
        public string FontType { get; set; }
        public int FontSize { get; set; }
        public Color FontColor { get; set; }
        public TextAnchor TextAlign { get; set; }
        public string ImageKey { get; set; }
        public string ClickSfx { get; set; }
        public bool ImageHidden { get; set; }
        public bool AutoSizeHeight { get; set; }
        public bool AutoSizeWidth { get; set; }
        public Color ImageColor { get; set; }
        public override Component Init(Component parent);
        protected override Component CreateHelper();
        public override Component Inherit(Component from, bool recursive);
    }

}

public class ButtonComponent : Component, IButtonComponent, IBoxComponent, ITextComponent, IImageComponent
{
    public ButtonComponent(string id);
    public override Color BackgroundColor { get; set; }
    public string Command { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    public string Text { get; set; }
    public string FontType { get; set; }
    public int FontSize { get; set; }
    public Color FontColor { get; set; }
    public TextAnchor TextAlign { get; set; }
    public string ImageKey { get; set; }
    public string ClickSfx { get; set; }
    public bool ImageHidden { get; set; }
    public bool AutoSizeHeight { get; set; }
    public bool AutoSizeWidth { get; set; }
    public Color ImageColor { get; set; }
    public override Component Init(Component parent);
    protected override Component CreateHelper();
    public override Component Inherit(Component from, bool recursive);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    [Command("component.render")]
    private void cmd_component_render(IPlayer player, string command, string[] args);
    [Command("component.destroy")]
    private void cmd_component_destroy(IPlayer player, string command, string[] args);
    public partial class EZUI
    {
        public abstract class Component
        {
            public Component(string id);
            private Component _parent;
            private int? _pixelX;
            private int? _pixelY;
            private int? _pixelWidth;
            private int? _pixelHeight;
            private float _x;
            private float _y;
            private float _width;
            private float _height;
            private float? _size;
            private int _newPixelX;
            private int _newPixelY;
            private int _newPixelWidth;
            private int _newPixelHeight;
            private float _newX;
            private float _newY;
            private float _newWidth;
            private float _newHeight;
            public HashSet<string> Tags { get; set; }
            public string LocalId { get; set; }
            public string GlobalId { get; set; }
            public Component Parent { get; set; }
            public Component Content { get; set; }
            public HashSet<Component> Children { get; set; }
            public string ParentGlobalId { get; set; }
            public int ParentPixelY { get; set; }
            public int ParentPixelX { get; set; }
            public Dir<int> ParentPixelPadding { get; set; }
            public int ParentPixelWidth { get; set; }
            public int ParentPixelHeight { get; set; }
            public string AnchorMin { get; set; }
            public string AnchorMax { get; set; }
            public string OffsetMin { get; set; }
            public string OffsetMax { get; set; }
            public int PixelX { get; set; }
            public int PixelY { get; set; }
            public int PixelHeight { get; set; }
            public int PixelWidth { get; set; }
            public int PixelSize { get; set; }
            public virtual Dir<int> PixelPadding { get; set; }
            public Dir<int> PixelMargin { get; set; }
            public Dir<int> PixelCrop { get; set; }
            public float X { get; set; }
            public float Y { get; set; }
            public float Height { get; set; }
            public float Width { get; set; }
            public float Size { get; set; }
            public float Scale { get; set; }
            public Dir<float> Padding { get; set; }
            public Dir<float> Margin { get; set; }
            public bool Empty { get; set; }
            public List<CuiElement> Elements { get; set; }
            public bool Transparent { get; set; }
            public virtual Color BackgroundColor { get; set; }
            public float Opacity { get; set; }
            public bool Created { get; set; }
            public bool Rendered { get; set; }
            public virtual bool CenterX { get; set; }
            public bool CenterY { get; set; }
            public bool Centered { get; set; }
            public Anchor? AnchorTo { get; set; }
            public int? TopAlign { get; set; }
            public int? BottomAlign { get; set; }
            public int? RightAlign { get; set; }
            public int? LeftAlign { get; set; }
            public int Left { get; set; }
            public int Right { get; set; }
            public int Up { get; set; }
            public int Down { get; set; }
            public Value TopSide { get; set; }
            public Value BottomSide { get; set; }
            public Value LeftSide { get; set; }
            public Value RightSide { get; set; }
            public Dictionary<string, object> Info { get; set; }
            public override string ToString();
            public virtual Component Init(Component parent);
            public Component Tag(string tag);
            public Component Tag(object tag);
            public Component Create();
            public Component Create(Component parent);
            public Component CreateRecursively();
            public Component CreateRecursively(Component parent);
            protected abstract Component CreateHelper();
            public virtual Component Inherit(Component from, bool recursive);
            protected virtual List<CuiElement> CreateBaseElements();
            public virtual Component Include(Component[] components);
            public virtual void AddChild(Component child);
            public void Render(BasePlayer basePlayer);
            private List<CuiElement> RenderHelper(BasePlayer basePlayer, List<CuiElement> elements);
            public List<Component> GetNestedChildren();
            private List<Component> GetNestedChildrenHelper(List<Component> children);
            public void Destroy(BasePlayer basePlayer);
            public TComponent As();
            protected virtual Component OnRender(BasePlayer basePlayer);
            protected virtual Component OnDestroy(BasePlayer basePlayer);
            public override int GetHashCode();
            public override bool Equals(object obj);
        }

    }

}

public partial class EZUI
{
    public abstract class Component
    {
        public Component(string id);
        private Component _parent;
        private int? _pixelX;
        private int? _pixelY;
        private int? _pixelWidth;
        private int? _pixelHeight;
        private float _x;
        private float _y;
        private float _width;
        private float _height;
        private float? _size;
        private int _newPixelX;
        private int _newPixelY;
        private int _newPixelWidth;
        private int _newPixelHeight;
        private float _newX;
        private float _newY;
        private float _newWidth;
        private float _newHeight;
        public HashSet<string> Tags { get; set; }
        public string LocalId { get; set; }
        public string GlobalId { get; set; }
        public Component Parent { get; set; }
        public Component Content { get; set; }
        public HashSet<Component> Children { get; set; }
        public string ParentGlobalId { get; set; }
        public int ParentPixelY { get; set; }
        public int ParentPixelX { get; set; }
        public Dir<int> ParentPixelPadding { get; set; }
        public int ParentPixelWidth { get; set; }
        public int ParentPixelHeight { get; set; }
        public string AnchorMin { get; set; }
        public string AnchorMax { get; set; }
        public string OffsetMin { get; set; }
        public string OffsetMax { get; set; }
        public int PixelX { get; set; }
        public int PixelY { get; set; }
        public int PixelHeight { get; set; }
        public int PixelWidth { get; set; }
        public int PixelSize { get; set; }
        public virtual Dir<int> PixelPadding { get; set; }
        public Dir<int> PixelMargin { get; set; }
        public Dir<int> PixelCrop { get; set; }
        public float X { get; set; }
        public float Y { get; set; }
        public float Height { get; set; }
        public float Width { get; set; }
        public float Size { get; set; }
        public float Scale { get; set; }
        public Dir<float> Padding { get; set; }
        public Dir<float> Margin { get; set; }
        public bool Empty { get; set; }
        public List<CuiElement> Elements { get; set; }
        public bool Transparent { get; set; }
        public virtual Color BackgroundColor { get; set; }
        public float Opacity { get; set; }
        public bool Created { get; set; }
        public bool Rendered { get; set; }
        public virtual bool CenterX { get; set; }
        public bool CenterY { get; set; }
        public bool Centered { get; set; }
        public Anchor? AnchorTo { get; set; }
        public int? TopAlign { get; set; }
        public int? BottomAlign { get; set; }
        public int? RightAlign { get; set; }
        public int? LeftAlign { get; set; }
        public int Left { get; set; }
        public int Right { get; set; }
        public int Up { get; set; }
        public int Down { get; set; }
        public Value TopSide { get; set; }
        public Value BottomSide { get; set; }
        public Value LeftSide { get; set; }
        public Value RightSide { get; set; }
        public Dictionary<string, object> Info { get; set; }
        public override string ToString();
        public virtual Component Init(Component parent);
        public Component Tag(string tag);
        public Component Tag(object tag);
        public Component Create();
        public Component Create(Component parent);
        public Component CreateRecursively();
        public Component CreateRecursively(Component parent);
        protected abstract Component CreateHelper();
        public virtual Component Inherit(Component from, bool recursive);
        protected virtual List<CuiElement> CreateBaseElements();
        public virtual Component Include(Component[] components);
        public virtual void AddChild(Component child);
        public void Render(BasePlayer basePlayer);
        private List<CuiElement> RenderHelper(BasePlayer basePlayer, List<CuiElement> elements);
        public List<Component> GetNestedChildren();
        private List<Component> GetNestedChildrenHelper(List<Component> children);
        public void Destroy(BasePlayer basePlayer);
        public TComponent As();
        protected virtual Component OnRender(BasePlayer basePlayer);
        protected virtual Component OnDestroy(BasePlayer basePlayer);
        public override int GetHashCode();
        public override bool Equals(object obj);
    }

}

public abstract class Component
{
    public Component(string id);
    private Component _parent;
    private int? _pixelX;
    private int? _pixelY;
    private int? _pixelWidth;
    private int? _pixelHeight;
    private float _x;
    private float _y;
    private float _width;
    private float _height;
    private float? _size;
    private int _newPixelX;
    private int _newPixelY;
    private int _newPixelWidth;
    private int _newPixelHeight;
    private float _newX;
    private float _newY;
    private float _newWidth;
    private float _newHeight;
    public HashSet<string> Tags { get; set; }
    public string LocalId { get; set; }
    public string GlobalId { get; set; }
    public Component Parent { get; set; }
    public Component Content { get; set; }
    public HashSet<Component> Children { get; set; }
    public string ParentGlobalId { get; set; }
    public int ParentPixelY { get; set; }
    public int ParentPixelX { get; set; }
    public Dir<int> ParentPixelPadding { get; set; }
    public int ParentPixelWidth { get; set; }
    public int ParentPixelHeight { get; set; }
    public string AnchorMin { get; set; }
    public string AnchorMax { get; set; }
    public string OffsetMin { get; set; }
    public string OffsetMax { get; set; }
    public int PixelX { get; set; }
    public int PixelY { get; set; }
    public int PixelHeight { get; set; }
    public int PixelWidth { get; set; }
    public int PixelSize { get; set; }
    public virtual Dir<int> PixelPadding { get; set; }
    public Dir<int> PixelMargin { get; set; }
    public Dir<int> PixelCrop { get; set; }
    public float X { get; set; }
    public float Y { get; set; }
    public float Height { get; set; }
    public float Width { get; set; }
    public float Size { get; set; }
    public float Scale { get; set; }
    public Dir<float> Padding { get; set; }
    public Dir<float> Margin { get; set; }
    public bool Empty { get; set; }
    public List<CuiElement> Elements { get; set; }
    public bool Transparent { get; set; }
    public virtual Color BackgroundColor { get; set; }
    public float Opacity { get; set; }
    public bool Created { get; set; }
    public bool Rendered { get; set; }
    public virtual bool CenterX { get; set; }
    public bool CenterY { get; set; }
    public bool Centered { get; set; }
    public Anchor? AnchorTo { get; set; }
    public int? TopAlign { get; set; }
    public int? BottomAlign { get; set; }
    public int? RightAlign { get; set; }
    public int? LeftAlign { get; set; }
    public int Left { get; set; }
    public int Right { get; set; }
    public int Up { get; set; }
    public int Down { get; set; }
    public Value TopSide { get; set; }
    public Value BottomSide { get; set; }
    public Value LeftSide { get; set; }
    public Value RightSide { get; set; }
    public Dictionary<string, object> Info { get; set; }
    public override string ToString();
    public virtual Component Init(Component parent);
    public Component Tag(string tag);
    public Component Tag(object tag);
    public Component Create();
    public Component Create(Component parent);
    public Component CreateRecursively();
    public Component CreateRecursively(Component parent);
    protected abstract Component CreateHelper();
    public virtual Component Inherit(Component from, bool recursive);
    protected virtual List<CuiElement> CreateBaseElements();
    public virtual Component Include(Component[] components);
    public virtual void AddChild(Component child);
    public void Render(BasePlayer basePlayer);
    private List<CuiElement> RenderHelper(BasePlayer basePlayer, List<CuiElement> elements);
    public List<Component> GetNestedChildren();
    private List<Component> GetNestedChildrenHelper(List<Component> children);
    public void Destroy(BasePlayer basePlayer);
    public TComponent As();
    protected virtual Component OnRender(BasePlayer basePlayer);
    protected virtual Component OnDestroy(BasePlayer basePlayer);
    public override int GetHashCode();
    public override bool Equals(object obj);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    [Command("ezui.call")]
    private void cmd_ezui_call(IPlayer player, string command, string[] args);
    public partial class EZUI
    {
        private readonly static DoubleDictionary<string, string, Component> loaded;
        private readonly static DoubleDictionary<string, string, Component> tagged;
        private readonly static int MAX_X;
        private readonly static int MAX_Y;
        private readonly static string DEFAULT_FONT_TYPE;
        private readonly static int DEFAULT_FONT_SIZE;
        private static string _token;
        private readonly static List<string> RegisteredFunctions;
        internal static string Token { get; set; }
        public static void RegisterFunction(string function);
        public static bool FunctionIsRegisterd(string function);
        public static void GenerateToken();
        public static bool ValidateToken(IPlayer player, string command, string token);
        public static void Tag(BasePlayer basePlayer, Component component, string tag);
        public static Component Get(BasePlayer basePlayer, object tag, string localId);
        private static void Load(string userIdString, Component ui);
        public static void Unload(string userIdString, Component ui);
        public static void Unload(string userIdString, string globalId);
        public static void UnloadNested(string userIdString, Component ui);
        public static void DestroyAll(BasePlayer basePlayer);
        public static List<Component> GetAll(BasePlayer basePlayer);
        public static string PrintLoaded(BasePlayer basePlayer);
        public static Component Find(string userIdString, string globalId);
        public static Component Find(BasePlayer basePlayer, string globalId);
        public static Component Query(string userIdString, string localId);
        public static Component Query(BasePlayer basePlayer, string localId);
        public class Info
        {
            public string LocalId { get; set; }
            public string GlobalId { get; set; }
            public string ParentId { get; set; }
            public string Position { get; set; }
            public string Children { get; set; }
            public string Dimensions { get; set; }
            public string Proportions { get; set; }
            public string Padding { get; set; }
            public string Margin { get; set; }
            public string Color { get; set; }
        }

        public class Color
        {
            public static Color WHITE;
            public static Color RED;
            public static Color GREEN;
            public static Color BLUE;
            public static Color BLACK;
            public static Color TRANSPARENT;
            public Color();
            public Color(string colorString, char delim);
            public Color(int r, int g, int b);
            public Color(float r, float g, float b);
            public Color(float r, float g, float b, float a);
            public float Red { get; set; }
            public float Green { get; set; }
            public float Blue { get; set; }
            public float Alpha { get; set; }
            public override string ToString();
        }

        public class Dir
        {
            public readonly static Dir<int> ZERO;
            public Dir();
            public Dir(T all);
            public Dir(T top, T right, T bottom, T left);
            public Dir<float> ConvertToFloat();
            public Dir<int> ConvertToInt();
            private float CastToFloat(T value);
            private int CastToInt(T value);
            public T Top { get; set; }
            public T Right { get; set; }
            public T Bottom { get; set; }
            public T Left { get; set; }
            public override string ToString();
        }

        public class Value
        {
            public Value();
            public Value(int pixels, int max);
            public float Percent { get; set; }
            public int Pixels { get; set; }
        }

        public class BoundingBox
        {
            private int _left;
            private int _right;
            private int _bottom;
            private int _top;
            public BoundingBox(int minBottom, int minLeft, int maxTop, int maxRight);
            public int GapX { get; set; }
            public int GapY { get; set; }
            public int MaxTop { get; set; }
            public int MaxRight { get; set; }
            public int MinBottom { get; set; }
            public int MinLeft { get; set; }
            public int Bottom { get; set; }
            public int Left { get; set; }
            public int Right { get; set; }
            public int Top { get; set; }
            public int Height { get; set; }
            public int Width { get; set; }
            public override string ToString();
        }

    }

}

public partial class EZUI
{
    private readonly static DoubleDictionary<string, string, Component> loaded;
    private readonly static DoubleDictionary<string, string, Component> tagged;
    private readonly static int MAX_X;
    private readonly static int MAX_Y;
    private readonly static string DEFAULT_FONT_TYPE;
    private readonly static int DEFAULT_FONT_SIZE;
    private static string _token;
    private readonly static List<string> RegisteredFunctions;
    internal static string Token { get; set; }
    public static void RegisterFunction(string function);
    public static bool FunctionIsRegisterd(string function);
    public static void GenerateToken();
    public static bool ValidateToken(IPlayer player, string command, string token);
    public static void Tag(BasePlayer basePlayer, Component component, string tag);
    public static Component Get(BasePlayer basePlayer, object tag, string localId);
    private static void Load(string userIdString, Component ui);
    public static void Unload(string userIdString, Component ui);
    public static void Unload(string userIdString, string globalId);
    public static void UnloadNested(string userIdString, Component ui);
    public static void DestroyAll(BasePlayer basePlayer);
    public static List<Component> GetAll(BasePlayer basePlayer);
    public static string PrintLoaded(BasePlayer basePlayer);
    public static Component Find(string userIdString, string globalId);
    public static Component Find(BasePlayer basePlayer, string globalId);
    public static Component Query(string userIdString, string localId);
    public static Component Query(BasePlayer basePlayer, string localId);
    public class Info
    {
        public string LocalId { get; set; }
        public string GlobalId { get; set; }
        public string ParentId { get; set; }
        public string Position { get; set; }
        public string Children { get; set; }
        public string Dimensions { get; set; }
        public string Proportions { get; set; }
        public string Padding { get; set; }
        public string Margin { get; set; }
        public string Color { get; set; }
    }

    public class Color
    {
        public static Color WHITE;
        public static Color RED;
        public static Color GREEN;
        public static Color BLUE;
        public static Color BLACK;
        public static Color TRANSPARENT;
        public Color();
        public Color(string colorString, char delim);
        public Color(int r, int g, int b);
        public Color(float r, float g, float b);
        public Color(float r, float g, float b, float a);
        public float Red { get; set; }
        public float Green { get; set; }
        public float Blue { get; set; }
        public float Alpha { get; set; }
        public override string ToString();
    }

    public class Dir
    {
        public readonly static Dir<int> ZERO;
        public Dir();
        public Dir(T all);
        public Dir(T top, T right, T bottom, T left);
        public Dir<float> ConvertToFloat();
        public Dir<int> ConvertToInt();
        private float CastToFloat(T value);
        private int CastToInt(T value);
        public T Top { get; set; }
        public T Right { get; set; }
        public T Bottom { get; set; }
        public T Left { get; set; }
        public override string ToString();
    }

    public class Value
    {
        public Value();
        public Value(int pixels, int max);
        public float Percent { get; set; }
        public int Pixels { get; set; }
    }

    public class BoundingBox
    {
        private int _left;
        private int _right;
        private int _bottom;
        private int _top;
        public BoundingBox(int minBottom, int minLeft, int maxTop, int maxRight);
        public int GapX { get; set; }
        public int GapY { get; set; }
        public int MaxTop { get; set; }
        public int MaxRight { get; set; }
        public int MinBottom { get; set; }
        public int MinLeft { get; set; }
        public int Bottom { get; set; }
        public int Left { get; set; }
        public int Right { get; set; }
        public int Top { get; set; }
        public int Height { get; set; }
        public int Width { get; set; }
        public override string ToString();
    }

}

public class Info
{
    public string LocalId { get; set; }
    public string GlobalId { get; set; }
    public string ParentId { get; set; }
    public string Position { get; set; }
    public string Children { get; set; }
    public string Dimensions { get; set; }
    public string Proportions { get; set; }
    public string Padding { get; set; }
    public string Margin { get; set; }
    public string Color { get; set; }
}

public class Color
{
    public static Color WHITE;
    public static Color RED;
    public static Color GREEN;
    public static Color BLUE;
    public static Color BLACK;
    public static Color TRANSPARENT;
    public Color();
    public Color(string colorString, char delim);
    public Color(int r, int g, int b);
    public Color(float r, float g, float b);
    public Color(float r, float g, float b, float a);
    public float Red { get; set; }
    public float Green { get; set; }
    public float Blue { get; set; }
    public float Alpha { get; set; }
    public override string ToString();
}

public class Dir
{
    public readonly static Dir<int> ZERO;
    public Dir();
    public Dir(T all);
    public Dir(T top, T right, T bottom, T left);
    public Dir<float> ConvertToFloat();
    public Dir<int> ConvertToInt();
    private float CastToFloat(T value);
    private int CastToInt(T value);
    public T Top { get; set; }
    public T Right { get; set; }
    public T Bottom { get; set; }
    public T Left { get; set; }
    public override string ToString();
}

public class Value
{
    public Value();
    public Value(int pixels, int max);
    public float Percent { get; set; }
    public int Pixels { get; set; }
}

public class BoundingBox
{
    private int _left;
    private int _right;
    private int _bottom;
    private int _top;
    public BoundingBox(int minBottom, int minLeft, int maxTop, int maxRight);
    public int GapX { get; set; }
    public int GapY { get; set; }
    public int MaxTop { get; set; }
    public int MaxRight { get; set; }
    public int MinBottom { get; set; }
    public int MinLeft { get; set; }
    public int Bottom { get; set; }
    public int Left { get; set; }
    public int Right { get; set; }
    public int Top { get; set; }
    public int Height { get; set; }
    public int Width { get; set; }
    public override string ToString();
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static partial class EZUI
    {
        public class ImageComponent : Component, IBoxComponent, IImageComponent
        {
            public ImageComponent(string id);
            public override Color BackgroundColor { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            public string ImageKey { get; set; }
            public bool ImageHidden { get; set; }
            public Color ImageColor { get; set; }
            protected override Component CreateHelper();
            public override Component Inherit(Component from, bool recursive);
        }

    }

}

public static partial class EZUI
{
    public class ImageComponent : Component, IBoxComponent, IImageComponent
    {
        public ImageComponent(string id);
        public override Color BackgroundColor { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        public string ImageKey { get; set; }
        public bool ImageHidden { get; set; }
        public Color ImageColor { get; set; }
        protected override Component CreateHelper();
        public override Component Inherit(Component from, bool recursive);
    }

}

public class ImageComponent : Component, IBoxComponent, IImageComponent
{
    public ImageComponent(string id);
    public override Color BackgroundColor { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    public string ImageKey { get; set; }
    public bool ImageHidden { get; set; }
    public Color ImageColor { get; set; }
    protected override Component CreateHelper();
    public override Component Inherit(Component from, bool recursive);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    [Command("input.data")]
    private void cmd_input_data(IPlayer player, string command, string[] args);
    public static partial class EZUI
    {
        public class InputComponent : Component, IInputComponent, IBoxComponent, ITextComponent
        {
            public InputComponent(string id);
            public override Dir<int> PixelPadding { get; set; }
            public override Color BackgroundColor { get; set; }
            public string Command { get; set; }
            public int CharsLimit { get; set; }
            public string Text { get; set; }
            public string FontType { get; set; }
            public int FontSize { get; set; }
            public Color FontColor { get; set; }
            public TextAnchor TextAlign { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            public bool AutoSizeHeight { get; set; }
            public bool AutoSizeWidth { get; set; }
            public string Data { get; set; }
            private int CommandLength { get; set; }
            protected override Component CreateHelper();
        }

    }

}

public static partial class EZUI
{
    public class InputComponent : Component, IInputComponent, IBoxComponent, ITextComponent
    {
        public InputComponent(string id);
        public override Dir<int> PixelPadding { get; set; }
        public override Color BackgroundColor { get; set; }
        public string Command { get; set; }
        public int CharsLimit { get; set; }
        public string Text { get; set; }
        public string FontType { get; set; }
        public int FontSize { get; set; }
        public Color FontColor { get; set; }
        public TextAnchor TextAlign { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        public bool AutoSizeHeight { get; set; }
        public bool AutoSizeWidth { get; set; }
        public string Data { get; set; }
        private int CommandLength { get; set; }
        protected override Component CreateHelper();
    }

}

public class InputComponent : Component, IInputComponent, IBoxComponent, ITextComponent
{
    public InputComponent(string id);
    public override Dir<int> PixelPadding { get; set; }
    public override Color BackgroundColor { get; set; }
    public string Command { get; set; }
    public int CharsLimit { get; set; }
    public string Text { get; set; }
    public string FontType { get; set; }
    public int FontSize { get; set; }
    public Color FontColor { get; set; }
    public TextAnchor TextAlign { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    public bool AutoSizeHeight { get; set; }
    public bool AutoSizeWidth { get; set; }
    public string Data { get; set; }
    private int CommandLength { get; set; }
    protected override Component CreateHelper();
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static partial class EZUI
    {
        public class LayoutComponent : Component, IBoxComponent, ILayoutComponent
        {
            public LayoutComponent(string id);
            public override Color BackgroundColor { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            public List<Component> Entries { get; set; }
            public LayoutFlow LayoutFlow { get; set; }
            public int RowCount { get; set; }
            public int ColCount { get; set; }
            public Dir<int> EntryPixelPadding { get; set; }
            public int Page { get; set; }
            private Component ListContent { get; set; }
            public int MaxPage { get; set; }
            public PaginatorComponent Paginator { get; set; }
            protected override Component CreateHelper();
            private Component CreateListContent();
            private void CreateEntries();
            public void CreateEntry(Component parent, Component entry, int i);
            protected override Component OnRender(BasePlayer basePlayer);
            public void ClearEntries();
            public override void AddChild(Component child);
            public LayoutComponent SetPaginator(PaginatorComponent paginator);
        }

    }

}

public static partial class EZUI
{
    public class LayoutComponent : Component, IBoxComponent, ILayoutComponent
    {
        public LayoutComponent(string id);
        public override Color BackgroundColor { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        public List<Component> Entries { get; set; }
        public LayoutFlow LayoutFlow { get; set; }
        public int RowCount { get; set; }
        public int ColCount { get; set; }
        public Dir<int> EntryPixelPadding { get; set; }
        public int Page { get; set; }
        private Component ListContent { get; set; }
        public int MaxPage { get; set; }
        public PaginatorComponent Paginator { get; set; }
        protected override Component CreateHelper();
        private Component CreateListContent();
        private void CreateEntries();
        public void CreateEntry(Component parent, Component entry, int i);
        protected override Component OnRender(BasePlayer basePlayer);
        public void ClearEntries();
        public override void AddChild(Component child);
        public LayoutComponent SetPaginator(PaginatorComponent paginator);
    }

}

public class LayoutComponent : Component, IBoxComponent, ILayoutComponent
{
    public LayoutComponent(string id);
    public override Color BackgroundColor { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    public List<Component> Entries { get; set; }
    public LayoutFlow LayoutFlow { get; set; }
    public int RowCount { get; set; }
    public int ColCount { get; set; }
    public Dir<int> EntryPixelPadding { get; set; }
    public int Page { get; set; }
    private Component ListContent { get; set; }
    public int MaxPage { get; set; }
    public PaginatorComponent Paginator { get; set; }
    protected override Component CreateHelper();
    private Component CreateListContent();
    private void CreateEntries();
    public void CreateEntry(Component parent, Component entry, int i);
    protected override Component OnRender(BasePlayer basePlayer);
    public void ClearEntries();
    public override void AddChild(Component child);
    public LayoutComponent SetPaginator(PaginatorComponent paginator);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    [Command("page.set")]
    private void cmd_page_set(IPlayer player, string command, string[] args);
    public static partial class EZUI
    {
        public class PaginatorComponent : Component, IPaginatorComponent, IBoxComponent, ITextComponent
        {
            public PaginatorComponent(string id);
            public override Color BackgroundColor { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            public List<Component> Entries { get; set; }
            public string Text { get; set; }
            public string FontType { get; set; }
            public int FontSize { get; set; }
            public Color FontColor { get; set; }
            public TextAnchor TextAlign { get; set; }
            public LayoutComponent Layout { get; set; }
            public int Page { get; set; }
            public int MaxPage { get; set; }
            public bool AutoSizeHeight { get; set; }
            public bool AutoSizeWidth { get; set; }
            protected override Component CreateHelper();
            public PaginatorComponent SetLayout(LayoutComponent layout);
            public PaginatorComponent UpdatePageAndRender(BasePlayer basePlayer, int page);
        }

    }

}

public static partial class EZUI
{
    public class PaginatorComponent : Component, IPaginatorComponent, IBoxComponent, ITextComponent
    {
        public PaginatorComponent(string id);
        public override Color BackgroundColor { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        public List<Component> Entries { get; set; }
        public string Text { get; set; }
        public string FontType { get; set; }
        public int FontSize { get; set; }
        public Color FontColor { get; set; }
        public TextAnchor TextAlign { get; set; }
        public LayoutComponent Layout { get; set; }
        public int Page { get; set; }
        public int MaxPage { get; set; }
        public bool AutoSizeHeight { get; set; }
        public bool AutoSizeWidth { get; set; }
        protected override Component CreateHelper();
        public PaginatorComponent SetLayout(LayoutComponent layout);
        public PaginatorComponent UpdatePageAndRender(BasePlayer basePlayer, int page);
    }

}

public class PaginatorComponent : Component, IPaginatorComponent, IBoxComponent, ITextComponent
{
    public PaginatorComponent(string id);
    public override Color BackgroundColor { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    public List<Component> Entries { get; set; }
    public string Text { get; set; }
    public string FontType { get; set; }
    public int FontSize { get; set; }
    public Color FontColor { get; set; }
    public TextAnchor TextAlign { get; set; }
    public LayoutComponent Layout { get; set; }
    public int Page { get; set; }
    public int MaxPage { get; set; }
    public bool AutoSizeHeight { get; set; }
    public bool AutoSizeWidth { get; set; }
    protected override Component CreateHelper();
    public PaginatorComponent SetLayout(LayoutComponent layout);
    public PaginatorComponent UpdatePageAndRender(BasePlayer basePlayer, int page);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static partial class EZUI
    {
        public class StyleSheet
        {
            public static readonly StyleSheet DEFAULT;
            public Color HomeBackgroundColor { get; set; }
            public Color BackgroundColorLight1 { get; set; }
            public Color BackgroundColorLight2 { get; set; }
            public Color BackgroundColorLight3 { get; set; }
            public Color BackgroundColorLight4 { get; set; }
            public Color BackgroundColorDark1 { get; set; }
            public Color BackgroundColorDark2 { get; set; }
            public Color BackgroundColorDark3 { get; set; }
            public Color BackgroundColorDark4 { get; set; }
            public Color BackgroundColorHighlight1 { get; set; }
            public Color OutlineColorLight1 { get; set; }
            public Color OutlineColorDark1 { get; set; }
            public Color FontColorLight1 { get; set; }
            public Color FontColorLight2 { get; set; }
            public Color FontColorDark1 { get; set; }
            public Color FontColorDark2 { get; set; }
            public string FontType1 { get; set; }
            public string FontType2 { get; set; }
            public int FontSize1 { get; set; }
            public int FontSize2 { get; set; }
            public int FontSize3 { get; set; }
        }

    }

}

public static partial class EZUI
{
    public class StyleSheet
    {
        public static readonly StyleSheet DEFAULT;
        public Color HomeBackgroundColor { get; set; }
        public Color BackgroundColorLight1 { get; set; }
        public Color BackgroundColorLight2 { get; set; }
        public Color BackgroundColorLight3 { get; set; }
        public Color BackgroundColorLight4 { get; set; }
        public Color BackgroundColorDark1 { get; set; }
        public Color BackgroundColorDark2 { get; set; }
        public Color BackgroundColorDark3 { get; set; }
        public Color BackgroundColorDark4 { get; set; }
        public Color BackgroundColorHighlight1 { get; set; }
        public Color OutlineColorLight1 { get; set; }
        public Color OutlineColorDark1 { get; set; }
        public Color FontColorLight1 { get; set; }
        public Color FontColorLight2 { get; set; }
        public Color FontColorDark1 { get; set; }
        public Color FontColorDark2 { get; set; }
        public string FontType1 { get; set; }
        public string FontType2 { get; set; }
        public int FontSize1 { get; set; }
        public int FontSize2 { get; set; }
        public int FontSize3 { get; set; }
    }

}

public class StyleSheet
{
    public static readonly StyleSheet DEFAULT;
    public Color HomeBackgroundColor { get; set; }
    public Color BackgroundColorLight1 { get; set; }
    public Color BackgroundColorLight2 { get; set; }
    public Color BackgroundColorLight3 { get; set; }
    public Color BackgroundColorLight4 { get; set; }
    public Color BackgroundColorDark1 { get; set; }
    public Color BackgroundColorDark2 { get; set; }
    public Color BackgroundColorDark3 { get; set; }
    public Color BackgroundColorDark4 { get; set; }
    public Color BackgroundColorHighlight1 { get; set; }
    public Color OutlineColorLight1 { get; set; }
    public Color OutlineColorDark1 { get; set; }
    public Color FontColorLight1 { get; set; }
    public Color FontColorLight2 { get; set; }
    public Color FontColorDark1 { get; set; }
    public Color FontColorDark2 { get; set; }
    public string FontType1 { get; set; }
    public string FontType2 { get; set; }
    public int FontSize1 { get; set; }
    public int FontSize2 { get; set; }
    public int FontSize3 { get; set; }
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static partial class EZUI
    {
        public class TextComponent : Component, ITextComponent, IBoxComponent
        {
            public TextComponent(string id);
            public override Color BackgroundColor { get; set; }
            public string Text { get; set; }
            public string FontType { get; set; }
            public int FontSize { get; set; }
            public Color FontColor { get; set; }
            public TextAnchor TextAlign { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            public bool AutoSizeHeight { get; set; }
            public bool AutoSizeWidth { get; set; }
            protected override Component CreateHelper();
            public override Component Init(Component parent);
            public override Component Inherit(Component from, bool recursive);
        }

    }

}

public static partial class EZUI
{
    public class TextComponent : Component, ITextComponent, IBoxComponent
    {
        public TextComponent(string id);
        public override Color BackgroundColor { get; set; }
        public string Text { get; set; }
        public string FontType { get; set; }
        public int FontSize { get; set; }
        public Color FontColor { get; set; }
        public TextAnchor TextAlign { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        public bool AutoSizeHeight { get; set; }
        public bool AutoSizeWidth { get; set; }
        protected override Component CreateHelper();
        public override Component Init(Component parent);
        public override Component Inherit(Component from, bool recursive);
    }

}

public class TextComponent : Component, ITextComponent, IBoxComponent
{
    public TextComponent(string id);
    public override Color BackgroundColor { get; set; }
    public string Text { get; set; }
    public string FontType { get; set; }
    public int FontSize { get; set; }
    public Color FontColor { get; set; }
    public TextAnchor TextAlign { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    public bool AutoSizeHeight { get; set; }
    public bool AutoSizeWidth { get; set; }
    protected override Component CreateHelper();
    public override Component Init(Component parent);
    public override Component Inherit(Component from, bool recursive);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    [Command("t.show")]
    private void cmd_ui_test_show(IPlayer player, string command, string[] args);
    [Command("t.email")]
    private void cmd_ui_test_email(IPlayer player, string command, string[] args);
    [Command("t.close")]
    private void cmd_ui_test_close(IPlayer player, string command, string[] args);
    [Command("t.close2")]
    private void cmd_ui_test_close2(IPlayer player, string command, string[] args);
    [Command("t.print")]
    private void cmd_ui_test_print(IPlayer player, string command, string[] args);
    [Command("sfx")]
    private void cmd_sfx(IPlayer player, string command, string[] args);
    [Command("pc.destroy")]
    private void cmd_pc_destroy(IPlayer player, string command, string[] args);
    private void TestBox(BasePlayer basePlayer);
    private void TestWindow(BasePlayer basePlayer);
}

Oxide.Plugins
partial class ComputersPlus : CovalencePlugin
{
    public static partial class EZUI
    {
        public class WindowComponent : Component, IWindowComponent, IBoxComponent
        {
            public WindowComponent(string id);
            public override Color BackgroundColor { get; set; }
            public Color HeaderBackgroundColor { get; set; }
            public string HeaderText { get; set; }
            public int HeaderPixelHeight { get; set; }
            public Color OutlineColor { get; set; }
            public int OutlinePixelWeight { get; set; }
            private float WindowScale { get; set; }
            private Color WindowBackgroundColor { get; set; }
            public string OnCloseCommand { get; set; }
            protected override List<CuiElement> CreateBaseElements();
            private Component CreateHeader(Component box);
            protected override Component CreateHelper();
            protected override Component OnDestroy(BasePlayer basePlayer);
        }

    }

}

public static partial class EZUI
{
    public class WindowComponent : Component, IWindowComponent, IBoxComponent
    {
        public WindowComponent(string id);
        public override Color BackgroundColor { get; set; }
        public Color HeaderBackgroundColor { get; set; }
        public string HeaderText { get; set; }
        public int HeaderPixelHeight { get; set; }
        public Color OutlineColor { get; set; }
        public int OutlinePixelWeight { get; set; }
        private float WindowScale { get; set; }
        private Color WindowBackgroundColor { get; set; }
        public string OnCloseCommand { get; set; }
        protected override List<CuiElement> CreateBaseElements();
        private Component CreateHeader(Component box);
        protected override Component CreateHelper();
        protected override Component OnDestroy(BasePlayer basePlayer);
    }

}

public class WindowComponent : Component, IWindowComponent, IBoxComponent
{
    public WindowComponent(string id);
    public override Color BackgroundColor { get; set; }
    public Color HeaderBackgroundColor { get; set; }
    public string HeaderText { get; set; }
    public int HeaderPixelHeight { get; set; }
    public Color OutlineColor { get; set; }
    public int OutlinePixelWeight { get; set; }
    private float WindowScale { get; set; }
    private Color WindowBackgroundColor { get; set; }
    public string OnCloseCommand { get; set; }
    protected override List<CuiElement> CreateBaseElements();
    private Component CreateHeader(Component box);
    protected override Component CreateHelper();
    protected override Component OnDestroy(BasePlayer basePlayer);
}


```

---

## ConnectionDB by misticos - Connection database for developers

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Random = System.Random;

Oxide.Plugins
[Info("Connection DB", "Iv Misticos", "1.0.4")]
[Description("Connection database for developers.")]
public class ConnectionDB : RustPlugin
{
    private Dictionary<ulong, PlayerData> _data;
    private Dictionary<string, string> _pluginData;
    private Random _rnd;
    private Time _time;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Debug")]
        public bool Debug;
        [JsonProperty(PropertyName = "Time Between Self-Deletion and Last Connection (sec)")]
        public uint TimeToDelete;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void SaveData();
    private void LoadData();
    private bool LoadCustomData(string key);
    private class PlayerData
    {
        public List<string> Names;
        public List<string> IPs;
        public List<uint> TimeStamps;
        public uint SecondsPlayed;
    }

    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private bool CommandConsoleDebugInfo(ConsoleSystem.Arg arg);
    private bool CommandConsoleWipe(ConsoleSystem.Arg arg);
    private void InitPlayer(BasePlayer player, bool isDisconnect);
    private void PrintDebug(string s);
    private bool ConnectionDataExists(ulong steamid);
    private int ConnectionsCount();
    private string GetStringFromData(object data);
    private string GetPluginData(string key);
    private List<string> API_GetNames(ulong id);
    private string API_GetFirstName(ulong id);
    private string API_GetLastName(ulong id);
    private List<string> API_GetIPs(ulong id);
    private string API_GetFirstIP(ulong id);
    private string API_GetLastIP(ulong id);
    private List<uint> API_GetTimeStamps(ulong id);
    private uint API_GetFirstTimeStamp(ulong id);
    private uint API_GetLastTimeStamp(ulong id);
    private uint API_GetSecondsPlayed(ulong id);
    private void API_SetValue(string key, object value);
    private object API_GetValue(string key);
    private string API_GetValueRaw(string key);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Debug")]
    public bool Debug;
    [JsonProperty(PropertyName = "Time Between Self-Deletion and Last Connection (sec)")]
    public uint TimeToDelete;
}

private class PlayerData
{
    public List<string> Names;
    public List<string> IPs;
    public List<uint> TimeStamps;
    public uint SecondsPlayed;
}


```

---

## ConnectionLimiter by MrBlue - Limits and protects against player re-connection spam

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("ConnectionLimiter", "Exel80", "1.0.1", ResourceId = 2649)]
[Description("Help server admins block spam re-connecting")]
 class ConnectionLimiter : CovalencePlugin
{
    public Dictionary<string, DateTime> ConnectedPlayers;
    private Configuration config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Enable Connection Limit (true/false)")]
        public bool limitEnabled;
        [JsonProperty(PropertyName = "Kick message show current waiting time (true/false)")]
        public bool limitCurrenttime;
        [JsonProperty(PropertyName = "Connection cooldown (in Seconds)")]
        public int limitCooldown;
        public static Configuration DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Init();
     string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
     object CanUserLogin(string name, string id, string ip);
    private void OnUserDisconnected(IPlayer player);
}

public class Configuration
{
    [JsonProperty(PropertyName = "Enable Connection Limit (true/false)")]
    public bool limitEnabled;
    [JsonProperty(PropertyName = "Kick message show current waiting time (true/false)")]
    public bool limitCurrenttime;
    [JsonProperty(PropertyName = "Connection cooldown (in Seconds)")]
    public int limitCooldown;
    public static Configuration DefaultConfig();
}


```

---

## ConnectMessages by Mroczny - Provides connect and disconnect messages

```csharp
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Libraries;
using Newtonsoft.Json;
using System;

Oxide.Plugins
[Info("ConnectMessages", "Mroczny", "1.2.3")]
[Description("Custom connect and disconnect messages.")]
 class ConnectMessages : CovalencePlugin
{
    private class Response
    {
        [JsonProperty("country")]
        public string Country { get; set; }
        [JsonProperty("countryCode")]
        public string CountryCode { get; set; }
    }

    private void OnServerInitialized();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void OnUserConnected(IPlayer player);
    private void OnUserDisconnected(IPlayer player, string reason);
    private void Broadcast(string msg, object player, string country);
}

private class Response
{
    [JsonProperty("country")]
    public string Country { get; set; }
    [JsonProperty("countryCode")]
    public string CountryCode { get; set; }
}


```

---

## ConnectRespawn by Tryhard - Automatically respawns dead players upon connection

```csharp

Oxide.Plugins
[Info("Connect Respawn", "Tryhard", "1.0.2")]
[Description("Automatically respawns players upon connection")]
public class ConnectRespawn : RustPlugin
{
    private void Init();
    private void OnPlayerConnected(BasePlayer player);
}


```

---

## ConsoleChat by Death - Sends game chat into player's console with the ability to toggle off per-player.

```csharp
using ConVar;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("ConsoleChat", "Death", "1.0.5")]
[Description("Prints all player chat to console.")]
 class ConsoleChat : RustPlugin
{
    const string perm;
     BasePlayer cachedTeamPlayer;
     void Init();
     void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    [ConsoleCommand("consolechat.toggle")]
     void ConsoleCommand(ConsoleSystem.Arg arg);
    private ConfigData configData;
     class ConfigData
    {
        public Options Options;
    }

     class Options
    {
        public bool Enable_Toggle;
        public string Output_Color;
        public string Time_Format;
    }

    private void LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConfig(ConfigData config);
    protected override void LoadDefaultMessages();
}

 class ConfigData
{
    public Options Options;
}

 class Options
{
    public bool Enable_Toggle;
    public string Output_Color;
    public string Time_Format;
}


```

---

## ConsoleFilter by MrBlue - Filters debug, test, and other undesired output in the server console

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Console Filter", "Wulf", "0.0.2")]
[Description("Filters debug, test, and other undesired output in the server console")]
 class ConsoleFilter : CovalencePlugin
{
    private Configuration config;
     class Configuration
    {
        [JsonProperty("List of partial strings to filter", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Filter;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Init();
    private void Unload();
    private void HandleLog(string message, string stackTrace, UnityEngine.LogType type);
}

 class Configuration
{
    [JsonProperty("List of partial strings to filter", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Filter;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## ConsoleWelcome by Ryz0r - Sends a message to a players F1 console upon joining the server

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("Console Welcome", "Ryz0r", "1.0.0"), Description("Sends a welcome message to the console when a player connects.")]
public class ConsoleWelcome : RustPlugin
{
    private static string consolePerm;
    private void Init();
    private void OnPlayerConnected(BasePlayer player);
    protected override void LoadDefaultMessages();
}


```

---

## ContainerControl by Hamster - Allows you to restrict types of items which can be put in a certain kind of containers

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;

Oxide.Plugins
[Info("ContainerControl", "Hamster", "1.0.1")]
[Description("Allows you to restrict types of items which can be put in a certain kind of containers")]
 class ContainerControl : RustPlugin
{
    private PluginConfig config;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos);
}


```

---

## ConvertStatus by  - Changes your admin status on command

```csharp
using System.Collections.Generic;

Oxide.Plugins
[Info("Convert Status", "Orange", "1.0.8")]
[Description("Change your admin status by a command")]
public class ConvertStatus : RustPlugin
{
    private const string perm_use;
    private void Init();
    [ChatCommand("convert")]
    private void CmdConvert(BasePlayer p);
    private void Convert(BasePlayer p);
    private bool HasPerm(BasePlayer p, string s);
    private Dictionary<string, string> messagesEN;
    private Dictionary<string, string> messagesRU;
    private void message(BasePlayer player, string key, object[] args);
}


```

---

## CoptorTracker by k1lly0u - Spawns helicopters based on a timer, sets a lifetime, and announcements

```csharp
using System;
using UnityEngine;

Oxide.Plugins
[Info("Chopper Tracker", "Smoosher", "1.6.7", ResourceId = 1468)]
[Description("Spawns helicopters based on a timer, sets a lifetime, and announcements")]
 class CoptorTracker : RustPlugin
{
     DateTime TimerStart;
     int ChopperSpawnTime;
     float ChopperLifeTimeOriginal;
     float ChopperLifeTimeCurrent;
     DateTime TimerSpawn;
     DateTime ChopperSpawned;
     bool SpawnedHeli;
    protected override void LoadDefaultConfig();
     void SetConfig();
     bool TrueorFalse(string input);
     void Loaded();
    [ChatCommand("Nextheli")]
     void NextCoptor(BasePlayer player, string command, string[] args);
    [ChatCommand("KillAllHelis")]
     void KillHelis(BasePlayer player, string command, string[] args);
    [ChatCommand("SpawnHeli")]
     void SpawnHeli(BasePlayer player, string command, string[] args);
     void StartChopperSpawnFreq();
     void SetChopperLifetimeMins();
     void SpawnChopper();
     void OnEntitySpawned(BaseNetworkable entity);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
     void KillCoptor(BaseNetworkable entity);
     void KillCoptor();
}


```

---

## CopyPaste by misticos - Copy and paste your buildings to save them or move them

```csharp
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Libraries.Covalence;
using ProtoBuf;
using UnityEngine;
using Graphics = System.Drawing.Graphics;

Oxide.Plugins
[Info("Copy Paste", "misticos", "4.2.0")]
[Description("Copy and paste buildings to save them or move them")]
public class CopyPaste : CovalencePlugin
{
    private readonly Item _emptyItem;
    private readonly IPlayer _consolePlayer;
    private int _copyLayer;
    private int _groundLayer;
    private int _rayCopy;
    private int _rayPaste;
    private string _copyPermission;
    private string _listPermission;
    private string _pastePermission;
    private string _pastebackPermission;
    private string _undoPermission;
    private string _subDirectory;
    private Dictionary<string, Stack<List<BaseEntity>>> _lastPastes;
    private Dictionary<string, SignSize> _signSizes;
    private HashSet<Type> ItemModAssociatedEntities;
    private List<BaseEntity.Slot> _checkSlots;
    private class SignSize
    {
        public int Width;
        public int Height;
        public SignSize(int width, int height);
    }

    private ConfigData _config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Copy Options")]
        public CopyOptions Copy { get; set; }
        [JsonProperty(PropertyName = "Paste Options")]
        public PasteOptions Paste { get; set; }
        [JsonProperty(PropertyName =
                "Amount of entities to paste per batch. Use to tweak performance impact of pasting")]
        [DefaultValue(15)]
        public int PasteBatchSize;
        [JsonProperty(PropertyName =
                "Amount of entities to copy per batch. Use to tweak performance impact of copying")]
        [DefaultValue(100)]
        public int CopyBatchSize;
        [JsonProperty(PropertyName =
                "Amount of entities to undo per batch. Use to tweak performance impact of undoing")]
        [DefaultValue(15)]
        public int UndoBatchSize;
        [JsonProperty(PropertyName = "Enable data saving feature")]
        [DefaultValue(true)]
        public bool DataSaving;
        public class CopyOptions
        {
            [JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
            [DefaultValue(true)]
            public bool EachToEach { get; set; }
            [JsonProperty(PropertyName = "Share (true/false)")]
            [DefaultValue(false)]
            public bool Share { get; set; }
            [JsonProperty(PropertyName = "Tree (true/false)")]
            [DefaultValue(false)]
            public bool Tree { get; set; }
            [JsonProperty(PropertyName = "Default radius to look for entities from block")]
            [DefaultValue(3.0f)]
            public float Radius { get; set; }
        }

        public class PasteOptions
        {
            [JsonProperty(PropertyName = "Auth (true/false)")]
            [DefaultValue(false)]
            public bool Auth { get; set; }
            [JsonProperty(PropertyName = "Deployables (true/false)")]
            [DefaultValue(true)]
            public bool Deployables { get; set; }
            [JsonProperty(PropertyName = "Inventories (true/false)")]
            [DefaultValue(true)]
            public bool Inventories { get; set; }
            [JsonProperty(PropertyName = "Vending Machines (true/false)")]
            [DefaultValue(true)]
            public bool VendingMachines { get; set; }
            [JsonProperty(PropertyName = "Stability (true/false)")]
            [DefaultValue(true)]
            public bool Stability { get; set; }
            [JsonProperty(PropertyName = "EntityOwner (true/false)")]
            [DefaultValue(true)]
            public bool EntityOwner { get; set; }
        }

    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void Init();
    private void OnServerInitialized();
    private object TryCopyFromSteamId(ulong userId, string filename, string[] args, Action callback);
    private object TryPasteFromSteamId(ulong userId, string filename, string[] args, Action callback, Action<BaseEntity> callbackSpawned);
    private object TryPasteFromVector3(Vector3 pos, float rotationCorrection, string filename, string[] args, Action callback, Action<BaseEntity> callbackSpawned);
    private ValueTuple<object, Action> TryPasteFromVector3Cancellable(Vector3 pos, float rotationCorrection, string filename, string[] args, Action callback, Action<BaseEntity> callbackSpawned);
    private object CheckCollision(HashSet<Dictionary<string, object>> entities, Vector3 startPos, float radius);
    private bool CheckPlaced(string prefabname, Vector3 pos, Quaternion rot);
    private void UndoLoop(HashSet<BaseEntity> entities, IPlayer player, int count);
    private void Copy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection, CopyMechanics copyMechanics, float range, bool saveTree, bool saveShare, bool eachToEach, IPlayer player, Action callback);
    private void CopyLoop(CopyData copyData);
    private float DegreeToRadian(float angle);
    private Dictionary<string, object> EntityData(BaseEntity entity, Vector3 entPos, Vector3 entRot, CopyData copyData);
    private List<object> GetLineAnchors(IOEntity.LineAnchor[] lineAnchors, IOEntity ioEntity);
    private object FindBestHeight(HashSet<Dictionary<string, object>> entities, Vector3 startPos);
    private bool FindRayEntity(Vector3 sourcePos, Vector3 sourceDir, Vector3 point, BaseEntity entity, int rayLayer);
    private byte[] FixSignage(ISignage iSignage, byte[] imageBytes);
    private object GetGround(Vector3 pos);
    private int GetItemId(int itemId);
    private bool HasAccess(IPlayer player, string permName);
    private byte[] ImageResize(byte[] imageBytes, int width, int height);
    private string Lang(string key, string userId, object[] args);
    private Vector3 NormalizePosition(Vector3 initialPos, Vector3 currentPos, float diffRot);
    private PasteData Paste(ICollection<Dictionary<string, object>> entities, Dictionary<string, object> protocol, bool ownership, Vector3 startPos, IPlayer player, bool stability, float rotationCorrection, float heightAdj, bool auth, Action callback, Action<BaseEntity> callbackSpawned, string filename, bool checkPlaced, bool enableSaving);
    private void PasteLoop(PasteData pasteData);
    private void PasteEntity(Dictionary<string, object> data, PasteData pasteData, BaseEntity parent);
    private void ProgressIOEntity(Dictionary<string, object> ioData, PasteData pasteData);
    private void SetItemSubEntity(PasteData pasteData, Item item, ulong oldId);
    private void ExtractInventory(Dictionary<string, object> data, ItemContainer inventory, CopyData copyData);
    private void PopulateInventory(PasteData pasteData, Dictionary<string,object> data, BaseEntity entity, ItemContainer inventory);
     void ExtractTextures(Dictionary<string, object> data, uint[] textureIDs, BaseEntity entity, FileStorage.Type type);
     void ExtractCassette(Dictionary<string, object> data, Cassette cassette);
     void PopulateCassette(Dictionary<string, object> data, Cassette cassette);
     void ExtractHeadData(Dictionary<string, object> data, HeadData headData);
     void PopulateHeadData(Dictionary<string,object> data, HeadData headData);
    private HashSet<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos, float rotationCorrection, bool deployables, bool inventories, bool auth, bool vending);
    private void PreLoadChildrenData(Dictionary<string, object> entity);
    private object TryCopy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection, string[] args, IPlayer player, Action callback);
    private bool GetSlot(BaseEntity parent, BaseEntity child, BaseEntity.Slot? slot);
    private Dictionary<string, object> TryCopyFlags(BaseEntity entity);
    private ValueTuple<object, PasteData> TryPaste(Vector3 startPos, string filename, IPlayer player, float rotationCorrection, string[] args, bool autoHeight, Action callback, Action<BaseEntity> callbackSpawned);
    private void TryPasteLocks(BaseEntity entity, Dictionary<string, object> data, PasteData pasteData);
    private List<BaseEntity> TryPasteSlots(BaseEntity ent, Dictionary<string, object> structure, PasteData pasteData);
    private List<IndustrialConveyor.ItemFilter> DeSerializeConveyorFilter(string itemstring);
    private string SerializeConveyorFilter(List<IndustrialConveyor.ItemFilter> filterItems, string itemstring);
    private List<ProtoBuf.PatternFirework.Star> DeSerializeStarPattern(string stars);
    private string SerializeStarPattern(List<ProtoBuf.PatternFirework.Star> stars, string starstring);
    private object TryPasteBack(string filename, IPlayer player, string[] args);
    private static bool HasGrade(BuildingBlock block, BuildingGrade.Enum grade, ulong skin);
    [Command("copy")]
    private void CmdCopy(IPlayer player, string command, string[] args);
    [Command("paste")]
    private void CmdPaste(IPlayer player, string command, string[] args);
    [Command("copylist")]
    private void CmdList(IPlayer player, string command, string[] args);
    [Command("pasteback")]
    private void CmdPasteBack(IPlayer player, string command, string[] args);
    [Command("undo")]
    private void CmdUndo(IPlayer player, string command, string[] args);
    private static readonly Dictionary<int, int> ReplaceItemId;
    private readonly Dictionary<string, Dictionary<string, string>> _messages;
    public class CopyData
    {
        public IPlayer Player;
        public BasePlayer BasePlayer;
        public Stack<Vector3> CheckFrom;
        public HashSet<BaseEntity> HouseList;
        public List<object> RawData;
        public Vector3 SourcePos;
        public Vector3 SourceRot;
        public Action Callback;
        public string Filename;
        public int CurrentLayer;
        public float RotCor;
        public float Range;
        public bool SaveTree;
        public bool SaveShare;
        public CopyMechanics CopyMechanics;
        public bool EachToEach;
        public uint BuildingId;
    }

    public class PasteData
    {
        public ICollection<Dictionary<string, object>> Entities;
        public List<BaseEntity> PastedEntities;
        public string Filename;
        public Dictionary<ulong, Dictionary<string, object>> EntityLookup;
        public Dictionary<ulong, Item> ItemsWithSubEntity;
        public List<Action> FinalProcessingActions;
        public IPlayer Player;
        public BasePlayer BasePlayer;
        public List<StabilityEntity> StabilityEntities;
        public List<IndustrialStorageAdaptor> industrialStorageAdaptors;
        public Quaternion QuaternionRotation;
        public Action CallbackFinished;
        public Action<BaseEntity> CallbackSpawned;
        public bool Auth;
        public Vector3 StartPos;
        public float HeightAdj;
        public bool Stability;
        public bool IsItemReplace;
        public bool Ownership;
        public bool CheckPlaced;
        public bool EnableSaving;
        public bool Cancelled;
        public uint BuildingId;
        public VersionNumber Version { get; set; }
    }

    private VersionNumber ParseVersionNumber(string versionString);
}

private class SignSize
{
    public int Width;
    public int Height;
    public SignSize(int width, int height);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Copy Options")]
    public CopyOptions Copy { get; set; }
    [JsonProperty(PropertyName = "Paste Options")]
    public PasteOptions Paste { get; set; }
    [JsonProperty(PropertyName =
                "Amount of entities to paste per batch. Use to tweak performance impact of pasting")]
    [DefaultValue(15)]
    public int PasteBatchSize;
    [JsonProperty(PropertyName =
                "Amount of entities to copy per batch. Use to tweak performance impact of copying")]
    [DefaultValue(100)]
    public int CopyBatchSize;
    [JsonProperty(PropertyName =
                "Amount of entities to undo per batch. Use to tweak performance impact of undoing")]
    [DefaultValue(15)]
    public int UndoBatchSize;
    [JsonProperty(PropertyName = "Enable data saving feature")]
    [DefaultValue(true)]
    public bool DataSaving;
    public class CopyOptions
    {
        [JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
        [DefaultValue(true)]
        public bool EachToEach { get; set; }
        [JsonProperty(PropertyName = "Share (true/false)")]
        [DefaultValue(false)]
        public bool Share { get; set; }
        [JsonProperty(PropertyName = "Tree (true/false)")]
        [DefaultValue(false)]
        public bool Tree { get; set; }
        [JsonProperty(PropertyName = "Default radius to look for entities from block")]
        [DefaultValue(3.0f)]
        public float Radius { get; set; }
    }

    public class PasteOptions
    {
        [JsonProperty(PropertyName = "Auth (true/false)")]
        [DefaultValue(false)]
        public bool Auth { get; set; }
        [JsonProperty(PropertyName = "Deployables (true/false)")]
        [DefaultValue(true)]
        public bool Deployables { get; set; }
        [JsonProperty(PropertyName = "Inventories (true/false)")]
        [DefaultValue(true)]
        public bool Inventories { get; set; }
        [JsonProperty(PropertyName = "Vending Machines (true/false)")]
        [DefaultValue(true)]
        public bool VendingMachines { get; set; }
        [JsonProperty(PropertyName = "Stability (true/false)")]
        [DefaultValue(true)]
        public bool Stability { get; set; }
        [JsonProperty(PropertyName = "EntityOwner (true/false)")]
        [DefaultValue(true)]
        public bool EntityOwner { get; set; }
    }

}

public class CopyOptions
{
    [JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
    [DefaultValue(true)]
    public bool EachToEach { get; set; }
    [JsonProperty(PropertyName = "Share (true/false)")]
    [DefaultValue(false)]
    public bool Share { get; set; }
    [JsonProperty(PropertyName = "Tree (true/false)")]
    [DefaultValue(false)]
    public bool Tree { get; set; }
    [JsonProperty(PropertyName = "Default radius to look for entities from block")]
    [DefaultValue(3.0f)]
    public float Radius { get; set; }
}

public class PasteOptions
{
    [JsonProperty(PropertyName = "Auth (true/false)")]
    [DefaultValue(false)]
    public bool Auth { get; set; }
    [JsonProperty(PropertyName = "Deployables (true/false)")]
    [DefaultValue(true)]
    public bool Deployables { get; set; }
    [JsonProperty(PropertyName = "Inventories (true/false)")]
    [DefaultValue(true)]
    public bool Inventories { get; set; }
    [JsonProperty(PropertyName = "Vending Machines (true/false)")]
    [DefaultValue(true)]
    public bool VendingMachines { get; set; }
    [JsonProperty(PropertyName = "Stability (true/false)")]
    [DefaultValue(true)]
    public bool Stability { get; set; }
    [JsonProperty(PropertyName = "EntityOwner (true/false)")]
    [DefaultValue(true)]
    public bool EntityOwner { get; set; }
}

public class CopyData
{
    public IPlayer Player;
    public BasePlayer BasePlayer;
    public Stack<Vector3> CheckFrom;
    public HashSet<BaseEntity> HouseList;
    public List<object> RawData;
    public Vector3 SourcePos;
    public Vector3 SourceRot;
    public Action Callback;
    public string Filename;
    public int CurrentLayer;
    public float RotCor;
    public float Range;
    public bool SaveTree;
    public bool SaveShare;
    public CopyMechanics CopyMechanics;
    public bool EachToEach;
    public uint BuildingId;
}

public class PasteData
{
    public ICollection<Dictionary<string, object>> Entities;
    public List<BaseEntity> PastedEntities;
    public string Filename;
    public Dictionary<ulong, Dictionary<string, object>> EntityLookup;
    public Dictionary<ulong, Item> ItemsWithSubEntity;
    public List<Action> FinalProcessingActions;
    public IPlayer Player;
    public BasePlayer BasePlayer;
    public List<StabilityEntity> StabilityEntities;
    public List<IndustrialStorageAdaptor> industrialStorageAdaptors;
    public Quaternion QuaternionRotation;
    public Action CallbackFinished;
    public Action<BaseEntity> CallbackSpawned;
    public bool Auth;
    public Vector3 StartPos;
    public float HeightAdj;
    public bool Stability;
    public bool IsItemReplace;
    public bool Ownership;
    public bool CheckPlaced;
    public bool EnableSaving;
    public bool Cancelled;
    public uint BuildingId;
    public VersionNumber Version { get; set; }
}


```

---

## Cornucopia by  - The horn of plenty! Spawn extra crates, barrels, nodes, animals, etc. randomly on the map

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Cornucopia", "Deicide666ra", "1.1.8", ResourceId = 1264)]
 class Cornucopia : RustPlugin
{
     class CornuConfig
    {
        public CornuConfig();
        public int RefreshMinutes;
        public bool ApplyLootFix;
        public bool RefreshOnStart;
        public List<CornuConfigItem> Animals;
        public List<CornuConfigItem> Ores;
        public List<CornuConfigItem> Loots;
    }

     class CornuConfigItem
    {
        public string Prefab;
        public int Min;
        public int Max;
        public bool IgnoreIrridiated;
        public bool DeleteEmtpy;
    }

     CornuConfig g_config;
     Timer g_refreshTimer;
     void Loaded();
    protected override void LoadDefaultConfig();
     void LoadConfigValues();
     void SendHelpText(BasePlayer player);
     void OnServerInitialized();
     void OnTimer();
     void Unloaded();
     Dictionary<string, int> GetCollectibles();
     Dictionary<string, IGrouping<string, BaseEntity>> GetOreNodes();
     Dictionary<string, IGrouping<string, BaseEntity>> GetLootContainers();
     Dictionary<string, IGrouping<string, BaseEntity>> GetAnimals();
     void DumpSpawns(Dictionary<string, int> entities);
     void DumpSpawns(Dictionary<string, IGrouping<string, BaseEntity>> entities);
    [ConsoleCommand("cornu.dump")]
     void DumpCommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("cornu.spawn")]
     void SpawnCommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("cornu.fixloot")]
     void FixLootCommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("cornu.purge")]
     void PurgeCommand(ConsoleSystem.Arg arg);
     void DumpEntities();
     Vector2 GetBoxPos(LootContainer box);
    [ChatCommand("cpurge")]
     void cmdPurge(BasePlayer player, string command, string[] args);
    [ChatCommand("cfixloot")]
     void cmdFixLoot(BasePlayer player, string command, string[] args);
    [ChatCommand("cdump")]
     void cmdDump(BasePlayer player, string command, string[] args);
    [ChatCommand("cspawn")]
     void cmdSpawn(BasePlayer player, string command, string[] args);
    [ChatCommand("ctest")]
     void cmdTest(BasePlayer player, string command, string[] args);
     void SubCycle(IEnumerable<BaseEntity> entities, IEnumerable<CornuConfigItem> limits, List<CollectibleEntity> collectibles, bool aborted);
     void MainSpawnCycle();
     void PopulationControl(IEnumerable<BaseEntity> matches, int cap);
     void BatchSpawn(int current, int wanted, string prefab, List<CollectibleEntity> collectibles, bool aborted);
     void ReplaceCollectibleWithSomething(string prefabName, List<CollectibleEntity> collectibles);
     void FixLoot(BasePlayer player);
     void Purge();
}

 class CornuConfig
{
    public CornuConfig();
    public int RefreshMinutes;
    public bool ApplyLootFix;
    public bool RefreshOnStart;
    public List<CornuConfigItem> Animals;
    public List<CornuConfigItem> Ores;
    public List<CornuConfigItem> Loots;
}

 class CornuConfigItem
{
    public string Prefab;
    public int Min;
    public int Max;
    public bool IgnoreIrridiated;
    public bool DeleteEmtpy;
}


```

---

## Coroutines by birthdates - Allows other plugins to spread out large workloads over time to reduce lag spikes

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Coroutines", "birthdates", "3.0.8")]
[Description(
        "Allows other plugins to spread out large workloads over time to reduce lag spikes")]
public class Coroutines : CovalencePlugin
{
    private readonly LinkedList<KeyValuePair<string, LinkedList<Coroutine>>> _coroutines;
    private int _currentCoroutineCount;
    private readonly IDictionary<string, Number> _maxCoroutineCounter;
    private readonly IDictionary<string, int> _idToMax;
    private readonly LinkedList<Coroutine> _queuedCoroutines;
    private readonly Stopwatch _stopwatch;
    public static Coroutines Instance { get; set; }
    public class Coroutine
    {
        public Coroutine(Plugin owner, IEnumerator instructions, Action onComplete, string id, int cachedMaxInstances);
        public int CachedMaxInstances { get; set; }
        public bool HasCounter { get; set; }
        public string Id { get; set; }
        public Plugin Owner { get; set; }
        private LinkedList<IEnumerator> RecursiveInstructions { get; set; }
        private IEnumerator CurrentInstructions { get; set; }
        private int CurrentStage { get; set; }
        private int CurrentLevel { get; set; }
        public bool Stop { get; set; }
        private Action OnComplete { get; set; }
        public void Tick(float deltaTime);
        private string GetIdOrEmpty();
        private void CheckForInstructionRecursion();
        private void CheckStopwatch();
        private bool UpdateCurrentInstructions();
    }

    public class WaitForMilliseconds : ICoroutineInstruction
    {
        public WaitForMilliseconds(float time);
        public WaitForMilliseconds(float time, bool realTime);
        private bool RealTime { get; set; }
        private static DateTime DateTime { get; set; }
        private static double Milliseconds { get; set; }
        private static Func<DateTime, double> GetMilliseconds { get; set; }
        private double ExpiryTime { get; set; }
        protected float Time { get; set; }
        public bool IsCompleted { get; set; }
        public void Tick(float deltaTime);
        public void Reset(float time);
        public void Reset(float time, bool realTime);
    }

    public class WaitForSeconds : WaitForMilliseconds
    {
        public WaitForSeconds(float time);
        public WaitForSeconds(float time, bool realTime);
        public new void Reset(float time);
        public new void Reset(float time, bool realTime);
    }

    public class WaitForBool : ICoroutineInstruction
    {
        public WaitForBool(Func<bool> predicate);
        private Func<bool> Predicate { get; set; }
        public bool IsCompleted { get; set; }
        public void Tick(float deltaTime);
    }

    private void Init();
    private void Unload();
    private void OnFrame(float deltaTime);
    private void OnPluginUnloaded(Plugin plugin);
    [HookMethod("RegisterMax")]
    public void RegisterMax(string id, int max);
    [HookMethod("UnregisterMax")]
    public bool UnregisterMax(string id);
    [HookMethod("GetDelayedTask")]
    public Coroutine GetDelayedTask(Plugin owner, Action task, float initialDelay, string id, Action onComplete);
    [HookMethod("GetAsynchronousRepeatingTask")]
    public Coroutine GetAsynchronousRepeatingTask(Plugin owner, Func<bool> continuePredicate, float interval, float initialDelay, string id, Action onComplete);
    public Coroutine LoopListAsynchronously(Plugin owner, Action<T> callback, IList<T> list, float interval, int startIndex, bool reverse, int completePerTick, float initialDelay, string id, Action onComplete);
    public Coroutine LoopListAsynchronously(Plugin owner, Func<T, bool> callback, IList<T> list, float interval, int startIndex, bool reverse, int completePerTick, float initialDelay, string id, Action onComplete);
    public Coroutine SearchListAsynchronously(Plugin owner, T target, Action<bool> callback, IList<T> list, float interval, int startIndex, bool reverse, int completePerTick, float initialDelay, string id);
    public Coroutine SearchDictionaryAsynchronously(Plugin owner, TK target, Action<TV> callback, IDictionary<TK, TV> dictionary, float interval, int completePerTick, float initialDelay, string id);
    public Coroutine SearchAsynchronously(Plugin owner, TK target, T item, Func<T, int> getSize, Func<int, T, bool> keepSearchGoing, Func<int, TK, T, TV> handleSearchIndex, Action<TV> callback, float interval, int completePerTick, float initialDelay, string id);
    private void FindPlayerAsynchronously(Plugin owner, string data, Action<T> callback, bool includeName, bool ignoreCase, float interval, int completePerTick, float initialDelay, bool reverse, int startIndex, string id);
    private IEnumerable<Coroutine> GetCoroutinesById(string id);
    public bool IsCoroutineRunning(string id);
    [HookMethod("StopCoroutine")]
    public bool StopCoroutine(string id);
    [HookMethod("StopCoroutines")]
    private void StopCoroutines(Plugin owner);
    private void StartCheckingQueue();
    private void CheckQueue();
    private void RemoveFromQueue(int allowed);
    private bool CanTakeCoroutine(int count);
    private int GetMaximumInstances(string id);
    [HookMethod("CreateCoroutine")]
    private Coroutine CreateCoroutine(Plugin owner, IEnumerator enumerator, string id, Action onComplete);
    public bool StartCoroutine(Coroutine coroutine);
    private bool CanTakeCoroutine(string id, int max);
    private void ForcefullyAddCoroutine(Coroutine coroutine);
    private static void StopCoroutines(IEnumerable<Coroutine> coroutines);
    private static bool StopCoroutine(Coroutine coroutine);
    private static IEnumerator GetInitialDelayCoroutine(float initialDelay, Action task, WaitForSeconds waitForSeconds);
    private static IEnumerator GetRepeatingCoroutine(Func<bool> continuePredicate, float interval, float initialDelay);
    private IEnumerable<LinkedList<Coroutine>> GetAllCoroutines();
    private bool TryGetCoroutines(string owner, LinkedList<Coroutine> coroutines);
    private static void RestartStopWatch(Stopwatch stopwatch);
    private static float SecondsToMilliseconds(float time);
    private class Number
    {
        public Number(int value);
        public int Max { get; set; }
        public int Value { get; set; }
    }

    private ConfigFile _config;
    private class ConfigFile
    {
        [JsonProperty("Max Routines (others will be stacked up in a queue)")]
        public int MaxRoutines { get; set; }
        [JsonProperty("Queue Check Time (Seconds)")]
        public float QueueCheckTime { get; set; }
        [JsonProperty("Check Queue on Frame?")]
        public bool CheckQueueOnFrame { get; set; }
        [JsonProperty("Execution Warn Time (Milliseconds)")]
        public long WarnTimeMilliseconds { get; set; }
        [JsonProperty("Print Stacktrace on Warn?")]
        public bool PrintStackTraceOnWarn { get; set; }
        [JsonProperty("Use scaled time for time calculations?")]
        public bool UseScaledTime { get; set; }
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class Coroutine
{
    public Coroutine(Plugin owner, IEnumerator instructions, Action onComplete, string id, int cachedMaxInstances);
    public int CachedMaxInstances { get; set; }
    public bool HasCounter { get; set; }
    public string Id { get; set; }
    public Plugin Owner { get; set; }
    private LinkedList<IEnumerator> RecursiveInstructions { get; set; }
    private IEnumerator CurrentInstructions { get; set; }
    private int CurrentStage { get; set; }
    private int CurrentLevel { get; set; }
    public bool Stop { get; set; }
    private Action OnComplete { get; set; }
    public void Tick(float deltaTime);
    private string GetIdOrEmpty();
    private void CheckForInstructionRecursion();
    private void CheckStopwatch();
    private bool UpdateCurrentInstructions();
}

public class WaitForMilliseconds : ICoroutineInstruction
{
    public WaitForMilliseconds(float time);
    public WaitForMilliseconds(float time, bool realTime);
    private bool RealTime { get; set; }
    private static DateTime DateTime { get; set; }
    private static double Milliseconds { get; set; }
    private static Func<DateTime, double> GetMilliseconds { get; set; }
    private double ExpiryTime { get; set; }
    protected float Time { get; set; }
    public bool IsCompleted { get; set; }
    public void Tick(float deltaTime);
    public void Reset(float time);
    public void Reset(float time, bool realTime);
}

public class WaitForSeconds : WaitForMilliseconds
{
    public WaitForSeconds(float time);
    public WaitForSeconds(float time, bool realTime);
    public new void Reset(float time);
    public new void Reset(float time, bool realTime);
}

public class WaitForBool : ICoroutineInstruction
{
    public WaitForBool(Func<bool> predicate);
    private Func<bool> Predicate { get; set; }
    public bool IsCompleted { get; set; }
    public void Tick(float deltaTime);
}

private class Number
{
    public Number(int value);
    public int Max { get; set; }
    public int Value { get; set; }
}

private class ConfigFile
{
    [JsonProperty("Max Routines (others will be stacked up in a queue)")]
    public int MaxRoutines { get; set; }
    [JsonProperty("Queue Check Time (Seconds)")]
    public float QueueCheckTime { get; set; }
    [JsonProperty("Check Queue on Frame?")]
    public bool CheckQueueOnFrame { get; set; }
    [JsonProperty("Execution Warn Time (Milliseconds)")]
    public long WarnTimeMilliseconds { get; set; }
    [JsonProperty("Print Stacktrace on Warn?")]
    public bool PrintStackTraceOnWarn { get; set; }
    [JsonProperty("Use scaled time for time calculations?")]
    public bool UseScaledTime { get; set; }
    public static ConfigFile DefaultConfig();
}


```

---

## CorpseLocation by nivex - Allows player to locate and teleport to their last corpse

```csharp
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Corpse Location", "shinnova", "2.3.8")]
[Description("Allows users to locate their latest corpse")]
internal class CorpseLocation : RustPlugin
{
    [PluginReference]
     Plugin ZoneManager;
     Plugin AbandonedBases;
     Plugin RaidableBases;
    private const string UsePerm;
    private const string TPPerm;
    private const string VIPPerm;
    private const string AdminPerm;
    private const string NoCostPerm;
    private Dictionary<string, Timer> ActiveTimers;
    private Dictionary<string, Vector3> ReturnLocations;
    public class StoredData
    {
        public Dictionary<string, string> deaths;
        public Dictionary<string, int> teleportsRemaining;
        public StoredData();
    }

    private StoredData storedData;
    private void NewData();
    private void LoadData();
    private void SaveData();
    private void OnNewSave(string filename);
    private void OnServerSave();
    private void Unload();
    private void OnServerInitialized();
    private void OnPlayerRespawned(BasePlayer player);
    private void OnEntityDeath(BasePlayer player, HitInfo info);
    private void OnEntitySpawned(PlayerCorpse corpse);
    private void OnUserPermissionGranted(string id, string permName);
    private void OnUserGroupAdded(string id, string groupName);
    private void StartResetTimer();
    public bool CanPlayerTeleport(BasePlayer player, Vector3 to);
    private object OnBlockRaidableBasesTeleport(BasePlayer player, Vector3 to);
    private object OnBlockAbandonedBasesTeleport(BasePlayer player, Vector3 to);
    private static string PositionToGrid(Vector3 position);
    private void SendCorpseLocation(BasePlayer player, Vector3 location);
    private List<BasePlayer> GetPlayers(string NameOrID);
    [ChatCommand("where")]
    private void whereCommand(BasePlayer player, string command, string[] args);
    private bool TryPay(BasePlayer player, PaymentMethod m);
    private bool TryPay(BasePlayer player, PlayerType playerType, AmountType amountType, double amount, string pluginName, string balanceHook, string withdrawHook, string formattedCost);
    [HookMethod("Teleport")]
    public bool Teleport(BasePlayer player, Vector3 to, bool free);
    public void StartSleeping(BasePlayer player);
    [ChatCommand("return")]
    private void returnCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("tpcorpse")]
    private void tpCommand(BasePlayer player, string command, string[] args);
    private bool IsFree(BasePlayer player, string[] args);
    protected override void LoadDefaultMessages();
    private void Message(BasePlayer player, string key, object[] args);
    private Configuration config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "Teleport payment methods", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<PaymentMethod> Payments;
        [JsonProperty(PropertyName = "Show grid location")]
        public bool showGrid;
        [JsonProperty(PropertyName = "Track a corpse's location for x seconds")]
        public int trackTime;
        [JsonProperty(PropertyName = "Allow teleporting to own corpse x times per day (0 for unlimited)")]
        public int tpAmount;
        [JsonProperty(PropertyName = "Allow teleporting to own corpse x times per day (0 for unlimited), for VIPs")]
        public int viptpAmount;
        [JsonProperty(PropertyName = "Allow returning to original location after teleporting")]
        public bool allowReturn;
        [JsonProperty(PropertyName = "Countdown until teleporting to own corpse (0 for instant tp)")]
        public float tpCountdown;
        [JsonProperty(PropertyName = "Block teleports into Zone Manager's tp blocked zones")]
        public bool blockToZM;
        [JsonProperty(PropertyName = "Block teleports from Zone Manager's tp blocked zones")]
        public bool blockFromZM;
        [JsonProperty(PropertyName = "Block teleports into building blocked areas")]
        public bool blockToBuildBlocked;
        [JsonProperty(PropertyName = "Block teleports from building blocked areas")]
        public bool blockFromBuildBlocked;
        [JsonProperty(PropertyName = "Ignore Abandoned Bases")]
        public bool ignoreAB;
        [JsonProperty(PropertyName = "Ignore Raidable Bases")]
        public bool ignoreRB;
        [JsonProperty(PropertyName = "Reset players' remaining teleports at this time (HH:mm:ss format)")]
        public string resetTime;
        [JsonProperty(PropertyName = "Chat steam id")]
        public ulong steamId;
        [JsonProperty(PropertyName = "Allow admins to specify 'nocost' in commands")]
        public bool nocost;
        [JsonProperty(PropertyName = "ServerRewards Cost", NullValueHandling = NullValueHandling.Ignore)]
        public int? SRC { get; set; }
        [JsonProperty(PropertyName = "Economics Cost", NullValueHandling = NullValueHandling.Ignore)]
        public double? EC { get; set; }
    }

    public class PaymentMethod
    {
        [JsonProperty(PropertyName = "Player Type (0 = BasePlayer, 1 = String, 2 = ULong)")]
        public PlayerType PlayerType;
        [JsonProperty(PropertyName = "Amount Type (0 = Double, 1 = Float, 2 = Int)")]
        public AmountType AmountType;
        public bool Enabled;
        [JsonProperty(PropertyName = "Cost")]
        public double Amount;
        public string PluginName;
        public string BalanceHook;
        public string WithdrawHook;
        public string CostFormat;
        public PaymentMethod(bool enabled, PlayerType playerType, AmountType amountType, double amount, string pluginName, string balanceHook, string withdrawHook, string costFormat);
        internal bool IsEnabled { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private bool canSaveConfig;
    protected override void SaveConfig();
}

public class StoredData
{
    public Dictionary<string, string> deaths;
    public Dictionary<string, int> teleportsRemaining;
    public StoredData();
}

public class Configuration
{
    [JsonProperty(PropertyName = "Teleport payment methods", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<PaymentMethod> Payments;
    [JsonProperty(PropertyName = "Show grid location")]
    public bool showGrid;
    [JsonProperty(PropertyName = "Track a corpse's location for x seconds")]
    public int trackTime;
    [JsonProperty(PropertyName = "Allow teleporting to own corpse x times per day (0 for unlimited)")]
    public int tpAmount;
    [JsonProperty(PropertyName = "Allow teleporting to own corpse x times per day (0 for unlimited), for VIPs")]
    public int viptpAmount;
    [JsonProperty(PropertyName = "Allow returning to original location after teleporting")]
    public bool allowReturn;
    [JsonProperty(PropertyName = "Countdown until teleporting to own corpse (0 for instant tp)")]
    public float tpCountdown;
    [JsonProperty(PropertyName = "Block teleports into Zone Manager's tp blocked zones")]
    public bool blockToZM;
    [JsonProperty(PropertyName = "Block teleports from Zone Manager's tp blocked zones")]
    public bool blockFromZM;
    [JsonProperty(PropertyName = "Block teleports into building blocked areas")]
    public bool blockToBuildBlocked;
    [JsonProperty(PropertyName = "Block teleports from building blocked areas")]
    public bool blockFromBuildBlocked;
    [JsonProperty(PropertyName = "Ignore Abandoned Bases")]
    public bool ignoreAB;
    [JsonProperty(PropertyName = "Ignore Raidable Bases")]
    public bool ignoreRB;
    [JsonProperty(PropertyName = "Reset players' remaining teleports at this time (HH:mm:ss format)")]
    public string resetTime;
    [JsonProperty(PropertyName = "Chat steam id")]
    public ulong steamId;
    [JsonProperty(PropertyName = "Allow admins to specify 'nocost' in commands")]
    public bool nocost;
    [JsonProperty(PropertyName = "ServerRewards Cost", NullValueHandling = NullValueHandling.Ignore)]
    public int? SRC { get; set; }
    [JsonProperty(PropertyName = "Economics Cost", NullValueHandling = NullValueHandling.Ignore)]
    public double? EC { get; set; }
}

public class PaymentMethod
{
    [JsonProperty(PropertyName = "Player Type (0 = BasePlayer, 1 = String, 2 = ULong)")]
    public PlayerType PlayerType;
    [JsonProperty(PropertyName = "Amount Type (0 = Double, 1 = Float, 2 = Int)")]
    public AmountType AmountType;
    public bool Enabled;
    [JsonProperty(PropertyName = "Cost")]
    public double Amount;
    public string PluginName;
    public string BalanceHook;
    public string WithdrawHook;
    public string CostFormat;
    public PaymentMethod(bool enabled, PlayerType playerType, AmountType amountType, double amount, string pluginName, string balanceHook, string withdrawHook, string costFormat);
    internal bool IsEnabled { get; set; }
}


```

---

## CorpseLocker by WhiteThunder - Allows quickly taking and swapping loot with corpses

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Corpse Locker", "WhiteThunder", "1.0.2")]
[Description("Adds UI buttons to player corpses to allow quick looting.")]
internal class CorpseLocker : CovalencePlugin
{
    private const string PermissionUse;
    private Configuration _config;
    private ContainerManager _containerManager;
    private List<Item> _tempItemList;
    public CorpseLocker();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnLootEntity(BasePlayer looter, PlayerCorpse corpse);
    [Command("corpselocker.take.main")]
    private void CommandTakeMain(IPlayer player);
    [Command("corpselocker.take.clothing")]
    private void CommandTakeClothing(IPlayer player);
    [Command("corpselocker.take.belt")]
    private void CommandTakeBelt(IPlayer player);
    [Command("corpselocker.swap.clothing")]
    private void CommandSwapClothing(IPlayer player);
    [Command("corpselocker.swap.belt")]
    private void CommandSwapBelt(IPlayer player);
    private class CuiElementRecreate : CuiElement
    {
        [JsonProperty("destroyUi", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string DestroyUi { get; set; }
    }

    private static class UI
    {
        private static Dictionary<string, Dictionary<InventoryType, string>> _uiCacheByLanguage;
        public const string Name;
        private const float PanelEndX;
        private const float ButtonSpacingX;
        private const float RightButtonMinX;
        private const float LeftButtonMinX;
        private const float ButtonWidth;
        private const float ButtonHeight;
        public static void AddCorpseUI(CorpseLocker plugin, BasePlayer player, InventoryType inventoryTypes);
        private static CuiElementContainer CreatePanel();
        private static void AddButton(CuiElementContainer container, string text, string command, float offsetX, float offsetY);
    }

    private class CorpseComponent : FacepunchBehaviour
    {
        public static CorpseComponent AddToCorpse(ContainerManager containerManager, PlayerCorpse corpse);
        private ContainerManager _containerManager;
        private PlayerCorpse _corpse;
        private List<BasePlayer> _looters;
        private Action _handleDirty;
        private InventoryType _activeInventoryTypes;
        public void AddLooter(BasePlayer looter);
        private void AddUI(BasePlayer looter);
        private void DestroyUI(BasePlayer looter);
        private InventoryType DetermineActiveInventoryTypes();
        public void AddUI();
        public void DestroyUI();
        private void HandleDirtyDelayed();
        private void PlayerStoppedLooting(BasePlayer looter);
        private void OnDestroy();
    }

    private class ContainerManager
    {
        public CorpseLocker Plugin { get; set; }
        private Dictionary<PlayerCorpse, CorpseComponent> _corpseComponents;
        public ContainerManager(CorpseLocker plugin);
        public void AddCorpseLooter(PlayerCorpse corpse, BasePlayer looter);
        private CorpseComponent EnsureComponent(PlayerCorpse corpse);
        public void Unregister(PlayerCorpse corpse);
        public void Unload();
    }

    private static bool VerifyLootingEntity(IPlayer player, BasePlayer looter, T entity);
    private static ItemContainer GetCorpseContainer(PlayerCorpse corpse, InventoryType inventoryType);
    private static ItemContainer GetPlayerContainer(BasePlayer player, InventoryType inventoryType);
    private static bool AreValidCorpseContainers(PlayerCorpse corpse, List<ItemContainer> containers);
    private void TransferItems(BasePlayer looter, ItemContainer corpseContainer, ItemContainer playerContainer, bool swap);
    private bool IsCorpseAllowed(PlayerCorpse corpse, BasePlayer looter);
    private void HandleTransfer(IPlayer player, InventoryType inventoryType, bool swap);
    private bool HasPermission(BasePlayer player, string perm);
    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : BaseConfiguration
    {
        [JsonProperty("Require corpse ownership")]
        public bool RequireCorpseOwnership;
    }

    private Configuration GetDefaultConfig();
    [JsonObject(MemberSerialization.OptIn)]
    private class BaseConfiguration
    {
        private string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class LangEntry
    {
        public static List<LangEntry> AllLangEntries;
        public static readonly LangEntry TakeItems;
        public static readonly LangEntry SwapItems;
        public string Name;
        public string English;
        public LangEntry(string name, string english);
    }

    private string GetMessage(string playerId, LangEntry langEntry);
    protected override void LoadDefaultMessages();
}

private class CuiElementRecreate : CuiElement
{
    [JsonProperty("destroyUi", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string DestroyUi { get; set; }
}

private static class UI
{
    private static Dictionary<string, Dictionary<InventoryType, string>> _uiCacheByLanguage;
    public const string Name;
    private const float PanelEndX;
    private const float ButtonSpacingX;
    private const float RightButtonMinX;
    private const float LeftButtonMinX;
    private const float ButtonWidth;
    private const float ButtonHeight;
    public static void AddCorpseUI(CorpseLocker plugin, BasePlayer player, InventoryType inventoryTypes);
    private static CuiElementContainer CreatePanel();
    private static void AddButton(CuiElementContainer container, string text, string command, float offsetX, float offsetY);
}

private class CorpseComponent : FacepunchBehaviour
{
    public static CorpseComponent AddToCorpse(ContainerManager containerManager, PlayerCorpse corpse);
    private ContainerManager _containerManager;
    private PlayerCorpse _corpse;
    private List<BasePlayer> _looters;
    private Action _handleDirty;
    private InventoryType _activeInventoryTypes;
    public void AddLooter(BasePlayer looter);
    private void AddUI(BasePlayer looter);
    private void DestroyUI(BasePlayer looter);
    private InventoryType DetermineActiveInventoryTypes();
    public void AddUI();
    public void DestroyUI();
    private void HandleDirtyDelayed();
    private void PlayerStoppedLooting(BasePlayer looter);
    private void OnDestroy();
}

private class ContainerManager
{
    public CorpseLocker Plugin { get; set; }
    private Dictionary<PlayerCorpse, CorpseComponent> _corpseComponents;
    public ContainerManager(CorpseLocker plugin);
    public void AddCorpseLooter(PlayerCorpse corpse, BasePlayer looter);
    private CorpseComponent EnsureComponent(PlayerCorpse corpse);
    public void Unregister(PlayerCorpse corpse);
    public void Unload();
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : BaseConfiguration
{
    [JsonProperty("Require corpse ownership")]
    public bool RequireCorpseOwnership;
}

[JsonObject(MemberSerialization.OptIn)]
private class BaseConfiguration
{
    private string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private class LangEntry
{
    public static List<LangEntry> AllLangEntries;
    public static readonly LangEntry TakeItems;
    public static readonly LangEntry SwapItems;
    public string Name;
    public string English;
    public LangEntry(string name, string english);
}


```

---

## Countries by MrBlue - Limits players connecting from certain countries

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Random = System.Random;

Oxide.Plugins
[Info("Countries", "Wulf", "2.0.1")]
[Description("Limits players connecting from certain countries")]
 class Countries : CovalencePlugin
{
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("API key for paid IP lookup service (if applicable)")]
        public string ApiKey;
        [JsonProperty("Ban player if country is blacklisted (true/false)")]
        public bool BanPlayer;
        [JsonProperty("Only allow players from server's country (true/false)")]
        public bool NativesOnly;
        [JsonProperty("Cache responses from IP lookup service provider (true/false)")]
        public bool CacheResponses;
        [JsonProperty("Number of retries on IP lookup fail (0 to disable)")]
        public int RetriesOnFail;
        [JsonProperty("Log connections from players (true/false)")]
        public bool LogConnections;
        [JsonProperty("Use country code list as a whitelist (true/false)")]
        public bool IsWhitelist;
        [JsonProperty("List of two-digit countries codes to check", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> CountryList;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private Dictionary<string, string> apiLimits;
    private Dictionary<string, string> ipCache;
    private readonly List<Provider> providersFree;
    private readonly List<Provider> providersPaid;
    private static readonly Random random;
    private const string permAdmin;
    private const string permExclude;
    private string serverCountry;
    public class Provider
    {
        public string Name { get; set; }
        public string Url { get; set; }
        public string Field { get; set; }
        public string ApiKey { get; set; }
        public int ApiLimit { get; set; }
        public string LimitPeriod { get; set; }
        public Provider(string name, string url, string field, string apiKey, int apiLimit, string limitPeriod);
    }

    private void RegisterProviders();
    private void Init();
    private void OnServerInitialized();
    private void CommandAdmin(IPlayer player, string command, string[] args);
    private void IpLookup(string ip, Action<string, int> callback);
    private void IsPlayerBlocked(IPlayer player);
    private object CanUserLogin(string name, string id, string ip);
    private void OnUserConnected(IPlayer player);
    private void RejectPlayer(IPlayer player, string country);
    private IPlayer FindPlayer(string nameOrId, IPlayer player);
    private string GetCachedCountry(string ip);
    private static string IpAddress(string ip);
    private bool IsCountryAllowed(string country);
    private bool IsCountryCode(string countryCode);
    private static bool IsLocalIp(string ipAddress);
    public static string ToWildcardIp(string ip);
    private void AddLocalizedCommand(string command);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string langKey, object[] args);
    private void MigratePermission(string oldPerm, string newPerm);
}

public class Configuration
{
    [JsonProperty("API key for paid IP lookup service (if applicable)")]
    public string ApiKey;
    [JsonProperty("Ban player if country is blacklisted (true/false)")]
    public bool BanPlayer;
    [JsonProperty("Only allow players from server's country (true/false)")]
    public bool NativesOnly;
    [JsonProperty("Cache responses from IP lookup service provider (true/false)")]
    public bool CacheResponses;
    [JsonProperty("Number of retries on IP lookup fail (0 to disable)")]
    public int RetriesOnFail;
    [JsonProperty("Log connections from players (true/false)")]
    public bool LogConnections;
    [JsonProperty("Use country code list as a whitelist (true/false)")]
    public bool IsWhitelist;
    [JsonProperty("List of two-digit countries codes to check", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> CountryList;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

public class Provider
{
    public string Name { get; set; }
    public string Url { get; set; }
    public string Field { get; set; }
    public string ApiKey { get; set; }
    public int ApiLimit { get; set; }
    public string LimitPeriod { get; set; }
    public Provider(string name, string url, string field, string apiKey, int apiLimit, string limitPeriod);
}


```

---

## CraftChassis by WhiteThunder - Allows players to craft a modular car chassis at a car lift using a UI

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Craft Car Chassis", "WhiteThunder", "1.2.5")]
[Description("Allows players to craft a modular car chassis at a car lift using a UI.")]
internal class CraftChassis : CovalencePlugin
{
    [PluginReference]
    private Plugin Economics;
    private Plugin ServerRewards;
    private Configuration _config;
    private const string PermissionCraft2;
    private const string PermissionCraft3;
    private const string PermissionCraft4;
    private const string PermissionFree;
    private const string PermissionFuel;
    private const string ChassisPrefab2;
    private const string ChassisPrefab3;
    private const string ChassisPrefab4;
    private const string SpawnEffect;
    private readonly Dictionary<BasePlayer, ModularCarGarage> playerLifts;
    private readonly ChassisUIManager uiManager;
    private void Init();
    private void Unload();
    private void OnLootEntity(BasePlayer player, ModularCarGarage carLift);
    private void OnPlayerLootEnd(PlayerLoot inventory);
    [Command("craftchassis.ui")]
    private void CraftChassisUICommand(IPlayer player, string cmd, string[] args);
    private ModularCar SpawnChassis(ModularCarGarage carLift, int numSockets, BasePlayer player);
    private void AddOrRestoreFuel(ModularCar car, BasePlayer player);
    private string GetChassisPrefab(int numSockets);
    private int GetMaxAllowedSockets(IPlayer player);
    private bool CanPlayerCreateChassis(IPlayer player, int numSockets, ChassisCost chassisCost);
    private bool CanPlayerAffordSockets(BasePlayer basePlayer, int sockets);
    private bool CanPlayerAffordCost(BasePlayer basePlayer, ChassisCost chassisCost);
    private void ChargePlayer(BasePlayer basePlayer, ChassisCost chassisCost);
    private double GetPlayerCurrencyAmount(BasePlayer basePlayer, ChassisCost chassisCost, CurrencyType currencyType);
    private ChassisCost GetCostForSockets(int numSockets);
    internal class ChassisUIManager
    {
        private const string PanelBackgroundColor;
        private const string TextColor;
        private const string DisabledLabelTextColor;
        private const string ButtonColor;
        private const string DisabledButtonColor;
        private const string CraftChassisUIName;
        private const string CraftChassisUIHeaderName;
        private readonly List<BasePlayer> PlayersWithUIs;
        public void DestroyAllUIs();
        public void DestroyPlayerUI(BasePlayer player);
        private CuiLabel CreateCostLabel(CraftChassis plugin, BasePlayer player, bool freeCrafting, int maxAllowedSockets, int numSockets);
        private CuiButton CreateCraftButton(CraftChassis plugin, BasePlayer player, bool freeCrafting, int maxAllowedSockets, int numSockets);
        public void MaybeSendPlayerUI(CraftChassis plugin, BasePlayer player);
    }

    private class ChassisCost
    {
        [JsonProperty("Amount")]
        public int Amount;
        [JsonProperty("ItemShortName")]
        public string ItemShortName;
        [JsonProperty("UseEconomics")]
        public bool UseEconomics;
        [JsonProperty("UseServerRewards")]
        public bool UseServerRewards;
    }

    private class ChassisCostMap
    {
        [JsonProperty("2sockets")]
        public ChassisCost ChassisCost2;
        [JsonProperty("3sockets")]
        public ChassisCost ChassisCost3;
        [JsonProperty("4sockets")]
        public ChassisCost ChassisCost4;
    }

    private class Configuration : BaseConfiguration
    {
        [JsonProperty("ChassisCost")]
        public ChassisCostMap ChassisCostMap;
        [JsonProperty("FuelAmount")]
        public int FuelAmount;
        [JsonProperty("EnableEffects")]
        public bool EnableEffects;
        [JsonProperty("SetOwner")]
        public bool SetOwner;
    }

    private Configuration GetDefaultConfig();
    private class BaseConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(BaseConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(IPlayer player, string messageName, object[] args);
    protected override void LoadDefaultMessages();
}

internal class ChassisUIManager
{
    private const string PanelBackgroundColor;
    private const string TextColor;
    private const string DisabledLabelTextColor;
    private const string ButtonColor;
    private const string DisabledButtonColor;
    private const string CraftChassisUIName;
    private const string CraftChassisUIHeaderName;
    private readonly List<BasePlayer> PlayersWithUIs;
    public void DestroyAllUIs();
    public void DestroyPlayerUI(BasePlayer player);
    private CuiLabel CreateCostLabel(CraftChassis plugin, BasePlayer player, bool freeCrafting, int maxAllowedSockets, int numSockets);
    private CuiButton CreateCraftButton(CraftChassis plugin, BasePlayer player, bool freeCrafting, int maxAllowedSockets, int numSockets);
    public void MaybeSendPlayerUI(CraftChassis plugin, BasePlayer player);
}

private class ChassisCost
{
    [JsonProperty("Amount")]
    public int Amount;
    [JsonProperty("ItemShortName")]
    public string ItemShortName;
    [JsonProperty("UseEconomics")]
    public bool UseEconomics;
    [JsonProperty("UseServerRewards")]
    public bool UseServerRewards;
}

private class ChassisCostMap
{
    [JsonProperty("2sockets")]
    public ChassisCost ChassisCost2;
    [JsonProperty("3sockets")]
    public ChassisCost ChassisCost3;
    [JsonProperty("4sockets")]
    public ChassisCost ChassisCost4;
}

private class Configuration : BaseConfiguration
{
    [JsonProperty("ChassisCost")]
    public ChassisCostMap ChassisCostMap;
    [JsonProperty("FuelAmount")]
    public int FuelAmount;
    [JsonProperty("EnableEffects")]
    public bool EnableEffects;
    [JsonProperty("SetOwner")]
    public bool SetOwner;
}

private class BaseConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}


```

---

## CraftingController by Whispers88 - Allows you to modify the time spend crafting and which items can be crafted

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Facepunch;

Oxide.Plugins
[Info("Crafting Controller", "Whispers88", "3.3.4")]
[Description("Allows you to modify the time spend crafting and which items can be crafted")]
public class CraftingController : RustPlugin
{
    private Configuration config;
    private static Dictionary<string, CraftingData> defaultsetup;
    public class Configuration
    {
        [JsonProperty("Default crafting rate percentage")]
        public float CraftingRate;
        [JsonProperty("Save commands to config (save config changes via command to the configuration)")]
        public bool SaveCommands;
        [JsonProperty("Simple Mode (disables: instant bulk craft, skin options and full inventory checks for better performance)")]
        public bool SimpleMode;
        [JsonProperty("Allow crafting when inventory is full")]
        public bool FullInventory;
        [JsonProperty("Complete crafting on server shut down")]
        public bool CompleteCrafting;
        [JsonProperty("Craft items with random skins if not already skinned")]
        public bool RandomSkins;
        [JsonProperty("Show Crafting Notes")]
        public bool ShowCraftNotes;
        [JsonProperty("Crafting rate bonus mulitplier (apply oxide perms for additional mulitpliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, float> BonusMultiplier;
        [JsonProperty("Advanced Crafting Options", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, CraftingData> CraftingOptions;
        [JsonProperty("Version")]
        public float Version;
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private const string perminstantbulkcraft;
    private const string permblockitems;
    private const string permitemrate;
    private const string permcraftingrate;
    private const string permsetbenchlvl;
    private const string permsetskins;
    private List<string> permissions;
    private List<string> permissionsBonusMultiplier;
    private List<string> commands;
    private void OnServerInitialized();
    private void Unload();
    protected override void LoadDefaultMessages();
    private void CommandCraftingRate(IPlayer iplayer, string command, string[] args);
    private void CommandCraftTime(IPlayer iplayer, string command, string[] args);
    private void CommandBlockItem(IPlayer iplayer, string command, string[] args);
    private void CommandUnblockItem(IPlayer iplayer, string command, string[] args);
    private void CommandWorkbenchLVL(IPlayer iplayer, string command, string[] args);
    private void CommandSetDefaultSkin(IPlayer iplayer, string command, string[] args);
    private void UpdateCraftingRate();
    private void InstantBulkCraft(BasePlayer player, ItemCraftTask task, ItemDefinition item, List<int> stacks, int craftSkin, ulong skin);
    private static void CompleteCrafting(BasePlayer player);
    private static void CancelAllCrafting(BasePlayer player);
    private Dictionary<ItemCraftTask, ulong> skinupdate;
    private object OnItemCraft(ItemCraftTask task, BasePlayer player, Item fromTempBlueprint);
    private void OnItemCraftFinished(ItemCraftTask task, Item item);
     void OnItemCraftCancelled(ItemCraftTask task);
    private void OnServerQuit();
    private void ReturnCraft(ItemCraftTask task, BasePlayer crafter);
    private ItemDefinition FindItem(string itemNameOrId);
    private int FreeSpace(BasePlayer player, ItemDefinition item);
    private int FreeSlots(BasePlayer player);
    private int Stackroom(List<Item> items, string item);
    private List<int> GetStacks(ItemDefinition item, int amount);
    private readonly Dictionary<string, List<ulong>> skinsCache;
    private List<ulong> GetSkins(ItemDefinition def);
    private string GetLang(string langKey, string playerId, object[] args);
    private void Message(IPlayer player, string langKey, object[] args);
    private bool HasPerm(string id, string perm);
    private void AddLocalizedCommand(string command);
}

public class Configuration
{
    [JsonProperty("Default crafting rate percentage")]
    public float CraftingRate;
    [JsonProperty("Save commands to config (save config changes via command to the configuration)")]
    public bool SaveCommands;
    [JsonProperty("Simple Mode (disables: instant bulk craft, skin options and full inventory checks for better performance)")]
    public bool SimpleMode;
    [JsonProperty("Allow crafting when inventory is full")]
    public bool FullInventory;
    [JsonProperty("Complete crafting on server shut down")]
    public bool CompleteCrafting;
    [JsonProperty("Craft items with random skins if not already skinned")]
    public bool RandomSkins;
    [JsonProperty("Show Crafting Notes")]
    public bool ShowCraftNotes;
    [JsonProperty("Crafting rate bonus mulitplier (apply oxide perms for additional mulitpliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, float> BonusMultiplier;
    [JsonProperty("Advanced Crafting Options", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, CraftingData> CraftingOptions;
    [JsonProperty("Version")]
    public float Version;
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}


```

---

## CraftingStore by CraftingStore - CraftingStore is a donation platform that allows you process donations automatically.

```csharp
using System;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Crafting Store", "CraftingStore", "0.1.5")]
[Description("Checks the CraftingStore donation platform for new payments and executes the commands that have been set.")]
 class CraftingStore : CovalencePlugin
{
    private string baseUrl;
    private string baseUrlAlternative;
    private bool useAlternativeBaseUrl;
    private string apiToken;
     void OnServerInitialized();
    protected override void LoadDefaultConfig();
    private ApiResponse ParseResponse(string response);
    private void GetRequest(string uri, string action);
    private void GetCallback(int code, string response, string action);
    private void PostRequest(string uri, string action, string payload);
    private void PostCallback(int code, string response, string action);
    private void ProcessQueuedCommands(ApiResponse parsedResponse);
    private string getBaseUrl();
    private void RequestCommands();
    public class QueueResponse
    {
        public int id;
        public string command;
        public string packageName;
    }

    public class ApiResponse
    {
        public int id;
        public bool success;
        public string error;
        public string message;
        public QueueResponse[] result;
    }

}

public class QueueResponse
{
    public int id;
    public string command;
    public string packageName;
}

public class ApiResponse
{
    public int id;
    public bool success;
    public string error;
    public string message;
    public QueueResponse[] result;
}


```

---

## CraftMultiplier by  - Multiples crafting to allow making more items at one time

```csharp
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Craft Multiplier", "Arainrr", "1.4.1")]
[Description("Multiplier in craft, can craft more items at once")]
internal class CraftMultiplier : RustPlugin
{
    private const string PERMISSION_USE;
    private bool initialized;
    private readonly Dictionary<ulong, int> enabledMultiplier;
    private readonly Dictionary<ulong, Timer> autoDisableTimer;
    private void Init();
    private void Unload();
    private void OnServerInitialized();
    private object OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer player, Item item);
    private static void CollectIngredients(ItemCrafter itemCrafter, ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player);
    private static void CollectIngredient(ItemCrafter itemCrafter, int item, int amount, List<Item> collect);
    private static bool CanAffordCraftMultiplier(ItemCrafter itemCrafter, ItemBlueprint bp, int amount);
    private static bool DoesHaveUsableItem(ItemCrafter itemCrafter, int item, int iAmount);
    private void CmdCraftMultiplier(BasePlayer player, string command, string[] args);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Chat Command")]
        public string command;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong steamIDIcon;
        [JsonProperty(PropertyName = "Maximum Multiplier")]
        public int maxMultiplier;
        [JsonProperty(PropertyName = "Time Before The Multiplier Is Disabled")]
        public float timeBeforeDisable;
        [JsonProperty(PropertyName = "Use Blacklist (If false, a whitelist will be used)")]
        public bool useBlacklist;
        [JsonProperty(PropertyName = "Item List (Item short name)")]
        public HashSet<string> itemList;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Print(BasePlayer player, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Chat Command")]
    public string command;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong steamIDIcon;
    [JsonProperty(PropertyName = "Maximum Multiplier")]
    public int maxMultiplier;
    [JsonProperty(PropertyName = "Time Before The Multiplier Is Disabled")]
    public float timeBeforeDisable;
    [JsonProperty(PropertyName = "Use Blacklist (If false, a whitelist will be used)")]
    public bool useBlacklist;
    [JsonProperty(PropertyName = "Item List (Item short name)")]
    public HashSet<string> itemList;
}


```

---

## CraftQueueSaver by nivex - Saves your crafting queue on disconnect and on server shutdown

```csharp

Oxide.Plugins
[Info("Craft Queue Saver", "Jake_Rich", "1.1.6")]
[Description("Saves player crafting queues on disconnect and on server shutdown")]
 class CraftQueueSaver : RustPlugin
{
    private void Init();
}


```

---

## CraftSpamBlocker by misticos - Prevents items from being crafted if the player's inventory is full

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using Object = UnityEngine.Object;

Oxide.Plugins
[Info("Craft Spam Blocker", "Iv Misticos", "1.0.2")]
[Description("Prevents items from being crafted if the player's inventory is full")]
 class CraftSpamBlocker : RustPlugin
{
    private static List<PlayerController> _data;
    private static CraftSpamBlocker _ins;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Incorrect Crafts To Block")]
        public int IncorrectNeeded;
        [JsonProperty(PropertyName = "Incorrect Craft Lifetime (In Seconds)")]
        public float IncorrectCraftLifetime;
        [JsonProperty(PropertyName = "Block Time (In Seconds)")]
        public float BlockTime;
        [JsonProperty(PropertyName = "Debug")]
        public bool Debug;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private object CanCraft(ItemCrafter crafter, ItemBlueprint blueprint, int amount);
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(Object player);
    private class PlayerController : FacepunchBehaviour
    {
        public BasePlayer player;
        public List<float> craftHistory;
        public float blockStartTime;
        private void Awake();
        public object UpdateCraftTime();
        public static int FindIndex(Object player);
        public static PlayerController Find(Object player);
    }

    private object Process(ItemCrafter crafter, ItemBlueprint blueprint, int amount);
    private object Process(BasePlayer player, ItemBlueprint blueprint, int amount);
    private static string GetMsg(string key, string userId);
    private static void PrintDebug(string message);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Incorrect Crafts To Block")]
    public int IncorrectNeeded;
    [JsonProperty(PropertyName = "Incorrect Craft Lifetime (In Seconds)")]
    public float IncorrectCraftLifetime;
    [JsonProperty(PropertyName = "Block Time (In Seconds)")]
    public float BlockTime;
    [JsonProperty(PropertyName = "Debug")]
    public bool Debug;
}

private class PlayerController : FacepunchBehaviour
{
    public BasePlayer player;
    public List<float> craftHistory;
    public float blockStartTime;
    private void Awake();
    public object UpdateCraftTime();
    public static int FindIndex(Object player);
    public static PlayerController Find(Object player);
}


```

---

## CraftUI by  - A customizable custom crafting UI, which allows admins to change item ingredients or add new item

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("CraftUI", "EinTime/Orange/Black_demon6", "1.2.92", ResourceId = 2273)]
[Description("A fully customizable custom crafting UI, which allows admins to change item ingredients.")]
public class CraftUI : RustPlugin
{
    const string ItemInfoListName;
    const float refreshTime;
    [PluginReference]
    private Plugin ImageLibrary;
    public static CraftUI S;
     HashSet<int> customItemCrafts;
    static readonly Dictionary<string, string> displaynameToShortname;
    const string transparentSprite;
    const string Invalid;
    const string FormatHelp;
    const string InvalidFormat;
    const string AlreadyBlocked;
    const string UnknownError;
    const string ItemRateChange;
    const string ItemBlocked;
    const string ItemNotBlocked;
    const string AllItemsBlocked;
    const string AllItemsUnblocked;
    const string IngredientsCleared;
    const string IngredientsReset;
    const string AddedIngredient;
    const string RemovedIngredient;
    const string RemovedAllIngredient;
    const string DoesNotContainIngredient;
    const string HasNoIngredients;
    const string IngredientsList;
    const string ItemRenamed;
    const string DescriptionChanged;
    const string IconUrlChanged;
    const string CategoryChanged;
    const string NotAdmin;
    const string FacepunchGUIDisabled;
    const string ItemListLoaded;
    const string ItemListSaved;
    const string AddRemoveFormat;
    const string IngredientsFormat;
    const string CraftrateFormat;
    const string RenameFormat;
    const string ChangeDescriptionFormat;
    const string IconFormat;
    const string CategoryFormat;
    static readonly Dictionary<string, string> responseDic;
     bool AllowOldCrafting;
     string OpenCraftUIBinding;
     List<string> CategoryNames;
     bool IncludeUncraftableItems;
     int ItemIconSize;
     void OnServerInitialized();
     void Loaded();
     void Unload();
     void OnPlayerConnected(BasePlayer player);
     object OnItemCraft(ItemCraftTask task, BasePlayer crafter);
     void OnItemCraftFinished(ItemCraftTask task, Item item);
     void OnItemCraftCancelled(ItemCraftTask task);
     void OnLootEntity(BasePlayer player, BaseEntity entity);
     void RefreshCraftQueue();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
     T GetConfigValue(string category, string name, T defaultValue);
     List<T> GetConfigValue(string category, string name, List<T> defaultValue);
     Dictionary<string, object> GetConfigCategory(string category);
     void LoadDefaultMessages();
     class PlayerInfo
    {
        public readonly BasePlayer basePlayer;
        public bool uiOpen;
        public bool overlayOpen;
        public bool overlayLooting;
        public float overlayLootingColumns;
        public string selectedCategory;
        public ItemInfo selectedItem;
        public int currentCraftAmount;
        public PlayerInfo(BasePlayer player);
        public class CraftInfo
        {
            public List<string> amounts;
            public List<string> itemTypes;
            public List<string> totals;
            public List<string> haves;
            public bool canCraft;
            public CraftInfo();
        }

        public CraftInfo GetCraftInfo();
    }

    static Dictionary<ulong, PlayerInfo> playerDic;
     bool AddPlayer(BasePlayer player);
     PlayerInfo GetPlayer(BasePlayer player);
     class ItemInfo
    {
        public int itemID;
        public string realName;
        public string customName;
        public string customDescription;
        public bool blocked;
        public float craftRate;
        public List<ItemIngredient> ingredients;
        public string iconURL;
        public string category;
        public ItemInfo();
        public ItemInfo(ItemDefinition itemDef);
        public ItemDefinition GetItemDef();
        public bool GetCraftable(PlayerInfo playerInfo);
        public int GetCraftCount(PlayerInfo playerInfo);
        public string GetFormattedURL();
        public static ItemInfo FromObject(object obj);
    }

     class ItemIngredient
    {
        public int ingredientID;
        public string realName;
        public float amount;
        public ItemIngredient();
        public ItemIngredient(int ingredientID, float amount);
        public ItemDefinition GetItemDef();
        public ItemAmount GetItemAmount();
        public static ItemIngredient FromObject(object obj);
    }

    static Dictionary<int, ItemInfo> itemInfoDic;
    static Dictionary<int, float> originalCraftTimes;
    static Dictionary<int, List<ItemIngredient>> originalIngredients;
    static HashSet<int> nullBlueprintSet;
     bool CanAddItemInfo(ItemDefinition itemDef);
     void AddItemInfo(ItemDefinition itemDef, bool forceAdd);
     void SaveItemInfoDic();
     void LoadItemInfoDic();
     void VerifyItemInfoDic();
     void CreateMissingBlueprints();
     ItemBlueprint CreateMissingBlueprint(ItemDefinition itemDef);
     ItemInfo FindItemInfo(ItemDefinition itemDef);
     ItemInfo FindItemInfo(int itemID);
    [ChatCommand("craftui.add")]
     void AddIngredient_ChatCommands(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.remove")]
     void RemoveIngredient_ChatCommands(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.ingredients")]
     void IngredientsList_ChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.clearingredients")]
     void ClearIngredients_ChatCommands(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.resetingredients")]
     void ResetIngredients_ChatCommands(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.craftrate")]
     void CraftRate_ChatCommands(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.block")]
     void Block_ChatCommands(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.unblock")]
     void UnBlock_ChatCommands(BasePlayer player, string command, string[] args);
     void BlockItem(BasePlayer player, string command, string[] args, bool block);
    [ChatCommand("craftui.blockall")]
     void BlockAll(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.unblockall")]
     void UnblockAll(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.rename")]
     void Rename_ChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.description")]
     void ChangeDrescription_ChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.category")]
     void Category_ChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.seticon")]
     void SetIcon_ChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.load")]
     void Load_ChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui.save")]
     void Save_ChatCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("craftui")]
     void CraftUI_ChatCommand(BasePlayer player, string command, string[] args);
     void ShowHelpMessage(BasePlayer player);
     bool AdminCheck(BasePlayer player);
     bool ArgsCheck(BasePlayer player, string[] args, int minLength, string command, string formatKey);
     class PanelRect
    {
        public float left;
        public float bottom;
        public float right;
        public float top;
        public PanelRect();
        public PanelRect(float left, float bottom, float right, float top);
        public string AnchorMin { get; set; }
        public string AnchorMax { get; set; }
        public PanelRect RelativeTo(PanelRect other);
        public PanelRect Copy();
    }

     class PanelInfo
    {
        public PanelRect rect;
        public string backgroundColor;
        public PanelInfo(PanelRect rect, string color);
    }

    const string CraftUIName;
    const string CategoriesName;
    const string ItemListName;
    const string ItemInfoName;
    const string ResourceCostName;
    const string CraftAmountName;
    const string CraftCountName;
    const string CraftButtonName;
    const string CraftQueueName;
    const string CraftQueueTimerName;
    const string CraftingButtonOverlayName;
    const string QuickCraftOverlayName;
    const string QuickCraftOverlayLootingName;
    static readonly Dictionary<string, PanelInfo> panelAnchors;
    static readonly Dictionary<string, PanelInfo> overlayAnchors;
    static readonly Dictionary<float, PanelRect> lootableOverlayAnchors;
     void ToggleCraftUI(PlayerInfo playerInfo);
     void RenderCraftUI(PlayerInfo playerInfo);
     void CloseCraftUI(PlayerInfo playerInfo);
     void CloseCraftUI_AllPlayers();
     void RenderHudPanel(string panelName, PlayerInfo playerInfo);
     void RenderHudPanelDelayed(float delay, string panelName, PlayerInfo playerInfo);
     void RenderCategories(CuiElementContainer elements, PlayerInfo playerInfo);
     void AddCategory(CuiElementContainer elements, float numElements, float index, string name, bool selected);
     void RenderItemList(CuiElementContainer elements, PlayerInfo playerInfo);
     float AddItem(CuiElementContainer elements, float index, ItemInfo itemInfo, PlayerInfo playerInfo, bool craftable, float startTop);
     void RenderItemInfo(CuiElementContainer elements, PlayerInfo playerInfo);
     void RenderResourceCosts(CuiElementContainer elements, PlayerInfo playerInfo);
     void AddResourceCostColumn(CuiElementContainer elements, bool canCraft, string labelName, List<string> values, PanelRect rect);
     void RenderCraftAmount(CuiElementContainer elements, PlayerInfo playerInfo);
     void RenderCraftButton(CuiElementContainer elements, PlayerInfo playerInfo);
     void RenderCraftCount(CuiElementContainer elements, PlayerInfo playerInfo);
     void RenderCraftQueue(CuiElementContainer elements, PlayerInfo playerInfo);
     void AddQueuedItem(CuiElementContainer elements, PlayerInfo player, ItemCraftTask task, int index, int taskCount);
     void RenderCraftQueueTimer(CuiElementContainer elements, PlayerInfo playerInfo);
     void RenderOverlay(PlayerInfo playerInfo, bool looting, float lootColumns);
     void CloseOverlay(PlayerInfo playerInfo);
     void CloseOverlay_AllPlayers();
     void RenderOverlayPanel(string panelName, PlayerInfo playerInfo);
     void RenderCraftingButtonBlocker(CuiElementContainer elements, PlayerInfo playerInfo);
     void RenderQuickCraft(CuiElementContainer elements, PlayerInfo playerInfo);
     float AddQuickCraftItem(CuiElementContainer elements, float index, ItemInfo itemInfo, PlayerInfo playerInfo, string parentName);
     void ccmdOverlayToggle(ConsoleSystem.Arg arg);
    [ConsoleCommand("craftui.closeoverlay")]
     void ccmdOverlayClose(ConsoleSystem.Arg arg);
    [ConsoleCommand("craftui.closeoverlayopencraftui")]
     void ccmdCloseOverlayOpenCraftUI(ConsoleSystem.Arg arg);
    [ConsoleCommand("craftui.toggle")]
     void ccmdCraftUIToggle(ConsoleSystem.Arg arg);
    [ChatCommand("craft")]
     void chatCmdCraftUIToggle(BasePlayer player);
    [ConsoleCommand("craftui.close")]
     void ccmdCraftUIClose(ConsoleSystem.Arg arg);
    [ConsoleCommand("category.select")]
     void ccmdCategorySelect(ConsoleSystem.Arg arg);
    [ConsoleCommand("item.select")]
     void ccmdItemSelect(ConsoleSystem.Arg arg);
    [ConsoleCommand("craftamount.change")]
     void ccmdCraftAmountChange(ConsoleSystem.Arg arg);
    [ConsoleCommand("craftamount.set")]
     void ccmdCraftAmountSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("craftamount.max")]
     void ccmdCraftAmountMax(ConsoleSystem.Arg arg);
    [ConsoleCommand("craft.begin")]
     void ccmdCraft(ConsoleSystem.Arg arg);
    [ConsoleCommand("craft.end")]
     void ccmdCraftEnd(ConsoleSystem.Arg arg);
     Item BuildItem(int itemid, int amount, ulong skin);
     bool CraftItem(ItemBlueprint bp, BasePlayer owner, int amount, int skinID);
     void CollectIngredient(ItemCrafter crafter, int item, int amount, List<Item> collect);
     void CollectIngredients(ItemCrafter crafter, ItemBlueprint bp, ItemCraftTask task, int amount, BasePlayer player);
     ItemDefinition DisplayNameToItemDef(BasePlayer player, string displayName);
     void PlayerChat(BasePlayer player, string key, object[] args);
     string Lang(string key, string id, object[] args);
     class UStopWatch
    {
         float startTime;
         int startFrame;
         float stopTime;
         int stopFrame;
         bool _isRunning;
        public bool isRunning { get; set; }
        public float elapsedSeconds { get; set; }
        public int elapsedMilliseconds { get; set; }
        public int elapsedFrames { get; set; }
        public UStopWatch(bool startNow);
        public void Start();
        public void Stop();
        public void Reset();
    }

     string GetItemIconURL(ItemDefinition itemDef);
     string GetItemIconURL(string itemID);
    readonly Dictionary<int, string> idToURL;
    static readonly Dictionary<string, string> defaultBinds;
     Dictionary<string, string> CategoryShortNames;
}

 class PlayerInfo
{
    public readonly BasePlayer basePlayer;
    public bool uiOpen;
    public bool overlayOpen;
    public bool overlayLooting;
    public float overlayLootingColumns;
    public string selectedCategory;
    public ItemInfo selectedItem;
    public int currentCraftAmount;
    public PlayerInfo(BasePlayer player);
    public class CraftInfo
    {
        public List<string> amounts;
        public List<string> itemTypes;
        public List<string> totals;
        public List<string> haves;
        public bool canCraft;
        public CraftInfo();
    }

    public CraftInfo GetCraftInfo();
}

public class CraftInfo
{
    public List<string> amounts;
    public List<string> itemTypes;
    public List<string> totals;
    public List<string> haves;
    public bool canCraft;
    public CraftInfo();
}

 class ItemInfo
{
    public int itemID;
    public string realName;
    public string customName;
    public string customDescription;
    public bool blocked;
    public float craftRate;
    public List<ItemIngredient> ingredients;
    public string iconURL;
    public string category;
    public ItemInfo();
    public ItemInfo(ItemDefinition itemDef);
    public ItemDefinition GetItemDef();
    public bool GetCraftable(PlayerInfo playerInfo);
    public int GetCraftCount(PlayerInfo playerInfo);
    public string GetFormattedURL();
    public static ItemInfo FromObject(object obj);
}

 class ItemIngredient
{
    public int ingredientID;
    public string realName;
    public float amount;
    public ItemIngredient();
    public ItemIngredient(int ingredientID, float amount);
    public ItemDefinition GetItemDef();
    public ItemAmount GetItemAmount();
    public static ItemIngredient FromObject(object obj);
}

 class PanelRect
{
    public float left;
    public float bottom;
    public float right;
    public float top;
    public PanelRect();
    public PanelRect(float left, float bottom, float right, float top);
    public string AnchorMin { get; set; }
    public string AnchorMax { get; set; }
    public PanelRect RelativeTo(PanelRect other);
    public PanelRect Copy();
}

 class PanelInfo
{
    public PanelRect rect;
    public string backgroundColor;
    public PanelInfo(PanelRect rect, string color);
}

 class UStopWatch
{
     float startTime;
     int startFrame;
     float stopTime;
     int stopFrame;
     bool _isRunning;
    public bool isRunning { get; set; }
    public float elapsedSeconds { get; set; }
    public int elapsedMilliseconds { get; set; }
    public int elapsedFrames { get; set; }
    public UStopWatch(bool startNow);
    public void Start();
    public void Stop();
    public void Reset();
}


```

---

## CrateFix by birthdates - A fix for players being able to swap items in crates thus not letting them despawn

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Crate Fix", "birthdates", "1.0.2")]
[Description("A fix for players being able to swap items in crates thus not letting them despawn.")]
public class CrateFix : RustPlugin
{
    private void Init();
     object CanAcceptItem(ItemContainer container, Item item, int targetPos);
    public ConfigFile _config;
    public class ConfigFile
    {
        [JsonProperty("Disabled Crates (Prefab)")]
        public List<string> DisabledCrates;
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadDefaultMessages();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class ConfigFile
{
    [JsonProperty("Disabled Crates (Prefab)")]
    public List<string> DisabledCrates;
    public static ConfigFile DefaultConfig();
}


```

---

## CraterNote by rostov114 - Returns the analysis of the wells in a note, like before

```csharp

Oxide.Plugins
[Info("Crater Note", "rostov114", "1.0.0")]
[Description("Returns the analysis of the wells in a note. Like before.")]
 class CraterNote : RustPlugin
{
    private void OnAnalysisComplete(SurveyCrater crater, BasePlayer player);
}


```

---

## CrazyCopter by ColonBlow - Interference from monuments causes mini and scrap helicopters to have throttle glitches to 100%

```csharp
using Rust;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Crazy Copter", "Colon Blow", "1.0.2")]
[Description("Monuments cause helicopter throttles to glitch at 100%")]
public class CrazyCopter : CovalencePlugin
{
    private static PluginConfig config;
    private class PluginConfig
    {
        public CrazyCopterSettings copterSettings { get; set; }
        public class CrazyCopterSettings
        {
            [JsonProperty(PropertyName = "Percent : Throttle will max out to this when around Monuments Triggers : ")]
            public int throttleEffect { get; set; }
            [JsonProperty(PropertyName = "Radius : Helicopter will detect Monument Triggers within this radius : ")]
            public float detectionRadius { get; set; }
            [JsonProperty(PropertyName = "Force : Add force against Helicopters when they are effected")]
            public bool forceEnabled { get; set; }
            [JsonProperty(PropertyName = "Force : Max force possible when enabled (randomizes direction and amount from zero to max)")]
            public float maxForceAmount { get; set; }
            [JsonProperty(PropertyName = "Minicopters are effected by glitch ? ")]
            public bool miniCopterEnabled { get; set; }
            [JsonProperty(PropertyName = "Scrap Helicopters are effected by glitch ? ")]
            public bool scrapHeliEnabled { get; set; }
        }

        public static PluginConfig DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void OnEntitySpawned(BaseHelicopterVehicle baseHeli);
    private void SendPlayerWarning(BasePlayer pilotPlayer);
    private void Unload();
    private static void DestroyAll();
    private class ThrottleGlitchControl : MonoBehaviour
    {
        private CrazyCopter instance;
        private BaseHelicopterVehicle baseHeli;
        private SphereCollider sphereCollider;
        private bool isEffected;
        private float throttleSpeed;
        private float counter;
        private BasePlayer pilotPlayer;
        private void Awake();
        private void OnTriggerEnter(Collider col);
        private void OnTriggerExit(Collider col);
        private void SendWarning();
        private void FixedUpdate();
        private void OnDestroy();
    }

}

private class PluginConfig
{
    public CrazyCopterSettings copterSettings { get; set; }
    public class CrazyCopterSettings
    {
        [JsonProperty(PropertyName = "Percent : Throttle will max out to this when around Monuments Triggers : ")]
        public int throttleEffect { get; set; }
        [JsonProperty(PropertyName = "Radius : Helicopter will detect Monument Triggers within this radius : ")]
        public float detectionRadius { get; set; }
        [JsonProperty(PropertyName = "Force : Add force against Helicopters when they are effected")]
        public bool forceEnabled { get; set; }
        [JsonProperty(PropertyName = "Force : Max force possible when enabled (randomizes direction and amount from zero to max)")]
        public float maxForceAmount { get; set; }
        [JsonProperty(PropertyName = "Minicopters are effected by glitch ? ")]
        public bool miniCopterEnabled { get; set; }
        [JsonProperty(PropertyName = "Scrap Helicopters are effected by glitch ? ")]
        public bool scrapHeliEnabled { get; set; }
    }

    public static PluginConfig DefaultConfig();
}

public class CrazyCopterSettings
{
    [JsonProperty(PropertyName = "Percent : Throttle will max out to this when around Monuments Triggers : ")]
    public int throttleEffect { get; set; }
    [JsonProperty(PropertyName = "Radius : Helicopter will detect Monument Triggers within this radius : ")]
    public float detectionRadius { get; set; }
    [JsonProperty(PropertyName = "Force : Add force against Helicopters when they are effected")]
    public bool forceEnabled { get; set; }
    [JsonProperty(PropertyName = "Force : Max force possible when enabled (randomizes direction and amount from zero to max)")]
    public float maxForceAmount { get; set; }
    [JsonProperty(PropertyName = "Minicopters are effected by glitch ? ")]
    public bool miniCopterEnabled { get; set; }
    [JsonProperty(PropertyName = "Scrap Helicopters are effected by glitch ? ")]
    public bool scrapHeliEnabled { get; set; }
}

private class ThrottleGlitchControl : MonoBehaviour
{
    private CrazyCopter instance;
    private BaseHelicopterVehicle baseHeli;
    private SphereCollider sphereCollider;
    private bool isEffected;
    private float throttleSpeed;
    private float counter;
    private BasePlayer pilotPlayer;
    private void Awake();
    private void OnTriggerEnter(Collider col);
    private void OnTriggerExit(Collider col);
    private void SendWarning();
    private void FixedUpdate();
    private void OnDestroy();
}


```

---

## Crosshair by MisterPixie - Adds a customizable crosshair to your screen

```csharp
using System.Collections.Generic;
using System.Globalization;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Crosshair", "MisterPixie", "3.1.0")]
[Description("Allows the user to toggle a crosshair")]
 class Crosshair : RustPlugin
{
    private string mainUI;
    private CuiElementContainer _ui;
    private HashSet<string> _crosshairSettings;
    private const string _usePerm;
    private class UI
    {
        public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
        public static void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align, float fadein);
    }

    private void ToggleCrosshair(BasePlayer player, string command, string[] args);
    private void DestroyCrosshair(BasePlayer player);
    private void DestroyAllCommand(ConsoleSystem.Arg arg);
    private void CreateUI();
    private static string HexToColor(string hexColor);
    private void Init();
    private void Unload();
    private void OnPlayerDisconnected(BasePlayer player);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
    private ConfigData configData;
    private class ConfigData
    {
        public string CrosshairColor;
        public string CrosshairText;
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
}

private class UI
{
    public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
    public static void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align, float fadein);
}

private class ConfigData
{
    public string CrosshairColor;
    public string CrosshairText;
}


```

---

## CTFEvents by 2CHEVSKII - Adds 'capture the flag' type events to your server

```csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using UnityEngine.Assertions;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("CTF Events", "2CHEVSKII", "1.0.0")]
[Description("Adds 'capture the flag' type events to your server")]
 class CTFEvents : CovalencePlugin
{
    const string PERMISSION_MANAGE;
    const string PREFAB_MARKER_GENERIC;
    const string M_PREFIX;
    const string M_NO_PERMISSION;
    const string M_WRONG_USAGE;
    const string M_HELP;
    const string M_EVENT_INFO;
    const string M_EVENT_NOT_FOUND;
    const string M_NO_EVENTS;
    const string M_EVENT_STARTED;
    const string M_EVENT_STARTED_BY;
    const string M_EVENT_FINISHED_TIME;
    const string M_EVENT_FINISHED_FORCE;
    const string M_EVENT_FINISHED_CAPTURED;
    const string M_INVALID_POS;
    const string M_EVENT_EXISTS;
    const string M_EVENT_LIMIT;
    const string M_EVENT_TICK_CAPTURING;
    const string M_EVENT_TICK_CONTESTED;
    const string M_PLAYER_CAPTURE_ENTER;
    const string M_PLAYER_CAPTURE_LEAVE;
    const string COLOR_CLOSE;
    const string COLOR_DEFOCUS;
    const string COLOR_SUCCESS;
    const string COLOR_INFO;
    const string COLOR_WARN;
    const string COLOR_DANGER;
    static readonly int EventSpawnMask;
    static CTFEvents Instance;
     PluginSettings settings;
     int maxEventsPerMap;
     List<Vector3> eventSpawnPoints;
    readonly string[] hereSynonyms;
    readonly string[] allSynonyms;
    [Conditional("DEBUG")]
    static void LogDebug(string format, object[] args);
     void CommandHandler(IPlayer player, string _, string[] args);
     void StartCommand(IPlayer player, string arg);
     void EndCommand(IPlayer player, string arg);
     void InfoCommand(IPlayer player, string arg);
     Vector3 GetClosestSpawnPoint(Vector3 pos);
     Vector3 GetRandomSpawnPoint();
     bool CanSpawnEvent(Vector3 origPos, Vector3 closestSp);
     Vector3 GetViewPos(IPlayer player);
     List<Vector3> ScanTerrain();
     bool ScanCell(Vector3 pos, Vector3 point);
     void Init();
     void OnServerInitialized();
     void OnUserConnected(IPlayer player);
     void Unload();
     void OnEventStarted(Flag flag);
     void OnEventStarted(Flag flag, IPlayer manager);
     void OnEventStarted(Flag flag, Plugin caller);
     void OnEventFinished(Flag flag);
     void OnEventFinished(Flag flag, BasePlayer winner);
     void OnEventFinished(Flag flag, List<BasePlayer> winners);
     void OnEventFinished(Flag flag, IPlayer manager);
     void OnEventFinished(Flag flag, Plugin caller);
     void OnEventTick(Flag flag);
     void OnEventStateChange(Flag flag, Flag.EventState prevState, Flag.EventState newState);
     void OnPlayerEnterCaptureZone(Flag flag, BasePlayer player);
     void OnPlayerLeaveCaptureZone(Flag flag, BasePlayer player);
    [HookMethod("CTFEvents::GetInGridCell")]
    public Flag GetEventInGridCell(string gridCell);
    protected override void LoadDefaultMessages();
     void Message(IPlayer player, string langKey, object[] args);
     void MessageRaw(IPlayer player, string message, bool newLine);
     void Announce(string langKey, object[] args);
     void AnnounceRaw(string message, bool newLine);
     string GetMessage(IPlayer player, string langKey);
     string WrapInColor(string str, string color);
     string GetFlagInfo(IPlayer player, Flag flag);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    public class Flag : MonoBehaviour
    {
        static List<Flag> allEvents;
        static ItemDefinition captureItemDef;
         PluginSettings settings;
         DroppedItem bindObject;
         float startTime;
         float endTime;
         float capturePercentage;
         float lastCaptureTickTime;
         List<BasePlayer> currentCapturers;
         List<BasePlayer> allPlayersInZone;
         List<BasePlayer> alivePlayersInZone;
         string gridCell;
         MapMarkerGenericRadius mapMarker;
         EventState state;
         object initiator;
         Dictionary<IPlayer, float> lastNotificationTime;
        public static int EventCount { get; set; }
        public static bool IsEventLimitReached { get; set; }
        public string GridCell { get; set; }
        public int Id { get; set; }
        public int TimeLeft { get; set; }
        public float CaptureProgress { get; set; }
        public int CaptureTimeLeft { get; set; }
        public int CapturerCount { get; set; }
        public EventState State { get; set; }
        public static void Initialize();
        public static void Unload();
        public static List<Vector3> GetOccupiedSpawnPoints();
        public static Flag FindByGridCell(string gridCell);
        public static Flag FindById(int id);
        public static Flag[] GetAll();
        public static void OnPlayerConnected(BasePlayer player);
        public static void CreateNewEvent(Vector3 pos);
        public static void CreateNewEvent(Vector3 pos, object initiator);
        static Flag CreateEvent(Vector3 pos);
        public Dictionary<string, object> ToSerializable();
        public void ForceFinish(IPlayer manager);
        public void ForceFinish(Plugin caller);
        public void SetInitiator(object initiator);
        public bool ShouldNotify(IPlayer player);
        public void GetAlivePlayers(List<BasePlayer> list);
         void Awake();
         void Start();
         void OnTriggerEnter(Collider other);
         void OnTriggerExit(Collider other);
         void OnDestroy();
         void SetupCollider();
         void SetupRotation();
         void SetupMarker();
         void UpdateMarkerColors();
         void SendMarkerUpdate(BasePlayer player);
         void UpdateMarkerForAll();
         void Rotate();
         void EventTick();
         void OnPlayerEnterCaptureZone(BasePlayer player);
         void OnPlayerLeaveCaptureZone(BasePlayer player);
         void OnCaptureStart(BasePlayer player);
         void OnContestedStart(BasePlayer player);
         void OnCaptureStop(BasePlayer player);
         void OnCaptureTick(float deltaTime, int capturerCount);
         void OnCaptureSuccess();
         void OnEventStart();
         void OnEventStart(IPlayer manager);
         void OnEventStart(Plugin caller);
         void OnEventEnd(BasePlayer winner);
         void OnEventEnd(List<BasePlayer> winners);
         void Dispose();
         void TimedDispose();
         void ForceDispose(IPlayer manager);
         void ForceDispose(Plugin caller);
    }

     class PluginSettings
    {
        public static PluginSettings Default { get; set; }
        [JsonProperty("Capture item shortname")]
        public string CaptureItemShortName { get; set; }
        [JsonProperty("Capture item skin ID")]
        public ulong CaptureItemSkinId { get; set; }
        [JsonProperty("Total event time")]
        public float TotalEventTime { get; set; }
        [JsonProperty("Time needed to capture")]
        public float CaptureTime { get; set; }
        [JsonProperty("Capture radius")]
        public float CaptureRadius { get; set; }
        [JsonProperty("Allow capturing with teammates")]
        public bool AllowTeamCapture { get; set; }
        [JsonProperty("Capture speed increase per teammate")]
        public float MultipleCapturersSpeedup { get; set; }
        [JsonProperty("Enable map markers")]
        public bool EnableMapMarkers { get; set; }
        [JsonProperty("Event status update notifications frequency")]
        public float EventTickNotificationFrequency { get; set; }
        [JsonProperty("Event autospawn frequency")]
        public float EventAutoCreateFrequency { get; set; }
        [JsonProperty("Allow autospawn if another event is present")]
        public bool AutoCreateIfAnyExists { get; set; }
        [JsonProperty("Event count limit")]
        public int EventLimit { get; set; }
    }

}

public class Flag : MonoBehaviour
{
    static List<Flag> allEvents;
    static ItemDefinition captureItemDef;
     PluginSettings settings;
     DroppedItem bindObject;
     float startTime;
     float endTime;
     float capturePercentage;
     float lastCaptureTickTime;
     List<BasePlayer> currentCapturers;
     List<BasePlayer> allPlayersInZone;
     List<BasePlayer> alivePlayersInZone;
     string gridCell;
     MapMarkerGenericRadius mapMarker;
     EventState state;
     object initiator;
     Dictionary<IPlayer, float> lastNotificationTime;
    public static int EventCount { get; set; }
    public static bool IsEventLimitReached { get; set; }
    public string GridCell { get; set; }
    public int Id { get; set; }
    public int TimeLeft { get; set; }
    public float CaptureProgress { get; set; }
    public int CaptureTimeLeft { get; set; }
    public int CapturerCount { get; set; }
    public EventState State { get; set; }
    public static void Initialize();
    public static void Unload();
    public static List<Vector3> GetOccupiedSpawnPoints();
    public static Flag FindByGridCell(string gridCell);
    public static Flag FindById(int id);
    public static Flag[] GetAll();
    public static void OnPlayerConnected(BasePlayer player);
    public static void CreateNewEvent(Vector3 pos);
    public static void CreateNewEvent(Vector3 pos, object initiator);
    static Flag CreateEvent(Vector3 pos);
    public Dictionary<string, object> ToSerializable();
    public void ForceFinish(IPlayer manager);
    public void ForceFinish(Plugin caller);
    public void SetInitiator(object initiator);
    public bool ShouldNotify(IPlayer player);
    public void GetAlivePlayers(List<BasePlayer> list);
     void Awake();
     void Start();
     void OnTriggerEnter(Collider other);
     void OnTriggerExit(Collider other);
     void OnDestroy();
     void SetupCollider();
     void SetupRotation();
     void SetupMarker();
     void UpdateMarkerColors();
     void SendMarkerUpdate(BasePlayer player);
     void UpdateMarkerForAll();
     void Rotate();
     void EventTick();
     void OnPlayerEnterCaptureZone(BasePlayer player);
     void OnPlayerLeaveCaptureZone(BasePlayer player);
     void OnCaptureStart(BasePlayer player);
     void OnContestedStart(BasePlayer player);
     void OnCaptureStop(BasePlayer player);
     void OnCaptureTick(float deltaTime, int capturerCount);
     void OnCaptureSuccess();
     void OnEventStart();
     void OnEventStart(IPlayer manager);
     void OnEventStart(Plugin caller);
     void OnEventEnd(BasePlayer winner);
     void OnEventEnd(List<BasePlayer> winners);
     void Dispose();
     void TimedDispose();
     void ForceDispose(IPlayer manager);
     void ForceDispose(Plugin caller);
}

 class PluginSettings
{
    public static PluginSettings Default { get; set; }
    [JsonProperty("Capture item shortname")]
    public string CaptureItemShortName { get; set; }
    [JsonProperty("Capture item skin ID")]
    public ulong CaptureItemSkinId { get; set; }
    [JsonProperty("Total event time")]
    public float TotalEventTime { get; set; }
    [JsonProperty("Time needed to capture")]
    public float CaptureTime { get; set; }
    [JsonProperty("Capture radius")]
    public float CaptureRadius { get; set; }
    [JsonProperty("Allow capturing with teammates")]
    public bool AllowTeamCapture { get; set; }
    [JsonProperty("Capture speed increase per teammate")]
    public float MultipleCapturersSpeedup { get; set; }
    [JsonProperty("Enable map markers")]
    public bool EnableMapMarkers { get; set; }
    [JsonProperty("Event status update notifications frequency")]
    public float EventTickNotificationFrequency { get; set; }
    [JsonProperty("Event autospawn frequency")]
    public float EventAutoCreateFrequency { get; set; }
    [JsonProperty("Allow autospawn if another event is present")]
    public bool AutoCreateIfAnyExists { get; set; }
    [JsonProperty("Event count limit")]
    public int EventLimit { get; set; }
}


```

---

## CuiGenerator by bazuka5801 - Helps developer manage GUI manipulations in single line of code

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using System.Collections;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Network;
using System.ComponentModel;
using Newtonsoft.Json.Converters;
using UnityEngine.UI;

Oxide.Plugins
[Info("Cui Generator", "bazuka5801", "3.1.60"), Description("Helps developer manage GUI manipulations in single line of code")]
public class CuiGenerator : RustPlugin
{
    public class CuiElementComparer : IEqualityComparer<CuiElement>
    {
         bool Equals(CuiElement x, CuiElement y);
         int GetHashCode(CuiElement obj);
        public static bool EqualElement(CuiElement e1, CuiElement e2);
        private static bool EqualComponent(ICuiComponent e1, ICuiComponent e2);
        private static bool EqualComponent(CuiCountdownComponent e1, CuiCountdownComponent e2);
        private static bool EqualComponent(CuiRectTransformComponent e1, CuiRectTransformComponent e2);
        private static bool EqualComponent(CuiTextComponent e1, CuiTextComponent e2);
        private static bool EqualComponent(CuiButtonComponent e1, CuiButtonComponent e2);
        private static bool EqualComponent(CuiRawImageComponent e1, CuiRawImageComponent e2);
        private static bool EqualComponent(CuiImageComponent e1, CuiImageComponent e2);
        private static bool EqualComponent(CuiOutlineComponent e1, CuiOutlineComponent e2);
        private static bool EqualComponent(CuiInputFieldComponent e1, CuiInputFieldComponent e2);
    }

    [Serializable]
    internal class CuiFunction
    {
        public readonly List<List<CuiElement>> cacheArgs;
        private int _argc;
        public string GUI;
        public int argc();
    }

    internal class CuiFunctionConverter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private readonly HashSet<ulong> connected;
    private readonly Dictionary<ulong, List<string>> uiCache;
    private void OnServerInitialized();
    private void Unload();
    private void CacheUI(ulong userId, string json);
    private void PutsCacheUI(ulong userId);
    private void OnPlayerSleepEnded(BasePlayer player);
    private void OnPlayerConnected(BasePlayer player);
    private static string CleanName(string strIn);
    private void OnPlayerAddUiDisconnected(ulong userId, string reason);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnPluginUnloaded(Plugin plugin);
    internal void onCuiGeneratorInitialized();
    private Dictionary<string, Dictionary<string, CuiFunction>> functions;
    private readonly Dictionary<BasePlayer, List<UIData>> players;
    private readonly CuiElementComparer CuiComparer;
    private bool isLoaded;
    private bool isDebug;
    private int drawCache;
    private int draw;
    private readonly DynamicConfigFile uiDB;
    private readonly DynamicConfigFile imagesDB;
    private void IDrawUI(BasePlayer player, UIData data);
    private void DrawUIWithoutCache(BasePlayer player, UIData dataOld, UIData dataNew);
    private void GetHierarchy(CuiElement element, List<CuiElement> function, List<CuiElement> hierarchy);
    private int GetDept(CuiElement obj);
    private List<CuiElement> sortContainer;
    private List<CuiElement> SortHierarchy(List<CuiElement> container);
    private List<CuiElement> SortHierarchy(List<CuiElement> container, List<CuiElement> allElements);
    private Rect GetRect(CuiElement e);
    private bool Intersect(Rect a, Rect b);
    public static Vector2 ParseVector(string p);
    private string HandleArgs(string json, object[] args);
    private void IDestroyUI(BasePlayer player, UIData data);
    private void DestroyAllUI(BasePlayer player);
    internal void DrawUI_Internal(BasePlayer player, string plugin, string funcName, object[] args);
    internal void DrawUIWIthEx_Internal(BasePlayer player, string plugin, string funcName, CuiElementContainer additionalContainer, object[] args);
    internal void DestroyUI_Internal(BasePlayer player, string plugin, string funcName);
    private IEnumerator LoadFunctions();
    private List<CuiElement> GetChildsRecursive(List<CuiElement> elements, string name);
    private void SplitFunc(string func, string plugin, string funcName);
    private void DrawUI(BasePlayer player, string plugin, string funcName, object[] args);
    private void DrawUIWIthEx(BasePlayer player, string plugin, string funcName, Oxide.Game.Rust.Cui.CuiElementContainer additionalContainer, object[] args);
    private void DestroyUI(BasePlayer player, string plugin, string funcName);
    [ConsoleCommand("cui.debug")]
    private void cmdDebug(ConsoleSystem.Arg arg);
    [ConsoleCommand("cui.args")]
    private void cmdArgs(ConsoleSystem.Arg arg);
    public static class IntersectCore
    {
        public static Rect GetRect(CuiRectTransformComponent transform);
        private static bool ValueInRange(float value, float min, float max);
        public static bool Intersects(Rect a, Rect b);
    }

    internal class UIData
    {
        public CuiElementContainer additionalContainer;
        public object[] args;
        public string funcName;
        public string plugin;
        public UIData(string plugin, string funcName, object[] args);
        public UIData(string plugin, string funcName, CuiElementContainer additionalContainer, object[] args);
        public override string ToString();
    }

    public class ComponentConverter : JsonConverter
    {
        public override bool CanWrite { get; set; }
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    public class CuiButton
    {
        public CuiButtonComponent Button { get; set; }
        public CuiRectTransformComponent RectTransform { get; set; }
        public CuiTextComponent Text { get; set; }
        public float FadeOut { get; set; }
    }

    public class CuiPanel
    {
        public CuiImageComponent Image { get; set; }
        public CuiRawImageComponent RawImage { get; set; }
        public CuiRectTransformComponent RectTransform { get; set; }
        public bool CursorEnabled { get; set; }
        public float FadeOut { get; set; }
    }

    public class CuiLabel
    {
        public CuiTextComponent Text { get; set; }
        public CuiRectTransformComponent RectTransform { get; set; }
        public float FadeOut { get; set; }
    }

    public class CuiElementContainer : List<CuiElement>
    {
        public CuiElementContainer();
        public CuiElementContainer(List<CuiElement> elements);
        public string Add(CuiButton button, string parent, string name);
        public string Add(CuiLabel label, string parent, string name);
        public string Add(CuiPanel panel, string parent, string name);
        public string ToJson();
        public override string ToString();
    }

    public static class CuiHelper
    {
        public static string ToJson(List<CuiElement> elements, bool format);
        public static List<CuiElement> FromJson(string json);
        public static string GetGuid();
        public static bool AddUi(BasePlayer player, List<CuiElement> elements);
        public static bool AddUi(BasePlayer player, string json);
        public static bool DestroyUi(BasePlayer player, string elem);
        public static void SetColor(ICuiColor elem, Color color);
        public static Color GetColor(ICuiColor elem);
    }

    public class CuiButtonComponent : ICuiComponent, ICuiColor
    {
        public string Type { get; set; }
        [JsonProperty("command")]
        public string Command { get; set; }
        [JsonProperty("close")]
        public string Close { get; set; }
        [DefaultValue("Assets/Content/UI/UI.Background.Tile.psd")]
        [JsonProperty("sprite")]
        public string Sprite { get; set; }
        [DefaultValue("Assets/Icons/IconMaterial.mat")]
        [JsonProperty("material")]
        public string Material { get; set; }
        public string Color { get; set; }
        [DefaultValue(Image.Type.Simple)]
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty("imagetype")]
        public Image.Type ImageType { get; set; }
        [JsonProperty("fadeIn")]
        public float FadeIn { get; set; }
    }

    public class CuiCountdownComponent : ICuiComponent
    {
        public string Type { get; set; }
        [JsonProperty("startTime"), DefaultValue(0)]
        public int StartTime;
        [JsonProperty("endTime"), DefaultValue(0)]
        public int EndTime;
        [JsonProperty("step"), DefaultValue(1)]
        public int Step;
        [JsonProperty("command"), DefaultValue("")]
        public string Command;
    }

    public class CuiElement
    {
        [DefaultValue("AddUI CreatedPanel")]
        [JsonProperty("name")]
        public string Name { get; set; }
        [JsonProperty("parent")]
        public string Parent { get; set; }
        [JsonProperty("components")]
        public List<ICuiComponent> Components { get; set; }
        [JsonProperty("fadeOut")]
        public float FadeOut { get; set; }
    }

    public class CuiImageComponent : ICuiComponent, ICuiColor
    {
        public string Type { get; set; }
        [DefaultValue("Assets/Content/UI/UI.Background.Tile.psd")]
        [JsonProperty("sprite")]
        public string Sprite { get; set; }
        [DefaultValue("Assets/Icons/IconMaterial.mat")]
        [JsonProperty("material")]
        public string Material { get; set; }
        public string Color { get; set; }
        [DefaultValue(Image.Type.Simple)]
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty("imagetype")]
        public Image.Type ImageType { get; set; }
        [JsonProperty("png")]
        public string Png { get; set; }
        [JsonProperty("fadeIn")]
        public float FadeIn { get; set; }
    }

    public class CuiInputFieldComponent : ICuiComponent, ICuiColor
    {
        public string Type { get; set; }
        [DefaultValue("Text")]
        [JsonProperty("text")]
        public string Text { get; set; }
        [DefaultValue(14)]
        [JsonProperty("fontSize")]
        public int FontSize { get; set; }
        [DefaultValue("RobotoCondensed-Bold.ttf")]
        [JsonProperty("font")]
        public string Font { get; set; }
        [DefaultValue(TextAnchor.UpperLeft)]
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty("align")]
        public TextAnchor Align { get; set; }
        public string Color { get; set; }
        [DefaultValue(100)]
        [JsonProperty("characterLimit")]
        public int CharsLimit { get; set; }
        [JsonProperty("command")]
        public string Command { get; set; }
        [DefaultValue(false)]
        [JsonProperty("password")]
        public bool IsPassword { get; set; }
    }

    public class CuiNeedsCursorComponent : ICuiComponent
    {
        public string Type { get; set; }
    }

    public class CuiOutlineComponent : ICuiComponent, ICuiColor
    {
        public string Type { get; set; }
        public string Color { get; set; }
        [DefaultValue("1.0 -1.0")]
        [JsonProperty("distance")]
        public string Distance { get; set; }
        [DefaultValue(false)]
        [JsonProperty("useGraphicAlpha")]
        public bool UseGraphicAlpha { get; set; }
    }

    public class CuiRawImageComponent : ICuiComponent, ICuiColor
    {
        public string Type { get; set; }
        [DefaultValue("Assets/Icons/rust.png")]
        [JsonProperty("sprite")]
        public string Sprite { get; set; }
        public string Color { get; set; }
        [JsonProperty("material")]
        public string Material { get; set; }
        [JsonProperty("url")]
        public string Url { get; set; }
        [JsonProperty("png")]
        public string Png { get; set; }
        [JsonProperty("fadeIn")]
        public float FadeIn { get; set; }
    }

    public class CuiRectTransformComponent : ICuiComponent
    {
        public string Type { get; set; }
        [DefaultValue("0.0 0.0")]
        [JsonProperty("anchormin")]
        public string AnchorMin { get; set; }
        [DefaultValue("1.0 1.0")]
        [JsonProperty("anchormax")]
        public string AnchorMax { get; set; }
        [DefaultValue("0.0 0.0")]
        [JsonProperty("offsetmin")]
        public string OffsetMin { get; set; }
        [DefaultValue("0.0 0.0")]
        [JsonProperty("offsetmax")]
        public string OffsetMax { get; set; }
    }

    public class CuiTextComponent : ICuiComponent, ICuiColor
    {
        public string Type { get; set; }
        [DefaultValue("Text")]
        [JsonProperty("text")]
        public string Text { get; set; }
        [DefaultValue(14)]
        [JsonProperty("fontSize")]
        public int FontSize { get; set; }
        [DefaultValue("RobotoCondensed-Bold.ttf")]
        [JsonProperty("font")]
        public string Font { get; set; }
        [DefaultValue(TextAnchor.UpperLeft)]
        [JsonConverter(typeof(StringEnumConverter))]
        [JsonProperty("align")]
        public TextAnchor Align { get; set; }
        public string Color { get; set; }
        [JsonProperty("fadeIn")]
        public float FadeIn { get; set; }
    }

    [PluginReference]
    private Plugin ImageLibrary;
     bool AddImage(string url, string imageName, ulong imageId, Action callback);
     string GetImage(string imageName, ulong imageId, bool returnUrl);
     bool HasImage(string imageName, ulong imageId);
     IEnumerator AddImageCoroutine(string imagename, string url);
     IEnumerator AddImages(Dictionary<string, string> images);
}

public class CuiElementComparer : IEqualityComparer<CuiElement>
{
     bool Equals(CuiElement x, CuiElement y);
     int GetHashCode(CuiElement obj);
    public static bool EqualElement(CuiElement e1, CuiElement e2);
    private static bool EqualComponent(ICuiComponent e1, ICuiComponent e2);
    private static bool EqualComponent(CuiCountdownComponent e1, CuiCountdownComponent e2);
    private static bool EqualComponent(CuiRectTransformComponent e1, CuiRectTransformComponent e2);
    private static bool EqualComponent(CuiTextComponent e1, CuiTextComponent e2);
    private static bool EqualComponent(CuiButtonComponent e1, CuiButtonComponent e2);
    private static bool EqualComponent(CuiRawImageComponent e1, CuiRawImageComponent e2);
    private static bool EqualComponent(CuiImageComponent e1, CuiImageComponent e2);
    private static bool EqualComponent(CuiOutlineComponent e1, CuiOutlineComponent e2);
    private static bool EqualComponent(CuiInputFieldComponent e1, CuiInputFieldComponent e2);
}

[Serializable]
internal class CuiFunction
{
    public readonly List<List<CuiElement>> cacheArgs;
    private int _argc;
    public string GUI;
    public int argc();
}

internal class CuiFunctionConverter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

public static class IntersectCore
{
    public static Rect GetRect(CuiRectTransformComponent transform);
    private static bool ValueInRange(float value, float min, float max);
    public static bool Intersects(Rect a, Rect b);
}

internal class UIData
{
    public CuiElementContainer additionalContainer;
    public object[] args;
    public string funcName;
    public string plugin;
    public UIData(string plugin, string funcName, object[] args);
    public UIData(string plugin, string funcName, CuiElementContainer additionalContainer, object[] args);
    public override string ToString();
}

public class ComponentConverter : JsonConverter
{
    public override bool CanWrite { get; set; }
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

public class CuiButton
{
    public CuiButtonComponent Button { get; set; }
    public CuiRectTransformComponent RectTransform { get; set; }
    public CuiTextComponent Text { get; set; }
    public float FadeOut { get; set; }
}

public class CuiPanel
{
    public CuiImageComponent Image { get; set; }
    public CuiRawImageComponent RawImage { get; set; }
    public CuiRectTransformComponent RectTransform { get; set; }
    public bool CursorEnabled { get; set; }
    public float FadeOut { get; set; }
}

public class CuiLabel
{
    public CuiTextComponent Text { get; set; }
    public CuiRectTransformComponent RectTransform { get; set; }
    public float FadeOut { get; set; }
}

public class CuiElementContainer : List<CuiElement>
{
    public CuiElementContainer();
    public CuiElementContainer(List<CuiElement> elements);
    public string Add(CuiButton button, string parent, string name);
    public string Add(CuiLabel label, string parent, string name);
    public string Add(CuiPanel panel, string parent, string name);
    public string ToJson();
    public override string ToString();
}

public static class CuiHelper
{
    public static string ToJson(List<CuiElement> elements, bool format);
    public static List<CuiElement> FromJson(string json);
    public static string GetGuid();
    public static bool AddUi(BasePlayer player, List<CuiElement> elements);
    public static bool AddUi(BasePlayer player, string json);
    public static bool DestroyUi(BasePlayer player, string elem);
    public static void SetColor(ICuiColor elem, Color color);
    public static Color GetColor(ICuiColor elem);
}

public class CuiButtonComponent : ICuiComponent, ICuiColor
{
    public string Type { get; set; }
    [JsonProperty("command")]
    public string Command { get; set; }
    [JsonProperty("close")]
    public string Close { get; set; }
    [DefaultValue("Assets/Content/UI/UI.Background.Tile.psd")]
    [JsonProperty("sprite")]
    public string Sprite { get; set; }
    [DefaultValue("Assets/Icons/IconMaterial.mat")]
    [JsonProperty("material")]
    public string Material { get; set; }
    public string Color { get; set; }
    [DefaultValue(Image.Type.Simple)]
    [JsonConverter(typeof(StringEnumConverter))]
    [JsonProperty("imagetype")]
    public Image.Type ImageType { get; set; }
    [JsonProperty("fadeIn")]
    public float FadeIn { get; set; }
}

public class CuiCountdownComponent : ICuiComponent
{
    public string Type { get; set; }
    [JsonProperty("startTime"), DefaultValue(0)]
    public int StartTime;
    [JsonProperty("endTime"), DefaultValue(0)]
    public int EndTime;
    [JsonProperty("step"), DefaultValue(1)]
    public int Step;
    [JsonProperty("command"), DefaultValue("")]
    public string Command;
}

public class CuiElement
{
    [DefaultValue("AddUI CreatedPanel")]
    [JsonProperty("name")]
    public string Name { get; set; }
    [JsonProperty("parent")]
    public string Parent { get; set; }
    [JsonProperty("components")]
    public List<ICuiComponent> Components { get; set; }
    [JsonProperty("fadeOut")]
    public float FadeOut { get; set; }
}

public class CuiImageComponent : ICuiComponent, ICuiColor
{
    public string Type { get; set; }
    [DefaultValue("Assets/Content/UI/UI.Background.Tile.psd")]
    [JsonProperty("sprite")]
    public string Sprite { get; set; }
    [DefaultValue("Assets/Icons/IconMaterial.mat")]
    [JsonProperty("material")]
    public string Material { get; set; }
    public string Color { get; set; }
    [DefaultValue(Image.Type.Simple)]
    [JsonConverter(typeof(StringEnumConverter))]
    [JsonProperty("imagetype")]
    public Image.Type ImageType { get; set; }
    [JsonProperty("png")]
    public string Png { get; set; }
    [JsonProperty("fadeIn")]
    public float FadeIn { get; set; }
}

public class CuiInputFieldComponent : ICuiComponent, ICuiColor
{
    public string Type { get; set; }
    [DefaultValue("Text")]
    [JsonProperty("text")]
    public string Text { get; set; }
    [DefaultValue(14)]
    [JsonProperty("fontSize")]
    public int FontSize { get; set; }
    [DefaultValue("RobotoCondensed-Bold.ttf")]
    [JsonProperty("font")]
    public string Font { get; set; }
    [DefaultValue(TextAnchor.UpperLeft)]
    [JsonConverter(typeof(StringEnumConverter))]
    [JsonProperty("align")]
    public TextAnchor Align { get; set; }
    public string Color { get; set; }
    [DefaultValue(100)]
    [JsonProperty("characterLimit")]
    public int CharsLimit { get; set; }
    [JsonProperty("command")]
    public string Command { get; set; }
    [DefaultValue(false)]
    [JsonProperty("password")]
    public bool IsPassword { get; set; }
}

public class CuiNeedsCursorComponent : ICuiComponent
{
    public string Type { get; set; }
}

public class CuiOutlineComponent : ICuiComponent, ICuiColor
{
    public string Type { get; set; }
    public string Color { get; set; }
    [DefaultValue("1.0 -1.0")]
    [JsonProperty("distance")]
    public string Distance { get; set; }
    [DefaultValue(false)]
    [JsonProperty("useGraphicAlpha")]
    public bool UseGraphicAlpha { get; set; }
}

public class CuiRawImageComponent : ICuiComponent, ICuiColor
{
    public string Type { get; set; }
    [DefaultValue("Assets/Icons/rust.png")]
    [JsonProperty("sprite")]
    public string Sprite { get; set; }
    public string Color { get; set; }
    [JsonProperty("material")]
    public string Material { get; set; }
    [JsonProperty("url")]
    public string Url { get; set; }
    [JsonProperty("png")]
    public string Png { get; set; }
    [JsonProperty("fadeIn")]
    public float FadeIn { get; set; }
}

public class CuiRectTransformComponent : ICuiComponent
{
    public string Type { get; set; }
    [DefaultValue("0.0 0.0")]
    [JsonProperty("anchormin")]
    public string AnchorMin { get; set; }
    [DefaultValue("1.0 1.0")]
    [JsonProperty("anchormax")]
    public string AnchorMax { get; set; }
    [DefaultValue("0.0 0.0")]
    [JsonProperty("offsetmin")]
    public string OffsetMin { get; set; }
    [DefaultValue("0.0 0.0")]
    [JsonProperty("offsetmax")]
    public string OffsetMax { get; set; }
}

public class CuiTextComponent : ICuiComponent, ICuiColor
{
    public string Type { get; set; }
    [DefaultValue("Text")]
    [JsonProperty("text")]
    public string Text { get; set; }
    [DefaultValue(14)]
    [JsonProperty("fontSize")]
    public int FontSize { get; set; }
    [DefaultValue("RobotoCondensed-Bold.ttf")]
    [JsonProperty("font")]
    public string Font { get; set; }
    [DefaultValue(TextAnchor.UpperLeft)]
    [JsonConverter(typeof(StringEnumConverter))]
    [JsonProperty("align")]
    public TextAnchor Align { get; set; }
    public string Color { get; set; }
    [JsonProperty("fadeIn")]
    public float FadeIn { get; set; }
}


```

---

## CupboardAutoLock by  - Automatically add a codelock on cupboards, with option to lock access to all cupboards inventories

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Cupboard Auto Lock", "BuzZ/Arainrr", "0.0.6")]
[Description("Automatically add a codelock on cupboards.")]
public class CupboardAutoLock : RustPlugin
{
    private const string PERMISSION_USE;
    private const string PREFAB_CODE_LOCK;
    private void Init();
    private void OnEntityBuilt(Planner planner, GameObject obj);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Prevent inventory from being accessed")]
        public bool cupboardNoRefill;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private string Lang(string key, string id, object[] args);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Prevent inventory from being accessed")]
    public bool cupboardNoRefill;
}


```

---

## CupboardForFriends by j0se - Only allow friends, team and clan mates of already authorized people to authorize themselves.

```csharp
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Cupboard for Friends", "LaserHydra", "2.0.0", ResourceId = 1578)]
[Description("Only allow friends of already authorized people to authorize themselves.")]
 class CupboardForFriends : RustPlugin
{
     bool debug;
     bool blockDamage;
     bool adminByPass;
    [PluginReference]
     Plugin Clans;
     Plugin Friends;
     void Loaded();
     void LoadMessages();
    new void LoadConfig();
    protected override void LoadDefaultConfig();
     void OnEntityTakeDamage(BaseCombatEntity vic, HitInfo info);
     object OnCupboardClearList(BuildingPrivlidge priviledge, BasePlayer player);
     object OnCupboardAuthorize(BuildingPrivlidge priviledge, BasePlayer player);
     object TestForFriends(BuildingPrivlidge priviledge, BasePlayer player, bool isDamage);
     bool IsFriend(BasePlayer player, string friendID);
     bool IsClanMember(BasePlayer player, string targetID);
     bool IsTeamMember(BasePlayer player, string targetID);
     string ListToString(List<string> list, int first, string seperator);
     void SetConfig(object[] args);
     string GetMsg(string key, string userID);
     void DevMsg(string prefix, string msg);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
}


```

---

## CupboardInfoLogs by  - Logs info about TC when placed!

```csharp
using System;
using UnityEngine;

Oxide.Plugins
[Info("CupboardInfoLogs", "NubbbZ", "1.1.1")]
[Description("Logs info about TC when placed!")]
 class CupboardInfoLogs : CovalencePlugin
{
     void OnEntityBuilt(Planner plan, GameObject go);
    private void Make_Log(BasePlayer Player, BaseEntity TC);
}


```

---

## CupboardLimiter by Spiikesan - Set a max on cupboard placements for player(s) with permissions

```csharp
using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("Cupboard Limiter", "Spiikesan", "1.7.6")]
[Description("Simplified version for cupboard limits")]
public class CupboardLimiter : RustPlugin
{
     bool debug;
    const string Vip_Perm;
    const string Bypass_Perm;
    const string Admin_Perm;
    const string Other_Perm;
    const string CommandList_Perm;
    const string Message_MaxLimitDefault;
    const string Message_MaxLimitVip;
    const string Message_MaxLimit;
    const string Message_Remaining;
    const string Message_NoPermission;
    const string Message_Inspect;
    const string Message_InspectOwn;
    const string Message_InspectNotFound;
    const string Message_InspectUsage;
    const string Message_TeamOvercount;
    const string Message_TeamOvercountTarget;
    const string Message_Error;
     Dictionary<ulong, List<BuildingPrivlidge>> TCIDs;
    private int TCCount(BasePlayer player);
    private void TCAdd(ulong playerId, BuildingPrivlidge tcId);
    private void TCDel(ulong playerId, BuildingPrivlidge tcId);
     void Init();
    private ConfigData configData;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Max amount of TC(s) to place")]
        public Settings Limits;
        [JsonProperty(PropertyName = "Discord Notification")]
        public SettingsDiscord Discord;
        [JsonProperty(PropertyName = "Chat Settings")]
        public SettingsChat Chat;
    }

     class Settings
    {
        [JsonProperty(PropertyName = "Limit Default")]
        public int DefaultLimit;
        [JsonProperty(PropertyName = "Limit Vip")]
        public int VipLimit;
        [JsonProperty(PropertyName = "Limit Others")]
        public List<int> OtherLimits;
        [JsonProperty(PropertyName = "Limit Others Can Downgrade Default")]
        public bool OtherLimitsOverDefault;
        [JsonProperty(PropertyName = "Global Team Limit")]
        public bool GlobalTeamLimit;
        [JsonProperty(PropertyName = "Limits In Team")]
        public Dictionary<int, int> TeamLimits;
    }

     class SettingsDiscord
    {
        [JsonProperty(PropertyName = "Discord Webhook URL")]
        public string DiscordWebhookAddress;
    }

     class SettingsChat
    {
        [JsonProperty(PropertyName = "Prefix")]
        public string Prefix;
        [JsonProperty(PropertyName = "Icon's SteamId")]
        public ulong SteamIdIcon;
    }

    private bool LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConf();
    protected override void LoadDefaultMessages();
     void OnServerInitialized();
     void OnEntitySpawned(BaseEntity entity, UnityEngine.GameObject gameObject);
     void OnEntityKill(BaseEntity entity);
     object OnTeamInvite(BasePlayer inviter, BasePlayer target);
    [ChatCommand("tc")]
    private void ChatCommand_Inspect(BasePlayer player, string command, string[] args);
    [ConsoleCommand("tc")]
    private void ServerCommand_Inspect(ConsoleSystem.Arg arg);
     void RefundTC(BaseEntity tC, BasePlayer player);
    public int GetTCLimit(BasePlayer player, bool isInvite);
    public void Callback(int code, string response);
    public string FormatMessage(string messageId, string userId, object[] parameters);
    private void ChatMessage(BasePlayer player, string message);
    private string PlayerTcsString(BasePlayer player, string receiverId, bool isOwn);
    private string GetCoordinates(Vector3 position);
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Max amount of TC(s) to place")]
    public Settings Limits;
    [JsonProperty(PropertyName = "Discord Notification")]
    public SettingsDiscord Discord;
    [JsonProperty(PropertyName = "Chat Settings")]
    public SettingsChat Chat;
}

 class Settings
{
    [JsonProperty(PropertyName = "Limit Default")]
    public int DefaultLimit;
    [JsonProperty(PropertyName = "Limit Vip")]
    public int VipLimit;
    [JsonProperty(PropertyName = "Limit Others")]
    public List<int> OtherLimits;
    [JsonProperty(PropertyName = "Limit Others Can Downgrade Default")]
    public bool OtherLimitsOverDefault;
    [JsonProperty(PropertyName = "Global Team Limit")]
    public bool GlobalTeamLimit;
    [JsonProperty(PropertyName = "Limits In Team")]
    public Dictionary<int, int> TeamLimits;
}

 class SettingsDiscord
{
    [JsonProperty(PropertyName = "Discord Webhook URL")]
    public string DiscordWebhookAddress;
}

 class SettingsChat
{
    [JsonProperty(PropertyName = "Prefix")]
    public string Prefix;
    [JsonProperty(PropertyName = "Icon's SteamId")]
    public ulong SteamIdIcon;
}


```

---

## CupboardList by KrunghCrow - Displays a list of who is authorized on tool cupboards and who placed it

```csharp
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("CupboardList", "Krungh Crow", "1.0.4")]
 class CupboardList : RustPlugin
{
    private const string Prefab;
    private const string Prefab2;
    private string msg(string key, string id);
    private string prefix;
    private ulong chaticon;
    private CupboardListConfig config;
     void Init();
     void LoadConfigValues();
    protected override void LoadDefaultConfig();
     class CupboardListConfig
    {
        public string Prefix { get; set; }
        public ulong ChatIcon { get; set; }
    }

    [ChatCommand("cupauth")]
     void AuthCmd(BasePlayer player, string command, string[] args);
    [ChatCommand("cupowner")]
     void OwnerCmd(BasePlayer player, string command, string[] args);
    private BaseEntity GetViewEntity(BasePlayer player);
    private bool IsCupboardEntity(BaseEntity entity);
    protected override void LoadDefaultMessages();
}

 class CupboardListConfig
{
    public string Prefix { get; set; }
    public ulong ChatIcon { get; set; }
}


```

---

## CupboardMessages by Ryan - Sends a configured message to a player when they place a tool cupboard

```csharp
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Plugins.CupboardMessagesExt;

Oxide.Plugins
[Info("Cupboard Messages", "Ryan", "1.1.0")]
[Description("Sends a configured message to a user when they place a tool cupboard")]
public class CupboardMessages : RustPlugin
{
    public static CupboardMessages Instance;
    private const string Perm;
    private bool UseTooltips;
    private readonly Dictionary<ulong, Timer> NoticeTimers;
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void NoticePlayer(BasePlayer player, string notice);
    private void Init();
    private void OnEntitySpawned(BaseNetworkable networkable);
}

Oxide.Plugins.CupboardMessagesExt
public static class Extensions
{
    private static readonly Permission permission;
    private static readonly Lang lang;
    public static bool HasPermission(BasePlayer player, string perm);
    public static string Lang(string key, string id, object[] args);
}


```

---

## CupboardNoDecay by Rick6 - Use cupboard to protect from decay without resources and prevent entity decay under radius.

```csharp
using System;
using Rust;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Facepunch;

Oxide.Plugins
[Info("CupboardNoDecay", "Rick", "1.3.0")]
[Description("Use cupboard to protect from decay without consuming resources.")]
public class CupboardNoDecay : RustPlugin
{
    private ConfigData configData;
     void OnServerInitialized();
    private class ConfigData
    {
        public bool CheckAuth { get; set; }
        public bool DecayTwig { get; set; }
        public bool DecayWood { get; set; }
        public bool DecayStone { get; set; }
        public bool DecayMetal { get; set; }
        public bool DecayArmor { get; set; }
        public float TwigRate { get; set; }
        public float WoodRate { get; set; }
        public float StoneRate { get; set; }
        public float MetalRate { get; set; }
        public float ArmorRate { get; set; }
        public float EntityRadius { get; set; }
        public string[] NeverDecay { get; set; }
    }

    protected override void LoadDefaultConfig();
    private void LoadVariables();
     void LoadConfigVariables();
     void SaveConfig(ConfigData config);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private bool CheckCupboardEntity(BaseEntity entity, HitInfo hitInfo, string name);
    private bool CheckCupboardBlock(BuildingBlock block, HitInfo hitInfo, string ename);
    private bool CupboardAuthCheck(BuildingPrivlidge priv, ulong hitEntityOwnerID);
}

private class ConfigData
{
    public bool CheckAuth { get; set; }
    public bool DecayTwig { get; set; }
    public bool DecayWood { get; set; }
    public bool DecayStone { get; set; }
    public bool DecayMetal { get; set; }
    public bool DecayArmor { get; set; }
    public float TwigRate { get; set; }
    public float WoodRate { get; set; }
    public float StoneRate { get; set; }
    public float MetalRate { get; set; }
    public float ArmorRate { get; set; }
    public float EntityRadius { get; set; }
    public string[] NeverDecay { get; set; }
}


```

---

## CupboardOnFoundation by  - Authorize cupboard to be placed only on foundation

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

Oxide.Plugins
[Info("Cupboard On Foundation", "BuzZ/Krungh Crow", "1.1.1")]
[Description("Authorize cupboard to be placed only on foundation")]
public class CupboardOnFoundation : RustPlugin
{
     bool debug;
    const string FoundationOnly;
     void Init();
    protected override void LoadDefaultMessages();
     void OnEntitySpawned(BaseEntity entity, UnityEngine.GameObject gameObject);
     void CheckWherePlaced(BaseEntity cupboard, BaseEntity entity, BasePlayer player, string found);
     void CancelThisCupboard(BaseEntity entity, BasePlayer player);
}


```

---

## CupboardPlus by Mevent - Destroys the home and runs commands after cupboard destroying

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Cupboard Plus", "Mevent", "1.0.0")]
[Description("Destroys the home and runs commands after cupboard destroying")]
public class CupboardPlus : RustPlugin
{
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Commands List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Commands;
        [JsonProperty(PropertyName = "Destroy the home?")]
        public bool HomeDestroy;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private void OnEntityDeath(BuildingPrivlidge cupboard, HitInfo info);
    private IEnumerator DestroyEntities(List<BaseEntity> entities);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Commands List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Commands;
    [JsonProperty(PropertyName = "Destroy the home?")]
    public bool HomeDestroy;
}


```

---

## CupboardProtection by NooBlet - Makes cupboards and their foundations invulnerable, unable to be destroyed

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using Newtonsoft.Json;

Oxide.Plugins
[Info("CupboardProtection", "Wulf/lukespragg and birthdates Maintained by NooBlet", "1.9.4")]
[Description("Makes cupboards and their foundations invulnerable, unable to be destroyed.")]
public class CupboardProtection : RustPlugin
{
    private readonly int Mask;
    private object OnEntityTakeDamage(DecayEntity entity, HitInfo info);
    private static object CHook(string Name, BaseEntity Player, DecayEntity Entity);
    private void Init();
    private void OnNewSave(string filename);
    private void Unload();
    private void OnEntityBuilt(Planner plan, GameObject go);
    private BuildingBlock GetFoundation(BuildingPrivlidge Priv);
    private void OnEntityKill(BuildingPrivlidge entity);
     void CheckTCs();
    private void timer10m();
    private bool canBreakTC(BasePlayer player, DecayEntity Entity);
    private Data IDData;
    private class Data
    {
        public readonly Dictionary<ulong, ulong> IDs;
    }

    private void SaveData();
    private ConfigFile Configuration;
    public class ConfigFile
    {
        [JsonProperty("Foundation Invincible?")]
        public bool foundation;
        [JsonProperty("TC Owner can Damage TC and Foundation?")]
        public bool OwnerCanDoDamage;
        [JsonProperty("Team can Damage TC and Foundation?")]
        public bool teamCanDoDamage;
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class Data
{
    public readonly Dictionary<ulong, ulong> IDs;
}

public class ConfigFile
{
    [JsonProperty("Foundation Invincible?")]
    public bool foundation;
    [JsonProperty("TC Owner can Damage TC and Foundation?")]
    public bool OwnerCanDoDamage;
    [JsonProperty("Team can Damage TC and Foundation?")]
    public bool teamCanDoDamage;
    public static ConfigFile DefaultConfig();
}


```

---

## CupboardRange by  - Prohibits construction in the range of the cupboard

```csharp
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("CupboardRange", "DEUSNEXUS", "1.0.0")]
 class CupboardRange : RustPlugin
{
    private Dictionary<ulong, DateTime> _cooldown;
     void LoadDefaultMessages();
    private object CanBuild(Planner plan, Construction prefab);
     string Lang(string key, string id, object[] args);
}


```

---

## CustomAmmo by Ryz0r - Allows players with permission to change the ammo type for their currently held weapon

```csharp
using System.Collections.Generic;
using Oxide.Core;

Oxide.Plugins
[Info("Custom Ammo", "Ryz0r", "1.0.1")]
[Description("Allows players to use a custom ammunition in their gun they are holding. Enabling custom ammo will give infinite ammo.")]
internal class CustomAmmo : RustPlugin
{
    private const string NoReloadPerm;
    private const string NoDamagePerm;
    private const string CommandPerm;
    private static List<string> _toggledList;
    private void SaveData();
    protected override void LoadDefaultMessages();
    private void OnNewSave(string filename);
    private void Init();
    [ChatCommand("switch")]
    private void SwitchAmmoCommand(BasePlayer player, string command, string[] args);
    private void OnWeaponFired(BaseProjectile weapon, BasePlayer player);
    private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile);
}


```

---

## CustomAnimalSpawns by k1lly0u - Creates additional spawn points for animals of your choosing, that re-spawn on a timer

```csharp
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;

Oxide.Plugins
[Info("CustomAnimalSpawns", "k1lly0u", "0.1.56")]
[Description("Creates additional spawn points for animals of your choosing, that re-spawn on a timer")]
 class CustomAnimalSpawns : RustPlugin
{
    private CASData casData;
    private DynamicConfigFile casdata;
    private List<BaseEntity> animalCache;
    private List<Timer> refreshTimers;
    private Dictionary<ulong, int> animalCreators;
    private Dictionary<int, string> animalTypes;
    private void Loaded();
    private void OnServerInitialized();
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private void OnPlayerInput(BasePlayer player, InputState input);
    private void Unload();
    private void InitializeAnimalSpawns();
    private void InitiateRefresh(BaseEntity resource);
    private void InitializeNewSpawn(string type, Vector3 position);
    private Vector3 SpawnAnimalEntity(string type, Vector3 pos);
    private BaseEntity InstantiateEntity(string type, Vector3 position);
    private bool FindPointOnNavmesh(Vector3 center, float range, Vector3 result);
    private class NPCController : MonoBehaviour
    {
        public BaseNpc npc;
        private Vector3 homePos;
        private void Awake();
        private void OnDestroy();
        public void SetHome(Vector3 homePos);
        private void CheckLocation();
    }

    private void AddSpawn(BasePlayer player, int type);
    private Vector3 GetSpawnPos(BasePlayer player);
    private List<Vector3> FindInRadius(Vector3 pos, float rad);
    private bool RemoveFromData(Vector3 pos);
    private float GetDistance(Vector3 v3, Vector3 v32);
    private void ShowAnimalList(BasePlayer player);
    private void ShowCurrentAnimals(BasePlayer player);
    private void SendEchoConsole(Network.Connection cn, string msg);
    [ChatCommand("cas")]
    private void chatAnimalSpawn(BasePlayer player, string command, string[] args);
    private bool CanSpawnAnimals(BasePlayer player);
    private ConfigData configData;
    private class ConfigData
    {
        public int RespawnTimer { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
    private void SaveData();
    private void LoadData();
    private class CASData
    {
        public List<CLAnimal> animals;
    }

    private class CLAnimal
    {
        public string Type;
        public Vector3 Position;
    }

    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private void SendMSG(BasePlayer player, string message);
    private string MSG(string key, string playerid);
    private Dictionary<string, string> messages;
}

private class NPCController : MonoBehaviour
{
    public BaseNpc npc;
    private Vector3 homePos;
    private void Awake();
    private void OnDestroy();
    public void SetHome(Vector3 homePos);
    private void CheckLocation();
}

private class ConfigData
{
    public int RespawnTimer { get; set; }
}

private class CASData
{
    public List<CLAnimal> animals;
}

private class CLAnimal
{
    public string Type;
    public Vector3 Position;
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## CustomAutoKits by  - Automatic kits by permission

```csharp
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Custom Auto Kits", "Absolut/Arainrr", "1.2.5", ResourceId = 41234154)]
[Description("Automatic kits by permission")]
public class CustomAutoKits : RustPlugin
{
    [PluginReference]
    private readonly Plugin EventManager;
    private readonly Plugin Kits;
    private readonly Dictionary<ulong, Hash<string, float>> kitCooldown;
    private void Init();
    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    private string GetSelectedKit(BasePlayer player, StoredData.PlayerData playerData);
    private static ConfigData.KitS GetDefaultKit(IEnumerable<ConfigData.KitS> availableKits);
    private IEnumerable<ConfigData.KitS> GetAvailableKits(BasePlayer player);
    private bool IsKit(string kitName);
    private void GiveKit(BasePlayer player, string kitName);
    private StoredData.PlayerData GetPlayerData(ulong playerID, bool readOnly);
    private void CmdChooseKit(BasePlayer player, string command, string[] args);
    [ConsoleCommand("CustomAutoKitsUI")]
    private void CCmdCustomAutoKitsUI(ConsoleSystem.Arg arg);
    private const string UINAME_MAIN;
    private const string UINAME_MENU;
    private void CreateMainUI(BasePlayer player);
    private void UpdateMenuUI(BasePlayer player, StoredData.PlayerData playerData);
    private static void CreateEntry(CuiElementContainer container, string command, string leftText, string rightText, string anchorMin, string anchorMax);
    private static float[] GetEntryAnchors(int i, float spacing);
    private static void DestroyUI(BasePlayer player);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Empty default items before give kits")]
        public bool emptyInventory;
        [JsonProperty(PropertyName = "Auto Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<AutoKit> autoKits;
        public class AutoKit
        {
            public string permission;
            public List<KitS> kits;
        }

        public class KitS
        {
            public int priority;
            public float cooldown;
            public string kitName;
            public string cooldownKit;
        }

        [JsonProperty(PropertyName = "Chat Settings")]
        public ChatSettings chatS;
        public class ChatSettings
        {
            [JsonProperty(PropertyName = "Chat Command")]
            public string command;
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string prefix;
            [JsonProperty(PropertyName = "Chat SteamID Icon")]
            public ulong steamIDIcon;
        }

        [JsonProperty(PropertyName = "Version")]
        public VersionNumber version;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private StoredData storedData;
    private class StoredData
    {
        public readonly Dictionary<ulong, PlayerData> playerPrefs;
        public readonly HashSet<ulong> players;
        public class PlayerData
        {
            public bool enabled;
            public string selectedKit;
        }

    }

    private void LoadData();
    private void SaveData();
    private void ClearData();
    private void OnNewSave(string filename);
    private void Print(BasePlayer player, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Empty default items before give kits")]
    public bool emptyInventory;
    [JsonProperty(PropertyName = "Auto Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<AutoKit> autoKits;
    public class AutoKit
    {
        public string permission;
        public List<KitS> kits;
    }

    public class KitS
    {
        public int priority;
        public float cooldown;
        public string kitName;
        public string cooldownKit;
    }

    [JsonProperty(PropertyName = "Chat Settings")]
    public ChatSettings chatS;
    public class ChatSettings
    {
        [JsonProperty(PropertyName = "Chat Command")]
        public string command;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat SteamID Icon")]
        public ulong steamIDIcon;
    }

    [JsonProperty(PropertyName = "Version")]
    public VersionNumber version;
}

public class AutoKit
{
    public string permission;
    public List<KitS> kits;
}

public class KitS
{
    public int priority;
    public float cooldown;
    public string kitName;
    public string cooldownKit;
}

public class ChatSettings
{
    [JsonProperty(PropertyName = "Chat Command")]
    public string command;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat SteamID Icon")]
    public ulong steamIDIcon;
}

private class StoredData
{
    public readonly Dictionary<ulong, PlayerData> playerPrefs;
    public readonly HashSet<ulong> players;
    public class PlayerData
    {
        public bool enabled;
        public string selectedKit;
    }

}

public class PlayerData
{
    public bool enabled;
    public string selectedKit;
}


```

---

## CustomCards by Camoec - Allows changing the max uses of keycards

```csharp
using System;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Custom Cards", "Camoec", 1.1)]
[Description("Allows to change the max uses of the keycards")]
public class CustomCards : RustPlugin
{
    private PluginConfig _config;
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Green KeyCard Max Uses")]
        public int GreenMaxUses;
        [JsonProperty(PropertyName = "Blue KeyCard Max Uses")]
        public int BlueMaxUses;
        [JsonProperty(PropertyName = "Red KeyCard Max Uses")]
        public int RedMaxUses;
    }

    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    private object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player);
}

private class PluginConfig
{
    [JsonProperty(PropertyName = "Green KeyCard Max Uses")]
    public int GreenMaxUses;
    [JsonProperty(PropertyName = "Blue KeyCard Max Uses")]
    public int BlueMaxUses;
    [JsonProperty(PropertyName = "Red KeyCard Max Uses")]
    public int RedMaxUses;
}


```

---

## CustomChatCommands by MrBlue - Allows you to add new chat commands

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("CustomChatCommands", "PsychoTea", "2.1.2")]
[Description("Allows you to set up custom commands.")]
 class CustomChatCommands : CovalencePlugin
{
     class ChatCommand
    {
        public string Command;
        public List<string> Messages;
        public string Permission;
        public List<string> ConsoleCmd;
        public ulong UserID;
        public bool Broadcast;
        public List<string> RconCmd;
        public float Cooldown;
        public int MaxUses;
        public ChatCommand(string Command, List<string> Messages, string Permission, List<string> ConsoleCmd, ulong UserID, bool Broadcast, List<string> RconCmd, float Cooldown, int MaxUses);
    }

     class Cooldown
    {
        public string CommandName;
        public double ExpiryPoint;
        public Cooldown(string CommandName, double ExpiryPoint);
    }

     class MaxUses
    {
        public string CommandName;
        public int Uses;
        public MaxUses(string CommandName, int Uses);
    }

     ConfigFile config;
     class ConfigFile
    {
        [JsonProperty(PropertyName = "Reset Cooldowns On New Map")]
        public bool ResetCooldownsOnNewMap;
        [JsonProperty(PropertyName = "Reset Max Uses On New Map")]
        public bool ResetMaxUsesOnNewMap;
        [JsonProperty(PropertyName = "Reset Max Uses At Midnight")]
        public bool ResetMaxUsesAtMidnight;
        public List<ChatCommand> Commands;
        public static ConfigFile DefaultConfig();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
     class StoredData
    {
        public Dictionary<ulong, List<Cooldown>> Cooldowns;
        public Dictionary<ulong, List<MaxUses>> MaxUses;
    }

     StoredData storedData;
     void SaveData();
     void ReadData();
     void Init();
     void Unload();
     void OnNewSave();
     void OnServerSave();
     void CustomCommand(IPlayer player, string command, string[] args);
    [Command("ccc.resetcooldowns")]
     void CCCResetCooldowns(IPlayer player, string command, string[] args);
    [Command("ccc.resetmaxuses")]
     void CCCResetMaxUses(IPlayer player, string command, string[] args);
     void SendMessages(IPlayer player, List<string> messages, ulong userID);
     void BroadcastMessages(List<string> messages, ulong userID);
     void AddCooldown(ulong userID, string commandName, float time);
     bool IsOnCooldown(ulong userID, string commandName);
     double CooldownRemaining(ulong userID, string commandName);
     void ResetCooldowns();
     void AddUse(ulong userID, string commandName);
     bool CanUseCommand(ulong userID, string commandName);
     void ResetMaxUses();
     double TimeSinceEpoch();
     bool IsHours(double seconds, double hours);
     string GetMessage(string key, string userID, string[] args);
}

 class ChatCommand
{
    public string Command;
    public List<string> Messages;
    public string Permission;
    public List<string> ConsoleCmd;
    public ulong UserID;
    public bool Broadcast;
    public List<string> RconCmd;
    public float Cooldown;
    public int MaxUses;
    public ChatCommand(string Command, List<string> Messages, string Permission, List<string> ConsoleCmd, ulong UserID, bool Broadcast, List<string> RconCmd, float Cooldown, int MaxUses);
}

 class Cooldown
{
    public string CommandName;
    public double ExpiryPoint;
    public Cooldown(string CommandName, double ExpiryPoint);
}

 class MaxUses
{
    public string CommandName;
    public int Uses;
    public MaxUses(string CommandName, int Uses);
}

 class ConfigFile
{
    [JsonProperty(PropertyName = "Reset Cooldowns On New Map")]
    public bool ResetCooldownsOnNewMap;
    [JsonProperty(PropertyName = "Reset Max Uses On New Map")]
    public bool ResetMaxUsesOnNewMap;
    [JsonProperty(PropertyName = "Reset Max Uses At Midnight")]
    public bool ResetMaxUsesAtMidnight;
    public List<ChatCommand> Commands;
    public static ConfigFile DefaultConfig();
}

 class StoredData
{
    public Dictionary<ulong, List<Cooldown>> Cooldowns;
    public Dictionary<ulong, List<MaxUses>> MaxUses;
}


```

---

## CustomCraftTimes by Camoec - Allows changing the crafting times for items

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Custom Craft Times", "Camoec", "1.1.1")]
[Description("Allows you to change the crafting times")]
public class CustomCraftTimes : RustPlugin
{
    private const string UsePerm;
     Dictionary<int, BPItem> _restore;
    private PluginConfig _config;
    private class BPItem
    {
        public string shortname;
        public float time;
    }

    private class PluginConfig
    {
        public Dictionary<int,BPItem> itemdefinitions;
    }

    private void Init();
    protected override void SaveConfig();
    private void _LoadDefaultConfig();
    private void _LoadConfig();
    [ConsoleCommand("cct")]
     void GlobalSetup(ConsoleSystem.Arg arg);
     void OnServerInitialized(bool initial);
     void Unload();
}

private class BPItem
{
    public string shortname;
    public float time;
}

private class PluginConfig
{
    public Dictionary<int,BPItem> itemdefinitions;
}


```

---

## CustomDecay by  - Custom decay for all individual entities with auto configuration for any new entities added

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("CustomDecay", "Wizera", "1.0.2", ResourceId = 2690)]
[Description("Custom decay for all individual entities")]
 class CustomDecay : CovalencePlugin
{
    private bool configChanged;
    private int saveConfigInterval;
    private ConfigData config;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    [Command("customdecay.toggledebug")]
    private void CustomDecayToggleDebug(IPlayer player, string command, string[] args);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    private bool UserHasCupboardPrivAtEntityPosition(Vector3 position, ulong entityOwnerID);
    private void ProcessEntity(BaseCombatEntity entity, HitInfo hitInfo, Dictionary<string, float> dictionary, string prefabName);
    private bool GetMultiplierValueFromConfig(string prefabName, Dictionary<string, float> dictionary, float configMultiplier);
    private void AddDefaultToConfig(string prefabName, Dictionary<string, float> dictionary);
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Default Decay Multiplier")]
        public float DefaultMultiplier { get; set; }
        [JsonProperty(PropertyName = "Prevent Decay Within Cupboard Range")]
        public bool PreventDecayWithinCupboardRange { get; set; }
        [JsonProperty(PropertyName = "Developer Debug")]
        public bool DeveloperDebug { get; set; }
        [JsonProperty(PropertyName = "Decay Config")]
        public DecayConfigEntry DecayConfig { get; set; }
        public class DecayConfigEntry
        {
            [JsonProperty(PropertyName = "Building Blocks")]
            public Dictionary<string, float> buildingBlocks;
            [JsonProperty(PropertyName = "Deployables")]
            public Dictionary<string, float> deployables;
        }

    }

}

private class ConfigData
{
    [JsonProperty(PropertyName = "Default Decay Multiplier")]
    public float DefaultMultiplier { get; set; }
    [JsonProperty(PropertyName = "Prevent Decay Within Cupboard Range")]
    public bool PreventDecayWithinCupboardRange { get; set; }
    [JsonProperty(PropertyName = "Developer Debug")]
    public bool DeveloperDebug { get; set; }
    [JsonProperty(PropertyName = "Decay Config")]
    public DecayConfigEntry DecayConfig { get; set; }
    public class DecayConfigEntry
    {
        [JsonProperty(PropertyName = "Building Blocks")]
        public Dictionary<string, float> buildingBlocks;
        [JsonProperty(PropertyName = "Deployables")]
        public Dictionary<string, float> deployables;
    }

}

public class DecayConfigEntry
{
    [JsonProperty(PropertyName = "Building Blocks")]
    public Dictionary<string, float> buildingBlocks;
    [JsonProperty(PropertyName = "Deployables")]
    public Dictionary<string, float> deployables;
}


```

---

## CustomGenetics by rostov114 - Allows the player to change the genetics of seeds

```csharp
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using UnityEngine;
using System;

Oxide.Plugins
[Info("Custom Genetics", "rostov114 / yoshi2", "0.17.2")]
[Description("Allows players to change genetics for seeds in their inventory")]
 class CustomGenetics : RustPlugin
{
    private GrowableGenes growablegenes;
    private const string CustomGenes;
    private HashSet<char> possibleGenes;
    private Configuration _config;
    public class Configuration
    {
        [JsonProperty(PropertyName = "allowed seeds (full or short names)")]
        public HashSet<string> AllowedPlants;
        [JsonProperty(PropertyName = "admins bypass (true/false)")]
        public bool AdminBypass;
        [JsonProperty(PropertyName = "only affect the active item (true/false)")]
        public bool WholeInventory;
        [JsonProperty(PropertyName = "command name")]
        public string CommandName;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    public void ReplyToPlayer(IPlayer player, string messageName, object[] args);
    public void ChatMessage(BasePlayer player, string messageName, object[] args);
    public string GetMessage(IPlayer player, string messageName, object[] args);
    private void Init();
    private void GetUserGenes(IPlayer player, string command, string[] args);
    [ConsoleCommand("customgenetics.give")]
    private void CustomGeneticsGive(ConsoleSystem.Arg args);
    public void EditGenes(BasePlayer player, char[] genes);
    public void NewGenes(Item item, BasePlayer player, char[] genes);
    public GrowableGenetics.GeneType CharToGeneType(char gene);
}

public class Configuration
{
    [JsonProperty(PropertyName = "allowed seeds (full or short names)")]
    public HashSet<string> AllowedPlants;
    [JsonProperty(PropertyName = "admins bypass (true/false)")]
    public bool AdminBypass;
    [JsonProperty(PropertyName = "only affect the active item (true/false)")]
    public bool WholeInventory;
    [JsonProperty(PropertyName = "command name")]
    public string CommandName;
}


```

---

## CustomIcon by collectvood - Sets a customizable icon for all non-user messages

```csharp
using System.Collections.Generic;
using Network;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Custom Icon", "collect_vood", "1.0.4")]
[Description("Set a customizable icon for all non user messages")]
 class CustomIcon : CovalencePlugin
{
    private Configuration _configuration;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Steam Avatar User ID")]
        public ulong SteamAvatarUserID;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void OnBroadcastCommand(string command, object[] args);
    private void OnSendCommand(Connection cn, string command, object[] args);
    private void OnSendCommand(List<Connection> cn, string command, object[] args);
    private void TryApplySteamAvatarUserID(string command, object[] args);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Steam Avatar User ID")]
    public ulong SteamAvatarUserID;
}


```

---

## CustomItemDrops by MACHIN3 - Custom Item Drops were you create 5 lists of items that will randomly drop in a players inventory.

```csharp
using System.Data;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Custom Item Drops", "MACHIN3", "1.1.200")]
[Description("Drops items from custom lists for gathering, mining, looting, and more.")]
public class CustomItemDrops : RustPlugin
{
    private readonly LootData _CID_lootData;
    private DynamicConfigFile _CID_LootContainData;
    private Dictionary<NetworkableId, Loot> _CID_lootCache;
    private Configuration config;
    private const string PermGatheringChance;
    private const string PermMiningChance;
    private const string PermLootingChance;
    private const string PermAnimalChance;
    private const string PermNPCChance;
    private const string PermPlayerChance;
    private const string PermVIPChance;
    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("General Settings")]
        public GeneralSettings generalSettings;
        [JsonProperty("Gathering Options / List")]
        public GatheringOptions gatheringoptions;
        [JsonProperty("Mining Options / List")]
        public MiningOptions miningoptions;
        [JsonProperty("Looting Options / List")]
        public LootingOptions lootingoptions;
        [JsonProperty("Animal Kill Options / List")]
        public AnimalOptions animaloptions;
        [JsonProperty("NPC Kill Options / List")]
        public NPCOptions NPCoptions;
        [JsonProperty("Player Kill Options / List")]
        public PlayerOptions Playeroptions;
    }

    public class GeneralSettings
    {
        public bool showchatmessage;
        public bool disablepowertoolchance;
    }

    public class GatheringOptions
    {
        public int dropchance;
        public int vipdropchance;
        public bool trees;
        public bool berries;
        public bool wood;
        public bool stones;
        public bool ore;
        public bool hemp;
        public bool mushrooms;
        public bool pumpkins;
        public bool corn;
        public bool potatos;
        public Dictionary<int, GatheringItemList> gatheringItemList;
    }

    public class MiningOptions
    {
        public int dropchance;
        public int vipdropchance;
        public Dictionary<int, MiningItemList> miningItemList;
    }

    public class LootingOptions
    {
        public int dropchance;
        public int vipdropchance;
        public bool lootcontainer;
        public bool freeablelootcontainer;
        public bool lockedbyentcrate;
        public bool hackablelockedcrate;
        public Dictionary<int, LootingItemList> lootingItemList;
    }

    public class AnimalOptions
    {
        public int dropchance;
        public int vipdropchance;
        public bool chicken;
        public bool boar;
        public bool stag;
        public bool wolf;
        public bool bear;
        public bool polarbear;
        public bool horse;
        public bool shark;
        public Dictionary<int, AnimalItemList> AnimalItemList;
    }

    public class NPCOptions
    {
        public int dropchance;
        public int vipdropchance;
        public bool scientist;
        public bool dweller;
        public bool bradley;
        public bool heli;
        public bool scarcrow;
        public bool customnpc;
        public bool zombie;
        public Dictionary<int, NPCItemList> NPCItemList;
    }

    public class PlayerOptions
    {
        public int dropchance;
        public int vipdropchance;
        public bool enableplayers;
        public Dictionary<int, PlayerItemList> PlayerItemList;
    }

    public class GatheringItemList
    {
        public string shortname;
        public string displayname;
        public int amount;
        public ulong SkinID;
    }

    public class MiningItemList
    {
        public string shortname;
        public string displayname;
        public int amount;
        public ulong SkinID;
    }

    public class LootingItemList
    {
        public string shortname;
        public string displayname;
        public int amount;
        public ulong SkinID;
    }

    public class AnimalItemList
    {
        public string shortname;
        public string displayname;
        public int amount;
        public ulong SkinID;
    }

    public class NPCItemList
    {
        public string shortname;
        public string displayname;
        public int amount;
        public ulong SkinID;
    }

    public class PlayerItemList
    {
        public string shortname;
        public string displayname;
        public int amount;
        public ulong SkinID;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    internal class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    private void SaveLoot();
    private class LootData
    {
        public Dictionary<NetworkableId, Loot> CID_LootRecords;
    }

    private class Loot
    {
        public NetworkableId lootcontainer;
        public List<string> id;
    }

    private void AddLootData(BasePlayer player, LootContainer lootcontainer);
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnServerShutdown();
    private void OnServerSave();
    private void OnLootSpawn(LootContainer container);
    private void OnLootEntity(BasePlayer player, LootContainer lootcontainer);
    private void OnContainerDropItems(ItemContainer lootcontainer);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player);
    private void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player);
    private void CreateItemFromList(BasePlayer player, string selectedlist);
    protected override void LoadDefaultMessages();
    private string CIDLang(string key, string id, object[] args);
    private int GetItemDropChance(string list, string type);
    private string GetItemDropLists(string list);
}

private class Configuration : SerializableConfiguration
{
    [JsonProperty("General Settings")]
    public GeneralSettings generalSettings;
    [JsonProperty("Gathering Options / List")]
    public GatheringOptions gatheringoptions;
    [JsonProperty("Mining Options / List")]
    public MiningOptions miningoptions;
    [JsonProperty("Looting Options / List")]
    public LootingOptions lootingoptions;
    [JsonProperty("Animal Kill Options / List")]
    public AnimalOptions animaloptions;
    [JsonProperty("NPC Kill Options / List")]
    public NPCOptions NPCoptions;
    [JsonProperty("Player Kill Options / List")]
    public PlayerOptions Playeroptions;
}

public class GeneralSettings
{
    public bool showchatmessage;
    public bool disablepowertoolchance;
}

public class GatheringOptions
{
    public int dropchance;
    public int vipdropchance;
    public bool trees;
    public bool berries;
    public bool wood;
    public bool stones;
    public bool ore;
    public bool hemp;
    public bool mushrooms;
    public bool pumpkins;
    public bool corn;
    public bool potatos;
    public Dictionary<int, GatheringItemList> gatheringItemList;
}

public class MiningOptions
{
    public int dropchance;
    public int vipdropchance;
    public Dictionary<int, MiningItemList> miningItemList;
}

public class LootingOptions
{
    public int dropchance;
    public int vipdropchance;
    public bool lootcontainer;
    public bool freeablelootcontainer;
    public bool lockedbyentcrate;
    public bool hackablelockedcrate;
    public Dictionary<int, LootingItemList> lootingItemList;
}

public class AnimalOptions
{
    public int dropchance;
    public int vipdropchance;
    public bool chicken;
    public bool boar;
    public bool stag;
    public bool wolf;
    public bool bear;
    public bool polarbear;
    public bool horse;
    public bool shark;
    public Dictionary<int, AnimalItemList> AnimalItemList;
}

public class NPCOptions
{
    public int dropchance;
    public int vipdropchance;
    public bool scientist;
    public bool dweller;
    public bool bradley;
    public bool heli;
    public bool scarcrow;
    public bool customnpc;
    public bool zombie;
    public Dictionary<int, NPCItemList> NPCItemList;
}

public class PlayerOptions
{
    public int dropchance;
    public int vipdropchance;
    public bool enableplayers;
    public Dictionary<int, PlayerItemList> PlayerItemList;
}

public class GatheringItemList
{
    public string shortname;
    public string displayname;
    public int amount;
    public ulong SkinID;
}

public class MiningItemList
{
    public string shortname;
    public string displayname;
    public int amount;
    public ulong SkinID;
}

public class LootingItemList
{
    public string shortname;
    public string displayname;
    public int amount;
    public ulong SkinID;
}

public class AnimalItemList
{
    public string shortname;
    public string displayname;
    public int amount;
    public ulong SkinID;
}

public class NPCItemList
{
    public string shortname;
    public string displayname;
    public int amount;
    public ulong SkinID;
}

public class PlayerItemList
{
    public string shortname;
    public string displayname;
    public int amount;
    public ulong SkinID;
}

internal class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private class LootData
{
    public Dictionary<NetworkableId, Loot> CID_LootRecords;
}

private class Loot
{
    public NetworkableId lootcontainer;
    public List<string> id;
}


```

---

## CustomItemGambling by cymug - Allows putting items other than scrap into the scrap wheel at Bandit Camp

```csharp
using System.Collections.Generic;
using System;

Oxide.Plugins
[Info("Custom Item Gambling", "Pro Noob (patched by chrome)", "1.0.2")]
[Description("Allows putting items other than scrap into the scrap wheel at Bandit Camp")]
 class CustomItemGambling : CovalencePlugin
{
    private const string usePermission;
    private ConfigData configData;
    private Dictionary<ItemContainer, ItemDefinition[]> originalAllowedItems;
    private List<string> itemWhitelist;
    private bool allowAnyItem;
    private class ConfigData
    {
        public List<string> ItemWhitelist;
        public bool AllowAnyItem;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadDefaultConfig();
    private void Init();
     void Unload();
    private object CanMoveItem(Item item, PlayerInventory playerLoot, ItemContainerId targetContainerID, int targetSlot, int amount);
    private void ResetContainer(ItemContainer itemContainer);
}

private class ConfigData
{
    public List<string> ItemWhitelist;
    public bool AllowAnyItem;
}


```

---

## CustomizableMagazines by Razor - Create new items to extend ammo amounts in your gun with new extended magazine's

```csharp
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using System;

Oxide.Plugins
[Info("Customizable Magazines", "Razor", "1.1.5")]
[Description("Change the Magazines Around.")]
public class CustomizableMagazines : RustPlugin
{
     bool debug;
    static CustomizableMagazines Instance;
    private ItemModMagazine _itemModMagazine;
    private string MagazineUse;
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private static void AddToItemDefinition(ItemDefinition itemDefinition, ItemMod itemMod);
    private static void RemoveFromItemDefinition(ItemDefinition itemDefinition, ItemMod itemMod);
    private class ItemModMagazine : ItemMod
    {
        public override void OnParentChanged(Item item);
    }

     void OnLootSpawn(LootContainer container);
    private static void SetupMagazine(ProjectileWeaponMod mag, Item item, ulong configName);
    public class customMagazines
    {
        [JsonProperty(PropertyName = "Magazine Display Name")]
        public string displayName;
        [JsonProperty(PropertyName = "Ammo Multiplier 1.0 = default Gun")]
        public float totalAmmo;
        [JsonProperty(PropertyName = "Can Spawn In LootContainer types")]
        public List<string> LootContainers;
        [JsonProperty(PropertyName = "LootContainer Spawn Chance 1-100")]
        public float SpawnChance;
        public customMagazines(string displayName, float totalAmmo, float reloadTime, List<string> lootContainers);
    }

    [JsonObject(MemberSerialization.OptIn)]
     class ConfigData
    {
        [JsonProperty(PropertyName = "Settings")]
        public Settings settings { get; set; }
        [JsonProperty(PropertyName = "Magazine settings")]
        public Dictionary<ulong, customMagazines> mags { get; set; }
        public class Settings
        {
            [JsonProperty("Enable Loot Container Spawns")]
            public bool randomMagazine { get; set; }
        }

        [JsonProperty(PropertyName = "Version")]
        public VersionNumber Version { get; set; }
        public VersionNumber LastBreakingChange { get; set; }
    }

    private ConfigData configData;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void UpdateConfig();
     void UpdateConfigVersion();
    [ConsoleCommand("magazine")]
    private void CmdConsoleMagazine(ConsoleSystem.Arg args);
    [ChatCommand("magazine")]
    private void GetTheMagazine(BasePlayer player, string command, string[] args);
    private void messagePlayer(BasePlayer player);
    private void GetMagazineItem(BasePlayer player, ulong skinID, int total, bool message);
    protected override void LoadDefaultMessages();
}

private class ItemModMagazine : ItemMod
{
    public override void OnParentChanged(Item item);
}

public class customMagazines
{
    [JsonProperty(PropertyName = "Magazine Display Name")]
    public string displayName;
    [JsonProperty(PropertyName = "Ammo Multiplier 1.0 = default Gun")]
    public float totalAmmo;
    [JsonProperty(PropertyName = "Can Spawn In LootContainer types")]
    public List<string> LootContainers;
    [JsonProperty(PropertyName = "LootContainer Spawn Chance 1-100")]
    public float SpawnChance;
    public customMagazines(string displayName, float totalAmmo, float reloadTime, List<string> lootContainers);
}

[JsonObject(MemberSerialization.OptIn)]
 class ConfigData
{
    [JsonProperty(PropertyName = "Settings")]
    public Settings settings { get; set; }
    [JsonProperty(PropertyName = "Magazine settings")]
    public Dictionary<ulong, customMagazines> mags { get; set; }
    public class Settings
    {
        [JsonProperty("Enable Loot Container Spawns")]
        public bool randomMagazine { get; set; }
    }

    [JsonProperty(PropertyName = "Version")]
    public VersionNumber Version { get; set; }
    public VersionNumber LastBreakingChange { get; set; }
}

public class Settings
{
    [JsonProperty("Enable Loot Container Spawns")]
    public bool randomMagazine { get; set; }
}


```

---

## CustomLootSpawns by k1lly0u - Creates additional custom spawn points for loot boxes of your choosing

```csharp
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

Oxide.Plugins
[Info("Custom Loot Spawns", "k1lly0u", "0.2.17")]
[Description("Creates additional custom spawn points for loot boxes of your choosing")]
 class CustomLootSpawns : RustPlugin
{
    private CLSData clsData;
    private DynamicConfigFile clsdata;
    private Dictionary<BaseEntity, int> boxCache;
    private Dictionary<int, CustomBoxData> boxTypes;
    private List<Timer> refreshTimers;
    private List<BaseEntity> wipeList;
    private Dictionary<ulong, BoxCreator> boxCreators;
    private const int blueprintId;
    private void Loaded();
    private void OnServerInitialized();
    private void OnEntityKill(BaseNetworkable entity);
    private void OnPlayerLootEnd(PlayerLoot inventory);
    private void OnLootSpawn(LootContainer container);
    private void Unload();
    private void InitializeBoxSpawns();
    private void InitiateRefresh(BaseEntity box, int ID);
    private void InitializeNewBox(int ID);
    private void SpawnLoot(BaseEntity entity, int ID);
    private BaseEntity SpawnBoxEntity(string type, Vector3 pos, float rot, ulong skin);
    private BaseEntity InstantiateEntity(string type, Vector3 position, Quaternion rotation);
    private void ClearContainer(BaseEntity container);
    private void AddSpawn(BasePlayer player, int type, int time);
    private void CreateNewCLB(BasePlayer player, string name, int type, ulong skin);
    private void StoreBoxData(BasePlayer player);
    private Item CreateItem(int itemID, int itemAmount, ulong itemSkin);
    private int GenerateRandomID();
    private Vector3 GetGroundPosition(Vector3 sourcePos);
    private void FindBoxTypes();
    private Vector3 GetSpawnPos(BasePlayer player);
    private BaseEntity FindContainer(BasePlayer player);
    private object CastRay(Vector3 Pos, Vector3 Aim);
    private List<BaseEntity> FindInRadius(Vector3 pos, float rad);
    private float GetDistance(Vector3 v3, float x, float y, float z);
    private bool IsUncreateable(string name);
    private void ShowBoxList(BasePlayer player);
    private void ShowCurrentBoxes(BasePlayer player);
    private void SendEchoConsole(Network.Connection cn, string msg);
    private bool IsLootBox(BaseEntity entity);
    [ChatCommand("cls")]
    private void chatLootspawn(BasePlayer player, string command, string[] args);
    private bool CanSpawnLoot(BasePlayer player);
    private ConfigData configData;
    private class ConfigData
    {
        public int RespawnTimer { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
    private void SaveData();
    private void LoadData();
    private class CLSData
    {
        public Dictionary<int, CLBox> lootBoxes;
        public Dictionary<string, CustomBoxData> customBoxes;
    }

    private class CLBox
    {
        public float yRotation;
        public Vector3 Position;
        public BoxType boxType;
        public string customLoot;
        public int time;
    }

    private class BoxCreator
    {
        public BaseEntity entity;
        public CustomBoxData boxData;
    }

    private class CustomBoxData
    {
        public string Name;
        public BoxType boxType;
        public List<ItemStorage> itemList;
    }

    private class BoxType
    {
        public string SkinName;
        public ulong SkinID;
        public string Type;
    }

    private class ItemStorage
    {
        public string Shortname;
        public int ID;
        public ulong SkinID;
        public int Amount;
        public bool IsBlueprint;
    }

    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private void SendMSG(BasePlayer player, string message);
    private string MSG(string key, string playerid);
    private Dictionary<string, string> messages;
    private List<string> unCreateable;
}

private class ConfigData
{
    public int RespawnTimer { get; set; }
}

private class CLSData
{
    public Dictionary<int, CLBox> lootBoxes;
    public Dictionary<string, CustomBoxData> customBoxes;
}

private class CLBox
{
    public float yRotation;
    public Vector3 Position;
    public BoxType boxType;
    public string customLoot;
    public int time;
}

private class BoxCreator
{
    public BaseEntity entity;
    public CustomBoxData boxData;
}

private class CustomBoxData
{
    public string Name;
    public BoxType boxType;
    public List<ItemStorage> itemList;
}

private class BoxType
{
    public string SkinName;
    public ulong SkinID;
    public string Type;
}

private class ItemStorage
{
    public string Shortname;
    public int ID;
    public ulong SkinID;
    public int Amount;
    public bool IsBlueprint;
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## CustomMapVehicleVendorFix by Ryz0r - Fixes Boat & Airwolf Vendor on custom maps where the vendor has no time delay on sales.

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Custom Map Vehicle Vendor Fix", "Ryz0r", "1.0.5")]
[Description("Fixes Airwolf & Boat spawner on custom maps. Previously, a player could buy immediately after completing a transaction.")]
public class CustomMapVehicleVendorFix : RustPlugin
{
    private const string AirwolfConversationalistPrefab;
    private const string BoatVendorPrefab;
    private void OnServerInitialized();
}


```

---

## CustomResourceSpawns by k1lly0u - Creates additional spawn points for resources of your choosing that respawn on a timer

```csharp
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

Oxide.Plugins
[Info("Custom Resource Spawns", "k1lly0u", "0.2.33", ResourceId = 1783)]
[Description("Creates additional spawn points for resources of your choosing, that re-spawn on a timer")]
 class CustomResourceSpawns : RustPlugin
{
    private RaycastHit raycastHit;
    private static readonly RaycastHit[] raycastBuffer;
    private readonly List<BaseEntity> currentResourceEntities;
    private readonly List<Timer> refreshTimers;
    private readonly Dictionary<ulong, int> resourceCreators;
    private const string ADMIN_PERMISSION;
    private void OnServerInitialized();
    protected override void LoadDefaultMessages();
    private void OnEntityKill(BaseEntity entity);
    private void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity);
    private void OnPlayerInput(BasePlayer player, InputState input);
    private void Unload();
    private void InitializeResourceSpawns();
    private void InitiateRefresh(BaseEntity resource);
    private void InitializeNewSpawn(string type, Vector3 position);
    private BaseEntity InstantiateEntity(string type, Vector3 position);
    private void AddSpawn(BasePlayer player, int id);
    private Vector3 GetSpawnPosition(BasePlayer player);
    private BaseEntity FindResourceEntity(BasePlayer player);
    private BaseEntity FindResourcePosition(Vector3 position);
    private void FindInRadius(Vector3 position, float radius, List<Vector3> foundResources);
    private bool RemoveResource(BaseEntity entity);
    private bool RemoveFromData(BaseEntity baseEntity);
    private void ShowResourceCategories(BasePlayer player);
    private void ShowResourcesByCategory(BasePlayer player, string category);
    private void ShowCurrentResources(BasePlayer player);
    private void SendEchoConsole(Network.Connection cn, string msg);
    [ChatCommand("crs")]
    private void chatResourceSpawn(BasePlayer player, string command, string[] args);
    private bool CanSpawnResources(BasePlayer player);
    private ConfigData configData;
    private class ConfigData
    {
        public int RespawnTimer { get; set; }
        public Oxide.Core.VersionNumber Version { get; set; }
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    private ConfigData GetBaseConfig();
    protected override void SaveConfig();
    private void UpdateConfigValues();
    private StoredData storedData;
    private DynamicConfigFile dynamicConfigFile;
    private void SaveData();
    private void LoadData();
    private class StoredData
    {
        public List<StoredResource> resources;
        public class StoredResource
        {
            public string Type;
            public Vector3 Position;
        }

    }

    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private void ChatMessage(BasePlayer player, string message);
    private string Message(string key, string playerid);
    private readonly Dictionary<string, string> Messages;
}

private class ConfigData
{
    public int RespawnTimer { get; set; }
    public Oxide.Core.VersionNumber Version { get; set; }
}

private class StoredData
{
    public List<StoredResource> resources;
    public class StoredResource
    {
        public string Type;
        public Vector3 Position;
    }

}

public class StoredResource
{
    public string Type;
    public Vector3 Position;
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## CustomRock by birthdates - Allows your players to spawn with a specific rock skin

```csharp
using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Text;

Oxide.Plugins
[Info("Custom Rock", "birthdates", "0.5", ResourceId = 0)]
[Description("Custom rock when you spawn.")]
public class CustomRock : RustPlugin
{
    private class StoredData
    {
        public readonly Dictionary<string, ulong> delayedRocks;
        public readonly Dictionary<string, ulong> rocks;
    }

    private StoredData sd;
    private ulong DefaultRockSkin;
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void Init();
    private void OnPlayerRespawned(BasePlayer player);
    private void OnServerSave();
    private void GiveKit(BasePlayer player);
    [ChatCommand("rskin")]
    private void rSkinCommand(BasePlayer player, string command, string[] args);
}

private class StoredData
{
    public readonly Dictionary<string, ulong> delayedRocks;
    public readonly Dictionary<string, ulong> rocks;
}


```

---

## CustomSets by  - Set creation and management system with built-in purchasing

```csharp
using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Newtonsoft.Json.Linq;

Oxide.Plugins
[Info("CustomSets", "Absolut", "1.0.3", ResourceId = 2425)]
[Description("An equipment set creation and management system. All Sets are managed through the UI and can be given or sold to players with Economics or ServerRewards")]
 class CustomSets : RustPlugin
{
    [PluginReference]
     Plugin EventManager;
     Plugin ServerRewards;
     Plugin Economics;
     Plugin ImageLibrary;
     SavedData csData;
    private DynamicConfigFile CSDATA;
     bool ready;
     string TitleColor;
     string MsgColor;
    private List<ulong> SavingCollection;
    private Dictionary<string, Timer> timers;
     Dictionary<string, List<ulong>> ItemSkins;
    private Dictionary<ulong, SetCreation> NewSet;
     class SetCreation
    {
        public string setname;
        public bool Editing;
        public bool UsePermission;
        public Set set;
    }

    private Dictionary<ulong, screen> CSUIInfo;
     class screen
    {
        public bool open;
        public bool admin;
        public string SelectedCategory;
        public string SelectedSet;
        public int CategoryIndex;
        public int SetIndex;
        public int page;
        public int InspectedGear;
        public string InspectedAttachment;
        public string location;
    }

     void Loaded();
     void Unload();
     void OnServerInitialized();
    private void InitializeStuff();
    private void CreateLoadOrder();
    private void OnPlayerInit(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    private void SRAction(ulong ID, int amount, string action);
    private void ECOAction(ulong ID, int amount, string action);
     object OnServerCommand(ConsoleSystem.Arg arg);
    private void CollectionCreationChat(BasePlayer player, string Args);
    private string TryForImage(string shortname, ulong skin);
    public string GetImage(string shortname, ulong skin, bool returnUrl);
    public bool HasImage(string shortname, ulong skin);
    public bool AddImage(string url, string shortname, ulong skin);
    public List<ulong> GetImageList(string shortname);
    public bool isReady();
    private object CheckPoints(ulong ID);
     void DestroyPlayer(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void GetSendMSG(BasePlayer player, string message, string arg1, string arg2, string arg3);
    private string GetMSG(string message, BasePlayer player, string arg1, string arg2, string arg3);
    [ChatCommand("sets")]
    private void chatauction(BasePlayer player, string cmd, string[] args);
    [ConsoleCommand("ToggleCSUI")]
    private void cmdToggleCSUI(ConsoleSystem.Arg arg);
    private void ToggleCSUI(BasePlayer player);
    public void DestroyUI(BasePlayer player);
    public void DestroySetPanels(BasePlayer player);
    public void Broadcast(string message, string userid);
    private void SaveCollection(BasePlayer player);
    private void ExitSetCreation(BasePlayer player);
     bool isAuth(BasePlayer player);
    private string BackgroundPanel;
    private string SetIndexPanel;
    private string SetContentsPanel;
    private string PanelInspector;
    private string PanelOnScreen;
    private string PanelMisc;
    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
        static public CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor);
        static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
        static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
        static public void LoadImage(CuiElementContainer container, string panel, string img, string aMin, string aMax);
        static public void CreateTextOutline(CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align);
    }

    private Dictionary<string, string> UIColors;
     void UIPanel(BasePlayer player);
    private static readonly DateTime Epoch;
    static double CurrentTotalMinutes();
    private string GetMinutesFormat(double minutes);
     void SetListPanel(BasePlayer player);
    private float[] CalcSetButtons(int number);
     void SetPanel(BasePlayer player);
    private void GearEntries(BasePlayer player, CuiElementContainer element, List<Gear> list, string location);
    private void InspectorPanel(BasePlayer player);
     string GetDisplayNameFromSN(string shortname);
     void OnScreen(BasePlayer player, string msg);
    private void SelectIfFree(BasePlayer player);
    private void SelectIfPermission(BasePlayer player);
    private void SelectIfHidden(BasePlayer player);
    private void NumberPad(BasePlayer player, string cmd, string title, bool small);
    private void CreateNumberPadButton(CuiElementContainer container, string panelName, int i, int number, string command);
    private float[] WearLocation(int number);
    private float[] BeltLocation(int number);
    private float[] MainLocation(int number);
    private float[] AttachmentInspectorPos(int number);
    private float[] AttachmentMainScreenPos(Vector2 min, int number);
    private float[] CalcButtonPos(int number);
    private float[] CalcNumButtonPos(int number);
    [ConsoleCommand("UI_AddItemAttributes")]
    private void cmdUI_AddGearAttributes(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_RemoveItem")]
    private void cmdUI_RemoveItem(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_ChangeSkinPage")]
    private void cmdUI_ChangeSkinPage(ConsoleSystem.Arg arg);
    private void SelectSkin(BasePlayer player);
    [ConsoleCommand("UI_SetCost")]
    private void cmdUI_SetCollectionCost(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_SetCooldown")]
    private void cmdUI_SetCooldown(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_SetDailyUses")]
    private void cmdUI_SetDailyUses(ConsoleSystem.Arg arg);
     void SetCollectionName(BasePlayer player);
    [ConsoleCommand("UI_EditSetCost")]
    private void cmdUI_EditSetCost(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_EditSetUses")]
    private void cmdUI_EditSetUses(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_EditSetCooldown")]
    private void cmdUI_EditSetCooldown(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_Permission")]
    private void cmdUI_Permission(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_HiddenSet")]
    private void cmdUI_HiddenSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_ChangeCategory")]
    private void cmdUI_ChangeCategory(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_ChangeSet")]
    private void cmdUI_ChangeGearSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_ChangeSelection")]
    private void cmdUI_ChangeSelection(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_SwitchAdminView")]
    private void cmdUI_SwitchAdminView(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_CategoryIndexShownChange")]
    private void cmdUI_CategoryIndexShownChange(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_GearIndexShownChange")]
    private void cmdUI_GearIndexShownChange(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_DestroyPurchaseConfirmation")]
    private void cmdUI_DestroyPurchaseConfirmation(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_ProcessSelection")]
    private void cmdUI_ProcessSelection(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_SetPurchase")]
    private void cmdUI_SetPurchase(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_ExecutePurchase")]
    private void cmdUI_ExecutePurchase(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_SaveCollect")]
    private void cmdUI_SaveCollect(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_CreateGearSet")]
    private void cmdUI_CreateGearSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_EditGearSet")]
    private void cmdUI_EditGearSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_CancelSetCreation")]
    private void cmdUI_CancelGearSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_DeleteGearSet")]
    private void cmdUI_DeleteGearSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("UI_SelectSkin")]
    private void cmdUI_SelectSkin(ConsoleSystem.Arg arg);
    private void ProcessSelection(BasePlayer player, string name);
    private void GiveGearSet(BasePlayer player, string setname);
    private Item BuildSet(Gear gear);
    private Item BuildItem(string shortname, int amount, ulong skin);
    public void CreateGearSet(BasePlayer player);
     class SavedData
    {
        public Dictionary<string, Set> SavedSets;
        public Dictionary<ulong, PlayerSetData> PlayerData;
    }

     class PlayerSetData
    {
        public Dictionary<string, CoolandUse> cooldownANDuses;
    }

     class CoolandUse
    {
        public double CooldownExpiration;
        public int timesUsed;
        public double FirstUse;
    }

     class Set
    {
        public int cost;
        public string Category;
        public string permission;
        public bool hidden;
        public int cooldown;
        public int dailyUses;
        public List<Gear> belt;
        public List<Gear> wear;
        public List<Gear> main;
    }

     class Gear
    {
        public string shortname;
        public string displayName;
        public ulong skin;
        public int amount;
        public int ammo;
        public string ammoType;
        public List<string> attachments;
        public int position;
    }

    private void SaveLoop();
    private void InfoLoop();
    private bool isSet(string set);
    private bool GiveSet(BasePlayer player, string set);
    private bool TryGiveSet(BasePlayer player, string set);
    [HookMethod("GetSetInfo")]
    public object GetSetInfo(string set);
    private object GetSetContents(string set);
    private bool isKit(string set);
    private object GiveKit(BasePlayer player, string set);
    private string[] GetAllKits();
    private string[] GetKitContents(string kitname);
     CoolandUse GetSetData(ulong userID, string setname);
    private double KitCooldown(string kitname);
    private double PlayerKitCooldown(ulong ID, string kitname);
    private string KitDescription(string kitname);
    private int KitMax(string kitname);
    private double PlayerKitMax(ulong ID, string kitname);
     void SaveData();
     void LoadData();
    private ConfigData configData;
     class ConfigData
    {
        public int InfoInterval { get; set; }
        public List<string> Categories { get; set; }
        public Dictionary<int, string> SpawnSets { get; set; }
        public bool UsePayment { get; set; }
        public bool ShowLockedSets { get; set; }
        public int UsesResetInterval_InHours { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     void LoadDefaultMessages();
     Dictionary<string, string> messages;
}

 class SetCreation
{
    public string setname;
    public bool Editing;
    public bool UsePermission;
    public Set set;
}

 class screen
{
    public bool open;
    public bool admin;
    public string SelectedCategory;
    public string SelectedSet;
    public int CategoryIndex;
    public int SetIndex;
    public int page;
    public int InspectedGear;
    public string InspectedAttachment;
    public string location;
}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor);
    static public CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor);
    static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
    static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
    static public void LoadImage(CuiElementContainer container, string panel, string img, string aMin, string aMax);
    static public void CreateTextOutline(CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align);
}

 class SavedData
{
    public Dictionary<string, Set> SavedSets;
    public Dictionary<ulong, PlayerSetData> PlayerData;
}

 class PlayerSetData
{
    public Dictionary<string, CoolandUse> cooldownANDuses;
}

 class CoolandUse
{
    public double CooldownExpiration;
    public int timesUsed;
    public double FirstUse;
}

 class Set
{
    public int cost;
    public string Category;
    public string permission;
    public bool hidden;
    public int cooldown;
    public int dailyUses;
    public List<Gear> belt;
    public List<Gear> wear;
    public List<Gear> main;
}

 class Gear
{
    public string shortname;
    public string displayName;
    public ulong skin;
    public int amount;
    public int ammo;
    public string ammoType;
    public List<string> attachments;
    public int position;
}

 class ConfigData
{
    public int InfoInterval { get; set; }
    public List<string> Categories { get; set; }
    public Dictionary<int, string> SpawnSets { get; set; }
    public bool UsePayment { get; set; }
    public bool ShowLockedSets { get; set; }
    public int UsesResetInterval_InHours { get; set; }
}


```

---

## CustomSkinsStacksFix by TheFriendlyChap - Fixes problems stacking/splitting/moving custom items (skins). DO NOT USE WITH OTHER STACK PLUGINS.

```csharp
using Oxide.Core.Plugins;
using System;

Oxide.Plugins
[Info("Custom Skins Stacks Fix", "The Friendly Chap", "1.0.4")]
[Description("Fixing problem with stacking/splitting/moving custom items (skins)")]
public class CustomSkinsStacksFix : RustPlugin
{
    [PluginReference]
     Plugin StackModifier;
    private object CanStackItem(Item original, Item target);
    private Item OnItemSplit(Item item, int amount);
    private object CanAcceptItem(ItemContainer container, Item movingItem, int targetPos);
    private object CanCombineDroppedItem(WorldItem first, WorldItem second);
     void OnServerInitialized();
}


```

---

## CustomSpawnPoints by k1lly0u - Creates custom spawn points for players

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("CustomSpawnPoints", "Reneb / k1lly0u", "1.1.3")]
[Description("Allows you to set a spawnfile created via SpawnsDatabase to override Rusts default spawn points")]
 class CustomSpawnPoints : RustPlugin
{
    [PluginReference]
     Plugin Spawns;
    private List<Vector3> spawnPoints;
    private List<Vector3> remainingPoints;
    private bool initialized;
    private void OnServerInitialized();
    private void OnPluginLoaded(Plugin plugin);
    private object OnPlayerRespawn(BasePlayer player);
    private void LoadSpawnpoints();
    private object GetSpawnPoint(int attempt);
    [ConsoleCommand("spawns.config")]
    private void ccmdSpawnFile(ConsoleSystem.Arg arg);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Spawnfile name")]
        public string Spawnfile { get; set; }
        [JsonProperty(PropertyName = "Entity detection radius")]
        public float Detect { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Spawnfile name")]
    public string Spawnfile { get; set; }
    [JsonProperty(PropertyName = "Entity detection radius")]
    public float Detect { get; set; }
}


```

---

## CustomUI by birthdates - Create your custom user interface without code

```csharp
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Custom UI", "birthdates", "1.1.3")]
[Description("Create your custom user interface without code!")]
public class CustomUI : RustPlugin
{
    private readonly Dictionary<string, string> StoredMedia;
    [PluginReference]
    private Plugin ImageLibrary;
    private const string PermissionOpenUI;
    private const string PermissionCloseUI;
    private void Init();
    private void OnServerInitialized();
    [ConsoleCommand("CustomUI.OpenUI")]
    private void OpenUICommand(ConsoleSystem.Arg Arg);
    [ConsoleCommand("CustomUI.CloseUI")]
    private void CloseUICommand(ConsoleSystem.Arg Arg);
    private bool LoadImages();
    private void AddImage(string Media);
    private string GetImage(string Media);
    private void CacheUIs();
    private void CacheUI(string Name, UI UI);
    private static IEnumerable<UIElement> AllElements(UI UI);
    private ICuiComponent GetImageFromMedia(string Media);
    private static string HexToRGB(string hexColor);
    private static bool IsHexColor(string Media);
    private void OpenUI(BasePlayer Target, string UIName, UI UI);
    private void RegisterUICommands();
    private new ConfigFile Config;
    protected override void LoadDefaultMessages();
    public class ConfigFile
    {
        [JsonProperty("Max Time to Load UI (Turn up/down depending on how fast images download)")]
        public float TimeToLoadUI;
        public Dictionary<string, UI> UIs;
        public static ConfigFile DefaultConfig();
    }

    public class UI
    {
        [JsonIgnore]
        public CuiElementContainer CachedElements;
        [JsonProperty("Chat Command")]
        public string ChatCommand;
        [JsonProperty("Cursor Enabled?")]
        public bool Cursor;
        [JsonProperty("Background Media")]
        public string Media;
        public string Parent;
        public string Permission;
        public Position Position;
        [JsonProperty("UI Elements")]
        public UIElements UIElements;
    }

    public class UIElements
    {
        public List<Button> Buttons;
        public List<UIElement> Panels;
        public List<Text> Text;
    }

    public class UIElement
    {
        [JsonProperty("Media (URL/Hex Color)")]
        public string Media;
        public string Name;
        public string Parent;
        public Position Position;
    }

    public class Button : UIElement
    {
        public string Command;
        public Text Text;
    }

    public class Text : UIElement
    {
        [JsonProperty("Text Alignment")]
        public TextAnchor Anchor;
        [JsonProperty("Hex Color")]
        public string Color;
        [JsonProperty("Font Size")]
        public int Size;
        public string Value;
    }

    public class Position
    {
        [JsonProperty("Height (0-1)")]
        public float Height;
        [JsonProperty("Width (0-1)")]
        public float Width;
        [JsonProperty("X (0-1)")]
        public float X;
        [JsonProperty("Y (0-1)")]
        public float Y;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class ConfigFile
{
    [JsonProperty("Max Time to Load UI (Turn up/down depending on how fast images download)")]
    public float TimeToLoadUI;
    public Dictionary<string, UI> UIs;
    public static ConfigFile DefaultConfig();
}

public class UI
{
    [JsonIgnore]
    public CuiElementContainer CachedElements;
    [JsonProperty("Chat Command")]
    public string ChatCommand;
    [JsonProperty("Cursor Enabled?")]
    public bool Cursor;
    [JsonProperty("Background Media")]
    public string Media;
    public string Parent;
    public string Permission;
    public Position Position;
    [JsonProperty("UI Elements")]
    public UIElements UIElements;
}

public class UIElements
{
    public List<Button> Buttons;
    public List<UIElement> Panels;
    public List<Text> Text;
}

public class UIElement
{
    [JsonProperty("Media (URL/Hex Color)")]
    public string Media;
    public string Name;
    public string Parent;
    public Position Position;
}

public class Button : UIElement
{
    public string Command;
    public Text Text;
}

public class Text : UIElement
{
    [JsonProperty("Text Alignment")]
    public TextAnchor Anchor;
    [JsonProperty("Hex Color")]
    public string Color;
    [JsonProperty("Font Size")]
    public int Size;
    public string Value;
}

public class Position
{
    [JsonProperty("Height (0-1)")]
    public float Height;
    [JsonProperty("Width (0-1)")]
    public float Width;
    [JsonProperty("X (0-1)")]
    public float X;
    [JsonProperty("Y (0-1)")]
    public float Y;
}


```

---

## CustomVendingSetup by WhiteThunder - Customize monument vending machines

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using ProtoBuf;
using UnityEngine;
using VLB;
using static ProtoBuf.VendingMachine;
using static VendingMachine;
using CustomGetDataCallback = System.Func<Newtonsoft.Json.Linq.JObject>;
using CustomSaveDataCallback = System.Action<Newtonsoft.Json.Linq.JObject>;
using CustomGetSkinCallback = System.Func<ulong>;
using CustomSetSkinCallback = System.Action<ulong>;
using Pool = Facepunch.Pool;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("Custom Vending Setup", "WhiteThunder", "2.14.3")]
[Description("Allows editing orders at NPC vending machines.")]
internal class CustomVendingSetup : CovalencePlugin
{
    [PluginReference]
    private readonly Plugin BagOfHolding;
    private readonly Plugin Economics;
    private readonly Plugin ItemRetriever;
    private readonly Plugin MonumentFinder;
    private readonly Plugin ServerRewards;
    private SavedPrefabRelativeData _prefabRelativeData;
    private SavedMapData _mapData;
    private SavedSalesData _salesData;
    private Configuration _config;
    private const string PermissionUse;
    private const string StoragePrefab;
    private const int ItemsPerRow;
    private const int InventorySize;
    private const int MaxVendingOffers;
    private const int GeneralSettingsNoteSlot;
    private const int ContainerCapacity;
    private const int MaxItemRows;
    private const int BlueprintItemId;
    private const float MinCurrencyCondition;
    private const ulong NpcVendingMachineSkinId;
    private static readonly Regex KeyValueRegex;
    private readonly object True;
    private readonly object False;
    private ItemRetrieverAdapter _itemRetrieverAdapter;
    private PluginDataProviderRegistry _dataProviderRegistry;
    private ComponentTracker<NPCVendingMachine, VendingMachineComponent> _componentTracker;
    private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
    private MonumentFinderAdapter _monumentFinderAdapter;
    private VendingMachineManager _vendingMachineManager;
    private BagOfHoldingLimitManager _bagOfHoldingLimitManager;
    private DynamicHookSubscriber<VendingController> _inaccessibleVendingMachines;
    private DynamicHookSubscriber<BasePlayer> _playersNeedingFakeInventory;
    private PaymentProviderResolver _paymentProviderResolver;
    private ItemDefinition _noteItemDefinition;
    private bool _isServerInitialized;
    private bool _performingInstantRestock;
    private VendingItem _itemBeingSold;
    private Dictionary<string, object> _itemRetrieverQuery;
    private List<Item> _reusableItemList;
    private object[] _objectArray1;
    private object[] _objectArray2;
    public CustomVendingSetup();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnNewSave();
    private void OnServerSave();
    private void OnPluginLoaded(Plugin plugin);
    private void OnPluginUnloaded(Plugin plugin);
    private void OnEntitySpawned(NPCVendingMachine vendingMachine);
    private void OnEntityKill(NPCVendingMachine vendingMachine);
    private void OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer player);
    private object OnVendingTransaction(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderIndex, int numberOfTransactions, ItemContainer targetContainer);
    private void OnBuyVendingItem(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderID, int amount);
    private object OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item item, BasePlayer player);
    private object CanVendingStockRefill(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer player);
    private object CanAccessVendingMachine(DeliveryDroneConfig deliveryDroneConfig, NPCVendingMachine vendingMachine);
    private void OnEntitySaved(BasePlayer player, BaseNetworkable.SaveInfo saveInfo);
    private void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updatedItemContainer, PlayerInventory.Type inventoryType);
    [HookMethod(nameof(API_IsCustomized))]
    public object API_IsCustomized(NPCVendingMachine vendingMachine);
    [HookMethod(nameof(API_RefreshDataProvider))]
    public void API_RefreshDataProvider(NPCVendingMachine vendingMachine);
    [HookMethod(nameof(API_MigrateVendingProfile))]
    public JObject API_MigrateVendingProfile(NPCVendingMachine vendingMachine);
    private class MonumentAdapter
    {
        public string PrefabName { get; set; }
        public string ShortName { get; set; }
        public string Alias { get; set; }
        public Vector3 Position { get; set; }
        private Dictionary<string, object> _monumentInfo;
        public MonumentAdapter(Dictionary<string, object> monumentInfo);
        public Vector3 InverseTransformPoint(Vector3 worldPosition);
        public bool IsInBounds(Vector3 position);
    }

    private class MonumentFinderAdapter
    {
        private CustomVendingSetup _plugin;
        private Plugin _monumentFinder { get; set; }
        public MonumentFinderAdapter(CustomVendingSetup plugin);
        public MonumentAdapter GetMonumentAdapter(Vector3 position);
        public MonumentAdapter GetMonumentAdapter(BaseEntity entity);
    }

    private class BagOfHoldingLimitManager
    {
        private class CustomLimitProfile
        {
            [JsonProperty("Max total bags")]
            public int MaxTotalBags;
        }

        private CustomVendingSetup _plugin;
        private object _limitProfile;
        public BagOfHoldingLimitManager(CustomVendingSetup plugin);
        public void OnServerInitialized();
        public void HandleBagOfHoldingLoadedChanged();
        public void SetLimitProfile(ItemContainer container);
        public void RemoveLimitProfile(ItemContainer container);
    }

    private class ItemRetrieverApi
    {
        public Func<BasePlayer, Dictionary<string, object>, int> SumPlayerItems { get; set; }
        public Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int> TakePlayerItems { get; set; }
        public ItemRetrieverApi(Dictionary<string, object> apiDict);
    }

    private class ItemRetrieverAdapter
    {
        public ItemRetrieverApi Api { get; set; }
        private CustomVendingSetup _plugin;
        private Plugin ItemRetriever { get; set; }
        public ItemRetrieverAdapter(CustomVendingSetup plugin);
        public void HandleItemRetrieverLoaded();
        public void HandleItemRetrieverUnloaded();
    }

    private static class ExposedHooks
    {
        public static object OnCustomVendingSetup(NPCVendingMachine vendingMachine);
        public static object CanPurchaseItem(BasePlayer player, Item item, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vendingMachine, ItemContainer targetContainer);
        public static Dictionary<string, object> OnCustomVendingSetupDataProvider(NPCVendingMachine vendingMachine);
        public static void OnCustomVendingSetupOfferSettingsParse(CaseInsensitiveDictionary<string> localizedSettings, CaseInsensitiveDictionary<object> customSettings);
        public static void OnCustomVendingSetupOfferSettingsDisplay(CaseInsensitiveDictionary<object> customSettings, CaseInsensitiveDictionary<string> localizedSettings);
        public static void OnCustomVendingSetupTransactionWithCustomSettings(NPCVendingMachine vendingMachine, CaseInsensitiveDictionary<object> customSettings);
        public static void OnCustomVendingSetupGiveSoldItem(NPCVendingMachine vendingMachine, Item item, BasePlayer player);
    }

    private static class UICommands
    {
        public const string Edit;
        public const string Reset;
        public const string Save;
        public const string Cancel;
        public const string ToggleBroadcast;
        public const string ToggleDroneAccessible;
    }

    [Command("customvendingsetup.ui")]
    private void CommandUI(IPlayer player, string cmd, string[] args);
    public static void LogInfo(string message);
    public static void LogError(string message);
    public static void LogWarning(string message);
    private static bool IsLootingVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine);
    private static bool AreVectorsClose(Vector3 a, Vector3 b, float xZTolerance, float yTolerance);
    private static bool HasCondition(ItemDefinition itemDefinition);
    private static void OpenVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine);
    private static bool CanVendingMachineBeSkinned(NPCVendingMachine vendingMachine);
    private static bool CanVendingMachineBroadcast(NPCVendingMachine vendingMachine);
    private static VendingOffer[] GetOffersFromVendingMachine(NPCVendingMachine vendingMachine);
    private static VendingOffer[] GetOffersFromContainer(CustomVendingSetup plugin, BasePlayer player, ItemContainer container);
    private static StorageContainer CreateContainerEntity(string prefabPath);
    private static int OrderIndexToSlot(int orderIndex);
    private static string CreateNoteContents(Dictionary<string, string> settingsMap);
    private static StorageContainer CreateOrdersContainer(CustomVendingSetup plugin, NPCVendingMachine vendingMachine, BasePlayer player, VendingOffer[] vendingOffers);
    private static void MaybeGiveWeaponAmmo(Item item, BasePlayer player);
    private static void GiveSoldItem(Item item, BasePlayer player, TransactionContext transaction);
    private static int GetHighestUsedSlot(ProtoBuf.ItemContainer containerData);
    private static void AddItemForNetwork(ProtoBuf.ItemContainer containerData, int slot, int itemId, int amount, ItemId uid);
    private static CaseInsensitiveDictionary<string> ParseSettings(string text);
    private object CallPlugin(Plugin plugin, string methodName, T1 arg1);
    private object CallPlugin(Plugin plugin, string methodName, T1 arg1, T2 arg2);
    private void ScheduleRemoveUI(NPCVendingMachine vendingMachine, BasePlayer player, VendingMachineComponent component);
    private void AddCurrencyToContainerSnapshot(BasePlayer player, ProtoBuf.ItemContainer containerData);
    private Dictionary<string, object> SetupItemRetrieverQuery(ItemQuery itemQuery);
    private int SumPlayerItems(BasePlayer player, ItemQuery itemQuery);
    private int TakePlayerItems(BasePlayer player, ItemQuery itemQuery, int amount, List<Item> collect);
    private bool PassesUICommandChecks(IPlayer player, string[] args, NPCVendingMachine vendingMachine, VendingController controller);
    private void OpenVendingMachineDelayed(BasePlayer player, NPCVendingMachine vendingMachine, float delay);
    private bool IsCustomized(NPCVendingMachine vendingMachine);
    private static class UIConstants
    {
        public const string EditButtonColor;
        public const string EditButtonTextColor;
        public const string ResetButtonColor;
        public const string ResetButtonTextColor;
        public const string SaveButtonColor;
        public const string SaveButtonTextColor;
        public const string CancelButtonColor;
        public const string CancelButtonTextColor;
        public const float PanelWidth;
        public const float HeaderHeight;
        public const float ItemSpacing;
        public const float ItemBoxSize;
        public const int ButtonHorizontalSpacing;
        public const int ButtonHeight;
        public const int ButtonWidth;
        public const string TexturedBackgroundSprite;
        public const string BroadcastIcon;
        public const string DroneIcon;
        public const string IconMaterial;
        public const string GreyOutMaterial;
        public const string AnchorMin;
        public const string AnchorMax;
    }

    private class EditFormState
    {
        public static EditFormState FromVendingMachine(VendingController vendingController, NPCVendingMachine vendingMachine);
        public bool Broadcast;
        public bool DroneAccessible;
    }

    private static class ContainerUIRenderer
    {
        public const string UIName;
        public const string TipUIName;
        public const string BroadcastUIName;
        public const string DroneUIName;
        public static string RenderContainerUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingController controller, EditFormState uiState);
        private static void AddDataProviderInfo(CuiElementContainer cuiElements, string text);
        private static void AddHeaderLabel(CuiElementContainer cuiElements, int index, string text);
        private static void AddBroadcastButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState);
        private static void AddDroneButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState);
        public static string RenderBroadcastUI(NPCVendingMachine vendingMachine, EditFormState uiState);
        private static void AddButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, float xMax, string color, string textColor);
    }

    private static class AdminUIRenderer
    {
        public const string UIName;
        public static string RenderAdminUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingProfile profile);
        private static float GetButtonOffset(int reverseButtonIndex);
        private static void AddVendingButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, int reverseButtonIndex, string color, string textColor);
    }

    private static class ShopUIRenderer
    {
        public const string UIName;
        private const float OffsetXItem;
        private const float OffsetXCurrency;
        private const float OverlaySize;
        private const float IconSize;
        private const float PaddingLeft;
        private const float PaddingBottom;
        public static string RenderShopUI(VendingProfile vendingProfile);
        private static void AddItemOverlay(CuiElementContainer cuiElements, int indexFromBottom, VendingOffer offer, bool isCurrency);
    }

    private static class StringUtils
    {
        public static bool EqualsCaseInsensitive(string a, string b);
    }

    private static class ObjectCache
    {
        private static class StaticObjectCache
        {
            private static readonly Dictionary<T, object> _cacheByValue;
            public static object Get(T value);
            public static void Clear();
        }

        public static object Get(T value);
        public static void Clear();
    }

    private static bool LocationsMatch(T1 a, T2 b);
    private class ItemsPaymentProvider : IPaymentProvider
    {
        public VendingItem VendingItem;
        private CustomVendingSetup _plugin;
        public ItemsPaymentProvider(CustomVendingSetup plugin);
        public int GetBalance(BasePlayer player);
        public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
        public bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
    }

    private class EconomicsPaymentProvider : IPaymentProvider
    {
        private CustomVendingSetup _plugin;
        private Plugin _ownerPlugin { get; set; }
        public EconomicsPaymentProvider(CustomVendingSetup plugin);
        public bool IsAvailable { get; set; }
        public int GetBalance(BasePlayer player);
        public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
        public bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
    }

    private class ServerRewardsPaymentProvider : IPaymentProvider
    {
        private CustomVendingSetup _plugin;
        private Plugin _ownerPlugin { get; set; }
        public ServerRewardsPaymentProvider(CustomVendingSetup plugin);
        public bool IsAvailable { get; set; }
        public int GetBalance(BasePlayer player);
        public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
        public bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
    }

    private class PaymentProviderResolver
    {
        public readonly EconomicsPaymentProvider EconomicsPaymentProvider;
        public readonly ServerRewardsPaymentProvider ServerRewardsPaymentProvider;
        private readonly CustomVendingSetup _plugin;
        private readonly ItemsPaymentProvider _itemsPaymentProvider;
        private Configuration _config { get; set; }
        public PaymentProviderResolver(CustomVendingSetup plugin);
        public IPaymentProvider Resolve(VendingItem vendingItem);
    }

    private static class ItemUtils
    {
        public static Item FindFirstContainerItem(ItemContainer container, ItemQuery itemQuery);
        public static int SumContainerItems(ItemContainer container, ItemQuery itemQuery);
        public static int SumPlayerItems(BasePlayer player, ItemQuery itemQuery);
        public static int TakeContainerItems(ItemContainer container, ItemQuery itemQuery, int totalAmountToTake, List<Item> collect);
        public static int TakePlayerItems(BasePlayer player, ItemQuery itemQuery, int amountToTake, List<Item> collect);
    }

    private class DynamicHookSubscriber
    {
        private CustomVendingSetup _plugin;
        private HashSet<T> _list;
        private string[] _hookNames;
        public DynamicHookSubscriber(CustomVendingSetup plugin, string[] hookNames);
        public bool Contains(T item);
        public void Add(T item);
        public void Remove(T item);
        public void SubscribeAll();
        public void UnsubscribeAll();
    }

    private class ProtoLoader : IDataLoader
    {
        public bool Exists(string filename);
        public T Load(string filename);
        public void Save(string filename, T data);
    }

    private class JsonLoader : IDataLoader
    {
        public bool Exists(string filename);
        public T Load(string filename);
        public void Save(string filename, T data);
    }

    private class ProtoLoader : IDataLoader<T>
    {
        private readonly ProtoLoader _protoLoader;
        private readonly string _filename;
        public ProtoLoader(string filename);
        public bool Exists();
        public T Load();
        public void Save(T data);
    }

    private class JsonLoader : IDataLoader<T>
    {
        private readonly JsonLoader _jsonLoader;
        private readonly string _filename;
        public JsonLoader(string filename);
        public bool Exists();
        public T Load();
        public void Save(T data);
    }

    private abstract class DataFileDataProvider : IDataProvider
    {
        private BaseVendingProfileDataFile _dataFile;
        private VendingProfile _vendingProfile;
        protected abstract void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
        protected DataFileDataProvider(BaseVendingProfileDataFile dataFile, VendingProfile vendingProfile);
        public VendingProfile GetData();
        public void SaveData(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
    }

    private class PrefabRelativeDataProvider : DataFileDataProvider
    {
        public PrefabRelativePosition Location;
        public PrefabRelativeDataProvider(SavedPrefabRelativeData prefabRelativeData, PrefabRelativePosition location, VendingProfile vendingProfile);
        protected override void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
    }

    private class MapDataProvider : DataFileDataProvider
    {
        public MapDataProvider(SavedMapData mapData, VendingProfile vendingProfile);
        protected override void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
    }

    private class PluginDataProvider : IDataProvider
    {
        public static PluginDataProvider FromDictionary(Dictionary<string, object> spec);
        public Dictionary<string, object> Spec { get; set; }
        public Plugin Plugin;
        public CustomGetDataCallback GetDataCallback;
        public CustomSaveDataCallback SaveDataCallback;
        public CustomGetSkinCallback GetSkinCallback;
        public CustomSetSkinCallback SetSkinCallback;
        private VendingProfile _vendingProfile;
        public VendingProfile GetData();
        public void SaveData(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
    }

    private class PluginDataProviderRegistry
    {
        private Dictionary<Dictionary<string, object>, PluginDataProvider> _dataProviderCache;
        public PluginDataProvider Register(Dictionary<string, object> dataProviderSpec);
        public void Unregister(PluginDataProvider dataProvider);
    }

    private class VendingMachineManager
    {
        private CustomVendingSetup _plugin;
        private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
        private PluginDataProviderRegistry _dataProviderRegistry;
        private HashSet<VendingController> _uniqueControllers;
        private Dictionary<NetworkableId, VendingController> _controllersByVendingMachine;
        private Dictionary<PluginDataProvider, VendingController> _controllersByPluginDataProvider;
        private MonumentFinderAdapter _monumentFinderAdapter { get; set; }
        private SavedPrefabRelativeData PrefabRelativeData { get; set; }
        private SavedMapData _mapData { get; set; }
        private SavedSalesData _salesData { get; set; }
        public VendingMachineManager(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, PluginDataProviderRegistry dataProviderRegistry);
        public void HandleVendingMachineSpawned(NPCVendingMachine vendingMachine);
        public void HandleVendingMachineKilled(NPCVendingMachine vendingMachine);
        public void RefreshDataProvider(NPCVendingMachine vendingMachine);
        public VendingController GetController(NPCVendingMachine vendingMachine);
        public void SetupAll();
        public void ResetAll();
        public void SaveAllSalesData();
        private VendingController FindPrefabRelativeController(PrefabRelativePosition location);
        private VendingController GetControllerByPluginDataProvider(PluginDataProvider dataProvider);
        private VendingController CreateController(IDataProvider dataProvider);
        private void AddToController(VendingController controller, NPCVendingMachine vendingMachine);
        private void RemoveFromController(VendingController controller, NPCVendingMachine vendingMachine);
        private VendingController CreatePrefabRelativeController(PrefabRelativePosition location);
        private void HandleExistingController(NPCVendingMachine vendingMachine, VendingController controller);
        private MapDataProvider CreateMapDataProvider(VendingProfile vendingProfile);
        private VendingController GetOrCreateController(NPCVendingMachine vendingMachine);
    }

    private class EditContainerComponent : FacepunchBehaviour
    {
        public static void AddToContainer(CustomVendingSetup plugin, StorageContainer container, EditController editController);
        private CustomVendingSetup _plugin;
        private EditController _editController;
        private void PlayerStoppedLooting(BasePlayer player);
    }

    private class EditController
    {
        private static void OpenEditPanel(BasePlayer player, StorageContainer containerEntity);
        public BasePlayer EditorPlayer { get; set; }
        private CustomVendingSetup _plugin;
        private VendingController _vendingController;
        private NPCVendingMachine _vendingMachine;
        private StorageContainer _container;
        private EditFormState _formState;
        public EditController(CustomVendingSetup plugin, VendingController vendingController, NPCVendingMachine vendingMachine, BasePlayer editorPlayer);
        public void ToggleBroadcast();
        public void ToggleDroneAccessible();
        public void ApplyStateTo(VendingProfile profile);
        public void HandlePlayerLootEnd(BasePlayer player);
        public void Kill();
        private void DestroyUI();
        private void KillContainer();
    }

    private class VendingController
    {
        public IDataProvider DataProvider { get; set; }
        public VendingProfile Profile { get; set; }
        public EditController EditController { get; set; }
        public bool HasVendingMachines { get; set; }
        protected CustomVendingSetup _plugin;
        public HashSet<NPCVendingMachine> VendingMachineList;
        private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
        private string _cachedShopUI;
        public VendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, IDataProvider dataProvider);
        public void StartEditing(BasePlayer player, NPCVendingMachine vendingMachine);
        public void HandleReset();
        public void Destroy();
        public void HandleSave(NPCVendingMachine vendingMachine);
        public void AddVendingMachine(NPCVendingMachine vendingMachine);
        public void RemoveVendingMachine(NPCVendingMachine vendingMachine);
        public void OnEditControllerKilled();
        public string GetShopUI();
        protected void UpdateDroneAccessibility();
        private void SetupVendingMachines();
        private void ResetVendingMachines();
    }

    private class ComponentTracker
    {
        private readonly Dictionary<THost, TGuest> _hostToGuest;
        public void RegisterComponent(THost host, TGuest guest);
        public TGuest GetComponent(THost host);
        public void UnregisterComponent(THost source);
    }

    private class TrackedComponent : FacepunchBehaviour
    {
        public CustomVendingSetup Plugin;
        public ComponentTracker<THost, TGuest> ComponentTracker;
        public THost Host;
        public virtual void OnCreated();
        protected virtual void OnDestroy();
    }

    private class ComponentFactory
    {
        private CustomVendingSetup _plugin;
        private ComponentTracker<THost, TGuest> _componentTracker;
        public ComponentFactory(CustomVendingSetup plugin, ComponentTracker<THost, TGuest> componentTracker);
        public TGuest GetOrAddTo(THost host);
    }

    private class VendingMachineComponent : TrackedComponent<NPCVendingMachine, VendingMachineComponent>
    {
        public static void RemoveFromVendingMachine(NPCVendingMachine vendingMachine);
        public VendingProfile Profile { get; set; }
        private readonly List<BasePlayer> _adminUIViewers;
        private readonly List<BasePlayer> _shopUIViewers;
        private VendingController _vendingController;
        private NPCVendingMachine _vendingMachine;
        private float[] _refillTimes;
        private string _originalShopName;
        private ulong _originalSkinId;
        private bool _originalBypassDynamicPricing;
        private bool? _originalBroadcast;
        private IDataProvider _dataProvider { get; set; }
        public override void OnCreated();
        public bool HasUI(BasePlayer player);
        public void ShowAdminUI(BasePlayer player);
        public void ShowShopUI(BasePlayer player);
        public void RemoveUI(BasePlayer player);
        protected override void OnDestroy();
        private void PlayerStoppedLooting(BasePlayer player);
        public void SetController(VendingController vendingController);
        public void SetProfile(VendingProfile profile);
        private void ScheduleRefill(int offerIndex, VendingOffer offer, int min);
        private void ScheduleDelayedRefill(int offerIndex, VendingOffer offer);
        private void StopRefilling(int offerIndex);
        private void CustomRefill(bool maxRefill);
        private void TimedRefill();
        private void DestroyAdminUI(BasePlayer player);
        private void DestroyShopUI(BasePlayer player);
        private void DestroyUIs();
        private void DisableVanillaBehavior();
        private ulong GetOriginalSkin();
        private void ResetToVanilla();
    }

    private class CaseInsensitiveDictionary : Dictionary<string, TValue>
    {
        public CaseInsensitiveDictionary();
        public CaseInsensitiveDictionary(Dictionary<string, TValue> dict);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class VendingItem
    {
        public static VendingItem FromItem(Item item);
        private static List<VendingItem> SerializeContents(List<Item> itemList);
        private static int GetAmmoAmountAndType(Item item, ItemDefinition ammoType);
        [JsonProperty("ShortName")]
        public string ShortName;
        [JsonProperty("DisplayName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string DisplayName;
        [JsonProperty("Amount")]
        public int Amount;
        [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public ulong SkinId;
        [JsonProperty("IsBlueprint", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool IsBlueprint;
        [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int DataInt;
        [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int Position;
        [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(-1)]
        public int AmmoAmount;
        [JsonProperty("AmmoType", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string AmmoType;
        [JsonProperty("Capacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public int Capacity;
        [JsonProperty("Contents", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public List<VendingItem> Contents;
        private ItemDefinition _itemDefinition;
        public ItemDefinition ItemDefinition { get; set; }
        private ItemDefinition _ammoTypeDefinition;
        public ItemDefinition AmmoTypeDefinition { get; set; }
        public bool IsValid { get; set; }
        public int ItemId { get; set; }
        public Item Create(int amount);
        public Item Create();
        public VendingItem Copy();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class VendingOffer
    {
        public const int DefaultRefillMax;
        public const int DefaultRefillDelay;
        public const int DefaultRefillAmount;
        public static VendingOffer FromVanillaSellOrder(SellOrder sellOrder, NPCVendingOrder.Entry manifestEntry);
        public static VendingOffer FromItems(CustomVendingSetup plugin, BasePlayer player, Item sellItem, Item currencyItem, Item settingsItem);
        private static bool TryParseIntKey(Dictionary<string, string> dict, string key, int result);
        [JsonProperty("SellItem")]
        public VendingItem SellItem;
        [JsonProperty("CurrencyItem")]
        public VendingItem CurrencyItem;
        [JsonProperty("RefillMax", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(DefaultRefillMax)]
        public int RefillMax;
        [JsonProperty("RefillDelay", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(DefaultRefillDelay)]
        public int RefillDelay;
        [JsonProperty("RefillAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(DefaultRefillAmount)]
        public int RefillAmount;
        [JsonProperty("CustomSettings", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public CaseInsensitiveDictionary<object> CustomSettings;
        public bool IsValid { get; set; }
        public VendingOffer Copy();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class VendingProfile : IRelativePosition
    {
        public const string SkinIdField;
        public static VendingProfile FromVendingMachine(NPCVendingMachine vendingMachine);
        [JsonProperty("ShopName", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string ShopName;
        [JsonProperty(SkinIdField, DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(NpcVendingMachineSkinId)]
        public ulong SkinId;
        [JsonProperty("BypassDynamicPricing", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public bool BypassDynamicPricing;
        [JsonProperty("Broadcast", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(true)]
        public bool Broadcast;
        [JsonProperty("DroneAccessible", DefaultValueHandling = DefaultValueHandling.Ignore)]
        [DefaultValue(true)]
        public bool DroneAccessible;
        [JsonProperty("Monument", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string Monument;
        [JsonProperty("MonumentAlias", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public string MonumentAlias;
        [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
        public Vector3 Position;
        [JsonProperty("Offers")]
        public VendingOffer[] Offers;
        public VendingOffer GetOfferForSellOrderIndex(int index);
        public bool HasPaymentProviderCurrency(PaymentProviderConfig paymentProviderConfig);
        public string GetPrefabName();
        public string GetPrefabAlias();
        public Vector3 GetPosition();
        [OnDeserialized]
        private void OnDeserialized(StreamingContext context);
        private void UpdateOldSaddleOffers();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private abstract class BaseVendingProfileDataFile
    {
        [JsonProperty("VendingProfiles")]
        public List<VendingProfile> VendingProfiles { get; set; }
        public abstract void Save();
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class SavedPrefabRelativeData : BaseVendingProfileDataFile
    {
        private static IDataLoader<SavedPrefabRelativeData> _dataLoader;
        public static SavedPrefabRelativeData Load();
        public override void Save();
        public VendingProfile FindProfile(T location);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class SavedMapData : BaseVendingProfileDataFile
    {
        private static IDataLoader _dataLoader;
        private static string GetPerWipeSaveName();
        private static string GetCrossWipeSaveName();
        private static bool IsProcedural();
        private static string GetPerWipeFilePath();
        private static string GetCrossWipeFilePath();
        private static string GetFilepath();
        public static string GetMapName();
        public static SavedMapData Load();
        public override void Save();
        public VendingProfile FindProfile(Vector3 position);
    }

    [ProtoContract]
    [JsonObject(MemberSerialization.OptIn)]
    private class CustomSalesData
    {
        public static CustomSalesData FromVendingMachineSalesData(NPCVendingMachine.SalesData salesData);
        [ProtoMember(1)]
        [JsonProperty("CurrentMultiplier")]
        public float CurrentMultiplier;
        [ProtoMember(2)]
        [JsonProperty("SoldThisInterval")]
        public ulong SoldThisInterval;
        [ProtoMember(3)]
        [JsonProperty("TotalIntervals")]
        public ulong TotalIntervals;
        [ProtoMember(4)]
        [JsonProperty("TotalSales")]
        public ulong TotalSales;
        public NPCVendingMachine.SalesData ToVendingMachineSalesData();
        public void CopyToVendingMachineSalesData(NPCVendingMachine.SalesData salesData);
    }

    [ProtoContract]
    [JsonObject(MemberSerialization.OptIn)]
    private class VendingMachineState
    {
        private static readonly FieldInfo AllSalesDataField;
        public static VendingMachineState FromVendingMachine(NPCVendingMachine vendingMachine);
        [ProtoMember(1)]
        [JsonProperty("EntityId")]
        public ulong EntityId;
        [ProtoMember(2)]
        [JsonProperty("SalesData")]
        public CustomSalesData[] SalesData;
        [ProtoMember(3)]
        [JsonProperty("Position")]
        public SerializableVector3 Position;
        public void ApplyToVendingMachine(NPCVendingMachine vendingMachine);
    }

    [ProtoContract]
    [JsonObject(MemberSerialization.OptIn)]
    private class SavedSalesData
    {
        private static string FileName;
        private static IDataLoader<SavedSalesData> DataLoader;
        public static SavedSalesData Load();
        [ProtoMember(1)]
        [JsonProperty("VendingMachines")]
        public List<VendingMachineState> VendingMachines;
        public void Save();
        public void Reset();
        public VendingMachineState FindState(NPCVendingMachine vendingMachine);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class ShopUISettings
    {
        [JsonProperty("Enable skin overlays")]
        public bool EnableSkinOverlays;
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class PaymentProviderConfig
    {
        [JsonProperty("Enabled")]
        public bool Enabled;
        [JsonProperty("Item short name")]
        public string ItemShortName;
        [JsonProperty("Item skin ID")]
        public ulong ItemSkinId;
        public ItemDefinition ItemDefinition { get; set; }
        public bool EnabledAndValid { get; set; }
        public void Init();
        public bool MatchesItem(VendingItem vendingItem);
    }

    [JsonObject(MemberSerialization.OptIn)]
    private class Configuration : SerializableConfiguration
    {
        [JsonProperty("Shop UI settings")]
        public ShopUISettings ShopUISettings;
        [JsonProperty("Economics integration")]
        public PaymentProviderConfig Economics;
        [JsonProperty("Server Rewards integration")]
        public PaymentProviderConfig ServerRewards;
        [JsonProperty("Override item max stack sizes (shortname: amount)")]
        public Dictionary<string, int> ItemStackSizeOverrides;
        public void Init();
        public int GetItemMaxStackSize(Item item);
    }

    private Configuration GetDefaultConfig();
    private class SerializableConfiguration
    {
        public string ToJson();
        public Dictionary<string, object> ToDictionary();
    }

    private static class JsonHelper
    {
        public static object Deserialize(string json);
        private static object ToObject(JToken token);
    }

    private bool MaybeUpdateConfig(SerializableConfiguration config);
    private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw);
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private string GetMessage(string playerId, string messageName, object[] args);
    private string GetMessage(IPlayer player, string messageName, object[] args);
    private string GetMessage(BasePlayer player, string messageName, object[] args);
    private void ChatMessage(BasePlayer player, string messageName, object[] args);
    private static class Lang
    {
        public const string ButtonEdit;
        public const string ButtonReset;
        public const string InfoForSale;
        public const string ButtonSave;
        public const string ButtonCancel;
        public const string InfoCost;
        public const string InfoSettings;
        public const string SettingsRefillMax;
        public const string SettingsRefillDelay;
        public const string SettingsRefillAmount;
        public const string SettingsSkinId;
        public const string SettingsBypassDynamicPricing;
        public const string SettingsShopName;
        public const string ErrorCurrentlyBeingEdited;
        public const string InfoDataProviderMap;
        public const string InfoDataProviderEntity;
        public const string InfoDataProviderMonument;
        public const string InfoDataProviderPlugin;
        public const string InfoDataProviderPluginUnknownName;
    }

    protected override void LoadDefaultMessages();
}

private class MonumentAdapter
{
    public string PrefabName { get; set; }
    public string ShortName { get; set; }
    public string Alias { get; set; }
    public Vector3 Position { get; set; }
    private Dictionary<string, object> _monumentInfo;
    public MonumentAdapter(Dictionary<string, object> monumentInfo);
    public Vector3 InverseTransformPoint(Vector3 worldPosition);
    public bool IsInBounds(Vector3 position);
}

private class MonumentFinderAdapter
{
    private CustomVendingSetup _plugin;
    private Plugin _monumentFinder { get; set; }
    public MonumentFinderAdapter(CustomVendingSetup plugin);
    public MonumentAdapter GetMonumentAdapter(Vector3 position);
    public MonumentAdapter GetMonumentAdapter(BaseEntity entity);
}

private class BagOfHoldingLimitManager
{
    private class CustomLimitProfile
    {
        [JsonProperty("Max total bags")]
        public int MaxTotalBags;
    }

    private CustomVendingSetup _plugin;
    private object _limitProfile;
    public BagOfHoldingLimitManager(CustomVendingSetup plugin);
    public void OnServerInitialized();
    public void HandleBagOfHoldingLoadedChanged();
    public void SetLimitProfile(ItemContainer container);
    public void RemoveLimitProfile(ItemContainer container);
}

private class CustomLimitProfile
{
    [JsonProperty("Max total bags")]
    public int MaxTotalBags;
}

private class ItemRetrieverApi
{
    public Func<BasePlayer, Dictionary<string, object>, int> SumPlayerItems { get; set; }
    public Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int> TakePlayerItems { get; set; }
    public ItemRetrieverApi(Dictionary<string, object> apiDict);
}

private class ItemRetrieverAdapter
{
    public ItemRetrieverApi Api { get; set; }
    private CustomVendingSetup _plugin;
    private Plugin ItemRetriever { get; set; }
    public ItemRetrieverAdapter(CustomVendingSetup plugin);
    public void HandleItemRetrieverLoaded();
    public void HandleItemRetrieverUnloaded();
}

private static class ExposedHooks
{
    public static object OnCustomVendingSetup(NPCVendingMachine vendingMachine);
    public static object CanPurchaseItem(BasePlayer player, Item item, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vendingMachine, ItemContainer targetContainer);
    public static Dictionary<string, object> OnCustomVendingSetupDataProvider(NPCVendingMachine vendingMachine);
    public static void OnCustomVendingSetupOfferSettingsParse(CaseInsensitiveDictionary<string> localizedSettings, CaseInsensitiveDictionary<object> customSettings);
    public static void OnCustomVendingSetupOfferSettingsDisplay(CaseInsensitiveDictionary<object> customSettings, CaseInsensitiveDictionary<string> localizedSettings);
    public static void OnCustomVendingSetupTransactionWithCustomSettings(NPCVendingMachine vendingMachine, CaseInsensitiveDictionary<object> customSettings);
    public static void OnCustomVendingSetupGiveSoldItem(NPCVendingMachine vendingMachine, Item item, BasePlayer player);
}

private static class UICommands
{
    public const string Edit;
    public const string Reset;
    public const string Save;
    public const string Cancel;
    public const string ToggleBroadcast;
    public const string ToggleDroneAccessible;
}

private static class UIConstants
{
    public const string EditButtonColor;
    public const string EditButtonTextColor;
    public const string ResetButtonColor;
    public const string ResetButtonTextColor;
    public const string SaveButtonColor;
    public const string SaveButtonTextColor;
    public const string CancelButtonColor;
    public const string CancelButtonTextColor;
    public const float PanelWidth;
    public const float HeaderHeight;
    public const float ItemSpacing;
    public const float ItemBoxSize;
    public const int ButtonHorizontalSpacing;
    public const int ButtonHeight;
    public const int ButtonWidth;
    public const string TexturedBackgroundSprite;
    public const string BroadcastIcon;
    public const string DroneIcon;
    public const string IconMaterial;
    public const string GreyOutMaterial;
    public const string AnchorMin;
    public const string AnchorMax;
}

private class EditFormState
{
    public static EditFormState FromVendingMachine(VendingController vendingController, NPCVendingMachine vendingMachine);
    public bool Broadcast;
    public bool DroneAccessible;
}

private static class ContainerUIRenderer
{
    public const string UIName;
    public const string TipUIName;
    public const string BroadcastUIName;
    public const string DroneUIName;
    public static string RenderContainerUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingController controller, EditFormState uiState);
    private static void AddDataProviderInfo(CuiElementContainer cuiElements, string text);
    private static void AddHeaderLabel(CuiElementContainer cuiElements, int index, string text);
    private static void AddBroadcastButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState);
    private static void AddDroneButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState);
    public static string RenderBroadcastUI(NPCVendingMachine vendingMachine, EditFormState uiState);
    private static void AddButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, float xMax, string color, string textColor);
}

private static class AdminUIRenderer
{
    public const string UIName;
    public static string RenderAdminUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingProfile profile);
    private static float GetButtonOffset(int reverseButtonIndex);
    private static void AddVendingButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, int reverseButtonIndex, string color, string textColor);
}

private static class ShopUIRenderer
{
    public const string UIName;
    private const float OffsetXItem;
    private const float OffsetXCurrency;
    private const float OverlaySize;
    private const float IconSize;
    private const float PaddingLeft;
    private const float PaddingBottom;
    public static string RenderShopUI(VendingProfile vendingProfile);
    private static void AddItemOverlay(CuiElementContainer cuiElements, int indexFromBottom, VendingOffer offer, bool isCurrency);
}

private static class StringUtils
{
    public static bool EqualsCaseInsensitive(string a, string b);
}

private static class ObjectCache
{
    private static class StaticObjectCache
    {
        private static readonly Dictionary<T, object> _cacheByValue;
        public static object Get(T value);
        public static void Clear();
    }

    public static object Get(T value);
    public static void Clear();
}

private static class StaticObjectCache
{
    private static readonly Dictionary<T, object> _cacheByValue;
    public static object Get(T value);
    public static void Clear();
}

private class ItemsPaymentProvider : IPaymentProvider
{
    public VendingItem VendingItem;
    private CustomVendingSetup _plugin;
    public ItemsPaymentProvider(CustomVendingSetup plugin);
    public int GetBalance(BasePlayer player);
    public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
    public bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
}

private class EconomicsPaymentProvider : IPaymentProvider
{
    private CustomVendingSetup _plugin;
    private Plugin _ownerPlugin { get; set; }
    public EconomicsPaymentProvider(CustomVendingSetup plugin);
    public bool IsAvailable { get; set; }
    public int GetBalance(BasePlayer player);
    public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
    public bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
}

private class ServerRewardsPaymentProvider : IPaymentProvider
{
    private CustomVendingSetup _plugin;
    private Plugin _ownerPlugin { get; set; }
    public ServerRewardsPaymentProvider(CustomVendingSetup plugin);
    public bool IsAvailable { get; set; }
    public int GetBalance(BasePlayer player);
    public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
    public bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
}

private class PaymentProviderResolver
{
    public readonly EconomicsPaymentProvider EconomicsPaymentProvider;
    public readonly ServerRewardsPaymentProvider ServerRewardsPaymentProvider;
    private readonly CustomVendingSetup _plugin;
    private readonly ItemsPaymentProvider _itemsPaymentProvider;
    private Configuration _config { get; set; }
    public PaymentProviderResolver(CustomVendingSetup plugin);
    public IPaymentProvider Resolve(VendingItem vendingItem);
}

private static class ItemUtils
{
    public static Item FindFirstContainerItem(ItemContainer container, ItemQuery itemQuery);
    public static int SumContainerItems(ItemContainer container, ItemQuery itemQuery);
    public static int SumPlayerItems(BasePlayer player, ItemQuery itemQuery);
    public static int TakeContainerItems(ItemContainer container, ItemQuery itemQuery, int totalAmountToTake, List<Item> collect);
    public static int TakePlayerItems(BasePlayer player, ItemQuery itemQuery, int amountToTake, List<Item> collect);
}

private class DynamicHookSubscriber
{
    private CustomVendingSetup _plugin;
    private HashSet<T> _list;
    private string[] _hookNames;
    public DynamicHookSubscriber(CustomVendingSetup plugin, string[] hookNames);
    public bool Contains(T item);
    public void Add(T item);
    public void Remove(T item);
    public void SubscribeAll();
    public void UnsubscribeAll();
}

private class ProtoLoader : IDataLoader
{
    public bool Exists(string filename);
    public T Load(string filename);
    public void Save(string filename, T data);
}

private class JsonLoader : IDataLoader
{
    public bool Exists(string filename);
    public T Load(string filename);
    public void Save(string filename, T data);
}

private class ProtoLoader : IDataLoader<T>
{
    private readonly ProtoLoader _protoLoader;
    private readonly string _filename;
    public ProtoLoader(string filename);
    public bool Exists();
    public T Load();
    public void Save(T data);
}

private class JsonLoader : IDataLoader<T>
{
    private readonly JsonLoader _jsonLoader;
    private readonly string _filename;
    public JsonLoader(string filename);
    public bool Exists();
    public T Load();
    public void Save(T data);
}

private abstract class DataFileDataProvider : IDataProvider
{
    private BaseVendingProfileDataFile _dataFile;
    private VendingProfile _vendingProfile;
    protected abstract void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
    protected DataFileDataProvider(BaseVendingProfileDataFile dataFile, VendingProfile vendingProfile);
    public VendingProfile GetData();
    public void SaveData(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
}

private class PrefabRelativeDataProvider : DataFileDataProvider
{
    public PrefabRelativePosition Location;
    public PrefabRelativeDataProvider(SavedPrefabRelativeData prefabRelativeData, PrefabRelativePosition location, VendingProfile vendingProfile);
    protected override void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
}

private class MapDataProvider : DataFileDataProvider
{
    public MapDataProvider(SavedMapData mapData, VendingProfile vendingProfile);
    protected override void BeforeSave(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
}

private class PluginDataProvider : IDataProvider
{
    public static PluginDataProvider FromDictionary(Dictionary<string, object> spec);
    public Dictionary<string, object> Spec { get; set; }
    public Plugin Plugin;
    public CustomGetDataCallback GetDataCallback;
    public CustomSaveDataCallback SaveDataCallback;
    public CustomGetSkinCallback GetSkinCallback;
    public CustomSetSkinCallback SetSkinCallback;
    private VendingProfile _vendingProfile;
    public VendingProfile GetData();
    public void SaveData(VendingProfile vendingProfile, NPCVendingMachine vendingMachine);
}

private class PluginDataProviderRegistry
{
    private Dictionary<Dictionary<string, object>, PluginDataProvider> _dataProviderCache;
    public PluginDataProvider Register(Dictionary<string, object> dataProviderSpec);
    public void Unregister(PluginDataProvider dataProvider);
}

private class VendingMachineManager
{
    private CustomVendingSetup _plugin;
    private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
    private PluginDataProviderRegistry _dataProviderRegistry;
    private HashSet<VendingController> _uniqueControllers;
    private Dictionary<NetworkableId, VendingController> _controllersByVendingMachine;
    private Dictionary<PluginDataProvider, VendingController> _controllersByPluginDataProvider;
    private MonumentFinderAdapter _monumentFinderAdapter { get; set; }
    private SavedPrefabRelativeData PrefabRelativeData { get; set; }
    private SavedMapData _mapData { get; set; }
    private SavedSalesData _salesData { get; set; }
    public VendingMachineManager(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, PluginDataProviderRegistry dataProviderRegistry);
    public void HandleVendingMachineSpawned(NPCVendingMachine vendingMachine);
    public void HandleVendingMachineKilled(NPCVendingMachine vendingMachine);
    public void RefreshDataProvider(NPCVendingMachine vendingMachine);
    public VendingController GetController(NPCVendingMachine vendingMachine);
    public void SetupAll();
    public void ResetAll();
    public void SaveAllSalesData();
    private VendingController FindPrefabRelativeController(PrefabRelativePosition location);
    private VendingController GetControllerByPluginDataProvider(PluginDataProvider dataProvider);
    private VendingController CreateController(IDataProvider dataProvider);
    private void AddToController(VendingController controller, NPCVendingMachine vendingMachine);
    private void RemoveFromController(VendingController controller, NPCVendingMachine vendingMachine);
    private VendingController CreatePrefabRelativeController(PrefabRelativePosition location);
    private void HandleExistingController(NPCVendingMachine vendingMachine, VendingController controller);
    private MapDataProvider CreateMapDataProvider(VendingProfile vendingProfile);
    private VendingController GetOrCreateController(NPCVendingMachine vendingMachine);
}

private class EditContainerComponent : FacepunchBehaviour
{
    public static void AddToContainer(CustomVendingSetup plugin, StorageContainer container, EditController editController);
    private CustomVendingSetup _plugin;
    private EditController _editController;
    private void PlayerStoppedLooting(BasePlayer player);
}

private class EditController
{
    private static void OpenEditPanel(BasePlayer player, StorageContainer containerEntity);
    public BasePlayer EditorPlayer { get; set; }
    private CustomVendingSetup _plugin;
    private VendingController _vendingController;
    private NPCVendingMachine _vendingMachine;
    private StorageContainer _container;
    private EditFormState _formState;
    public EditController(CustomVendingSetup plugin, VendingController vendingController, NPCVendingMachine vendingMachine, BasePlayer editorPlayer);
    public void ToggleBroadcast();
    public void ToggleDroneAccessible();
    public void ApplyStateTo(VendingProfile profile);
    public void HandlePlayerLootEnd(BasePlayer player);
    public void Kill();
    private void DestroyUI();
    private void KillContainer();
}

private class VendingController
{
    public IDataProvider DataProvider { get; set; }
    public VendingProfile Profile { get; set; }
    public EditController EditController { get; set; }
    public bool HasVendingMachines { get; set; }
    protected CustomVendingSetup _plugin;
    public HashSet<NPCVendingMachine> VendingMachineList;
    private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
    private string _cachedShopUI;
    public VendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, IDataProvider dataProvider);
    public void StartEditing(BasePlayer player, NPCVendingMachine vendingMachine);
    public void HandleReset();
    public void Destroy();
    public void HandleSave(NPCVendingMachine vendingMachine);
    public void AddVendingMachine(NPCVendingMachine vendingMachine);
    public void RemoveVendingMachine(NPCVendingMachine vendingMachine);
    public void OnEditControllerKilled();
    public string GetShopUI();
    protected void UpdateDroneAccessibility();
    private void SetupVendingMachines();
    private void ResetVendingMachines();
}

private class ComponentTracker
{
    private readonly Dictionary<THost, TGuest> _hostToGuest;
    public void RegisterComponent(THost host, TGuest guest);
    public TGuest GetComponent(THost host);
    public void UnregisterComponent(THost source);
}

private class TrackedComponent : FacepunchBehaviour
{
    public CustomVendingSetup Plugin;
    public ComponentTracker<THost, TGuest> ComponentTracker;
    public THost Host;
    public virtual void OnCreated();
    protected virtual void OnDestroy();
}

private class ComponentFactory
{
    private CustomVendingSetup _plugin;
    private ComponentTracker<THost, TGuest> _componentTracker;
    public ComponentFactory(CustomVendingSetup plugin, ComponentTracker<THost, TGuest> componentTracker);
    public TGuest GetOrAddTo(THost host);
}

private class VendingMachineComponent : TrackedComponent<NPCVendingMachine, VendingMachineComponent>
{
    public static void RemoveFromVendingMachine(NPCVendingMachine vendingMachine);
    public VendingProfile Profile { get; set; }
    private readonly List<BasePlayer> _adminUIViewers;
    private readonly List<BasePlayer> _shopUIViewers;
    private VendingController _vendingController;
    private NPCVendingMachine _vendingMachine;
    private float[] _refillTimes;
    private string _originalShopName;
    private ulong _originalSkinId;
    private bool _originalBypassDynamicPricing;
    private bool? _originalBroadcast;
    private IDataProvider _dataProvider { get; set; }
    public override void OnCreated();
    public bool HasUI(BasePlayer player);
    public void ShowAdminUI(BasePlayer player);
    public void ShowShopUI(BasePlayer player);
    public void RemoveUI(BasePlayer player);
    protected override void OnDestroy();
    private void PlayerStoppedLooting(BasePlayer player);
    public void SetController(VendingController vendingController);
    public void SetProfile(VendingProfile profile);
    private void ScheduleRefill(int offerIndex, VendingOffer offer, int min);
    private void ScheduleDelayedRefill(int offerIndex, VendingOffer offer);
    private void StopRefilling(int offerIndex);
    private void CustomRefill(bool maxRefill);
    private void TimedRefill();
    private void DestroyAdminUI(BasePlayer player);
    private void DestroyShopUI(BasePlayer player);
    private void DestroyUIs();
    private void DisableVanillaBehavior();
    private ulong GetOriginalSkin();
    private void ResetToVanilla();
}

private class CaseInsensitiveDictionary : Dictionary<string, TValue>
{
    public CaseInsensitiveDictionary();
    public CaseInsensitiveDictionary(Dictionary<string, TValue> dict);
}

[JsonObject(MemberSerialization.OptIn)]
private class VendingItem
{
    public static VendingItem FromItem(Item item);
    private static List<VendingItem> SerializeContents(List<Item> itemList);
    private static int GetAmmoAmountAndType(Item item, ItemDefinition ammoType);
    [JsonProperty("ShortName")]
    public string ShortName;
    [JsonProperty("DisplayName", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string DisplayName;
    [JsonProperty("Amount")]
    public int Amount;
    [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public ulong SkinId;
    [JsonProperty("IsBlueprint", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool IsBlueprint;
    [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public int DataInt;
    [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public int Position;
    [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(-1)]
    public int AmmoAmount;
    [JsonProperty("AmmoType", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string AmmoType;
    [JsonProperty("Capacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public int Capacity;
    [JsonProperty("Contents", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public List<VendingItem> Contents;
    private ItemDefinition _itemDefinition;
    public ItemDefinition ItemDefinition { get; set; }
    private ItemDefinition _ammoTypeDefinition;
    public ItemDefinition AmmoTypeDefinition { get; set; }
    public bool IsValid { get; set; }
    public int ItemId { get; set; }
    public Item Create(int amount);
    public Item Create();
    public VendingItem Copy();
}

[JsonObject(MemberSerialization.OptIn)]
private class VendingOffer
{
    public const int DefaultRefillMax;
    public const int DefaultRefillDelay;
    public const int DefaultRefillAmount;
    public static VendingOffer FromVanillaSellOrder(SellOrder sellOrder, NPCVendingOrder.Entry manifestEntry);
    public static VendingOffer FromItems(CustomVendingSetup plugin, BasePlayer player, Item sellItem, Item currencyItem, Item settingsItem);
    private static bool TryParseIntKey(Dictionary<string, string> dict, string key, int result);
    [JsonProperty("SellItem")]
    public VendingItem SellItem;
    [JsonProperty("CurrencyItem")]
    public VendingItem CurrencyItem;
    [JsonProperty("RefillMax", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(DefaultRefillMax)]
    public int RefillMax;
    [JsonProperty("RefillDelay", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(DefaultRefillDelay)]
    public int RefillDelay;
    [JsonProperty("RefillAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(DefaultRefillAmount)]
    public int RefillAmount;
    [JsonProperty("CustomSettings", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public CaseInsensitiveDictionary<object> CustomSettings;
    public bool IsValid { get; set; }
    public VendingOffer Copy();
}

[JsonObject(MemberSerialization.OptIn)]
private class VendingProfile : IRelativePosition
{
    public const string SkinIdField;
    public static VendingProfile FromVendingMachine(NPCVendingMachine vendingMachine);
    [JsonProperty("ShopName", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string ShopName;
    [JsonProperty(SkinIdField, DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(NpcVendingMachineSkinId)]
    public ulong SkinId;
    [JsonProperty("BypassDynamicPricing", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public bool BypassDynamicPricing;
    [JsonProperty("Broadcast", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(true)]
    public bool Broadcast;
    [JsonProperty("DroneAccessible", DefaultValueHandling = DefaultValueHandling.Ignore)]
    [DefaultValue(true)]
    public bool DroneAccessible;
    [JsonProperty("Monument", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string Monument;
    [JsonProperty("MonumentAlias", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public string MonumentAlias;
    [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
    public Vector3 Position;
    [JsonProperty("Offers")]
    public VendingOffer[] Offers;
    public VendingOffer GetOfferForSellOrderIndex(int index);
    public bool HasPaymentProviderCurrency(PaymentProviderConfig paymentProviderConfig);
    public string GetPrefabName();
    public string GetPrefabAlias();
    public Vector3 GetPosition();
    [OnDeserialized]
    private void OnDeserialized(StreamingContext context);
    private void UpdateOldSaddleOffers();
}

[JsonObject(MemberSerialization.OptIn)]
private abstract class BaseVendingProfileDataFile
{
    [JsonProperty("VendingProfiles")]
    public List<VendingProfile> VendingProfiles { get; set; }
    public abstract void Save();
}

[JsonObject(MemberSerialization.OptIn)]
private class SavedPrefabRelativeData : BaseVendingProfileDataFile
{
    private static IDataLoader<SavedPrefabRelativeData> _dataLoader;
    public static SavedPrefabRelativeData Load();
    public override void Save();
    public VendingProfile FindProfile(T location);
}

[JsonObject(MemberSerialization.OptIn)]
private class SavedMapData : BaseVendingProfileDataFile
{
    private static IDataLoader _dataLoader;
    private static string GetPerWipeSaveName();
    private static string GetCrossWipeSaveName();
    private static bool IsProcedural();
    private static string GetPerWipeFilePath();
    private static string GetCrossWipeFilePath();
    private static string GetFilepath();
    public static string GetMapName();
    public static SavedMapData Load();
    public override void Save();
    public VendingProfile FindProfile(Vector3 position);
}

[ProtoContract]
[JsonObject(MemberSerialization.OptIn)]
private class CustomSalesData
{
    public static CustomSalesData FromVendingMachineSalesData(NPCVendingMachine.SalesData salesData);
    [ProtoMember(1)]
    [JsonProperty("CurrentMultiplier")]
    public float CurrentMultiplier;
    [ProtoMember(2)]
    [JsonProperty("SoldThisInterval")]
    public ulong SoldThisInterval;
    [ProtoMember(3)]
    [JsonProperty("TotalIntervals")]
    public ulong TotalIntervals;
    [ProtoMember(4)]
    [JsonProperty("TotalSales")]
    public ulong TotalSales;
    public NPCVendingMachine.SalesData ToVendingMachineSalesData();
    public void CopyToVendingMachineSalesData(NPCVendingMachine.SalesData salesData);
}

[ProtoContract]
[JsonObject(MemberSerialization.OptIn)]
private class VendingMachineState
{
    private static readonly FieldInfo AllSalesDataField;
    public static VendingMachineState FromVendingMachine(NPCVendingMachine vendingMachine);
    [ProtoMember(1)]
    [JsonProperty("EntityId")]
    public ulong EntityId;
    [ProtoMember(2)]
    [JsonProperty("SalesData")]
    public CustomSalesData[] SalesData;
    [ProtoMember(3)]
    [JsonProperty("Position")]
    public SerializableVector3 Position;
    public void ApplyToVendingMachine(NPCVendingMachine vendingMachine);
}

[ProtoContract]
[JsonObject(MemberSerialization.OptIn)]
private class SavedSalesData
{
    private static string FileName;
    private static IDataLoader<SavedSalesData> DataLoader;
    public static SavedSalesData Load();
    [ProtoMember(1)]
    [JsonProperty("VendingMachines")]
    public List<VendingMachineState> VendingMachines;
    public void Save();
    public void Reset();
    public VendingMachineState FindState(NPCVendingMachine vendingMachine);
}

[JsonObject(MemberSerialization.OptIn)]
private class ShopUISettings
{
    [JsonProperty("Enable skin overlays")]
    public bool EnableSkinOverlays;
}

[JsonObject(MemberSerialization.OptIn)]
private class PaymentProviderConfig
{
    [JsonProperty("Enabled")]
    public bool Enabled;
    [JsonProperty("Item short name")]
    public string ItemShortName;
    [JsonProperty("Item skin ID")]
    public ulong ItemSkinId;
    public ItemDefinition ItemDefinition { get; set; }
    public bool EnabledAndValid { get; set; }
    public void Init();
    public bool MatchesItem(VendingItem vendingItem);
}

[JsonObject(MemberSerialization.OptIn)]
private class Configuration : SerializableConfiguration
{
    [JsonProperty("Shop UI settings")]
    public ShopUISettings ShopUISettings;
    [JsonProperty("Economics integration")]
    public PaymentProviderConfig Economics;
    [JsonProperty("Server Rewards integration")]
    public PaymentProviderConfig ServerRewards;
    [JsonProperty("Override item max stack sizes (shortname: amount)")]
    public Dictionary<string, int> ItemStackSizeOverrides;
    public void Init();
    public int GetItemMaxStackSize(Item item);
}

private class SerializableConfiguration
{
    public string ToJson();
    public Dictionary<string, object> ToDictionary();
}

private static class JsonHelper
{
    public static object Deserialize(string json);
    private static object ToObject(JToken token);
}

private static class Lang
{
    public const string ButtonEdit;
    public const string ButtonReset;
    public const string InfoForSale;
    public const string ButtonSave;
    public const string ButtonCancel;
    public const string InfoCost;
    public const string InfoSettings;
    public const string SettingsRefillMax;
    public const string SettingsRefillDelay;
    public const string SettingsRefillAmount;
    public const string SettingsSkinId;
    public const string SettingsBypassDynamicPricing;
    public const string SettingsShopName;
    public const string ErrorCurrentlyBeingEdited;
    public const string InfoDataProviderMap;
    public const string InfoDataProviderEntity;
    public const string InfoDataProviderMonument;
    public const string InfoDataProviderPlugin;
    public const string InfoDataProviderPluginUnknownName;
}


```

---

## DamageControl by  - Allows tuning the damage entities take

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System.Reflection;
using Oxide.Core.Plugins;
using Oxide.Core.CSharp;
using UnityEngine.UI;
using System.Collections;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Rust;
using System.IO;
using UnityEngine;

Oxide.Plugins
[Info("Damage Control", "MSpeedie", "2.5.14")]
[Description("Allows authorized users to control damage settings for Time, animals, apc, minicopter, scrapcopter, balloons, barrels, buildings, bgrades, heli, npcs, players and zombies")]
 class DamageControl : CovalencePlugin
{
    readonly string permAdmin;
    public float ModifyDeployed;
    public float ModifyDoor;
    public float ModifyFloor;
    public float ModifyFoundation;
    public float ModifyHighExternal;
    public float ModifyOther;
    public float ModifyRoof;
    public float ModifyStairs;
    public float ModifyTC;
    public float ModifyBarrel;
    public float ModifyWall;
    public bool AllowDecay;
    readonly List < string > dcaction;
    readonly DynamicConfigFile dataFile;
    private Dictionary<string, float> EntityModifier;
    readonly List < string > dclass;
    readonly List < string > ttype;
    readonly List < string > bgtype;
    readonly List < string > btype;
    readonly List < string > dtype;
     List < string > deployable_list;
    private const int DamageTypeMax;
     float[] _Zeromultipliers;
     float[] _Onemultipliers;
     float[] _Bearmultipliers;
     float[] _Boarmultipliers;
     float[] _Chickenmultipliers;
     float[] _Horsemultipliers;
     float[] _RidableHorsemultipliers;
     float[] _Stagmultipliers;
     float[] _Wolfmultipliers;
     float[] _Balloonmultipliers;
     float[] _Minicoptermultipliers;
     float[] _Scrapcoptermultipliers;
     float[] _SAMSitemultipliers;
     float[] _Buildingmultipliers;
     float[] _Zombiemultipliers;
     float[] _Playermultipliers;
     float[] _NPCmultipliers;
     float[] _APCmultipliers;
     float[] _Helimultipliers;
     string _time_type;
     float[] _GlobalTimemultipliers;
     float[] _PlayerTimemultipliers;
     float[] _AnimalTimemultipliers;
     float[] _NPCTimemultipliers;
     float[] _HeliTimemultipliers;
     float[] _BradleyTimemultipliers;
     float[] _OtherTimemultipliers;
     float[] _BuildingTimemultipliers;
     float _TwigsMultiplier;
     float _WoodMultiplier;
     float _StoneMultiplier;
     float _MetalMultiplier;
     float _TopTierMultiplier;
     bool Heli_bypass;
     bool _didConfigChange;
     void Init();
    protected override void LoadDefaultMessages();
     void build_dep_list();
     void Loaded();
    protected override void LoadDefaultConfig();
     void LoadConfigValues();
     object GetConfigValue(string category, string setting, object defaultValue);
     object SetConfigValue(string category, string setting, object defaultValue);
    [Command("damagecontrol", "damcon", "dc")]
     void chatCommand_DamageControl(IPlayer iplayer, string command, string[] args);
     void printvalue(IPlayer player, string paramaclass, string paramatype, string paravalue);
     string getHitScale(string paramaclass, string paramatype);
     void setHitScale(HitInfo hitInfo, float[] _multipliers, float addlnmod);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
     bool IsAllowed(IPlayer iplayer);
     T GetConfig(string name, T value);
     string Lang(string key, string id, object[] args);
}


```

---

## Dance by Chepzz - This plugin allows players to dance, even if they don't own a VoiceProps DLC.

```csharp
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Dance", "senyaa", "1.2.0")]
[Description("This plugin allows players to dance, even if they don't own a VoiceProps DLC")]
 class Dance : RustPlugin
{
    private class PluginConfig
    {
        public uint[] gestureIds;
    }

     PluginConfig config;
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    protected override void LoadDefaultMessages();
    private void Init();
    private bool? CanUseGesture(BasePlayer player, GestureConfig gesture);
    [ChatCommand("dance")]
    private void DanceCommand(BasePlayer player, string command, string[] args);
}

private class PluginConfig
{
    public uint[] gestureIds;
}


```

---

## DangerousTreasures by nivex - Dangerous event with treasure chests

```csharp
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Plugins.DangerousTreasuresExtensionMethods;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.SceneManagement;

Oxide.Plugins
[Info("Dangerous Treasures", "nivex", "2.4.7")]
[Description("Event with treasure chests.")]
internal class DangerousTreasures : RustPlugin
{
    [PluginReference]
     Plugin ZoneManager;
     Plugin Economics;
     Plugin ServerRewards;
     Plugin GUIAnnouncements;
     Plugin MarkerManager;
     Plugin Kits;
     Plugin Duelist;
     Plugin RaidableBases;
     Plugin AbandonedBases;
     Plugin Notify;
     Plugin AdvancedAlerts;
     Plugin Clans;
     Plugin Friends;
    private new const string Name;
    private bool wipeChestsSeed;
    private StoredData data;
    private List<int> BlockedLayers;
    private Dictionary<ulong, HumanoidBrain> HumanoidBrains;
    private Dictionary<string, MonumentInfoEx> allowedMonuments;
    private List<MonumentInfoEx> monuments;
    private Dictionary<Vector3, ZoneInfo> managedZones;
    private Dictionary<NetworkableId, TreasureChest> treasureChests;
    private Dictionary<NetworkableId, string> looters;
    private Dictionary<string, ItemDefinition> _definitions;
    private Dictionary<string, SkinInfo> Skins;
    private List<ulong> newmanProtections;
    private List<ulong> indestructibleWarnings;
    private List<ulong> drawGrants;
    private List<int> obstructionLayers;
    private List<string> _blockedColliders;
    private List<string> underground;
    private HashSet<Vector3> _gridPositions;
    private const int TARGET_MASK;
    private const int targetMask;
    private const int visibleMask;
    private const int obstructionLayer;
    private const int heightLayer;
    private StringBuilder _sb;
    private Vector3 sd_customPos;
    public class ZoneInfo
    {
        public Vector3 Position;
        public Vector3 Size;
        public float Distance;
        public OBB OBB;
    }

    public class SkinInfo
    {
        public List<ulong> skins;
        public List<ulong> workshopSkins;
        public List<ulong> importedSkins;
        public List<ulong> allSkins;
    }

    private class PlayerInfo
    {
        public int StolenChestsTotal;
        public int StolenChestsSeed;
        public PlayerInfo();
    }

    private class StoredData
    {
        public Dictionary<string, PlayerInfo> Players;
        public double SecondsUntilEvent;
        public string CustomPosition;
        public int TotalEvents;
        public StoredData();
    }

    public class HumanoidNPC : ScientistNPC
    {
        public new HumanoidBrain Brain;
        public Configuration config { get; set; }
        public new Translate.Phrase LootPanelTitle { get; set; }
        public override string Categorize();
        public override bool ShouldDropActiveItem();
        public override string displayName { get; set; }
        public override void AttackerInfo(ProtoBuf.PlayerLifeStory.DeathInfo info);
        public override void OnDied(HitInfo info);
    }

    public class HumanoidBrain : ScientistBrain
    {
        public void DisableShouldThink();
        internal DangerousTreasures Instance;
        internal string displayName;
        internal Transform NpcTransform;
        internal HumanoidNPC npc;
        internal AttackEntity _attackEntity;
        internal FlameThrower flameThrower;
        internal LiquidWeapon liquidWeapon;
        internal BaseMelee baseMelee;
        internal BaseProjectile baseProjectile;
        internal BasePlayer AttackTarget;
        internal Transform AttackTransform;
        internal TreasureChest tc;
        internal NpcSettings Settings;
        internal List<Vector3> positions;
        internal Vector3 DestinationOverride;
        internal bool isKilled;
        internal bool isMurderer;
        internal ulong uid;
        internal float lastWarpTime;
        internal float softLimitSenseRange;
        internal float nextAttackTime;
        internal float attackRange;
        internal float attackCooldown;
        internal AttackType attackType;
        internal BaseNavigator.NavigationSpeed CurrentSpeed;
        internal Vector3 AttackPosition { get; set; }
        internal Vector3 ServerPosition { get; set; }
        private Configuration config { get; set; }
        internal AttackEntity AttackEntity { get; set; }
        public void UpdateWeapon(AttackEntity attackEntity, ItemId uid);
        internal void IdentifyWeapon();
        private void SetAttackRestrictions(AttackType attackType, float attackRange, float attackCooldown, float effectiveRange);
        public bool ValidTarget { get; set; }
        public override void OnDestroy();
        public override void InitializeAI();
        public override void AddStates();
        public class AttackState : BaseAttackState
        {
            private new HumanoidBrain brain;
            private global::HumanNPC npc;
            private Transform NpcTransform;
            private IAIAttack attack { get; set; }
            public AttackState(HumanoidBrain humanoidBrain);
            public override void StateEnter(BaseAIBrain _brain, BaseEntity _entity);
            public override void StateLeave(BaseAIBrain _brain, BaseEntity _entity);
            private void StopAttacking();
            public override StateStatus StateThink(float delta, BaseAIBrain _brain, BaseEntity _entity);
            private bool InAttackRange();
            private void StartAttacking();
            private void RealisticShotTest();
        }

        private bool init;
        public void Init();
        private void Converge();
        public void Forget();
        private void RandomMove(float radius);
        public void SetupNavigator(BaseCombatEntity owner, BaseNavigator navigator, float distance);
        public Vector3 GetAimDirection();
        private void SetAimDirection();
        private void SetDestination();
        private void SetDestination(Vector3 destination);
        public bool CanUseNavMesh();
        public bool SetTarget(BasePlayer player, bool converge);
        private void TryReturnHome();
        private void TryToAttack();
        private void TryToAttack(BasePlayer attacker);
        private void TryMurdererActions();
        private void TryScientistActions();
        public void SetupMovement(List<Vector3> positions);
        private void TryToRoam();
        private bool IsStuck();
        public void Warp();
        private void UseFlameThrower();
        private void UseWaterGun();
        private void UseChainsaw();
        private void MeleeAttack();
        private bool CanConverge(global::HumanNPC other);
        private bool CanLeave(Vector3 destination);
        private bool CanSeeTarget(BasePlayer target);
        public bool CanRoam(Vector3 destination);
        private bool CanShoot();
        public BasePlayer GetBestTarget();
        private Vector3 GetRandomRoamPosition();
        private bool IsAttackOnCooldown();
        private bool IsInAttackRange(float range);
        private bool IsInHomeRange();
        private bool IsInLeaveRange(Vector3 destination);
        private bool IsInReachableRange();
        private bool IsInSenseRange(Vector3 destination);
        private bool IsInTargetRange(Vector3 destination);
        private bool ShouldForgetTarget(BasePlayer target);
    }

    private class GuidanceSystem : FacepunchBehaviour
    {
        private TimedExplosive missile;
        private ServerProjectile projectile;
        private BaseEntity target;
        private Vector3 launchPos;
        private List<ulong> newmans;
        internal DangerousTreasures Instance;
        private Configuration config { get; set; }
        private void Awake();
        public void SetTarget(BaseEntity target);
        public void Launch(float targettingTime);
        public void Exclude(List<ulong> newmans);
        private void GuideMissile();
        private void OnDestroy();
    }

    public class TreasureChest : FacepunchBehaviour
    {
        internal DangerousTreasures Instance;
        internal ulong userid;
        internal GameObject go;
        internal StorageContainer container;
        internal Vector3 containerPos;
        internal Vector3 lastFirePos;
        internal int npcMaxAmountMurderers;
        internal int npcMaxAmountScientists;
        internal int npcSpawnedAmount;
        internal int countdownTime;
        internal bool started;
        internal bool opened;
        internal bool firstEntered;
        internal bool markerCreated;
        internal bool killed;
        internal bool IsUnloading;
        internal bool requireAllNpcsDie;
        internal bool whenNpcsDie;
        internal float claimTime;
        internal float _radius;
        internal long _unlockTime;
        internal NetworkableId uid;
        private Dictionary<string, List<string>> npcKits;
        private Dictionary<ulong, float> fireticks;
        private List<FireBall> fireballs;
        private List<ulong> newmans;
        private List<ulong> traitors;
        private List<ulong> protects;
        private List<ulong> players;
        private List<TimedExplosive> missiles;
        private List<int> times;
        private List<SphereEntity> spheres;
        private List<Vector3> missilePositions;
        private List<Vector3> firePositions;
        public List<HumanoidNPC> npcs;
        private Timer destruct;
        private Timer unlock;
        private Timer countdown;
        private Timer announcement;
        private MapMarkerExplosion explosionMarker;
        private MapMarkerGenericRadius genericMarker;
        private VendingMachineMapMarker vendingMarker;
        private string FormatGridReference(Vector3 position);
        private void Message(BasePlayer player, string key, object[] args);
        private Configuration config { get; set; }
        public float Radius { get; set; }
        private void Free();
        private class NewmanTracker : FacepunchBehaviour
        {
             BasePlayer player;
             TreasureChest chest;
             DangerousTreasures Instance;
             Configuration config { get; set; }
            private void Message(BasePlayer player, string key, object[] args);
            private void Awake();
            public void Assign(DangerousTreasures instance, TreasureChest chest);
            private void Track();
            private void OnDestroy();
        }

        public void Kill(bool isUnloading);
        public bool HasRustMarker { get; set; }
        public void Awaken();
         void Awake();
        public void SpawnLoot(StorageContainer container, List<LootItem> treasure);
        private Dictionary<string, ulong> skinIds { get; set; }
        private bool IsBlacklistedSkin(ItemDefinition def, int num);
        public ulong GetItemSkin(ItemDefinition def, ulong defaultSkin, bool unique);
        public SkinInfo GetItemSkins(ItemDefinition def);
         void OnTriggerEnter(Collider col);
         void OnTriggerExit(Collider col);
        public void SpawnNpcs();
        private NavMeshHit _navHit;
        private Vector3 FindPointOnNavmesh(Vector3 target, float radius);
        private RaycastHit _hit;
        private bool IsAcceptableWaterDepth(Vector3 position);
        private bool TestInsideObject(Vector3 position);
        private bool TestInsideRock(Vector3 a);
        private bool IsRockFaceDownwards(Vector3 a);
        private bool IsRockFaceUpwards(Vector3 point);
        private bool IsRock(string name);
        private List<string> _prefabs;
        private static void CopySerializableFields(T src, T dst);
        private bool InstantiateEntity(Vector3 position, bool isMurderer, HumanoidBrain humanoidBrain, HumanoidNPC npc);
        private Vector3 RandomPosition(float radius);
        private List<Vector3> RandomWanderPositions(float radius);
        private Vector3 GetRandomPoint(float radius);
        private HumanoidNPC SpawnNpc(bool isMurderer);
        public class Loadout
        {
            public List<PlayerInventoryProperties.ItemAmountSkinned> belt;
            public List<PlayerInventoryProperties.ItemAmountSkinned> main;
            public List<PlayerInventoryProperties.ItemAmountSkinned> wear;
        }

        private PlayerInventoryProperties GetLoadout(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
        private Loadout CreateLoadout(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
        private void AddItemAmountSkinned(List<PlayerInventoryProperties.ItemAmountSkinned> source, List<string> shortnames);
        private void SetupNpc(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer, List<Vector3> positions);
        private void GiveKit(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
        private void UpdateItems(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
        private bool ToggleNpcMinerHat(HumanoidNPC npc, bool state);
        public void EquipWeapon(HumanoidNPC npc, HumanoidBrain brain);
         void SetupNpcKits();
         bool IsKit(string kit);
        public void UpdateMarker();
        private void CreateGenericMarker();
        private void SafelyKill(HumanoidNPC npc);
        private void KillNpc();
        public void RemoveMapMarkers();
        private void OnDestroy();
        public void DestroyMe();
        public void LaunchMissile();
         void SpawnFire();
         void SpawnFire(Vector3 firePos);
        public void Destruct();
         void Unclaimed();
        public string GetUnlockTime(string userID);
        public void Unlock();
        public void SetUnlockTime(float time);
        public void TrySetOwner(HitInfo hitInfo);
        private void SafelyKill(BaseEntity e);
        public void DestroyLauncher();
        public void DestroySphere();
        public void DestroyFire();
    }

     void OnNewSave(string filename);
     void Init();
     void OnServerInitialized(bool isStartup);
     void Unload();
     object canTeleport(BasePlayer player);
     object CanTeleport(BasePlayer player);
     object CanBradleyApcTarget(BradleyAPC apc, HumanoidNPC npc);
     object OnEntityEnter(TriggerBase trigger, BasePlayer player);
    private object OnNpcDuck(HumanoidNPC npc);
    private object OnNpcDestinationSet(HumanoidNPC npc, Vector3 newDestination);
    private object OnNpcResume(HumanoidNPC npc);
     object OnNpcTarget(BasePlayer player, BasePlayer target);
     object OnNpcTarget(BaseNpc npc, BasePlayer target);
     object OnNpcTarget(BasePlayer target, BaseNpc npc);
     void OnEntitySpawned(BaseLock entity);
     void OnEntitySpawned(NPCPlayerCorpse corpse);
     void OnEntitySpawned(DroppedItemContainer backpack);
     void OnEntitySpawned(PlayerCorpse corpse);
     object CanBuild(Planner planner, Construction prefab, Construction.Target target);
    private bool IsAlly(ulong playerId, ulong targetId);
    private object CanLootEntity(BasePlayer player, BoxStorage container);
    private void OnItemRemovedFromContainer(ItemContainer container, Item item);
    private object CanEntityBeTargeted(BasePlayer player, BaseEntity target);
    private object CanEntityTrapTrigger(BaseTrap trap, BasePlayer player);
    private object CanEntityTakeDamage(BaseEntity entity, HitInfo hitInfo);
    private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo);
    private void OnEntityTakeDamage(BoxStorage box, HitInfo hitInfo);
    private void ProtectionDamageHelper(HitInfo hitInfo, string key);
    private object OnNpcKits(ulong targetId);
    private bool HasNPC(ulong userID);
    private TreasureChest Get(Vector3 target);
    private bool IsTrueDamage(BaseEntity entity);
    private bool EventTerritory(Vector3 target);
    private void LoadData();
     void TryWipeData();
     void BlockZoneManagerZones(bool show);
    private class MonumentInfoEx
    {
        public MonumentInfo monument;
        public Vector3 position;
        public float radius;
        public string name;
        public string prefab;
        public MonumentInfoEx();
        public MonumentInfoEx(MonumentInfo monument, Vector3 position, float radius, string name, string prefab);
        public bool IsInBounds(Vector3 target);
    }

    private Coroutine _cmc;
    private void InitializeMonuments();
    private IEnumerator SetupMonuments();
    public IEnumerator CalculateMonumentSize(MonumentInfo monument, Vector3 from, string text, string prefab);
    public bool ContainsTopology(TerrainTopology.Enum mask, Vector3 position, float radius);
    public List<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next);
    private void SortMonuments();
     void InitializeSkins();
     void StartAutomation();
    private static PooledList<T> FindEntitiesOfType(Vector3 a, float n, int m);
     void NpcDamageHelper(BasePlayer player, HitInfo hitInfo);
    private static bool InRange2D(Vector3 a, Vector3 b, float distance);
    private static bool InRange(Vector3 a, Vector3 b, float distance);
     bool IsMelee(BasePlayer player);
     void SaveData();
    protected new static void Puts(string format, object[] args);
     void SubscribeHooks(bool flag);
    private static List<Vector3> GetRandomPositions(Vector3 destination, float radius, int amount, float y);
    private bool IsInsideBounds(OBB obb, Vector3 worldPos);
    public Vector3 GetEventPosition();
     Vector3 TryGetMonumentDropPosition();
     bool IsTooClose(Vector3 vector, float multi);
     bool IsZoneBlocked(Vector3 vector);
     bool IsSafeZone(Vector3 a);
     Vector3 GetSafeDropPosition(Vector3 position);
     float GetSpawnHeight(Vector3 target, bool flag, bool draw);
     bool IsLayerBlocked(Vector3 position, float radius, int mask);
     Vector3 GetRandomMonumentDropPosition(Vector3 position);
     bool IsMonumentPosition(Vector3 target);
     Vector3 GetMonumentDropPosition(int retry);
    private void SetupPositions();
    private bool IsPositionBlocked(Vector3 pos);
    public Vector3 RandomDropPosition();
     TreasureChest TryOpenEvent(BasePlayer player);
     void AnnounceEventSpawn();
     void AnnounceEventSpawn(StorageContainer container, float unlockTime, string posStr);
     void API_SetContainer(StorageContainer container, float radius, bool spawnNpcs);
     void CheckSecondsUntilEvent();
    public string FormatGridReference(Vector3 position, bool showGrid);
    private string FormatTime(double seconds, string id);
     bool AssignTreasureHunters(List<KeyValuePair<string, int>> ladder);
     void DrawText(BasePlayer player, Vector3 drawPos, string text);
     void AddItem(BasePlayer player, string[] args);
     void cmdTreasureHunter(BasePlayer player, string command, string[] args);
    private void ccmdDangerousTreasures(ConsoleSystem.Arg arg);
     void cmdDangerousTreasures(BasePlayer player, string command, string[] args);
     Dictionary<string, string> GetMessages();
    protected override void LoadDefaultMessages();
    private int GetPercentIncreasedAmount(int amount);
    public static Color __(string hex);
    private string _(string key, string id, object[] args);
    private Regex IndexRegex;
    public string Format(string format, object[] args);
    private string msg(string key, string id, object[] args);
    private string msg2(string key, string id, object[] args);
    private string RemoveFormatting(string source);
    private void Message(BasePlayer player, string key, object[] args);
    private void Message(IPlayer user, string key, object[] args);
    private void Message(ConsoleSystem.Arg arg, string key, object[] args);
    public class Notification
    {
        public BasePlayer player;
        public string messageEx;
    }

    private Dictionary<ulong, List<Notification>> _notifications;
    private void CheckNotifications();
    private void SendNotification(Notification notification);
    private Configuration config;
    private static List<LootItem> DefaultLoot { get; set; }
    public class PluginSettings
    {
        [JsonProperty(PropertyName = "Permission Name")]
        public string PermName { get; set; }
        [JsonProperty(PropertyName = "Event Chat Command")]
        public string EventChatCommand { get; set; }
        [JsonProperty(PropertyName = "Distance Chat Command")]
        public string DistanceChatCommand { get; set; }
        [JsonProperty(PropertyName = "Draw Location On Screen With Distance Command")]
        public bool AllowDrawText { get; set; }
        [JsonProperty(PropertyName = "Event Console Command")]
        public string EventConsoleCommand { get; set; }
        [JsonProperty(PropertyName = "Show X Z Coordinates")]
        public bool ShowXZ { get; set; }
        [JsonProperty(PropertyName = "Show Grid Coordinates")]
        public bool ShowGrid { get; set; }
        [JsonProperty(PropertyName = "Grids To Block Spawns At", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlockedGrids;
        [JsonProperty(PropertyName = "Block Spawns At Positions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ManagementSettingsLocations> BlockedPositions;
    }

    public class ManagementSettingsLocations
    {
        [JsonProperty(PropertyName = "position")]
        [JsonConverter(typeof(UnityVector3Converter))]
        public Vector3 position;
        public float radius;
        public ManagementSettingsLocations();
        public ManagementSettingsLocations(Vector3 position, float radius);
    }

    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    public class CountdownSettings
    {
        [JsonProperty(PropertyName = "Use Countdown Before Event Starts")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Time In Seconds", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<int> Times { get; set; }
    }

    public class EventSettings
    {
        [JsonProperty(PropertyName = "Allow Player Bags To Be Lootable At Events")]
        public bool PlayersLootable;
        [JsonProperty(PropertyName = "Automated")]
        public bool Automated { get; set; }
        [JsonProperty(PropertyName = "Every Min Seconds")]
        public float IntervalMin { get; set; }
        [JsonProperty(PropertyName = "Every Max Seconds")]
        public float IntervalMax { get; set; }
        [JsonProperty(PropertyName = "Use Vending Map Marker")]
        public bool MarkerVending { get; set; }
        [JsonProperty(PropertyName = "Use Marker Manager Plugin")]
        public bool MarkerManager { get; set; }
        [JsonProperty(PropertyName = "Use Explosion Map Marker")]
        public bool MarkerExplosion { get; set; }
        [JsonProperty(PropertyName = "Marker Color")]
        public string MarkerColor { get; set; }
        [JsonProperty(PropertyName = "Marker Radius")]
        public float MarkerRadius { get; set; }
        [JsonProperty(PropertyName = "Marker Radius (Smaller Maps)")]
        public float MarkerRadiusSmall { get; set; }
        [JsonProperty(PropertyName = "Marker Event Name")]
        public string MarkerName { get; set; }
        [JsonProperty(PropertyName = "Max Manual Events")]
        public int Max { get; set; }
        [JsonProperty(PropertyName = "Always Spawn Max Manual Events")]
        public bool SpawnMax { get; set; }
        [JsonProperty(PropertyName = "Stagger Spawns Every X Seconds")]
        public float Stagger { get; set; }
        [JsonProperty(PropertyName = "Amount Of Items To Spawn")]
        public int TreasureAmount { get; set; }
        [JsonProperty(PropertyName = "Use Spheres")]
        public bool Spheres { get; set; }
        [JsonProperty(PropertyName = "Amount Of Spheres")]
        public int SphereAmount { get; set; }
        [JsonProperty(PropertyName = "Destroy Spheres When Event Starts")]
        public bool DestroySphereOnStart { get; set; }
        [JsonProperty(PropertyName = "Player Limit For Event")]
        public int PlayerLimit { get; set; }
        [JsonProperty(PropertyName = "Fire Aura Radius (Advanced Users Only)")]
        public float Radius { get; set; }
        [JsonProperty(PropertyName = "Auto Draw On New Event For Nearby Players")]
        public bool DrawTreasureIfNearby { get; set; }
        [JsonProperty(PropertyName = "Auto Draw Minimum Distance")]
        public float AutoDrawDistance { get; set; }
        [JsonProperty(PropertyName = "Grant DDRAW temporarily to players")]
        public bool GrantDraw { get; set; }
        [JsonProperty(PropertyName = "Grant Draw Time")]
        public float DrawTime { get; set; }
        [JsonProperty(PropertyName = "Time To Loot")]
        public float DestructTime { get; set; }
    }

    public class UIAdvancedAlertSettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Anchor Min")]
        public string AnchorMin { get; set; }
        [JsonProperty(PropertyName = "Anchor Max")]
        public string AnchorMax { get; set; }
        [JsonProperty(PropertyName = "Time Shown")]
        public float Time { get; set; }
    }

    public class EventMessageSettings
    {
        [JsonProperty(PropertyName = "Advanced Alerts UI")]
        public UIAdvancedAlertSettings AA { get; set; }
        [JsonProperty(PropertyName = "Notify Plugin - Type (-1 = disabled)")]
        public int NotifyType { get; set; }
        [JsonProperty(PropertyName = "UI Popup Interval")]
        public float Interval { get; set; }
        [JsonProperty(PropertyName = "Show Noob Warning Message")]
        public bool NoobWarning { get; set; }
        [JsonProperty(PropertyName = "Show Barrage Message")]
        public bool Barrage { get; set; }
        [JsonProperty(PropertyName = "Show Despawn Message")]
        public bool Destruct { get; set; }
        [JsonProperty(PropertyName = "Show You Have Entered")]
        public bool Entered { get; set; }
        [JsonProperty(PropertyName = "Show First Player Entered")]
        public bool FirstEntered { get; set; }
        [JsonProperty(PropertyName = "Show First Player Opened")]
        public bool FirstOpened { get; set; }
        [JsonProperty(PropertyName = "Show Opened Message")]
        public bool Opened { get; set; }
        [JsonProperty(PropertyName = "Show Prefix")]
        public bool Prefix { get; set; }
        [JsonProperty(PropertyName = "Show Started Message")]
        public bool Started { get; set; }
        [JsonProperty(PropertyName = "Show Thief Message")]
        public bool Thief { get; set; }
        [JsonProperty(PropertyName = "Send Messages To Player")]
        public bool Message { get; set; }
    }

    public class FireballSettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Damage Per Second")]
        public float DamagePerSecond { get; set; }
        [JsonProperty(PropertyName = "Lifetime Min")]
        public float LifeTimeMin { get; set; }
        [JsonProperty(PropertyName = "Lifetime Max")]
        public float LifeTimeMax { get; set; }
        [JsonProperty(PropertyName = "Radius")]
        public float Radius { get; set; }
        [JsonProperty(PropertyName = "Tick Rate")]
        public float TickRate { get; set; }
        [JsonProperty(PropertyName = "Generation")]
        public float Generation { get; set; }
        [JsonProperty(PropertyName = "Water To Extinguish")]
        public int WaterToExtinguish { get; set; }
        [JsonProperty(PropertyName = "Spawn Every X Seconds")]
        public int SecondsBeforeTick { get; set; }
    }

    public class GUIAnnouncementSettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Text Color")]
        public string TextColor { get; set; }
        [JsonProperty(PropertyName = "Banner Tint Color")]
        public string TintColor { get; set; }
        [JsonProperty(PropertyName = "Maximum Distance")]
        public float Distance { get; set; }
    }

    public class MissileLauncherSettings
    {
        [JsonProperty(PropertyName = "Acquire Time In Seconds")]
        public float TargettingTime { get; set; }
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Damage Per Missile")]
        public float Damage { get; set; }
        [JsonProperty(PropertyName = "Detection Distance")]
        public float Distance { get; set; }
        [JsonProperty(PropertyName = "Life Time In Seconds")]
        public float Lifetime { get; set; }
        [JsonProperty(PropertyName = "Ignore Flying Players")]
        public bool IgnoreFlying { get; set; }
        [JsonProperty(PropertyName = "Spawn Every X Seconds")]
        public float Frequency { get; set; }
        [JsonProperty(PropertyName = "Target Chest If No Player Target")]
        public bool TargetChest { get; set; }
    }

    public class MonumentSettings
    {
        [JsonProperty(PropertyName = "Blacklisted Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, bool> Blacklist { get; set; }
        [JsonProperty(PropertyName = "Auto Spawn At Monuments Only")]
        public bool Only { get; set; }
        [JsonProperty(PropertyName = "Chance To Spawn At Monuments Instead")]
        public float Chance { get; set; }
        [JsonProperty(PropertyName = "Allow Treasure Loot Underground")]
        public bool Underground { get; set; }
    }

    public class NewmanModeSettings
    {
        [JsonProperty(PropertyName = "Protect Nakeds From Fire Aura")]
        public bool Aura { get; set; }
        [JsonProperty(PropertyName = "Protect Nakeds From Other Harm")]
        public bool Harm { get; set; }
    }

    public class NpcKitSettings
    {
        [JsonProperty(PropertyName = "Helm", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Helm;
        [JsonProperty(PropertyName = "Torso", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Torso;
        [JsonProperty(PropertyName = "Pants", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Pants;
        [JsonProperty(PropertyName = "Gloves", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Gloves;
        [JsonProperty(PropertyName = "Boots", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Boots;
        [JsonProperty(PropertyName = "Shirt", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Shirt;
        [JsonProperty(PropertyName = "Kilts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Kilts;
        [JsonProperty(PropertyName = "Weapon", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Weapon;
    }

    public class NpcLootSettings
    {
        [JsonProperty(PropertyName = "Prefab ID List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> IDs { get; set; }
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Disable All Prefab Loot Spawns")]
        public bool None { get; set; }
        public uint GetRandom();
    }

    public class NpcSettingsAccuracy
    {
        [JsonProperty(PropertyName = "AK47")]
        public double AK47 { get; set; }
        [JsonProperty(PropertyName = "AK47 ICE")]
        public double AK47ICE { get; set; }
        [JsonProperty(PropertyName = "Bolt Rifle")]
        public double BOLT_RIFLE { get; set; }
        [JsonProperty(PropertyName = "Compound Bow")]
        public double COMPOUND_BOW { get; set; }
        [JsonProperty(PropertyName = "Crossbow")]
        public double CROSSBOW { get; set; }
        [JsonProperty(PropertyName = "Double Barrel Shotgun")]
        public double DOUBLE_SHOTGUN { get; set; }
        [JsonProperty(PropertyName = "Eoka")]
        public double EOKA { get; set; }
        [JsonProperty(PropertyName = "Glock")]
        public double GLOCK { get; set; }
        [JsonProperty(PropertyName = "HMLMG")]
        public double HMLMG { get; set; }
        [JsonProperty(PropertyName = "L96")]
        public double L96 { get; set; }
        [JsonProperty(PropertyName = "LR300")]
        public double LR300 { get; set; }
        [JsonProperty(PropertyName = "M249")]
        public double M249 { get; set; }
        [JsonProperty(PropertyName = "M39")]
        public double M39 { get; set; }
        [JsonProperty(PropertyName = "M92")]
        public double M92 { get; set; }
        [JsonProperty(PropertyName = "MP5")]
        public double MP5 { get; set; }
        [JsonProperty(PropertyName = "Nailgun")]
        public double NAILGUN { get; set; }
        [JsonProperty(PropertyName = "Pump Shotgun")]
        public double PUMP_SHOTGUN { get; set; }
        [JsonProperty(PropertyName = "Python")]
        public double PYTHON { get; set; }
        [JsonProperty(PropertyName = "Revolver")]
        public double REVOLVER { get; set; }
        [JsonProperty(PropertyName = "Semi Auto Pistol")]
        public double SEMI_AUTO_PISTOL { get; set; }
        [JsonProperty(PropertyName = "Semi Auto Rifle")]
        public double SEMI_AUTO_RIFLE { get; set; }
        [JsonProperty(PropertyName = "Spas12")]
        public double SPAS12 { get; set; }
        [JsonProperty(PropertyName = "Speargun")]
        public double SPEARGUN { get; set; }
        [JsonProperty(PropertyName = "SMG")]
        public double SMG { get; set; }
        [JsonProperty(PropertyName = "Snowball Gun")]
        public double SNOWBALL_GUN { get; set; }
        [JsonProperty(PropertyName = "Thompson")]
        public double THOMPSON { get; set; }
        [JsonProperty(PropertyName = "Waterpipe Shotgun")]
        public double WATERPIPE_SHOTGUN { get; set; }
        public NpcSettingsAccuracy(double accuracy);
        public double Get(HumanoidBrain brain);
    }

    public class NpcSettingsMurderer
    {
        [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> RandomNames { get; set; }
        [JsonProperty(PropertyName = "Items)")]
        public NpcKitSettings Items { get; set; }
        [JsonProperty(PropertyName = "Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Kits { get; set; }
        [JsonProperty(PropertyName = "Spawn Alternate Loot")]
        public NpcLootSettings Alternate { get; set; }
        [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
        public NpcSettingsAccuracy Accuracy { get; set; }
        [JsonProperty(PropertyName = "Aggression Range")]
        public float AggressionRange { get; set; }
        [JsonProperty(PropertyName = "Despawn Inventory On Death")]
        public bool DespawnInventory { get; set; }
        [JsonProperty(PropertyName = "Corpse Despawn Time When Despawn Inventory On Death")]
        public float DespawnInventoryTime { get; set; }
        [JsonProperty(PropertyName = "Corpse Despawn Time Otherwise")]
        public float CorpseDespawnTime { get; set; }
        [JsonProperty(PropertyName = "Die Instantly From Headshots")]
        public bool Headshot { get; set; }
        [JsonProperty(PropertyName = "Amount To Spawn (min)")]
        public int SpawnMinAmount { get; set; }
        [JsonProperty(PropertyName = "Amount To Spawn (max)")]
        public int SpawnAmount { get; set; }
        [JsonProperty(PropertyName = "Health")]
        public float Health { get; set; }
    }

    public class NpcSettingsScientist
    {
        [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> RandomNames { get; set; }
        [JsonProperty(PropertyName = "Items")]
        public NpcKitSettings Items { get; set; }
        [JsonProperty(PropertyName = "Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Kits { get; set; }
        [JsonProperty(PropertyName = "Spawn Alternate Loot")]
        public NpcLootSettings Alternate { get; set; }
        [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
        public NpcSettingsAccuracy Accuracy { get; set; }
        [JsonProperty(PropertyName = "Aggression Range")]
        public float AggressionRange { get; set; }
        [JsonProperty(PropertyName = "Despawn Inventory On Death")]
        public bool DespawnInventory { get; set; }
        [JsonProperty(PropertyName = "Corpse Despawn Time When Despawn Inventory On Death")]
        public float DespawnInventoryTime { get; set; }
        [JsonProperty(PropertyName = "Corpse Despawn Time Otherwise")]
        public float CorpseDespawnTime { get; set; }
        [JsonProperty(PropertyName = "Die Instantly From Headshots")]
        public bool Headshot { get; set; }
        [JsonProperty(PropertyName = "Amount To Spawn (min)")]
        public int SpawnMinAmount { get; set; }
        [JsonProperty(PropertyName = "Amount To Spawn (max)")]
        public int SpawnAmount { get; set; }
        [JsonProperty(PropertyName = "Health (100 min, 5000 max)")]
        public float Health { get; set; }
    }

    public class NpcSettings
    {
        [JsonProperty(PropertyName = "Blacklisted Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, bool> BlacklistedMonuments { get; set; }
        [JsonProperty(PropertyName = "Murderers")]
        public NpcSettingsMurderer Murderers { get; set; }
        [JsonProperty(PropertyName = "Scientists")]
        public NpcSettingsScientist Scientists { get; set; }
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Allow Npcs To Leave Dome When Attacking")]
        public bool CanLeave { get; set; }
        [JsonProperty(PropertyName = "Allow Npcs To Target Other Npcs")]
        public bool TargetNpcs { get; set; }
        [JsonProperty(PropertyName = "Block Damage From Players Beyond X Distance (0 = disabled)")]
        public float Range { get; set; }
        [JsonProperty(PropertyName = "Block Npc Kits Plugin")]
        public bool BlockNpcKits { get; set; }
        [JsonProperty(PropertyName = "Kill Underwater Npcs")]
        public bool KillUnderwater { get; set; }
    }

    public class PasteOption
    {
        [JsonProperty(PropertyName = "Option")]
        public string Key { get; set; }
        [JsonProperty(PropertyName = "Value")]
        public string Value { get; set; }
    }

    public class RankedLadderSettings
    {
        [JsonProperty(PropertyName = "Award Top X Players On Wipe")]
        public int Amount { get; set; }
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Group Name")]
        public string Group { get; set; }
        [JsonProperty(PropertyName = "Permission Name")]
        public string Permission { get; set; }
    }

    public class RewardSettings
    {
        [JsonProperty(PropertyName = "Economics Money")]
        public double Money { get; set; }
        [JsonProperty(PropertyName = "ServerRewards Points")]
        public double Points { get; set; }
        [JsonProperty(PropertyName = "Use Economics")]
        public bool Economics { get; set; }
        [JsonProperty(PropertyName = "Use ServerRewards")]
        public bool ServerRewards { get; set; }
    }

    public class RocketOpenerSettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Rockets")]
        public int Amount { get; set; }
        [JsonProperty(PropertyName = "Speed")]
        public float Speed { get; set; }
        [JsonProperty(PropertyName = "Use Fire Rockets")]
        public bool FireRockets { get; set; }
    }

    public class SkinSettings
    {
        [JsonProperty(PropertyName = "Custom Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> Custom { get; set; }
        [JsonProperty(PropertyName = "Use Random Skin")]
        public bool RandomSkins { get; set; }
        [JsonProperty(PropertyName = "Preset Skin")]
        public ulong PresetSkin { get; set; }
        [JsonProperty(PropertyName = "Include Workshop Skins")]
        public bool RandomWorkshopSkins { get; set; }
        [JsonProperty(PropertyName = "Randomize Npc Item Skins")]
        public bool Npcs { get; set; }
        [JsonProperty(PropertyName = "Use Identical Skins For All Npcs")]
        public bool UniqueNpcs { get; set; }
    }

    public class LootItem
    {
        public string shortname { get; set; }
        public string name { get; set; }
        public int amount { get; set; }
        public ulong skin { get; set; }
        public int amountMin { get; set; }
        public float condition { get; set; }
        public float probability { get; set; }
        [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> skins { get; set; }
    }

    public class TreasureSettings
    {
        [JsonProperty(PropertyName = "Loot", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> Loot { get; set; }
        [JsonProperty(PropertyName = "Minimum Percent Loss")]
        public decimal PercentLoss { get; set; }
        [JsonProperty(PropertyName = "Percent Increase When Using Day Of Week Loot")]
        public bool Increased { get; set; }
        [JsonProperty(PropertyName = "Use Random Skins")]
        public bool RandomSkins { get; set; }
        [JsonProperty(PropertyName = "Include Workshop Skins")]
        public bool RandomWorkshopSkins { get; set; }
        [JsonProperty(PropertyName = "Day Of Week Loot Monday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> DOWL_Monday { get; set; }
        [JsonProperty(PropertyName = "Day Of Week Loot Tuesday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> DOWL_Tuesday { get; set; }
        [JsonProperty(PropertyName = "Day Of Week Loot Wednesday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> DOWL_Wednesday { get; set; }
        [JsonProperty(PropertyName = "Day Of Week Loot Thursday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> DOWL_Thursday { get; set; }
        [JsonProperty(PropertyName = "Day Of Week Loot Friday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> DOWL_Friday { get; set; }
        [JsonProperty(PropertyName = "Day Of Week Loot Saturday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> DOWL_Saturday { get; set; }
        [JsonProperty(PropertyName = "Day Of Week Loot Sunday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<LootItem> DOWL_Sunday { get; set; }
        [JsonProperty(PropertyName = "Use Day Of Week Loot")]
        public bool UseDOWL { get; set; }
        [JsonProperty(PropertyName = "Percent Increase On Monday")]
        public decimal PercentIncreaseOnMonday { get; set; }
        [JsonProperty(PropertyName = "Percent Increase On Tuesday")]
        public decimal PercentIncreaseOnTuesday { get; set; }
        [JsonProperty(PropertyName = "Percent Increase On Wednesday")]
        public decimal PercentIncreaseOnWednesday { get; set; }
        [JsonProperty(PropertyName = "Percent Increase On Thursday")]
        public decimal PercentIncreaseOnThursday { get; set; }
        [JsonProperty(PropertyName = "Percent Increase On Friday")]
        public decimal PercentIncreaseOnFriday { get; set; }
        [JsonProperty(PropertyName = "Percent Increase On Saturday")]
        public decimal PercentIncreaseOnSaturday { get; set; }
        [JsonProperty(PropertyName = "Percent Increase On Sunday")]
        public decimal PercentIncreaseOnSunday { get; set; }
    }

    public class TruePVESettings
    {
        [JsonProperty(PropertyName = "Allow Building Damage At Events")]
        public bool AllowBuildingDamageAtEvents { get; set; }
        [JsonProperty(PropertyName = "Allow PVP At Events")]
        public bool AllowPVPAtEvents { get; set; }
        [JsonProperty(PropertyName = "Allow PVP Server-Wide During Events")]
        public bool ServerWidePVP { get; set; }
    }

    public class UnlockSettings
    {
        [JsonProperty(PropertyName = "Min Seconds")]
        public float MinTime { get; set; }
        [JsonProperty(PropertyName = "Max Seconds")]
        public float MaxTime { get; set; }
        [JsonProperty(PropertyName = "Unlock When Npcs Die")]
        public bool WhenNpcsDie { get; set; }
        [JsonProperty(PropertyName = "Require All Npcs Die Before Unlocking")]
        public bool RequireAllNpcsDie { get; set; }
        [JsonProperty(PropertyName = "Lock Event To Player On Npc Death")]
        public bool LockToPlayerOnNpcDeath { get; set; }
        [JsonProperty(PropertyName = "Lock Event To Player On First Entered")]
        public bool LockToPlayerFirstEntered { get; set; }
    }

    public class UnlootedAnnouncementSettings
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled { get; set; }
        [JsonProperty(PropertyName = "Notify Every X Minutes (Minimum 1)")]
        public float Interval { get; set; }
    }

    public class Configuration
    {
        [JsonProperty(PropertyName = "Settings")]
        public PluginSettings Settings;
        [JsonProperty(PropertyName = "Countdown")]
        public CountdownSettings Countdown;
        [JsonProperty(PropertyName = "Events")]
        public EventSettings Event;
        [JsonProperty(PropertyName = "Event Messages")]
        public EventMessageSettings EventMessages;
        [JsonProperty(PropertyName = "Fireballs")]
        public FireballSettings Fireballs;
        [JsonProperty(PropertyName = "GUIAnnouncements")]
        public GUIAnnouncementSettings GUIAnnouncement;
        [JsonProperty(PropertyName = "Monuments")]
        public MonumentSettings Monuments;
        [JsonProperty(PropertyName = "Newman Mode")]
        public NewmanModeSettings NewmanMode;
        [JsonProperty(PropertyName = "NPCs")]
        public NpcSettings NPC;
        [JsonProperty(PropertyName = "Missile Launcher")]
        public MissileLauncherSettings MissileLauncher;
        [JsonProperty(PropertyName = "Ranked Ladder")]
        public RankedLadderSettings RankedLadder;
        [JsonProperty(PropertyName = "Rewards")]
        public RewardSettings Rewards;
        [JsonProperty(PropertyName = "Rocket Opener")]
        public RocketOpenerSettings Rocket;
        [JsonProperty(PropertyName = "Skins")]
        public SkinSettings Skins;
        [JsonProperty(PropertyName = "Treasure")]
        public TreasureSettings Treasure;
        [JsonProperty(PropertyName = "TruePVE")]
        public TruePVESettings TruePVE;
        [JsonProperty(PropertyName = "Unlock Time")]
        public UnlockSettings Unlock;
        [JsonProperty(PropertyName = "Unlooted Announcements")]
        public UnlootedAnnouncementSettings UnlootedAnnouncements;
    }

    protected override void LoadConfig();
    private void ValidateConfig();
     List<LootItem> ChestLoot { get; set; }
    private bool canSaveConfig;
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
}

public class ZoneInfo
{
    public Vector3 Position;
    public Vector3 Size;
    public float Distance;
    public OBB OBB;
}

public class SkinInfo
{
    public List<ulong> skins;
    public List<ulong> workshopSkins;
    public List<ulong> importedSkins;
    public List<ulong> allSkins;
}

private class PlayerInfo
{
    public int StolenChestsTotal;
    public int StolenChestsSeed;
    public PlayerInfo();
}

private class StoredData
{
    public Dictionary<string, PlayerInfo> Players;
    public double SecondsUntilEvent;
    public string CustomPosition;
    public int TotalEvents;
    public StoredData();
}

public class HumanoidNPC : ScientistNPC
{
    public new HumanoidBrain Brain;
    public Configuration config { get; set; }
    public new Translate.Phrase LootPanelTitle { get; set; }
    public override string Categorize();
    public override bool ShouldDropActiveItem();
    public override string displayName { get; set; }
    public override void AttackerInfo(ProtoBuf.PlayerLifeStory.DeathInfo info);
    public override void OnDied(HitInfo info);
}

public class HumanoidBrain : ScientistBrain
{
    public void DisableShouldThink();
    internal DangerousTreasures Instance;
    internal string displayName;
    internal Transform NpcTransform;
    internal HumanoidNPC npc;
    internal AttackEntity _attackEntity;
    internal FlameThrower flameThrower;
    internal LiquidWeapon liquidWeapon;
    internal BaseMelee baseMelee;
    internal BaseProjectile baseProjectile;
    internal BasePlayer AttackTarget;
    internal Transform AttackTransform;
    internal TreasureChest tc;
    internal NpcSettings Settings;
    internal List<Vector3> positions;
    internal Vector3 DestinationOverride;
    internal bool isKilled;
    internal bool isMurderer;
    internal ulong uid;
    internal float lastWarpTime;
    internal float softLimitSenseRange;
    internal float nextAttackTime;
    internal float attackRange;
    internal float attackCooldown;
    internal AttackType attackType;
    internal BaseNavigator.NavigationSpeed CurrentSpeed;
    internal Vector3 AttackPosition { get; set; }
    internal Vector3 ServerPosition { get; set; }
    private Configuration config { get; set; }
    internal AttackEntity AttackEntity { get; set; }
    public void UpdateWeapon(AttackEntity attackEntity, ItemId uid);
    internal void IdentifyWeapon();
    private void SetAttackRestrictions(AttackType attackType, float attackRange, float attackCooldown, float effectiveRange);
    public bool ValidTarget { get; set; }
    public override void OnDestroy();
    public override void InitializeAI();
    public override void AddStates();
    public class AttackState : BaseAttackState
    {
        private new HumanoidBrain brain;
        private global::HumanNPC npc;
        private Transform NpcTransform;
        private IAIAttack attack { get; set; }
        public AttackState(HumanoidBrain humanoidBrain);
        public override void StateEnter(BaseAIBrain _brain, BaseEntity _entity);
        public override void StateLeave(BaseAIBrain _brain, BaseEntity _entity);
        private void StopAttacking();
        public override StateStatus StateThink(float delta, BaseAIBrain _brain, BaseEntity _entity);
        private bool InAttackRange();
        private void StartAttacking();
        private void RealisticShotTest();
    }

    private bool init;
    public void Init();
    private void Converge();
    public void Forget();
    private void RandomMove(float radius);
    public void SetupNavigator(BaseCombatEntity owner, BaseNavigator navigator, float distance);
    public Vector3 GetAimDirection();
    private void SetAimDirection();
    private void SetDestination();
    private void SetDestination(Vector3 destination);
    public bool CanUseNavMesh();
    public bool SetTarget(BasePlayer player, bool converge);
    private void TryReturnHome();
    private void TryToAttack();
    private void TryToAttack(BasePlayer attacker);
    private void TryMurdererActions();
    private void TryScientistActions();
    public void SetupMovement(List<Vector3> positions);
    private void TryToRoam();
    private bool IsStuck();
    public void Warp();
    private void UseFlameThrower();
    private void UseWaterGun();
    private void UseChainsaw();
    private void MeleeAttack();
    private bool CanConverge(global::HumanNPC other);
    private bool CanLeave(Vector3 destination);
    private bool CanSeeTarget(BasePlayer target);
    public bool CanRoam(Vector3 destination);
    private bool CanShoot();
    public BasePlayer GetBestTarget();
    private Vector3 GetRandomRoamPosition();
    private bool IsAttackOnCooldown();
    private bool IsInAttackRange(float range);
    private bool IsInHomeRange();
    private bool IsInLeaveRange(Vector3 destination);
    private bool IsInReachableRange();
    private bool IsInSenseRange(Vector3 destination);
    private bool IsInTargetRange(Vector3 destination);
    private bool ShouldForgetTarget(BasePlayer target);
}

public class AttackState : BaseAttackState
{
    private new HumanoidBrain brain;
    private global::HumanNPC npc;
    private Transform NpcTransform;
    private IAIAttack attack { get; set; }
    public AttackState(HumanoidBrain humanoidBrain);
    public override void StateEnter(BaseAIBrain _brain, BaseEntity _entity);
    public override void StateLeave(BaseAIBrain _brain, BaseEntity _entity);
    private void StopAttacking();
    public override StateStatus StateThink(float delta, BaseAIBrain _brain, BaseEntity _entity);
    private bool InAttackRange();
    private void StartAttacking();
    private void RealisticShotTest();
}

private class GuidanceSystem : FacepunchBehaviour
{
    private TimedExplosive missile;
    private ServerProjectile projectile;
    private BaseEntity target;
    private Vector3 launchPos;
    private List<ulong> newmans;
    internal DangerousTreasures Instance;
    private Configuration config { get; set; }
    private void Awake();
    public void SetTarget(BaseEntity target);
    public void Launch(float targettingTime);
    public void Exclude(List<ulong> newmans);
    private void GuideMissile();
    private void OnDestroy();
}

public class TreasureChest : FacepunchBehaviour
{
    internal DangerousTreasures Instance;
    internal ulong userid;
    internal GameObject go;
    internal StorageContainer container;
    internal Vector3 containerPos;
    internal Vector3 lastFirePos;
    internal int npcMaxAmountMurderers;
    internal int npcMaxAmountScientists;
    internal int npcSpawnedAmount;
    internal int countdownTime;
    internal bool started;
    internal bool opened;
    internal bool firstEntered;
    internal bool markerCreated;
    internal bool killed;
    internal bool IsUnloading;
    internal bool requireAllNpcsDie;
    internal bool whenNpcsDie;
    internal float claimTime;
    internal float _radius;
    internal long _unlockTime;
    internal NetworkableId uid;
    private Dictionary<string, List<string>> npcKits;
    private Dictionary<ulong, float> fireticks;
    private List<FireBall> fireballs;
    private List<ulong> newmans;
    private List<ulong> traitors;
    private List<ulong> protects;
    private List<ulong> players;
    private List<TimedExplosive> missiles;
    private List<int> times;
    private List<SphereEntity> spheres;
    private List<Vector3> missilePositions;
    private List<Vector3> firePositions;
    public List<HumanoidNPC> npcs;
    private Timer destruct;
    private Timer unlock;
    private Timer countdown;
    private Timer announcement;
    private MapMarkerExplosion explosionMarker;
    private MapMarkerGenericRadius genericMarker;
    private VendingMachineMapMarker vendingMarker;
    private string FormatGridReference(Vector3 position);
    private void Message(BasePlayer player, string key, object[] args);
    private Configuration config { get; set; }
    public float Radius { get; set; }
    private void Free();
    private class NewmanTracker : FacepunchBehaviour
    {
         BasePlayer player;
         TreasureChest chest;
         DangerousTreasures Instance;
         Configuration config { get; set; }
        private void Message(BasePlayer player, string key, object[] args);
        private void Awake();
        public void Assign(DangerousTreasures instance, TreasureChest chest);
        private void Track();
        private void OnDestroy();
    }

    public void Kill(bool isUnloading);
    public bool HasRustMarker { get; set; }
    public void Awaken();
     void Awake();
    public void SpawnLoot(StorageContainer container, List<LootItem> treasure);
    private Dictionary<string, ulong> skinIds { get; set; }
    private bool IsBlacklistedSkin(ItemDefinition def, int num);
    public ulong GetItemSkin(ItemDefinition def, ulong defaultSkin, bool unique);
    public SkinInfo GetItemSkins(ItemDefinition def);
     void OnTriggerEnter(Collider col);
     void OnTriggerExit(Collider col);
    public void SpawnNpcs();
    private NavMeshHit _navHit;
    private Vector3 FindPointOnNavmesh(Vector3 target, float radius);
    private RaycastHit _hit;
    private bool IsAcceptableWaterDepth(Vector3 position);
    private bool TestInsideObject(Vector3 position);
    private bool TestInsideRock(Vector3 a);
    private bool IsRockFaceDownwards(Vector3 a);
    private bool IsRockFaceUpwards(Vector3 point);
    private bool IsRock(string name);
    private List<string> _prefabs;
    private static void CopySerializableFields(T src, T dst);
    private bool InstantiateEntity(Vector3 position, bool isMurderer, HumanoidBrain humanoidBrain, HumanoidNPC npc);
    private Vector3 RandomPosition(float radius);
    private List<Vector3> RandomWanderPositions(float radius);
    private Vector3 GetRandomPoint(float radius);
    private HumanoidNPC SpawnNpc(bool isMurderer);
    public class Loadout
    {
        public List<PlayerInventoryProperties.ItemAmountSkinned> belt;
        public List<PlayerInventoryProperties.ItemAmountSkinned> main;
        public List<PlayerInventoryProperties.ItemAmountSkinned> wear;
    }

    private PlayerInventoryProperties GetLoadout(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
    private Loadout CreateLoadout(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
    private void AddItemAmountSkinned(List<PlayerInventoryProperties.ItemAmountSkinned> source, List<string> shortnames);
    private void SetupNpc(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer, List<Vector3> positions);
    private void GiveKit(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
    private void UpdateItems(HumanoidNPC npc, HumanoidBrain brain, bool isMurderer);
    private bool ToggleNpcMinerHat(HumanoidNPC npc, bool state);
    public void EquipWeapon(HumanoidNPC npc, HumanoidBrain brain);
     void SetupNpcKits();
     bool IsKit(string kit);
    public void UpdateMarker();
    private void CreateGenericMarker();
    private void SafelyKill(HumanoidNPC npc);
    private void KillNpc();
    public void RemoveMapMarkers();
    private void OnDestroy();
    public void DestroyMe();
    public void LaunchMissile();
     void SpawnFire();
     void SpawnFire(Vector3 firePos);
    public void Destruct();
     void Unclaimed();
    public string GetUnlockTime(string userID);
    public void Unlock();
    public void SetUnlockTime(float time);
    public void TrySetOwner(HitInfo hitInfo);
    private void SafelyKill(BaseEntity e);
    public void DestroyLauncher();
    public void DestroySphere();
    public void DestroyFire();
}

private class NewmanTracker : FacepunchBehaviour
{
     BasePlayer player;
     TreasureChest chest;
     DangerousTreasures Instance;
     Configuration config { get; set; }
    private void Message(BasePlayer player, string key, object[] args);
    private void Awake();
    public void Assign(DangerousTreasures instance, TreasureChest chest);
    private void Track();
    private void OnDestroy();
}

public class Loadout
{
    public List<PlayerInventoryProperties.ItemAmountSkinned> belt;
    public List<PlayerInventoryProperties.ItemAmountSkinned> main;
    public List<PlayerInventoryProperties.ItemAmountSkinned> wear;
}

private class MonumentInfoEx
{
    public MonumentInfo monument;
    public Vector3 position;
    public float radius;
    public string name;
    public string prefab;
    public MonumentInfoEx();
    public MonumentInfoEx(MonumentInfo monument, Vector3 position, float radius, string name, string prefab);
    public bool IsInBounds(Vector3 target);
}

public class Notification
{
    public BasePlayer player;
    public string messageEx;
}

public class PluginSettings
{
    [JsonProperty(PropertyName = "Permission Name")]
    public string PermName { get; set; }
    [JsonProperty(PropertyName = "Event Chat Command")]
    public string EventChatCommand { get; set; }
    [JsonProperty(PropertyName = "Distance Chat Command")]
    public string DistanceChatCommand { get; set; }
    [JsonProperty(PropertyName = "Draw Location On Screen With Distance Command")]
    public bool AllowDrawText { get; set; }
    [JsonProperty(PropertyName = "Event Console Command")]
    public string EventConsoleCommand { get; set; }
    [JsonProperty(PropertyName = "Show X Z Coordinates")]
    public bool ShowXZ { get; set; }
    [JsonProperty(PropertyName = "Show Grid Coordinates")]
    public bool ShowGrid { get; set; }
    [JsonProperty(PropertyName = "Grids To Block Spawns At", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> BlockedGrids;
    [JsonProperty(PropertyName = "Block Spawns At Positions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ManagementSettingsLocations> BlockedPositions;
}

public class ManagementSettingsLocations
{
    [JsonProperty(PropertyName = "position")]
    [JsonConverter(typeof(UnityVector3Converter))]
    public Vector3 position;
    public float radius;
    public ManagementSettingsLocations();
    public ManagementSettingsLocations(Vector3 position, float radius);
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

public class CountdownSettings
{
    [JsonProperty(PropertyName = "Use Countdown Before Event Starts")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Time In Seconds", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<int> Times { get; set; }
}

public class EventSettings
{
    [JsonProperty(PropertyName = "Allow Player Bags To Be Lootable At Events")]
    public bool PlayersLootable;
    [JsonProperty(PropertyName = "Automated")]
    public bool Automated { get; set; }
    [JsonProperty(PropertyName = "Every Min Seconds")]
    public float IntervalMin { get; set; }
    [JsonProperty(PropertyName = "Every Max Seconds")]
    public float IntervalMax { get; set; }
    [JsonProperty(PropertyName = "Use Vending Map Marker")]
    public bool MarkerVending { get; set; }
    [JsonProperty(PropertyName = "Use Marker Manager Plugin")]
    public bool MarkerManager { get; set; }
    [JsonProperty(PropertyName = "Use Explosion Map Marker")]
    public bool MarkerExplosion { get; set; }
    [JsonProperty(PropertyName = "Marker Color")]
    public string MarkerColor { get; set; }
    [JsonProperty(PropertyName = "Marker Radius")]
    public float MarkerRadius { get; set; }
    [JsonProperty(PropertyName = "Marker Radius (Smaller Maps)")]
    public float MarkerRadiusSmall { get; set; }
    [JsonProperty(PropertyName = "Marker Event Name")]
    public string MarkerName { get; set; }
    [JsonProperty(PropertyName = "Max Manual Events")]
    public int Max { get; set; }
    [JsonProperty(PropertyName = "Always Spawn Max Manual Events")]
    public bool SpawnMax { get; set; }
    [JsonProperty(PropertyName = "Stagger Spawns Every X Seconds")]
    public float Stagger { get; set; }
    [JsonProperty(PropertyName = "Amount Of Items To Spawn")]
    public int TreasureAmount { get; set; }
    [JsonProperty(PropertyName = "Use Spheres")]
    public bool Spheres { get; set; }
    [JsonProperty(PropertyName = "Amount Of Spheres")]
    public int SphereAmount { get; set; }
    [JsonProperty(PropertyName = "Destroy Spheres When Event Starts")]
    public bool DestroySphereOnStart { get; set; }
    [JsonProperty(PropertyName = "Player Limit For Event")]
    public int PlayerLimit { get; set; }
    [JsonProperty(PropertyName = "Fire Aura Radius (Advanced Users Only)")]
    public float Radius { get; set; }
    [JsonProperty(PropertyName = "Auto Draw On New Event For Nearby Players")]
    public bool DrawTreasureIfNearby { get; set; }
    [JsonProperty(PropertyName = "Auto Draw Minimum Distance")]
    public float AutoDrawDistance { get; set; }
    [JsonProperty(PropertyName = "Grant DDRAW temporarily to players")]
    public bool GrantDraw { get; set; }
    [JsonProperty(PropertyName = "Grant Draw Time")]
    public float DrawTime { get; set; }
    [JsonProperty(PropertyName = "Time To Loot")]
    public float DestructTime { get; set; }
}

public class UIAdvancedAlertSettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Anchor Min")]
    public string AnchorMin { get; set; }
    [JsonProperty(PropertyName = "Anchor Max")]
    public string AnchorMax { get; set; }
    [JsonProperty(PropertyName = "Time Shown")]
    public float Time { get; set; }
}

public class EventMessageSettings
{
    [JsonProperty(PropertyName = "Advanced Alerts UI")]
    public UIAdvancedAlertSettings AA { get; set; }
    [JsonProperty(PropertyName = "Notify Plugin - Type (-1 = disabled)")]
    public int NotifyType { get; set; }
    [JsonProperty(PropertyName = "UI Popup Interval")]
    public float Interval { get; set; }
    [JsonProperty(PropertyName = "Show Noob Warning Message")]
    public bool NoobWarning { get; set; }
    [JsonProperty(PropertyName = "Show Barrage Message")]
    public bool Barrage { get; set; }
    [JsonProperty(PropertyName = "Show Despawn Message")]
    public bool Destruct { get; set; }
    [JsonProperty(PropertyName = "Show You Have Entered")]
    public bool Entered { get; set; }
    [JsonProperty(PropertyName = "Show First Player Entered")]
    public bool FirstEntered { get; set; }
    [JsonProperty(PropertyName = "Show First Player Opened")]
    public bool FirstOpened { get; set; }
    [JsonProperty(PropertyName = "Show Opened Message")]
    public bool Opened { get; set; }
    [JsonProperty(PropertyName = "Show Prefix")]
    public bool Prefix { get; set; }
    [JsonProperty(PropertyName = "Show Started Message")]
    public bool Started { get; set; }
    [JsonProperty(PropertyName = "Show Thief Message")]
    public bool Thief { get; set; }
    [JsonProperty(PropertyName = "Send Messages To Player")]
    public bool Message { get; set; }
}

public class FireballSettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Damage Per Second")]
    public float DamagePerSecond { get; set; }
    [JsonProperty(PropertyName = "Lifetime Min")]
    public float LifeTimeMin { get; set; }
    [JsonProperty(PropertyName = "Lifetime Max")]
    public float LifeTimeMax { get; set; }
    [JsonProperty(PropertyName = "Radius")]
    public float Radius { get; set; }
    [JsonProperty(PropertyName = "Tick Rate")]
    public float TickRate { get; set; }
    [JsonProperty(PropertyName = "Generation")]
    public float Generation { get; set; }
    [JsonProperty(PropertyName = "Water To Extinguish")]
    public int WaterToExtinguish { get; set; }
    [JsonProperty(PropertyName = "Spawn Every X Seconds")]
    public int SecondsBeforeTick { get; set; }
}

public class GUIAnnouncementSettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Text Color")]
    public string TextColor { get; set; }
    [JsonProperty(PropertyName = "Banner Tint Color")]
    public string TintColor { get; set; }
    [JsonProperty(PropertyName = "Maximum Distance")]
    public float Distance { get; set; }
}

public class MissileLauncherSettings
{
    [JsonProperty(PropertyName = "Acquire Time In Seconds")]
    public float TargettingTime { get; set; }
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Damage Per Missile")]
    public float Damage { get; set; }
    [JsonProperty(PropertyName = "Detection Distance")]
    public float Distance { get; set; }
    [JsonProperty(PropertyName = "Life Time In Seconds")]
    public float Lifetime { get; set; }
    [JsonProperty(PropertyName = "Ignore Flying Players")]
    public bool IgnoreFlying { get; set; }
    [JsonProperty(PropertyName = "Spawn Every X Seconds")]
    public float Frequency { get; set; }
    [JsonProperty(PropertyName = "Target Chest If No Player Target")]
    public bool TargetChest { get; set; }
}

public class MonumentSettings
{
    [JsonProperty(PropertyName = "Blacklisted Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, bool> Blacklist { get; set; }
    [JsonProperty(PropertyName = "Auto Spawn At Monuments Only")]
    public bool Only { get; set; }
    [JsonProperty(PropertyName = "Chance To Spawn At Monuments Instead")]
    public float Chance { get; set; }
    [JsonProperty(PropertyName = "Allow Treasure Loot Underground")]
    public bool Underground { get; set; }
}

public class NewmanModeSettings
{
    [JsonProperty(PropertyName = "Protect Nakeds From Fire Aura")]
    public bool Aura { get; set; }
    [JsonProperty(PropertyName = "Protect Nakeds From Other Harm")]
    public bool Harm { get; set; }
}

public class NpcKitSettings
{
    [JsonProperty(PropertyName = "Helm", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Helm;
    [JsonProperty(PropertyName = "Torso", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Torso;
    [JsonProperty(PropertyName = "Pants", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Pants;
    [JsonProperty(PropertyName = "Gloves", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Gloves;
    [JsonProperty(PropertyName = "Boots", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Boots;
    [JsonProperty(PropertyName = "Shirt", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Shirt;
    [JsonProperty(PropertyName = "Kilts", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Kilts;
    [JsonProperty(PropertyName = "Weapon", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Weapon;
}

public class NpcLootSettings
{
    [JsonProperty(PropertyName = "Prefab ID List", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> IDs { get; set; }
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Disable All Prefab Loot Spawns")]
    public bool None { get; set; }
    public uint GetRandom();
}

public class NpcSettingsAccuracy
{
    [JsonProperty(PropertyName = "AK47")]
    public double AK47 { get; set; }
    [JsonProperty(PropertyName = "AK47 ICE")]
    public double AK47ICE { get; set; }
    [JsonProperty(PropertyName = "Bolt Rifle")]
    public double BOLT_RIFLE { get; set; }
    [JsonProperty(PropertyName = "Compound Bow")]
    public double COMPOUND_BOW { get; set; }
    [JsonProperty(PropertyName = "Crossbow")]
    public double CROSSBOW { get; set; }
    [JsonProperty(PropertyName = "Double Barrel Shotgun")]
    public double DOUBLE_SHOTGUN { get; set; }
    [JsonProperty(PropertyName = "Eoka")]
    public double EOKA { get; set; }
    [JsonProperty(PropertyName = "Glock")]
    public double GLOCK { get; set; }
    [JsonProperty(PropertyName = "HMLMG")]
    public double HMLMG { get; set; }
    [JsonProperty(PropertyName = "L96")]
    public double L96 { get; set; }
    [JsonProperty(PropertyName = "LR300")]
    public double LR300 { get; set; }
    [JsonProperty(PropertyName = "M249")]
    public double M249 { get; set; }
    [JsonProperty(PropertyName = "M39")]
    public double M39 { get; set; }
    [JsonProperty(PropertyName = "M92")]
    public double M92 { get; set; }
    [JsonProperty(PropertyName = "MP5")]
    public double MP5 { get; set; }
    [JsonProperty(PropertyName = "Nailgun")]
    public double NAILGUN { get; set; }
    [JsonProperty(PropertyName = "Pump Shotgun")]
    public double PUMP_SHOTGUN { get; set; }
    [JsonProperty(PropertyName = "Python")]
    public double PYTHON { get; set; }
    [JsonProperty(PropertyName = "Revolver")]
    public double REVOLVER { get; set; }
    [JsonProperty(PropertyName = "Semi Auto Pistol")]
    public double SEMI_AUTO_PISTOL { get; set; }
    [JsonProperty(PropertyName = "Semi Auto Rifle")]
    public double SEMI_AUTO_RIFLE { get; set; }
    [JsonProperty(PropertyName = "Spas12")]
    public double SPAS12 { get; set; }
    [JsonProperty(PropertyName = "Speargun")]
    public double SPEARGUN { get; set; }
    [JsonProperty(PropertyName = "SMG")]
    public double SMG { get; set; }
    [JsonProperty(PropertyName = "Snowball Gun")]
    public double SNOWBALL_GUN { get; set; }
    [JsonProperty(PropertyName = "Thompson")]
    public double THOMPSON { get; set; }
    [JsonProperty(PropertyName = "Waterpipe Shotgun")]
    public double WATERPIPE_SHOTGUN { get; set; }
    public NpcSettingsAccuracy(double accuracy);
    public double Get(HumanoidBrain brain);
}

public class NpcSettingsMurderer
{
    [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> RandomNames { get; set; }
    [JsonProperty(PropertyName = "Items)")]
    public NpcKitSettings Items { get; set; }
    [JsonProperty(PropertyName = "Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Kits { get; set; }
    [JsonProperty(PropertyName = "Spawn Alternate Loot")]
    public NpcLootSettings Alternate { get; set; }
    [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
    public NpcSettingsAccuracy Accuracy { get; set; }
    [JsonProperty(PropertyName = "Aggression Range")]
    public float AggressionRange { get; set; }
    [JsonProperty(PropertyName = "Despawn Inventory On Death")]
    public bool DespawnInventory { get; set; }
    [JsonProperty(PropertyName = "Corpse Despawn Time When Despawn Inventory On Death")]
    public float DespawnInventoryTime { get; set; }
    [JsonProperty(PropertyName = "Corpse Despawn Time Otherwise")]
    public float CorpseDespawnTime { get; set; }
    [JsonProperty(PropertyName = "Die Instantly From Headshots")]
    public bool Headshot { get; set; }
    [JsonProperty(PropertyName = "Amount To Spawn (min)")]
    public int SpawnMinAmount { get; set; }
    [JsonProperty(PropertyName = "Amount To Spawn (max)")]
    public int SpawnAmount { get; set; }
    [JsonProperty(PropertyName = "Health")]
    public float Health { get; set; }
}

public class NpcSettingsScientist
{
    [JsonProperty(PropertyName = "Random Names", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> RandomNames { get; set; }
    [JsonProperty(PropertyName = "Items")]
    public NpcKitSettings Items { get; set; }
    [JsonProperty(PropertyName = "Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Kits { get; set; }
    [JsonProperty(PropertyName = "Spawn Alternate Loot")]
    public NpcLootSettings Alternate { get; set; }
    [JsonProperty(PropertyName = "Weapon Accuracy (0 - 100)")]
    public NpcSettingsAccuracy Accuracy { get; set; }
    [JsonProperty(PropertyName = "Aggression Range")]
    public float AggressionRange { get; set; }
    [JsonProperty(PropertyName = "Despawn Inventory On Death")]
    public bool DespawnInventory { get; set; }
    [JsonProperty(PropertyName = "Corpse Despawn Time When Despawn Inventory On Death")]
    public float DespawnInventoryTime { get; set; }
    [JsonProperty(PropertyName = "Corpse Despawn Time Otherwise")]
    public float CorpseDespawnTime { get; set; }
    [JsonProperty(PropertyName = "Die Instantly From Headshots")]
    public bool Headshot { get; set; }
    [JsonProperty(PropertyName = "Amount To Spawn (min)")]
    public int SpawnMinAmount { get; set; }
    [JsonProperty(PropertyName = "Amount To Spawn (max)")]
    public int SpawnAmount { get; set; }
    [JsonProperty(PropertyName = "Health (100 min, 5000 max)")]
    public float Health { get; set; }
}

public class NpcSettings
{
    [JsonProperty(PropertyName = "Blacklisted Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, bool> BlacklistedMonuments { get; set; }
    [JsonProperty(PropertyName = "Murderers")]
    public NpcSettingsMurderer Murderers { get; set; }
    [JsonProperty(PropertyName = "Scientists")]
    public NpcSettingsScientist Scientists { get; set; }
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Allow Npcs To Leave Dome When Attacking")]
    public bool CanLeave { get; set; }
    [JsonProperty(PropertyName = "Allow Npcs To Target Other Npcs")]
    public bool TargetNpcs { get; set; }
    [JsonProperty(PropertyName = "Block Damage From Players Beyond X Distance (0 = disabled)")]
    public float Range { get; set; }
    [JsonProperty(PropertyName = "Block Npc Kits Plugin")]
    public bool BlockNpcKits { get; set; }
    [JsonProperty(PropertyName = "Kill Underwater Npcs")]
    public bool KillUnderwater { get; set; }
}

public class PasteOption
{
    [JsonProperty(PropertyName = "Option")]
    public string Key { get; set; }
    [JsonProperty(PropertyName = "Value")]
    public string Value { get; set; }
}

public class RankedLadderSettings
{
    [JsonProperty(PropertyName = "Award Top X Players On Wipe")]
    public int Amount { get; set; }
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Group Name")]
    public string Group { get; set; }
    [JsonProperty(PropertyName = "Permission Name")]
    public string Permission { get; set; }
}

public class RewardSettings
{
    [JsonProperty(PropertyName = "Economics Money")]
    public double Money { get; set; }
    [JsonProperty(PropertyName = "ServerRewards Points")]
    public double Points { get; set; }
    [JsonProperty(PropertyName = "Use Economics")]
    public bool Economics { get; set; }
    [JsonProperty(PropertyName = "Use ServerRewards")]
    public bool ServerRewards { get; set; }
}

public class RocketOpenerSettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Rockets")]
    public int Amount { get; set; }
    [JsonProperty(PropertyName = "Speed")]
    public float Speed { get; set; }
    [JsonProperty(PropertyName = "Use Fire Rockets")]
    public bool FireRockets { get; set; }
}

public class SkinSettings
{
    [JsonProperty(PropertyName = "Custom Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> Custom { get; set; }
    [JsonProperty(PropertyName = "Use Random Skin")]
    public bool RandomSkins { get; set; }
    [JsonProperty(PropertyName = "Preset Skin")]
    public ulong PresetSkin { get; set; }
    [JsonProperty(PropertyName = "Include Workshop Skins")]
    public bool RandomWorkshopSkins { get; set; }
    [JsonProperty(PropertyName = "Randomize Npc Item Skins")]
    public bool Npcs { get; set; }
    [JsonProperty(PropertyName = "Use Identical Skins For All Npcs")]
    public bool UniqueNpcs { get; set; }
}

public class LootItem
{
    public string shortname { get; set; }
    public string name { get; set; }
    public int amount { get; set; }
    public ulong skin { get; set; }
    public int amountMin { get; set; }
    public float condition { get; set; }
    public float probability { get; set; }
    [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> skins { get; set; }
}

public class TreasureSettings
{
    [JsonProperty(PropertyName = "Loot", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> Loot { get; set; }
    [JsonProperty(PropertyName = "Minimum Percent Loss")]
    public decimal PercentLoss { get; set; }
    [JsonProperty(PropertyName = "Percent Increase When Using Day Of Week Loot")]
    public bool Increased { get; set; }
    [JsonProperty(PropertyName = "Use Random Skins")]
    public bool RandomSkins { get; set; }
    [JsonProperty(PropertyName = "Include Workshop Skins")]
    public bool RandomWorkshopSkins { get; set; }
    [JsonProperty(PropertyName = "Day Of Week Loot Monday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> DOWL_Monday { get; set; }
    [JsonProperty(PropertyName = "Day Of Week Loot Tuesday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> DOWL_Tuesday { get; set; }
    [JsonProperty(PropertyName = "Day Of Week Loot Wednesday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> DOWL_Wednesday { get; set; }
    [JsonProperty(PropertyName = "Day Of Week Loot Thursday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> DOWL_Thursday { get; set; }
    [JsonProperty(PropertyName = "Day Of Week Loot Friday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> DOWL_Friday { get; set; }
    [JsonProperty(PropertyName = "Day Of Week Loot Saturday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> DOWL_Saturday { get; set; }
    [JsonProperty(PropertyName = "Day Of Week Loot Sunday", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<LootItem> DOWL_Sunday { get; set; }
    [JsonProperty(PropertyName = "Use Day Of Week Loot")]
    public bool UseDOWL { get; set; }
    [JsonProperty(PropertyName = "Percent Increase On Monday")]
    public decimal PercentIncreaseOnMonday { get; set; }
    [JsonProperty(PropertyName = "Percent Increase On Tuesday")]
    public decimal PercentIncreaseOnTuesday { get; set; }
    [JsonProperty(PropertyName = "Percent Increase On Wednesday")]
    public decimal PercentIncreaseOnWednesday { get; set; }
    [JsonProperty(PropertyName = "Percent Increase On Thursday")]
    public decimal PercentIncreaseOnThursday { get; set; }
    [JsonProperty(PropertyName = "Percent Increase On Friday")]
    public decimal PercentIncreaseOnFriday { get; set; }
    [JsonProperty(PropertyName = "Percent Increase On Saturday")]
    public decimal PercentIncreaseOnSaturday { get; set; }
    [JsonProperty(PropertyName = "Percent Increase On Sunday")]
    public decimal PercentIncreaseOnSunday { get; set; }
}

public class TruePVESettings
{
    [JsonProperty(PropertyName = "Allow Building Damage At Events")]
    public bool AllowBuildingDamageAtEvents { get; set; }
    [JsonProperty(PropertyName = "Allow PVP At Events")]
    public bool AllowPVPAtEvents { get; set; }
    [JsonProperty(PropertyName = "Allow PVP Server-Wide During Events")]
    public bool ServerWidePVP { get; set; }
}

public class UnlockSettings
{
    [JsonProperty(PropertyName = "Min Seconds")]
    public float MinTime { get; set; }
    [JsonProperty(PropertyName = "Max Seconds")]
    public float MaxTime { get; set; }
    [JsonProperty(PropertyName = "Unlock When Npcs Die")]
    public bool WhenNpcsDie { get; set; }
    [JsonProperty(PropertyName = "Require All Npcs Die Before Unlocking")]
    public bool RequireAllNpcsDie { get; set; }
    [JsonProperty(PropertyName = "Lock Event To Player On Npc Death")]
    public bool LockToPlayerOnNpcDeath { get; set; }
    [JsonProperty(PropertyName = "Lock Event To Player On First Entered")]
    public bool LockToPlayerFirstEntered { get; set; }
}

public class UnlootedAnnouncementSettings
{
    [JsonProperty(PropertyName = "Enabled")]
    public bool Enabled { get; set; }
    [JsonProperty(PropertyName = "Notify Every X Minutes (Minimum 1)")]
    public float Interval { get; set; }
}

public class Configuration
{
    [JsonProperty(PropertyName = "Settings")]
    public PluginSettings Settings;
    [JsonProperty(PropertyName = "Countdown")]
    public CountdownSettings Countdown;
    [JsonProperty(PropertyName = "Events")]
    public EventSettings Event;
    [JsonProperty(PropertyName = "Event Messages")]
    public EventMessageSettings EventMessages;
    [JsonProperty(PropertyName = "Fireballs")]
    public FireballSettings Fireballs;
    [JsonProperty(PropertyName = "GUIAnnouncements")]
    public GUIAnnouncementSettings GUIAnnouncement;
    [JsonProperty(PropertyName = "Monuments")]
    public MonumentSettings Monuments;
    [JsonProperty(PropertyName = "Newman Mode")]
    public NewmanModeSettings NewmanMode;
    [JsonProperty(PropertyName = "NPCs")]
    public NpcSettings NPC;
    [JsonProperty(PropertyName = "Missile Launcher")]
    public MissileLauncherSettings MissileLauncher;
    [JsonProperty(PropertyName = "Ranked Ladder")]
    public RankedLadderSettings RankedLadder;
    [JsonProperty(PropertyName = "Rewards")]
    public RewardSettings Rewards;
    [JsonProperty(PropertyName = "Rocket Opener")]
    public RocketOpenerSettings Rocket;
    [JsonProperty(PropertyName = "Skins")]
    public SkinSettings Skins;
    [JsonProperty(PropertyName = "Treasure")]
    public TreasureSettings Treasure;
    [JsonProperty(PropertyName = "TruePVE")]
    public TruePVESettings TruePVE;
    [JsonProperty(PropertyName = "Unlock Time")]
    public UnlockSettings Unlock;
    [JsonProperty(PropertyName = "Unlooted Announcements")]
    public UnlootedAnnouncementSettings UnlootedAnnouncements;
}

Oxide.Plugins.DangerousTreasuresExtensionMethods
public static class ExtensionMethods
{
    internal static Core.Libraries.Permission p;
    public static bool All(IEnumerable<T> a, Func<T, bool> b);
    public static T ElementAt(IEnumerable<T> a, int b);
    public static bool Exists(IEnumerable<T> a, Func<T, bool> b);
    public static T FirstOrDefault(IEnumerable<T> a, Func<T, bool> b);
    public static IEnumerable<V> Select(IEnumerable<T> a, Func<T, V> b);
    public static string[] Skip(string[] a, int b);
    public static List<T> Take(IList<T> a, int b);
    public static Dictionary<T, V> ToDictionary(IEnumerable<S> a, Func<S, T> b, Func<S, V> c);
    public static List<T> ToList(IEnumerable<T> a);
    public static List<T> Where(IEnumerable<T> a, Func<T, bool> b);
    public static List<T> OfType(IEnumerable<BaseNetworkable> a);
    public static int Sum(IEnumerable<T> a, Func<T, int> b);
    public static bool UserHasGroup(string a, string b);
    public static bool UserHasGroup(IPlayer a, string b);
    public static bool IsReallyConnected(BasePlayer a);
    public static bool IsKilled(BaseNetworkable a);
    public static bool IsNull(T a);
    public static bool IsNull(BasePlayer a);
    public static bool IsReallyValid(BaseNetworkable a);
    public static void SafelyKill(BaseNetworkable a);
    public static bool CanCall(Plugin o);
    public static bool IsHuman(BasePlayer a);
    public static float Distance(Vector3 a, Vector3 b);
    public static void ResetToPool(Dictionary<K, V> obj);
    public static void ResetToPool(List<T> obj);
}


```

---


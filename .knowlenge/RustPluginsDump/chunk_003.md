# uMod Plugins Dataset - Code Abstractions (Continued)

Chunk 3 - Generated: 2025-07-06 20:39:06

## DoorsControl

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using System;
using System.Reflection;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("DoorsControl", "RusskiIvan", "1.0.4")]
[Description("DoorsControl")]
public class DoorsControl : RustPlugin
{
    [PluginReference]
    private Plugin Clans;
    private StoredData _data;
    private ConfigData _config;
    private readonly FieldInfo _serverInput;
    private readonly Vector3 _eyesAdjust;
    private bool _dataLoaded;
    private readonly FieldInfo _hasCode;
    private class ConfigData
    {
        [JsonProperty("Команда для замков")]
        public string codelockCommand { get; set; }
        [JsonProperty("Команда для дверей ")]
        public string doorsCommand { get; set; }
        [JsonProperty("Привилегии")]
        public Permissions permissions { get; set; }
        [JsonProperty("Настройки")]
        public Settings settings { get; set; }
    }

    private class Permissions
    {
        [JsonProperty("Привилегия для дверей")]
        public string permissionDeployDoor { get; set; }
        [JsonProperty("Привилегия для ящиков")]
        public string permissionDeployBox { get; set; }
        [JsonProperty("Привилегия для шкафов с одеждой")]
        public string permissionDeployLocker { get; set; }
        [JsonProperty("Привилегия для шкафа")]
        public string permissionDeployCupboard { get; set; }
        [JsonProperty("Привилегия для автозакрытия замка")]
        public string permissionAutoLock { get; set; }
        [JsonProperty("Привилегия для установки замка без замка :)")]
        public string permissionNoLockNeed { get; set; }
        [JsonProperty("Привилегия для автозакрывания двери")]
        public string permissionAutoCloseDoor { get; set; }
        [JsonProperty("Привилегия для умного дома")]
        public string permissionSmartHome { get; set; }
    }

    private class Settings
    {
        [JsonProperty("Автозакрытие замка")]
        public bool AutoLock { get; set; }
        [JsonProperty("Авто установка на двери")]
        public bool DeployDoor { get; set; }
        [JsonProperty("Авто установка на ящики")]
        public bool DeployBox { get; set; }
        [JsonProperty("Авто установка на шкафы с одеждой")]
        public bool DeployLocker { get; set; }
        [JsonProperty("Авто установка на шкаф")]
        public bool DeployCupboard { get; set; }
        [JsonProperty("Задержка закрытия двери")]
        public float defaultDelay { get; set; }
        [JsonProperty("Автозакрытие дверей")]
        public bool autoDoor { get; set; }
    }

    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
    private void Loaded();
    private void OnServerInitialized();
    private void OnPlayerConnected(BasePlayer player);
    private void OnDoorOpened(Door door, BasePlayer player);
    private void OnItemDeployed(Deployer deployer, BaseEntity entity);
    private void OnEntityBuilt(Planner planner, GameObject obj);
    private void OnNewSave();
    private void OnServerSave();
    private void Unload();
     bool IsClanMember(ulong playerid, ulong targetID);
    private void CloseDoor(BaseEntity door);
    private static BaseEntity DoRay(Vector3 pos, Vector3 aim);
    private void AutoDoorCommand(BasePlayer player, string command, string[] args);
    private void SetDoor(BasePlayer player);
    private void SwitchDoor(BasePlayer player, BaseNetworkable door);
    private void RegisterPermissions();
    private void AddNewPlayer(BasePlayer player);
    private void SetPlayerData(BasePlayer player, int Code, bool AutoLock, bool DeployDoor, bool DeployBox, bool DeployLocker, bool DeployCupboard, bool autoDoor, float defaultDelay);
    private PlayerInfo GetPlayerData(BasePlayer player);
    private void LockPlacing(BasePlayer player, BaseEntity entity);
    private void CodeLockCommand(BasePlayer player, string command, string[] args);
    private void SaveData();
    private void LoadData();
     class StoredData
    {
        public Dictionary<ulong, PlayerInfo> PlayerInfo;
        public List<uint> DoorsList;
    }

     class PlayerInfo
    {
        public bool AutoLock;
        public bool DeployDoor;
        public bool DeployBox;
        public bool DeployLocker;
        public bool DeployCupboard;
        public int Password;
        public bool AutoDoor;
        public float DefaultDelay;
    }

    protected override void LoadDefaultMessages();
    private string Msg(string key, BasePlayer player);
}

private class ConfigData
{
    [JsonProperty("Команда для замков")]
    public string codelockCommand { get; set; }
    [JsonProperty("Команда для дверей ")]
    public string doorsCommand { get; set; }
    [JsonProperty("Привилегии")]
    public Permissions permissions { get; set; }
    [JsonProperty("Настройки")]
    public Settings settings { get; set; }
}

private class Permissions
{
    [JsonProperty("Привилегия для дверей")]
    public string permissionDeployDoor { get; set; }
    [JsonProperty("Привилегия для ящиков")]
    public string permissionDeployBox { get; set; }
    [JsonProperty("Привилегия для шкафов с одеждой")]
    public string permissionDeployLocker { get; set; }
    [JsonProperty("Привилегия для шкафа")]
    public string permissionDeployCupboard { get; set; }
    [JsonProperty("Привилегия для автозакрытия замка")]
    public string permissionAutoLock { get; set; }
    [JsonProperty("Привилегия для установки замка без замка :)")]
    public string permissionNoLockNeed { get; set; }
    [JsonProperty("Привилегия для автозакрывания двери")]
    public string permissionAutoCloseDoor { get; set; }
    [JsonProperty("Привилегия для умного дома")]
    public string permissionSmartHome { get; set; }
}

private class Settings
{
    [JsonProperty("Автозакрытие замка")]
    public bool AutoLock { get; set; }
    [JsonProperty("Авто установка на двери")]
    public bool DeployDoor { get; set; }
    [JsonProperty("Авто установка на ящики")]
    public bool DeployBox { get; set; }
    [JsonProperty("Авто установка на шкафы с одеждой")]
    public bool DeployLocker { get; set; }
    [JsonProperty("Авто установка на шкаф")]
    public bool DeployCupboard { get; set; }
    [JsonProperty("Задержка закрытия двери")]
    public float defaultDelay { get; set; }
    [JsonProperty("Автозакрытие дверей")]
    public bool autoDoor { get; set; }
}

 class StoredData
{
    public Dictionary<ulong, PlayerInfo> PlayerInfo;
    public List<uint> DoorsList;
}

 class PlayerInfo
{
    public bool AutoLock;
    public bool DeployDoor;
    public bool DeployBox;
    public bool DeployLocker;
    public bool DeployCupboard;
    public int Password;
    public bool AutoDoor;
    public float DefaultDelay;
}


```

---

## Draw

```csharp
using Oxide.Core.Libraries;
using UnityEngine;

Oxide.Plugins
[Info("Draw", "playrust.io / dcode", "1.0.1", ResourceId = 968)]
public class Draw : RustPlugin
{
    [LibraryFunction("Line")]
    public void Line(BasePlayer player, Vector3 from, Vector3 to, Color color, float duration);
    [LibraryFunction("Arrow")]
    public void Arrow(BasePlayer player, Vector3 from, Vector3 to, float headSize, Color color, float duration);
    [LibraryFunction("Sphere")]
    public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration);
    [LibraryFunction("Text")]
    public void Text(BasePlayer player, Vector3 pos, string text, Color color, float duration);
    [LibraryFunction("Box")]
    public void Box(BasePlayer player, Vector3 pos, float size, Color color, float duration);
}


```

---

## DrawBridges

```csharp
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Rust;
using Network;
using System.Collections.Generic;

Oxide.Plugins
[Info("DrawBridges", "Colon Blow", "2.0.12")]
public class DrawBridges : RustPlugin
{
    [PluginReference]
     Plugin Clans;
    [PluginReference]
     Plugin Friends;
     BaseEntity newBridge;
    public static DrawBridges instance;
    static Dictionary<ulong, PlayerBridgeData> loadplayer;
    static List<uint> storedBridges;
    private DynamicConfigFile data;
    private bool initialized;
    public class PlayerBridgeData
    {
        public BasePlayer player;
        public int bridgecount;
    }

    static bool UseSoundsEffects;
     bool UseMaxBridgeChecks;
     bool BlockBuildingOnBridge;
     bool AllowOnFloors;
     bool AllowOnFoundations;
    static bool UseFriendsChecks;
    static bool UseClansChecks;
     bool UseStabilityCheck;
     bool MasterBuilderFreedom;
    static bool UsePressurePlates;
    public int maxbridges;
    public int maxvipbridges;
     float userange;
     float rotaterange;
     float setramprange;
     float lockrange;
     float invertrange;
     float destroyrange;
     float minstability;
     bool Changed;
    private void LoadVariables();
     void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
     object GetConfig(string menu, string datavalue, object defaultValue);
     string msg(string key, string playerId);
     Dictionary<string, string> Messages;
     void Loaded();
    private void OnServerInitialized();
    private void OnServerSave();
     void Unload();
    private void RestoreBridges();
     void SaveData();
     void LoadData();
     bool isAllowed(BasePlayer player, string perm);
     bool isCorrectBlock(BaseEntity entity, BasePlayer player);
     bool BridgeLimitReached(BasePlayer player);
    private bool IsFriend(ulong playerid, ulong friendid);
    private bool IsClanmate(ulong playerid, ulong friendid);
    public void BuildBridge(BasePlayer player);
     void DeployPressurePlate(BasePlayer player);
     void DeployPublicPressurePlate(BasePlayer player);
     object CanBuild(Planner plan, Construction prefab, object obj);
    private object OnEntityGroundMissing(BaseEntity entity);
    private void OnEntityKill(BaseNetworkable networkable);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
     object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount);
     bool StandingOnBridge(BasePlayer player);
     void UseLocalBridge(BasePlayer player, bool setangle, float rotationx);
     void SetRampLocalBridge(BasePlayer player, bool setangle, float rotationx);
     void RotateLocalBridge(BasePlayer player);
     void InvertLocalBridge(BasePlayer player);
     void LockLocalBridge(BasePlayer player);
     void DestroyLocalBridge(BasePlayer player);
     void AddPlayerID(ulong ownerid);
     void RemovePlayerID(ulong ownerid);
    static void DestroyAll();
    [ChatCommand("bridge.help")]
     void cmdBridgeHelp(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.build")]
     void cmdBridgeBuild(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.use")]
     void cmdBridgeUse(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.setplate")]
     void cmdSetPressurePlate(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.setpublicplate")]
     void cmdSetPublicPressurePlate(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.setramp")]
     void cmdBridgeSetRamp(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.lock")]
     void cmdBridgeLock(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.invert")]
     void cmdBridgeInvert(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.rotate")]
     void cmdBridgeRotate(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.destroy")]
     void cmdBridgeDestroy(BasePlayer player, string command, string[] args);
    [ChatCommand("bridge.count")]
     void cmdChatBridgeCount(BasePlayer player, string command, string[] args);
     class BridgeEntity : BaseEntity
    {
         BaseEntity entity;
        public BaseEntity floor1;
        public BaseEntity floor2;
        public BaseEntity hinge;
         BaseEntity plate;
         BaseEntity pplate;
         BuildingBlock floor1block;
         BuildingBlock floor2block;
         BuildingBlock blockentity;
         Vector3 entitypos;
         Quaternion entityrot;
         bool isup;
        public bool isfloor;
        public bool islocked;
         ulong ownerid;
         float secsToTake;
         float secsTaken;
         Vector3 startRot;
         Vector3 endRot;
        public bool isRotating;
         bool triggered;
         int counter;
         SphereCollider sphereCollider;
         string prefabfloor;
         string prefabhinge;
         string prefabwall;
         void Awake();
        public void Activate(bool setangle, float rotationx);
        public void ActivateDown(float rotationx);
        public void ActivateUp(float rotationx);
         void SpawnPos();
         void SpawnRefresh(BaseNetworkable entity1);
         void ClntDstry(BaseNetworkable entity, bool recursive);
         void EnttSnpsht(BaseNetworkable entity, bool recursive);
        public void RefreshFloor();
         void ResetAnimationSound();
        public void SpawnPressurePlate();
        public void SpawnPublicPressurePlate();
        public void TogglePressurePlate();
        public void TogglePublicPressurePlate();
        private void OnTriggerEnter(Collider col);
         void FixedUpdate();
        public void OnDestroy();
    }

}

public class PlayerBridgeData
{
    public BasePlayer player;
    public int bridgecount;
}

 class BridgeEntity : BaseEntity
{
     BaseEntity entity;
    public BaseEntity floor1;
    public BaseEntity floor2;
    public BaseEntity hinge;
     BaseEntity plate;
     BaseEntity pplate;
     BuildingBlock floor1block;
     BuildingBlock floor2block;
     BuildingBlock blockentity;
     Vector3 entitypos;
     Quaternion entityrot;
     bool isup;
    public bool isfloor;
    public bool islocked;
     ulong ownerid;
     float secsToTake;
     float secsTaken;
     Vector3 startRot;
     Vector3 endRot;
    public bool isRotating;
     bool triggered;
     int counter;
     SphereCollider sphereCollider;
     string prefabfloor;
     string prefabhinge;
     string prefabwall;
     void Awake();
    public void Activate(bool setangle, float rotationx);
    public void ActivateDown(float rotationx);
    public void ActivateUp(float rotationx);
     void SpawnPos();
     void SpawnRefresh(BaseNetworkable entity1);
     void ClntDstry(BaseNetworkable entity, bool recursive);
     void EnttSnpsht(BaseNetworkable entity, bool recursive);
    public void RefreshFloor();
     void ResetAnimationSound();
    public void SpawnPressurePlate();
    public void SpawnPublicPressurePlate();
    public void TogglePressurePlate();
    public void TogglePublicPressurePlate();
    private void OnTriggerEnter(Collider col);
     void FixedUpdate();
    public void OnDestroy();
}


```

---

## DropBlocker

```csharp
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("Drop Blocker", "Krava", 1.1)]
[Description("Anti drop items at the craft.")]
public class DropBlocker : RustPlugin
{
    private class TempData
    {
        public int Uid { get; set; }
        public int Amount { get; set; }
        public int Stack { get; set; }
    }

    private void Loaded();
    private void Merge(ItemCraftTask task, List<TempData> data);
    private bool CanCraft(BasePlayer player, ItemCraftTask task);
    private void OnItemCraft(ItemCraftTask task, BasePlayer player);
    private string GetMessage(string name, string sid);
}

private class TempData
{
    public int Uid { get; set; }
    public int Amount { get; set; }
    public int Stack { get; set; }
}


```

---

## DropCars

```csharp
using System.Collections.Generic;
using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("DropCars", "TopPlugin.ru", "1.0.4")]
public class DropCars : RustPlugin
{
    private ConfigData cfg { get; set; }
    private class ConfigData
    {
        [JsonProperty("Список флаеров призыва")]
        public List<FlareList> listFlare;
        [JsonProperty("Высота полёта")]
        public float height;
        [JsonProperty("Скорость самолета")]
        public float speed;
        [JsonProperty("Заменить дефолтный вызов на вызов с самолета(Будут работать ток те которые есть во флаерах)")]
        public bool defaultSpawn;
        public static ConfigData GetNewConf();
    }

    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadConfig();
    [ConsoleCommand("give.flare")]
     void ConsCommad(ConsoleSystem.Arg arg);
     class FlareList
    {
        [JsonProperty("СкинАйди")]
        public ulong SkinId;
        [JsonProperty("Название в инвентаре")]
        public string DisplayName;
        [JsonProperty("Префаб")]
        public string PrefabName;
        [JsonProperty("Ящики в который будет появляться(Ящик и шанс)")]
        public Dictionary<string, float> _crateList;
        [JsonProperty("Минимум выпадает")]
        public int Min;
        [JsonProperty("Максимум выпадает")]
        public int Max;
    }

    public static DropCars ins;
     void Init();
    [PluginReference]
    private Plugin CustomSkinsStacksFix;
    private Item OnItemSplit(Item item, int amount);
    private object CanCombineDroppedItem(WorldItem first, WorldItem second);
     object CanStackItem(Item item, Item targetItem);
     object OnLootSpawn(LootContainer container);
     object OnServerCommand(ConsoleSystem.Arg arg);
     void OnExplosiveThrown(BasePlayer player, BaseEntity entity, ThrownWeapon item);
     void OnExplosiveDropped(BasePlayer player, BaseEntity entity, ThrownWeapon item);
     class Parachute : BaseEntity
    {
        private BaseEntity _entity;
        private BaseEntity parachute;
        private void Awake();
        public void RemoveParachute();
        private void OnTriggerEnter(Collider other);
    }

     class DropCar : MonoBehaviour
    {
        public string PrefabName;
        private CargoPlane _cargoPlane;
        private BaseEntity parachute;
        private BaseEntity _entity;
        private void Awake();
        private void OnDestroy();
        private void Update();
    }

}

private class ConfigData
{
    [JsonProperty("Список флаеров призыва")]
    public List<FlareList> listFlare;
    [JsonProperty("Высота полёта")]
    public float height;
    [JsonProperty("Скорость самолета")]
    public float speed;
    [JsonProperty("Заменить дефолтный вызов на вызов с самолета(Будут работать ток те которые есть во флаерах)")]
    public bool defaultSpawn;
    public static ConfigData GetNewConf();
}

 class FlareList
{
    [JsonProperty("СкинАйди")]
    public ulong SkinId;
    [JsonProperty("Название в инвентаре")]
    public string DisplayName;
    [JsonProperty("Префаб")]
    public string PrefabName;
    [JsonProperty("Ящики в который будет появляться(Ящик и шанс)")]
    public Dictionary<string, float> _crateList;
    [JsonProperty("Минимум выпадает")]
    public int Min;
    [JsonProperty("Максимум выпадает")]
    public int Max;
}

 class Parachute : BaseEntity
{
    private BaseEntity _entity;
    private BaseEntity parachute;
    private void Awake();
    public void RemoveParachute();
    private void OnTriggerEnter(Collider other);
}

 class DropCar : MonoBehaviour
{
    public string PrefabName;
    private CargoPlane _cargoPlane;
    private BaseEntity parachute;
    private BaseEntity _entity;
    private void Awake();
    private void OnDestroy();
    private void Update();
}


```

---

## Duel

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info("Duel", "RustPlugin.ru", "4.2.0")]
[Description("Automatic Duel (Bets) with GUI, weapons list, auto-created arenas, save players loot and position")]
 class Duel : RustPlugin
{
     string notAllowed;
     string duelCommand;
     string dontHaveRequest;
     string notFoundPlayer;
     string alreadyHaveDuel;
     string youOnDuel;
     string noArenas;
     string noBuildAcess;
     string cooldownMessage;
     string createRequest;
     string receiveRequest;
     string youDontHaveRequest;
     string cantCancelDuel;
    static string duelHasBeenCancelled;
    static string duelStart;
    static string playerNotFound;
    static string foundMultiplePlayers;
    static string guiChooseWeapon;
    static string guiYourChoose;
    static string guiWaitForOpponentChoose;
    static string guiOpponentsWeapon;
    static string guiStartAboutToBegin;
    static string guiSurrenderButton;
    static string guiAutoCloseSec;
    static string guiPlayerSleep;
     string statLoss;
     string statWin;
     string notificationAboutWin;
     string cantBuild;
     string cantUseRecycle;
     string cantUseNexusKits;
     string cantTrade;
     string cantRemove;
     string cantTp;
     string cantUseKit;
     string cantUseCommand;
     string cantUseBackPack;
     string cantUseSkins;
     string cantUseKill;
     string yourStat;
     string emptyTop;
     string topWin;
     string topTeamWin;
     string topLosses;
     string topTeamLoss;
     string playerInTop;
    static string returnPlayerReason;
    static string returnReasonSleep;
    static string returnReasonGUIFail;
    static string returnReasonLimitTime;
    static string returnReasonDisconnect;
    static string returnReasonSurrender;
    static string returnReasonUnload;
    static string teamDuelCancelled;
    static string teamPlayerDisconnect;
    static string teamWinRed;
    static string teamWinBlue;
    static string teamDuellerWounded;
    static string teamArensBusy;
    static string teamCooldownToCreate;
    static string teamAlreadyCreated;
    static string teamCreatedPermPref;
    static string teamSucessCreated;
    static string teamCancelDuel;
    static string teamNotOwner;
    static string teamNoSlotsBlue;
    static string teamNoSlotsRed;
    static string teamJoinPermPref;
    static string teamJoinRedPref;
    static string teamJoinBluePref;
    static string teamAboutToBegin;
    static string teamJoinAboutToBeginAnnounce;
    static string teamJoinAnnounce;
    static string teamPlayerWont;
    static string teamErrorNoCommand;
    static string teamAlreadyRequest;
    static string teamAlreadyStarted;
    static string teamNoPerm;
    static string teamSucessRequest;
    static string teamNewRequest;
    static string teamNoDuelsHowCreate;
    static string teamGuiWeapons;
    static string teamGuiNoWeapon;
    static string teamGuiBluePlayerColor;
    static string teamGuiRedPlayerColor;
    static string teamGuiWeaponColor;
    static string teamGuiWaiting;
    static string teamDamageTeammate;
    static string teamDeath;
    static float teamDuelRequestSecToClose;
     float cooldownTeamDuelCreate;
     float cooldownRequestSec;
    static float requestSecToClose;
    static float duelMaxSec;
    static float chooseWeaponMaxSec;
    static float teamChooseWeaponMaxSec;
     int maxWinsTop;
     int maxLoseTop;
    static bool debug;
    [PluginReference]
     Plugin Trade;
    static string duelJoinPermission;
    static string duelCreatePermission;
    private readonly int triggerLayer;
     bool isIni;
    static FieldInfo buildingPrivlidges;
    private MethodInfo newbuildingid;
    static List<ActiveDuel> createdDuels;
    static List<TeamDuel> createdTeamDuels;
    static List<ulong?> toRemoveCorpse;
     Dictionary<ulong, float> lastRequestTime;
     Dictionary<ulong, float> lastTeamDuelCreateTime;
    static Dictionary<string, ulong> Wears;
    static Dictionary<string, ulong> WearsBlue;
    static Dictionary<string, ulong> WearsRed;
    private List<BaseEntity> ArenaEntities;
    [PluginReference]
     Plugin NoEscape;
     bool IsRaidBlock(BasePlayer player);
    [ChatCommand("duel")]
     void chatduel(BasePlayer player, string command, string[] arg);
     bool IsArenaZone(Vector3 pos);
     void RemoveGarbage(BaseEntity entity);
     bool NeedToRemoveFromTeamDuel(ulong? userid);
     ActiveDuel PlayersActiveDuel(ulong? userid);
     bool NeedToRemoveGarbage(ulong? userid);
     bool IsDuelPlayer(BasePlayer player);
     bool IsPlayerOnActiveDuel(BasePlayer player);
     string CanDuel(BasePlayer player);
     bool canAcceptRequest(BasePlayer player);
     bool CanCreateDuel(BasePlayer player, bool isTeamDuel);
     void CreateRequest(BasePlayer starter, BasePlayer opponent);
     void AcceptRequest(BasePlayer player);
    public void CancelRequest(BasePlayer player);
    static ActiveDuel FindDuelByPlayer(BasePlayer player);
    public void EndDuel(BasePlayer player, int reason, string UserId, string UserIdLoss);
     class TeamDuel : MonoBehaviour
    {
        public List<DuelPlayer> teamblue;
        public List<DuelPlayer> teamred;
        public List<DuelPlayer> allPlayers;
        public List<BasePlayer> statTeamBlue;
        public List<BasePlayer> statTeamRed;
        public Dictionary<BasePlayer, string> requestPlayers;
        public BasePlayer owner;
        public Arena arena;
        public bool isRequest;
        public bool isStarted;
        public bool needCheckStart;
        public bool isActive;
        public bool allHere;
        public bool allReady;
        public bool isPermDuel;
        public bool randomWeaponsHasGiven;
        public float guiTime;
        public int playersAmount;
        public float startTime;
        public float requestTime;
        public float lastTimeMessage;
        public List<Item> droppedWeapons;
         void Awake();
        public void CheckOnline();
         void Update();
        public void CheckDuellers();
        public void PrepareDuellers();
        public void StartTeamDuel();
        public void RequestRemove();
        public void EndTeamDuelWithWinners();
        public void EndTeamDuel(int reason);
        public void Destroy();
    }

    public static void SetSpawns();
    public static Arena FindFreeTeamDuelArena(int slot);
     void createTeamDuel(BasePlayer player, int amount, bool perm);
     void AcceptRequestTeamDuel(BasePlayer owner, BasePlayer target);
     void JoinTeamDuel(BasePlayer player, string team);
     class ActiveDuel : MonoBehaviour
    {
        public DuelPlayer player1;
        public DuelPlayer player2;
        public bool isStarted;
        public bool aboutToStart;
        public bool isRequest;
        public bool isEnd;
        public bool bothReady;
        public float startTime;
        public float requestTime;
        public float guiTimeToRandom;
        public float timeWhenTp;
        public Arena arena;
        public List<Item> dropedWeapons;
         void Awake();
         void Update();
        public void RequestRemove();
        public void TimerToStart();
        public void StartDuel();
        public void EndDuel(int reason);
        public void Destroy();
    }

     class DuelPlayer : MonoBehaviour
    {
        public BasePlayer player;
        public float health;
        public float calories;
        public float hydration;
        public float readyTime;
        public bool savedInventory;
        public bool savedHome;
        public bool canMove;
        public bool guiEnabled;
        public bool guiMouseEnabled;
        public bool haveweapon;
        public bool induel;
        public bool readyForBattle;
        public bool canDoSomeThings;
        public bool isDeath;
        public bool isTeamDuel;
        public bool isReturned;
        public bool isReady;
        public string currentClass;
        public string weapon;
        public string team;
        public Vector3 Home;
        public Vector3 spawnPos;
         void Awake();
        public void StopMove();
        public void UpdateGUI();
        private ActiveDuel DuellerArena();
        public void Stopper();
        public void PrepairToDuel();
        public void ReturnWithCooldown();
        public void ReturnPlayer(int reason);
        public void SendChatMessage(int reason);
        public void Destroy();
        public void CheckReady();
        public void SaveHealth();
        public void SaveHome();
        public void SavePlayer(BasePlayer player);
        public void TeleportHome();
         class PlayerInfo
        {
            public bool RestoreOnce;
            public List<SavedItem> Items;
        }

        static Dictionary<ulong, PlayerInfo> cachedInventories;
         bool SaveInventory(BasePlayer player);
         List<SavedItem> GetPlayerItems(BasePlayer player);
         SavedItem ProcessItem(Item item, string container);
         bool RestoreInventory(BasePlayer player);
         void GiveItem(BasePlayer player, Item item, string container);
         Item BuildItem(SavedItem sItem);
         Item BuildWeapon(SavedItem sItem);
    }

     class SavedItem
    {
        public string shortname;
        public int itemid;
        public string container;
        public float condition;
        public int amount;
        public int ammoamount;
        public string ammotype;
        public int flamefuel;
        public ulong skinid;
        public bool weapon;
        public int blueprint;
        public List<SavedItem> mods;
    }

     bool HavePerm(string permis, ulong userID);
    public static BasePlayer FindPlayersSingle(string nameOrIdOrIp, BasePlayer player);
    public static HashSet<BasePlayer> FindPlayers(string nameOrIdOrIp);
    static void TPPlayer(BasePlayer player, Vector3 destination);
    static void StartSleeping(BasePlayer player);
    static DuelPlayer FindOpponent(BasePlayer player);
    [ConsoleCommand("duel")]
     void ccmdremove(ConsoleSystem.Arg arg);
    static void WeaponsGUI(BasePlayer player);
     void OnPlayerRespawned(BasePlayer player);
     object OnEntityTakeDamage(BaseCombatEntity victim, HitInfo hitInfo);
     void OnEntityDeath(BaseEntity entity, HitInfo hitinfo);
     void OnEntitySpawned(BaseEntity entity);
     void Unload();
     void OnPlayerDisconnected(BasePlayer player);
    private object CanBuild(Planner plan, Construction prefab);
    private object canRemove(BasePlayer player);
    private object CanTrade(BasePlayer player);
    private object BackpackItem(BasePlayer player);
    private object ConsoleAlias(BasePlayer player);
    private object CanTeleport(BasePlayer player);
    private object inDuel(BasePlayer player);
    private object canRedeemKit(BasePlayer player);
    private object OnServerCommand(ConsoleSystem.Arg arg);
    public List<string> Commands;
     object OnPlayerCommand(ConsoleSystem.Arg arg, BasePlayer player);
     void OnServerInitialized();
    public static void GiveRandomWeapon(BasePlayer player);
    public static void GiveWear(BasePlayer player);
    static List<string> weapons;
    public static void GiveAndShowItem(BasePlayer player, string item, int amount, ulong skindid);
    public static void GiveWeapon(BasePlayer player);
     class StoredData
    {
        public Dictionary<ulong, Stat> playerStat;
        public StoredData();
    }

    static StoredData db;
     class Stat
    {
        public string name;
        public int wins;
        public int losses;
        public int teamwins;
        public int teamloss;
    }

    public static void newStat(BasePlayer player);
     void SaveData();
     void OnServerSave();
     void showStat(BasePlayer player);
     void showTop(BasePlayer player);
    public class Arena
    {
        public string name;
        public Vector3 player1pos;
        public Vector3 player2pos;
        public Vector3 pos;
        public List<Vector3> teamblueSpawns;
        public List<Vector3> teamredSpawns;
    }

     Arena FreeArena();
    static List<Arena> busyArena;
    static List<Arena> arenaList;
     void CreateDuelArena();
     List<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos, float RotationCorrection, bool deployables, bool inventories);
     List<BaseEntity> Paste(List<Dictionary<string, object>> entities, Vector3 startPos, bool checkPlaced);
    public static void Debug(string message);
    public List<DuelStavki> Tops;
    public class DuelStavki
    {
        public DuelStavki(string SteamId, string Win, int item, int kolvo, bool weapon, int patron, string ammotype, int flamefuel);
        public string SteamId { get; set; }
        public string Win { get; set; }
        public int item { get; set; }
        public int kolvo { get; set; }
        public bool weapon { get; set; }
        public int patron { get; set; }
        public string ammotype { get; set; }
        public int flamefuel { get; set; }
    }

    private string box;
    private int slots;
    private float cooldownMinutes;
    private float maxRadius;
    private float pendingSeconds;
    private float radiationMax;
    [PluginReference]
    private Plugin Ignore;
    private Dictionary<string, DateTime> tradeCooldowns;
     class OnlinePlayer
    {
        public BasePlayer Player;
        public StorageContainer View;
        public OpenTrade Trade;
        public PlayerInventory inventory { get; set; }
        public ItemContainer containerMain { get; set; }
        public OnlinePlayer(BasePlayer player);
        public void Clear();
    }

    [OnlinePlayers]
     Hash<BasePlayer, OnlinePlayer> onlinePlayers;
     class OpenTrade
    {
        public OnlinePlayer source;
        public OnlinePlayer target;
        public BasePlayer sourcePlayer { get; set; }
        public BasePlayer targetPlayer { get; set; }
        public bool complete;
        public bool closing;
        public bool sourceAccept;
        public bool targetAccept;
        public OpenTrade(OnlinePlayer source, OnlinePlayer target);
        public OnlinePlayer GetOther(OnlinePlayer onlinePlayer);
        public BasePlayer GetOther(BasePlayer player);
        public void ResetAcceptance();
        public bool IsInventorySufficient();
        public bool IsValid();
        public bool IsSourceValid();
        public bool IsTargetValid();
    }

     class PendingTrade
    {
        public BasePlayer Target;
        public Timer Timer;
        public PendingTrade(BasePlayer target);
        public void Destroy();
    }

     List<OpenTrade> openTrades;
     Dictionary<BasePlayer, PendingTrade> pendingTrades;
     void Init();
     void Loaded();
    protected override void LoadDefaultConfig();
     void CheckConfig();
    protected void ReloadConfig();
     void LoadMessages();
     object CanNetworkTo(BaseNetworkable entity, BasePlayer target);
     void OnPlayerInit(BasePlayer player);
     void OnPlayerLootEnd(PlayerLoot inventory);
     void OnItemAddedToContainer(ItemContainer container, Item item);
     void OnItemRemovedFromContainer(ItemContainer container, Item item);
    [ChatCommand("duels")]
     void cmdTrade(BasePlayer player, string command, string[] args);
    [ConsoleCommand("duels")]
     void ccTrade(ConsoleSystem.Arg arg);
    [ConsoleCommand("duels.decline")]
     void ccTradeDecline(ConsoleSystem.Arg arg);
    [ConsoleCommand("duels.accept")]
     void ccTradeAccept(ConsoleSystem.Arg arg);
    public string jsonTrade;
    private void ShowTrade(BasePlayer player, OpenTrade trade, string status);
    private void HideTrade(BasePlayer player);
     bool CheckCooldown(BasePlayer player);
     void TradeCloseBoxes(OpenTrade trade);
     void TradeReply(OpenTrade trade, string msg, string msg2);
     void ShowTrades(OpenTrade trade, string msg);
     void TradeCooldown(OpenTrade trade);
     void PlayerCooldown(BasePlayer player);
     void FinishTrade(OpenTrade t);
     void AcceptTrade(BasePlayer player);
     void StartTrades(BasePlayer source, BasePlayer target);
     void StartTrade(BasePlayer source, BasePlayer target, OpenTrade trade);
     void OpenBox(BasePlayer player, BaseEntity target);
     void OpenBoxView(BasePlayer player, BaseEntity targArg);
     void CloseBoxView(BasePlayer player, StorageContainer view);
     bool CanPlayerTrade(BasePlayer player, string perm);
    private void SendHelpText(BasePlayer player);
    private bool IsTradeBox(BaseNetworkable entity);
     bool hasAccess(BasePlayer player, string permissionname);
    private BasePlayer FindPlayerByPartialName(string name);
    private T GetConfig(string name, T defaultValue);
    private T GetConfig(string name, string name2, T defaultValue);
     string GetMsg(string key, BasePlayer player);
    private string CleanName(string name);
}

 class TeamDuel : MonoBehaviour
{
    public List<DuelPlayer> teamblue;
    public List<DuelPlayer> teamred;
    public List<DuelPlayer> allPlayers;
    public List<BasePlayer> statTeamBlue;
    public List<BasePlayer> statTeamRed;
    public Dictionary<BasePlayer, string> requestPlayers;
    public BasePlayer owner;
    public Arena arena;
    public bool isRequest;
    public bool isStarted;
    public bool needCheckStart;
    public bool isActive;
    public bool allHere;
    public bool allReady;
    public bool isPermDuel;
    public bool randomWeaponsHasGiven;
    public float guiTime;
    public int playersAmount;
    public float startTime;
    public float requestTime;
    public float lastTimeMessage;
    public List<Item> droppedWeapons;
     void Awake();
    public void CheckOnline();
     void Update();
    public void CheckDuellers();
    public void PrepareDuellers();
    public void StartTeamDuel();
    public void RequestRemove();
    public void EndTeamDuelWithWinners();
    public void EndTeamDuel(int reason);
    public void Destroy();
}

 class ActiveDuel : MonoBehaviour
{
    public DuelPlayer player1;
    public DuelPlayer player2;
    public bool isStarted;
    public bool aboutToStart;
    public bool isRequest;
    public bool isEnd;
    public bool bothReady;
    public float startTime;
    public float requestTime;
    public float guiTimeToRandom;
    public float timeWhenTp;
    public Arena arena;
    public List<Item> dropedWeapons;
     void Awake();
     void Update();
    public void RequestRemove();
    public void TimerToStart();
    public void StartDuel();
    public void EndDuel(int reason);
    public void Destroy();
}

 class DuelPlayer : MonoBehaviour
{
    public BasePlayer player;
    public float health;
    public float calories;
    public float hydration;
    public float readyTime;
    public bool savedInventory;
    public bool savedHome;
    public bool canMove;
    public bool guiEnabled;
    public bool guiMouseEnabled;
    public bool haveweapon;
    public bool induel;
    public bool readyForBattle;
    public bool canDoSomeThings;
    public bool isDeath;
    public bool isTeamDuel;
    public bool isReturned;
    public bool isReady;
    public string currentClass;
    public string weapon;
    public string team;
    public Vector3 Home;
    public Vector3 spawnPos;
     void Awake();
    public void StopMove();
    public void UpdateGUI();
    private ActiveDuel DuellerArena();
    public void Stopper();
    public void PrepairToDuel();
    public void ReturnWithCooldown();
    public void ReturnPlayer(int reason);
    public void SendChatMessage(int reason);
    public void Destroy();
    public void CheckReady();
    public void SaveHealth();
    public void SaveHome();
    public void SavePlayer(BasePlayer player);
    public void TeleportHome();
     class PlayerInfo
    {
        public bool RestoreOnce;
        public List<SavedItem> Items;
    }

    static Dictionary<ulong, PlayerInfo> cachedInventories;
     bool SaveInventory(BasePlayer player);
     List<SavedItem> GetPlayerItems(BasePlayer player);
     SavedItem ProcessItem(Item item, string container);
     bool RestoreInventory(BasePlayer player);
     void GiveItem(BasePlayer player, Item item, string container);
     Item BuildItem(SavedItem sItem);
     Item BuildWeapon(SavedItem sItem);
}

 class PlayerInfo
{
    public bool RestoreOnce;
    public List<SavedItem> Items;
}

 class SavedItem
{
    public string shortname;
    public int itemid;
    public string container;
    public float condition;
    public int amount;
    public int ammoamount;
    public string ammotype;
    public int flamefuel;
    public ulong skinid;
    public bool weapon;
    public int blueprint;
    public List<SavedItem> mods;
}

 class StoredData
{
    public Dictionary<ulong, Stat> playerStat;
    public StoredData();
}

 class Stat
{
    public string name;
    public int wins;
    public int losses;
    public int teamwins;
    public int teamloss;
}

public class Arena
{
    public string name;
    public Vector3 player1pos;
    public Vector3 player2pos;
    public Vector3 pos;
    public List<Vector3> teamblueSpawns;
    public List<Vector3> teamredSpawns;
}

public class DuelStavki
{
    public DuelStavki(string SteamId, string Win, int item, int kolvo, bool weapon, int patron, string ammotype, int flamefuel);
    public string SteamId { get; set; }
    public string Win { get; set; }
    public int item { get; set; }
    public int kolvo { get; set; }
    public bool weapon { get; set; }
    public int patron { get; set; }
    public string ammotype { get; set; }
    public int flamefuel { get; set; }
}

 class OnlinePlayer
{
    public BasePlayer Player;
    public StorageContainer View;
    public OpenTrade Trade;
    public PlayerInventory inventory { get; set; }
    public ItemContainer containerMain { get; set; }
    public OnlinePlayer(BasePlayer player);
    public void Clear();
}

 class OpenTrade
{
    public OnlinePlayer source;
    public OnlinePlayer target;
    public BasePlayer sourcePlayer { get; set; }
    public BasePlayer targetPlayer { get; set; }
    public bool complete;
    public bool closing;
    public bool sourceAccept;
    public bool targetAccept;
    public OpenTrade(OnlinePlayer source, OnlinePlayer target);
    public OnlinePlayer GetOther(OnlinePlayer onlinePlayer);
    public BasePlayer GetOther(BasePlayer player);
    public void ResetAcceptance();
    public bool IsInventorySufficient();
    public bool IsValid();
    public bool IsSourceValid();
    public bool IsTargetValid();
}

 class PendingTrade
{
    public BasePlayer Target;
    public Timer Timer;
    public PendingTrade(BasePlayer target);
    public void Destroy();
}


```

---

## DVBuildingUpgrade

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("DVBuildingUpgrade", "ClayMond", "2.0.3")]
public class DVBuildingUpgrade : RustPlugin
{
    private class CurrentGrade
    {
        [JsonProperty("Текущий индекс улучшения")]
        public int Grade;
        [JsonProperty("Время до де-активации")]
        public int DeActivateTime;
        [JsonProperty("Таймер обновления")]
        public Timer DeTimer;
        public void UpdateTime(BasePlayer player, int time);
        public void UpGrade(BasePlayer player, int time);
        public void Activate(BasePlayer player, int grade, int time);
        public void DeActivate(BasePlayer player);
    }

    private const float RefundPercent;
    private static string CONF_RemovePermission;
    private static bool CONF_RemoveActivated;
    private static int CONF_RemoveTime;
    private static int CONF_RemoveDefaultTime;
    private static int CONF_RemoveHitTime;
    private static bool CONF_RemoveGameFriends;
    private static bool CONF_RemoveFriends;
    private static bool CONF_RemoveClans;
    private static bool CONF_RemoveByCup;
    private static bool CONF_BlockRemoveOnRaid;
    private static bool CONF_UpActivated;
    private static string CONF_UpPermission;
    private static bool CONF_BlockUpgradeOnRaid;
    private static bool CONF_EnableOnHit;
    [PluginReference]
     Plugin ImageLibrary;
    private static List<string> CONF_GradeNames;
    public static Dictionary<string, ItemBlueprint> DeployableToBlueprint;
    [PluginReference]
    private Plugin Friends;
    private Plugin Clans;
    private Plugin NoEscape;
    private string Layer;
    private static DVBuildingUpgrade instance;
     Dictionary<uint, double> removeTimers;
    private Dictionary<ulong, CurrentGrade> playerGrades;
    private void OnServerInitialized();
    private void Unload();
    private void SaveData();
    protected override void LoadDefaultConfig();
    private string CanRemove(BasePlayer player, BaseEntity entity);
    private string TryUpgrade(BasePlayer player, BuildingBlock block, CurrentGrade currentGrade);
    private void UpdateTimer(BasePlayer player);
    [ConsoleCommand("building.upgrade")]
     void cmdConsoleUpgrade(ConsoleSystem.Arg arg);
    [ChatCommand("remove")]
    private void cmdChatRemove(BasePlayer player, string command, string[] args);
    [ChatCommand("up")]
    private void cmdChatUpgrade(BasePlayer player, string command, string[] args);
    private void OnEntityBuilt(Planner plan, GameObject go);
     object OnHammerHit(BasePlayer player, HitInfo info);
    private bool HasUpgradePrivilege(BasePlayer player, BaseEntity entity);
     object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade);
    private void RemoveEntity(BasePlayer player, BaseEntity hitEntity);
    private static void RefundEntity(BasePlayer player, BaseEntity entity);
    private CurrentGrade GetPlayerCurrentGrade(BasePlayer player);
    public double GetRaidBlockTime(ulong userID);
    private static string HexToRustFormat(string hex);
    public static string FormatTime(TimeSpan time, int maxSubstr);
    private static string Format(int units, string form1, string form2, string form3);
    private bool GetConfig(string mainMenu, string key, T var);
    private static DateTime epoch;
    private static double CurrTimestamp();
}

private class CurrentGrade
{
    [JsonProperty("Текущий индекс улучшения")]
    public int Grade;
    [JsonProperty("Время до де-активации")]
    public int DeActivateTime;
    [JsonProperty("Таймер обновления")]
    public Timer DeTimer;
    public void UpdateTime(BasePlayer player, int time);
    public void UpGrade(BasePlayer player, int time);
    public void Activate(BasePlayer player, int grade, int time);
    public void DeActivate(BasePlayer player);
}


```

---

## DVMenu

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("DVMenu", "ClayMond", "0.0.5")]
[Description("Спасибо за покупку - by russia-oxide.ru")]
 class DVMenu : RustPlugin
{
    [PluginReference]
     Plugin ImageLibrary;
    private string GetImage(string fileName, ulong skin);
    public bool AddImage(string url, string shortname, ulong skin);
    public List<BasePlayer> IsOpenMenu;
    public List<string> ActiveEvent;
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty("Настройки плагина")]
        public SettingsPlugin SettingPlugin;
        internal class SettingsPlugin
        {
            [JsonProperty("Настройка иконки в панели")]
            public string PNG;
            [JsonProperty("Настройка логотипа в панели")]
            public string Logo;
            [JsonProperty("Командая при нажатие на логотип")]
            public string Bind;
            [JsonProperty("HEX Цвет панели")]
            public string HexColorPanel;
            [JsonProperty("HEX Цвет текста панели")]
            public string TextColorPanel;
            [JsonProperty("Интервал обновления информационной панели")]
            public int IntervalUpdateInfoPanel;
            [JsonProperty("Интервал обновления ивентов")]
            public int IntervalUpdateEvents;
        }

        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    public static string INTERFACE_PARENT_PANEL;
    public static string LOGO_PANEL;
     void OnPlayerConnected(BasePlayer player);
     void UI_Panel_Interface(BasePlayer player);
     void LOGO_UI(BasePlayer player);
    private void OnServerInitialized();
    private static string HexToRustFormat(string hex);
     void LoadImage();
}

private class Configuration
{
    [JsonProperty("Настройки плагина")]
    public SettingsPlugin SettingPlugin;
    internal class SettingsPlugin
    {
        [JsonProperty("Настройка иконки в панели")]
        public string PNG;
        [JsonProperty("Настройка логотипа в панели")]
        public string Logo;
        [JsonProperty("Командая при нажатие на логотип")]
        public string Bind;
        [JsonProperty("HEX Цвет панели")]
        public string HexColorPanel;
        [JsonProperty("HEX Цвет текста панели")]
        public string TextColorPanel;
        [JsonProperty("Интервал обновления информационной панели")]
        public int IntervalUpdateInfoPanel;
        [JsonProperty("Интервал обновления ивентов")]
        public int IntervalUpdateEvents;
    }

    public static Configuration GetNewConfiguration();
}

internal class SettingsPlugin
{
    [JsonProperty("Настройка иконки в панели")]
    public string PNG;
    [JsonProperty("Настройка логотипа в панели")]
    public string Logo;
    [JsonProperty("Командая при нажатие на логотип")]
    public string Bind;
    [JsonProperty("HEX Цвет панели")]
    public string HexColorPanel;
    [JsonProperty("HEX Цвет текста панели")]
    public string TextColorPanel;
    [JsonProperty("Интервал обновления информационной панели")]
    public int IntervalUpdateInfoPanel;
    [JsonProperty("Интервал обновления ивентов")]
    public int IntervalUpdateEvents;
}


```

---

## DVTeleportation

```csharp
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("DVTeleportation", "Sempai#3239", "1.5.0")]
[Description("Спасибо за покупку - by Sempai#3239")]
 class DVTeleportation : RustPlugin
{
    [PluginReference]
     Plugin Clans;
    [PluginReference]
     Plugin Friends;
     Dictionary<ulong, Vector3> lastPositions;
     Dictionary<BasePlayer, int> spectatingPlayers;
     bool IsClanMember(ulong playerid, ulong targetID);
     bool IsFriends(ulong playerID, ulong friendId);
     bool IsTeamate(BasePlayer player, ulong targetID);
     class TP
    {
        public BasePlayer Player;
        public BasePlayer Player2;
        public Vector3 pos;
        public float totalSeconds;
        public bool EnabledShip;
        public int seconds;
        public bool TPL;
        public TP(BasePlayer player, Vector3 Pos, int Seconds, bool EnabledShip1, bool tpl, BasePlayer player2);
    }

    const string TPADMIN;
     int homelimitDefault;
     Dictionary<string, int> homelimitPerms;
     int tpkdDefault;
     Dictionary<string, int> tpkdPerms;
     int tpkdhomeDefault;
     Dictionary<string, int> tpkdhomePerms;
     int teleportSecsDefault;
     int resetPendingTime;
     bool restrictCupboard;
     bool enabledTPR;
     bool homecupboard;
     bool homecupboardblock;
     bool adminsLogs;
     bool foundationOwner;
     bool foundationOwnerFC;
     bool restrictTPRCupboard;
     bool foundationEx;
     bool wipedData;
     bool createSleepingBug;
     string EffectPrefab1;
     string EffectPrefab;
     bool EnabledShipTP;
     bool EnabledBallonTP;
     bool CancelTPMetabolism;
     bool CancelTPCold;
     bool CancelTPRadiation;
     bool FriendsEnabled;
     bool CancelTPWounded;
     bool EnabledTPLForPlayers;
     int TPLCooldown;
     int TplPedingTime;
     bool TPLAdmin;
     string AutoTPAPermission;
    static DynamicConfigFile config;
     Dictionary<string, int> teleportSecsPerms;
     void OnNewSave();
     void WipeData();
    protected override void LoadDefaultConfig();
     T GetConfig(string name, T defaultValue);
    public static void GetVariable(DynamicConfigFile config, string name, T value, T defaultValue);
    public static class PermissionService
    {
        public static Permission permission;
        public static bool HasPermission(ulong uid, string permissionName);
        public static void RegisterPermissions(Plugin owner, List<string> permissions);
    }

    public BasePlayer FindBasePlayer(string nameOrUserId);
     Dictionary<ulong, Dictionary<string, Vector3>> homes;
     List<TPList> tpsave;
     class TPList
    {
        public string Name;
        public Vector3 pos;
    }

     Dictionary<ulong, int> cooldownsTP;
     Dictionary<ulong, int> cooldownsHOME;
     List<TP> tpQueue;
     List<TP> pendings;
     List<ulong> sethomeBlock;
    [ChatCommand("sethome")]
     void cmdChatSetHome(BasePlayer player, string command, string[] args);
    [ChatCommand("removehome")]
     void cmdChatRemoveHome(BasePlayer player, string command, string[] args);
    [ConsoleCommand("home")]
     void cmdHome(ConsoleSystem.Arg arg);
    [ChatCommand("homelist")]
    private void cmdHomeList(BasePlayer player, string command, string[] args);
    [ChatCommand("home")]
     void cmdChatHome(BasePlayer player, string command, string[] args);
    [ChatCommand("tpr")]
     void cmdChatTpr(BasePlayer player, string command, string[] args);
    [ChatCommand("tpa")]
     void cmdChatTpa(BasePlayer player, string command, string[] args);
    [ChatCommand("tpc")]
     void cmdChatTpc(BasePlayer player, string command, string[] args);
     void SpectateFinish(BasePlayer player);
    private void OnUserConnected(IPlayer player);
    private void OnUserDisconnected(IPlayer player);
    private void ResetSpectate(IPlayer player);
     object OnPlayerSpectateEnd(BasePlayer player, string spectateFilter);
    [ChatCommand("tpl")]
     void cmdChattpGo(BasePlayer player, string command, string[] args);
    [ChatCommand("tpspec")]
     void cmdTPSpec(BasePlayer player, string command, string[] args);
    [ChatCommand("tp")]
     void cmdTP(BasePlayer player, string command, string[] args);
    [ConsoleCommand("home.wipe")]
    private void CmdTest(ConsoleSystem.Arg arg);
    public string TimeToString(double time);
     void OnPlayerDisconnected(BasePlayer player);
     void Loaded();
     void OnServerInitialized();
     void OnServerSave();
     void Unload();
     void OnEntityBuilt(Planner planner, GameObject gameobject);
     object OnEntityTakeDamage(BasePlayer player, HitInfo info);
    [PluginReference]
     Plugin Duel;
     bool InDuel(BasePlayer player);
     void DVTeleportationTimerHandle();
     void SetTpSave(BasePlayer player, string name);
    private readonly int blockLayer;
    private bool ValidBlock(BaseEntity entity, Vector3 position);
    private List<BuildingBlock> GetFoundation(Vector3 position);
     void SetHome(BasePlayer player, string name, Vector3 pos);
    private bool CheckInsideInFoundation(Vector3 position);
     int GetKDHome(ulong uid);
     int GetKD(ulong uid);
     int GetHomeLimit(ulong uid);
     int GetTeleportTime(ulong uid);
     BaseEntity GetBuldings(Vector3 pos);
     SleepingBag GetSleepingBag(string name, Vector3 pos);
     void CreateSleepingBag(BasePlayer player, Vector3 pos, string name);
     Dictionary<string, Vector3> GetHomes(ulong uid);
    public void Teleport(BasePlayer player, BasePlayer target);
    public void Teleport(BasePlayer player, float x, float y, float z);
    public void Teleport(BasePlayer player, Vector3 position);
     DynamicConfigFile homesFile;
     DynamicConfigFile tpsaveFile;
    public Dictionary<ulong, AutoTPASettings> AutoTPA;
    public class AutoTPASettings
    {
        public bool Enabled;
        public Dictionary<string, ulong> PlayersList;
    }

     void LoadData();
     void SaveData();
     Dictionary<string, string> Messages;
     void CreateUpdateUI(BasePlayer player, DVTeleportation.TP teleport, string langMessage);
    private string GetFormatTime(TimeSpan timespan);
    public static string PARENT_TELEPORT;
     void DVTeleportationAcceptUI(BasePlayer target, string TprName);
    private static string HexToRustFormat(string hex);
}

 class TP
{
    public BasePlayer Player;
    public BasePlayer Player2;
    public Vector3 pos;
    public float totalSeconds;
    public bool EnabledShip;
    public int seconds;
    public bool TPL;
    public TP(BasePlayer player, Vector3 Pos, int Seconds, bool EnabledShip1, bool tpl, BasePlayer player2);
}

public static class PermissionService
{
    public static Permission permission;
    public static bool HasPermission(ulong uid, string permissionName);
    public static void RegisterPermissions(Plugin owner, List<string> permissions);
}

 class TPList
{
    public string Name;
    public Vector3 pos;
}

public class AutoTPASettings
{
    public bool Enabled;
    public Dictionary<string, ulong> PlayersList;
}


```

---

## DynamicCupShare

```csharp
using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using ProtoBuf;
using Facepunch;
using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries.Covalence;

Oxide.Plugins
[Info("DynamicCupShare", "FuJiCuRa", "2.7.2", ResourceId = 20)]
[Description("Dynamic sharing of cupboards/doors/boxes/lockers/turrets/quarries")]
internal class DynamicCupShare : RustPlugin
{
    [PluginReference]
    private Plugin Clans;
    private Plugin Friends;
    private static DynamicCupShare Instance { get; set; }
    private bool Changed;
    private bool Initialized;
    private bool clansEnabled;
    private bool friendsEnabled;
    private bool friendsAPIEnabled;
    private bool pluginDisabled;
    private List<ulong> usdCnslInpt;
    private Hash<ulong, bool> adminAccessEnabled;
    private Hash<ulong, List<uint>> adminCupboards;
    private Hash<ulong, List<uint>> adminTurrets;
    private StoredData playerPrefs;
    private Dictionary<string, List<uint>> playerCupboards;
    private Dictionary<string, List<uint>> playerTurrets;
    private List<object> pseudoAdminPerms;
    private List<string> pseudoPerms;
    [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
    private class StoredData
    {
        public Dictionary<ulong, PlayerInfo> PlayerInfo;
        public int saveStamp;
        public string lastStorage;
        public StoredData();
    }

    [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
    internal class PlayerInfo
    {
        public bool CS;
        public bool DS;
        public bool BS;
        public bool TS;
        public bool LS;
        public bool QS;
        public bool AA;
        public bool CCS;
        public bool CDS;
        public bool CBS;
        public bool CLS;
        public bool CQS;
        public bool CTS;
        [JsonIgnore]
        [ProtoIgnore]
        public bool CanAutoAuth;
        [JsonIgnore]
        [ProtoIgnore]
        public bool HasClanShare;
        [JsonIgnore]
        [ProtoIgnore]
        public bool HasFriendShare;
        [JsonIgnore]
        [ProtoIgnore]
        public BuildingPrivilegeHandler BPH;
        public PlayerInfo();
    }

    private int UnixTimeStampUTC();
    private string shareCommand;
    private bool useFriendsApi;
    private bool useClans;
    private bool useProtostorageUserdata;
    private bool blockCupClearClanMembers;
    private bool blockCupAccessNotSameClan;
    private bool blockCupClearFriends;
    private bool allowLaddersIntoBlocked;
    private bool allowTwigIntoBlocked;
    private bool notifyPlayersBeingBlocked;
    private bool allowIcebergBuilding;
    private bool allowIcesheetBuilding;
    private bool allowIcelakeBuilding;
    private string permGetClanShares;
    private bool usePermGetClanShares;
    private string permGetFriendShares;
    private bool usePermGetFriendShares;
    private string permAutoAuth;
    private bool usePermAutoAuth;
    private bool clanTurretShareOverride;
    private bool includeFlameTurrets;
    private bool includeGunTraps;
    private bool includeSamSites;
    private bool samSiteShootEmptyVehicles;
    private bool enableCupSharing;
    private bool enableDoorSharing;
    private bool enableBoxSharing;
    private bool enableLockerSharing;
    private bool enableTurretSharing;
    private bool enableAutoAuth;
    private bool enableQuarrySharing;
    private bool enableQuarrySwitchCheck;
    private bool notifyAuthCupboard;
    private bool notifyAuthTurret;
    private bool CupShare;
    private bool DoorShare;
    private bool TurretShare;
    private bool BoxShare;
    private bool LockerShare;
    private bool QuarryShare;
    private bool AutoAuth;
    private bool ClanCupShare;
    private bool ClanDoorShare;
    private bool ClanBoxShare;
    private bool ClanLockerShare;
    private bool ClanTurretShare;
    private bool ClanQuarryShare;
    private bool toggleCupShare;
    private bool toggleDoorShare;
    private bool toggleTurretShare;
    private bool toggleBoxShare;
    private bool toggleLockerShare;
    private bool toggleQuarryShare;
    private bool toggleAutoAuth;
    private bool toggleClanCupShare;
    private bool toggleClanDoorShare;
    private bool toggleClanBoxShare;
    private bool toggleClanLockerShare;
    private bool toggleClanQuarryShare;
    private bool toggleClanTurretShare;
    private bool adminsRemainCupAuthed;
    private bool adminsRemainTurretAuthed;
    private bool enableAdminmodeAtLogin;
    private int cupboardAuthMaxUsers;
    private string pluginPrefix;
    private string prefixColor;
    private string prefixFormat;
    private string colorTextMsg;
    private string colorCmdUsage;
    private string colorON;
    private string colorOFF;
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private void LoadVariables();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void Init();
    private void LdPlyrDt();
    private void SaveData();
    private void Loaded();
    private void OnServerInitialized();
    private void Initialize();
    private bool GetAdmin(BasePlayer player);
    private bool AccessOn(ulong id);
    private PlayerInfo SetPlayer(BasePlayer player);
    private bool IsPsdAdmn(string id);
    private void OnUserPermissionGranted(string id, string perm);
    private PlayerInfo AddPlayerData(ulong userID);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void Unload();
    private void OnServerSave();
    private void OnPluginUnloaded(Plugin name);
    private void OnPluginLoaded(Plugin name);
    private object CanBuild(Planner plan, Construction prefab, Construction.Target target);
    private void OnFriendAdded(string playerId, string friendId, bool isCup, bool isTurret);
    private IEnumerator CoFrndAddd(string playerId, string friendId, bool isCup, bool isTurret);
    private void OnFriendRemoved(string playerId, string friendId, bool isCup, bool isTurret);
    private IEnumerator CoFrndRmvd(string playerId, string friendId, bool isCup, bool isTurret);
    private WaitForEndOfFrame wait;
    private IEnumerator ClnMmbrChng(string memberId, List<ulong> clanMembers, bool wasAdded, bool isCup, bool isTurret);
    private void OnClanMemberJoined(string playerId, List<string> clanMembersCall);
    private void OnClanMemberGone(string playerId, List<string> clanMembersCall);
    private void OnClanDisbanded(List<string> clanMembersCall);
    private void CpSttsFrnd(BasePlayer player, bool IsOn);
    private void TrrtSttsFrnd(BasePlayer player, bool IsOn);
    private void CpSttsCln(BasePlayer player, bool IsOn);
    private void TrrtSttsCln(BasePlayer player, bool IsOn);
    private void OnEntityKill(BaseNetworkable entity);
    private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity);
    private object CanBeTargeted(BasePlayer player, FlameTurret turret);
    private object CanBeTargeted(BasePlayer player, GunTrap turret);
    private object CanBeTurretTarget(ulong userID, uint netID, ulong OwnerID);
    private object OnSamSiteTarget(SamSite sam, BaseCombatEntity target);
    private bool HasOccupants(BaseVehicle baseVehicle);
    private bool SamVerificationInternal(ulong ownerId, ulong playerId, Action action);
    private void OnEntityBuilt(Planner planner, GameObject obj);
    private object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player);
    private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player);
    private void CheckCupboardAccess(BasePlayer player, BuildingPrivlidge cup);
    private void OnLootEntity(BasePlayer looter, BaseEntity entity);
    internal class QuarryHandler : FacepunchBehaviour
    {
        private EngineSwitch engine;
        private MiningQuarry quarry;
        private ItemContainer fuelStorage;
        private bool isOn;
        private void Awake();
        private void OnDestroy();
        private bool FuelCheck();
        private void DoUpdate();
    }

    private bool CheckForCQS(ulong ownerID, BasePlayer player);
    private object CanUseLockedEntity(BasePlayer player, KeyLock code);
    private object CanUseLockedEntity(BasePlayer player, CodeLock code);
    private object CanUnlock(CodeLock code, BasePlayer player);
    private object CanLock(CodeLock code, BasePlayer player);
    private bool InAdmMode(BasePlayer player);
    private object UseLock(BasePlayer player, CodeLock code);
    [ConsoleCommand("dynashare.resetdata")]
    private void dataReset(ConsoleSystem.Arg arg);
    private void cShareCommand(ConsoleSystem.Arg arg);
    private void ShareCommand(BasePlayer player, string command, string[] args);
    private void PrintChat(BasePlayer player, string message, bool keepConsole);
    internal class BuildingPrivilegeHandler : FacepunchBehaviour
    {
        private BasePlayer player;
        private ulong userID;
        private BuildingPrivlidge lastPrivilege;
        private uint lastTurretID;
        private object lastTurretResult;
        private void Awake();
        public void Reset();
        public bool SameTurret(uint currentID);
        public object LastResult();
        public void SetTurret(uint currentID, object flag);
        private void Repeater();
        public void DoDestroy();
        private void OnDestroy();
    }

    private void OnPlayerRespawned(BasePlayer player);
    private void OnPlayerInit(BasePlayer player);
    private bool HasFriend(ulong owner, ulong friend);
    private bool HasFriendS(string owner, string friend);
    private bool SameClan(ulong owner, ulong member);
    private bool SameClanS(string owner, string member);
    private void StateDisabled();
    private void StateEnabled();
    private void ClansDisabled();
    private void ClansEnabled();
}

[ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
private class StoredData
{
    public Dictionary<ulong, PlayerInfo> PlayerInfo;
    public int saveStamp;
    public string lastStorage;
    public StoredData();
}

[ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
internal class PlayerInfo
{
    public bool CS;
    public bool DS;
    public bool BS;
    public bool TS;
    public bool LS;
    public bool QS;
    public bool AA;
    public bool CCS;
    public bool CDS;
    public bool CBS;
    public bool CLS;
    public bool CQS;
    public bool CTS;
    [JsonIgnore]
    [ProtoIgnore]
    public bool CanAutoAuth;
    [JsonIgnore]
    [ProtoIgnore]
    public bool HasClanShare;
    [JsonIgnore]
    [ProtoIgnore]
    public bool HasFriendShare;
    [JsonIgnore]
    [ProtoIgnore]
    public BuildingPrivilegeHandler BPH;
    public PlayerInfo();
}

internal class QuarryHandler : FacepunchBehaviour
{
    private EngineSwitch engine;
    private MiningQuarry quarry;
    private ItemContainer fuelStorage;
    private bool isOn;
    private void Awake();
    private void OnDestroy();
    private bool FuelCheck();
    private void DoUpdate();
}

internal class BuildingPrivilegeHandler : FacepunchBehaviour
{
    private BasePlayer player;
    private ulong userID;
    private BuildingPrivlidge lastPrivilege;
    private uint lastTurretID;
    private object lastTurretResult;
    private void Awake();
    public void Reset();
    public bool SameTurret(uint currentID);
    public object LastResult();
    public void SetTurret(uint currentID, object flag);
    private void Repeater();
    public void DoDestroy();
    private void OnDestroy();
}


```

---

## EasyAirdrop

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

Oxide.Plugins
[Info("Easy Airdrop", "LaserHydra", "3.2.2", ResourceId = 860)]
[Description("Easy Airdrop")]
 class EasyAirdrop : RustPlugin
{
     void Loaded();
     void LoadConfig();
     void LoadMessages();
     string msg(string key, string id);
    protected override void LoadDefaultConfig();
    [ConsoleCommand("airdrop")]
     void ccmdAirdrop(ConsoleSystem.Arg arg);
    [ConsoleCommand("massdrop")]
     void ccmdMassdrop(ConsoleSystem.Arg arg);
    [ChatCommand("airdrop")]
     void cmdAirdrop(BasePlayer player, string cmd, string[] args);
    [ChatCommand("massdrop")]
     void cmdMassdrop(BasePlayer player, string cmd, string[] args);
     void SpawnPlayerAirdrop(BasePlayer player, BasePlayer target);
     void SpawnMassdrop(BasePlayer player, int amount);
     void SpawnRandomAirdrop(BasePlayer player);
     void SpawnAirdrop(Vector3 position);
     bool HasPermission(BasePlayer player, string perm);
     Vector3 GetRandomVector();
     void RunAsChatCommand(ConsoleSystem.Arg arg, Action<BasePlayer, string, string[]> command);
     BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix);
     string ListToString(List<string> list, int first, string seperator);
     void SetConfig(object[] args);
     void BroadcastChat(string prefix, string msg);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
     void AnnounceAirdrop(BasePlayer player, Vector3[] locations);
}


```

---

## EasyBroadcast

```csharp
using System.Collections.Generic;
using System.Linq;
using System;

Oxide.Plugins
[Info("Easy Broadcast", "LaserHydra", "2.1.0", ResourceId = 863)]
[Description("Broadcast a message to the server")]
 class EasyBroadcast : RustPlugin
{
     void Loaded();
     void LoadConfig();
    protected override void LoadDefaultConfig();
    [ChatCommand("bcast")]
     void cmdBroadcast(BasePlayer player, string cmd, string[] args);
     string ListToString(List<string> list, int first, string seperator);
     void SetConfig(object[] args);
     void BroadcastChat(string prefix, string msg);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
}


```

---

## EasyFurnace

```csharp
using System.Collections.Generic;
using System.Linq;
using System;

Oxide.Plugins
[Info("EasyFurnace", "oskar3123", "1.1.4", ResourceId = 1191)]
 class EasyFurnace : RustPlugin
{
     class Cfg
    {
        public static double burntime_wood;
        public static double cooktime_hqmetal;
        public static double cooktime_metal;
        public static double cooktime_sulfur;
        public static int furnaceMetalOres;
        public static int furnaceMetalWood;
        public static int furnaceMetalOutput;
        public static int furnaceSulfurOres;
        public static int furnaceSulfurWood;
        public static int furnaceSulfurOutput;
        public static int furnaceHQMetalOres;
        public static int furnaceHQMetalWood;
        public static int furnaceHQMetalOutput;
        public static int largeFurnaceMetalOres;
        public static int largeFurnaceMetalWood;
        public static int largeFurnaceMetalOutput;
        public static int largeFurnaceSulfurOres;
        public static int largeFurnaceSulfurWood;
        public static int largeFurnaceSulfurOutput;
        public static int largeFurnaceHQMetalOres;
        public static int largeFurnaceHQMetalWood;
        public static int largeFurnaceHQMetalOutput;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
     double GetBurntime(ItemDefinition item);
     double GetBurntime(string shortname);
     double GetCooktime(ItemDefinition item);
     double GetCooktime(string shortname);
     int GetStackSize(string shortname);
     int GetStackSize(ItemDefinition item);
     Dictionary<BaseOven, BasePlayer> furnaceCache;
     void OnLootEntity(BasePlayer player, BaseEntity entity);
     int RemoveItemsFromInventory(BasePlayer player, ItemDefinition itemToRemove, int amount);
     int RemoveItemsFromInventory(BasePlayer player, string shortname, int amount);
     void GivePlayerItems(BasePlayer player, ItemDefinition item, int amount);
     void GivePlayerItems(BasePlayer player, string shortname, int amount);
     void OnItemAddedToContainer(ItemContainer container, Item item);
}

 class Cfg
{
    public static double burntime_wood;
    public static double cooktime_hqmetal;
    public static double cooktime_metal;
    public static double cooktime_sulfur;
    public static int furnaceMetalOres;
    public static int furnaceMetalWood;
    public static int furnaceMetalOutput;
    public static int furnaceSulfurOres;
    public static int furnaceSulfurWood;
    public static int furnaceSulfurOutput;
    public static int furnaceHQMetalOres;
    public static int furnaceHQMetalWood;
    public static int furnaceHQMetalOutput;
    public static int largeFurnaceMetalOres;
    public static int largeFurnaceMetalWood;
    public static int largeFurnaceMetalOutput;
    public static int largeFurnaceSulfurOres;
    public static int largeFurnaceSulfurWood;
    public static int largeFurnaceSulfurOutput;
    public static int largeFurnaceHQMetalOres;
    public static int largeFurnaceHQMetalWood;
    public static int largeFurnaceHQMetalOutput;
}


```

---

## EasyHeal

```csharp
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

Oxide.Plugins
[Info("Easy Heal", "LaserHydra", "2.2.0", ResourceId = 984)]
[Description("Heal yourself or others")]
 class EasyHeal : RustPlugin
{
    [ChatCommand("healall")]
     void cmdHealAll(BasePlayer player);
    [ChatCommand("heal")]
     void cmdHeal(BasePlayer player, string cmd, string[] args);
     string[] GetPlayer(string searchedPlayer);
     void BroadcastChat(string prefix, string msg);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
}


```

---

## EasyMute

```csharp
using Oxide.Core;
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Text.RegularExpressions;

Oxide.Plugins
[Info("EasyMute", "4seti [Lunatiq] for Rust Planet", "0.2.0", ResourceId = 730)]
 class EasyMute : RustPlugin
{
    private void Log(string message);
    private void Warn(string message);
    private void Error(string message);
     void ReplyChat(BasePlayer player, string msg);
     void Loaded();
     void Unload();
    private T GetConfig(string name, T defaultValue);
     IDictionary<ulong, Muted> MuteList;
     Oxide.Core.Libraries.Time time;
     string ReplyName;
     string DefaultReason;
    private Dictionary<string, string> Messages;
    private Dictionary<string, string> defMsg;
     void OnServerInitialized();
    protected override void LoadDefaultConfig();
     void LoadVariables();
     object OnPlayerChat(ConsoleSystem.Arg arg);
    private string getUnixTimeToString(uint timeDif);
    private bool stringTimeToUnixTimeStapm(string timeString, uint stamp);
    private List<BasePlayer> FindPlayerByName(string playerName);
    [ChatCommand("mute")]
     void cmdMute(BasePlayer player, string cmd, string[] args);
    [ConsoleCommand("mute")]
     void cmdConsoleMute(ConsoleSystem.Arg arg);
     void DoMute(BasePlayer player, string name, string time, string reasonGiven, bool chat, ConsoleSystem.Arg console);
    [ChatCommand("unmute")]
     void cmdUnMute(BasePlayer player, string cmd, string[] args);
    [ConsoleCommand("unmute")]
     void cmdConsoleUnMute(ConsoleSystem.Arg arg);
     void DoUnmute(BasePlayer player, string name, bool chat, ConsoleSystem.Arg console);
     bool HasPerm(BasePlayer p, string pe);
    [ChatCommand("mutesave")]
     void cmdSave(BasePlayer player, string cmd, string[] args);
    [ChatCommand("mutelist")]
     void cmdList(BasePlayer player, string cmd, string[] args);
    private void LoadData();
     void SaveData();
    private class Muted
    {
        public uint EndTime;
        public string Reason;
        public string Name;
        public string By;
        public Muted(string name, uint endTime, string reason, string by);
    }

}

private class Muted
{
    public uint EndTime;
    public string Reason;
    public string Name;
    public string By;
    public Muted(string name, uint endTime, string reason, string by);
}


```

---

## EasyReload

```csharp
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Rust;

Oxide.Plugins
[Info("Easy Reload", "LaserHydra", "2.0.0", ResourceId = 854)]
[Description("Reload your plugins easily")]
 class EasyReload : RustPlugin
{
     void Loaded();
    [ChatCommand("reload")]
     void cmdReload(BasePlayer player, string cmd, string[] args);
     string GetPlugin(string searchedPlugin, BasePlayer executer, string prefix);
     string GetPluginFile(string pluginname);
     void BroadcastChat(string prefix, string msg);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
}


```

---

## EasyTeams

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("EasyTeams", "Skrallex", "1.1.2")]
[Description("Easily create minigame/pvp teams")]
 class EasyTeams : RustPlugin
{
    const string configVersion;
    [PluginReference]
    static Plugin Kits;
     List<EventSettings> eventSettings;
     StoredData data;
     bool UsePermissionsOnly;
    const string adminPerm;
    const string editPerm;
    const string viewPerm;
    const string startPerm;
    const string stopPerm;
    const string joinPerm;
    const string joinSpecificPerm;
    const string claimPerm;
    public static Event teamEvent;
     System.Random rnd;
     void Loaded();
     void Unload();
    protected override void LoadDefaultConfig();
     string GetConfigVersion();
     void LoadConfig();
     void LoadDefaultMessages();
     void OnPlayerRespawned(BasePlayer player);
     void OnEntityTakeDamage(BaseEntity entity, HitInfo info);
     void OnPlayerDisconnected(BasePlayer player, string reason);
    [ChatCommand("teams")]
     void chatCmdTeams(BasePlayer player, string cmd, string[] args);
    [ChatCommand("teams_save")]
     void chatCmdTeamsSave(BasePlayer player, string cmd, string[] args);
    [ChatCommand("teams_load")]
     void chatCmdTeamsLoad(BasePlayer player, string cmd, string[] args);
     void ListEvents(BasePlayer player);
    [ChatCommand("teams_reload")]
     void chatCmdTeamsReload(BasePlayer player, string cmd, string[] args);
     void Reload(BasePlayer player);
    [ChatCommand("teams_create")]
     void chatCmdTeamsCreate(BasePlayer player, string cmd, string[] args);
     void CreateTeam(BasePlayer player, string teamName);
    [ChatCommand("teams_delete")]
     void chatCmdTeamsDelete(BasePlayer player, string cmd, string[] args);
     void DeleteTeam(BasePlayer player, string teamName);
    [ChatCommand("teams_add")]
     void chatCmdTeamsAdd(BasePlayer player, string cmd, string[] args);
     void AddPlayers(BasePlayer player, string teamName, string[] players);
     void AddPlayer(BasePlayer player, string teamName, string playerName);
    [ChatCommand("teams_remove")]
     void chatCmdTeamsRemove(BasePlayer player, string cmd, string[] args);
     void RemovePlayers(BasePlayer player, string teamName, string[] players);
     void RemovePlayer(BasePlayer player, string teamName, BasePlayer target);
     void RemovePlayer(BasePlayer player, string teamName, string playerName);
    [ChatCommand("teams_view")]
     void chatCmdTeamsView(BasePlayer player, string cmd, string[] args);
     void ViewAll(BasePlayer player);
     void View(BasePlayer player, string teamName);
    [ChatCommand("teams_clear")]
     void chatCmdTeamsClear(BasePlayer player, string cmd, string[] args);
     void Clear(BasePlayer player);
    [ChatCommand("teams_start")]
     void chatCmdTeamsStart(BasePlayer player, string cmd, string[] args);
     void StartEvent(BasePlayer player);
    [ChatCommand("teams_end")]
     void chatCmdTeamsEnd(BasePlayer player, string cmd, string[] args);
    [ChatCommand("teams_stop")]
     void chatCmdTeamsStop(BasePlayer player, string cmd, string[] args);
     void StopEvent(BasePlayer player);
    [ChatCommand("teams_restart")]
     void chatCmdTeamsRestart(BasePlayer player, string cmd, string[] args);
     void RestartEvent(BasePlayer player);
    [ChatCommand("teams_join")]
     void chatCmdTeamsJoin(BasePlayer player, string cmd, string[] args);
     void JoinRandomTeam(BasePlayer player);
     void JoinTeam(BasePlayer player, string teamName);
    [ChatCommand("teams_leave")]
     void chatCmdTeamsLeave(BasePlayer player, string cmd, string[] args);
     void Leave(BasePlayer player);
    [ChatCommand("teams_claim")]
     void chatCmdTeamsClaim(BasePlayer player, string cmd, string[] args);
     void Claim(BasePlayer player);
    [ChatCommand("teams_spectate")]
     void chatCmdTeamsSpectate(BasePlayer player, string cmd, string[] args);
     void Spectate(BasePlayer player, bool enabled);
    [ChatCommand("teams_setspawn")]
     void chatCmdTeamsSetSpawn(BasePlayer player, string cmd, string[] args);
     void SetSpawn(BasePlayer player, string teamName);
    [ChatCommand("teams_setkit")]
     void chatCmdTeamsSetKit(BasePlayer player, string cmd, string[] args);
     void SetKit(BasePlayer player, string teamName, string kitName);
     Event GetTeamEvent();
     void ReplyPlayer(BasePlayer player, string langKey);
     void ReplyFormatted(BasePlayer player, string msg);
     string Lang(string key);
     bool IsAllowed(BasePlayer player, string perm);
     List<BasePlayer> GetPlayersByName(string playerName);
     EventSettings GetEventSettingsByName(string eventName);
     Event GetEventByName(string eventName);
     void SaveEventSettings();
    public class Team
    {
        public string name;
        public string kitname;
        public int teamLives;
        public int usedLives;
        public int maxPlayers;
        public Pos spawnPos;
        public bool spawnSet;
        public bool joinable;
        public List<TeamPlayer> players;
        public void SetSpawnPos(Pos pos);
    }

    public class TeamPlayer
    {
        public BasePlayer player;
        public float health;
        public float hydration;
        public float calories;
        public float bleeding;
        public Pos homePos;
        public Team team;
        public bool itemsSaved;
        public List<InvItem> items;
        public List<InvItem> kitItems;
        public List<InvItem> eventItems;
        public void SaveHealth();
        public void SavePos();
        public void SaveItems(List<InvItem> itemList);
        public void RestoreHealth();
        public void RestorePos();
        public void RestoreItems(List<InvItem> itemList, bool strip);
        public void RestoreEventItems();
        public void Strip();
        public void Heal();
        public void TeleportTo(Pos pos);
        public void StartSleeping();
        public void MoveToEventAndSave(Event teamEvent, Team playerTeam, int spawnOffset);
        public void MoveToEvent(Event teamEvent, Team playerTeam, int spawnOffset);
        public void MoveFromEvent(Event teamEvent);
        private IEnumerable<InvItem> GetItems(ItemContainer container, string containerName);
    }

    public class InvItem
    {
        public int itemId;
        public int amount;
        public int ammo;
        public ulong skin;
        public string container;
        public float condition;
        public InvItem[] contents;
    }

    public class Event
    {
        public bool started;
        public bool spectateTeamEnabled;
        public bool allowPlayersJoin;
        public bool allowPlayersJoinSpecificTeam;
        public bool joinInProgress;
        public bool joinSpecificTeamInProgress;
        public bool autoBalanceTeamsOnJoin;
        public bool allowTeamSwitching;
        public bool endWhenSingleTeamRemaining;
        public bool restartWhenSingleTeamRemaining;
        public bool keepEventInventoryAsReward;
        public bool allowRewardClaiming;
        public int roundRestartTimer;
        public int numberOfTopTeams;
        public List<string> topTeamRewardKits;
        public List<Team> teams;
        public Event();
        public Event(EventSettings settings);
        public Team GetTeamByName(string teamName);
        public Team GetPlayersTeam(BasePlayer player);
        public TeamPlayer GetTeamPlayer(BasePlayer player);
    }

    public class EventSettings
    {
        public string eventName;
        public bool spectateTeamEnabled;
        public bool allowPlayersJoin;
        public bool allowPlayersJoinSpecificTeam;
        public bool joinInProgress;
        public bool joinSpecificTeamInProgress;
        public bool autoBalanceTeamsOnJoin;
        public bool allowTeamSwitching;
        public bool endWhenSingleTeamRemaining;
        public bool restartWhenSingleTeamRemaining;
        public bool keepEventInventoryAsReward;
        public bool allowRewardClaiming;
        public int roundRestartTimer;
        public int numberOfTopTeams;
        public List<string> topTeamRewardKits;
        public List<Team> teams;
        public EventSettings(Event teamEvent, string eventName);
        public EventSettings();
    }

    public class StoredData
    {
        public List<EventSettings> eventSettings;
    }

    [System.Serializable]
    public class Pos
    {
        public float x;
        public float y;
        public float z;
        public Pos(float x, float y, float z);
        public Pos(Vector3 vec3);
        public Pos();
    }

}

public class Team
{
    public string name;
    public string kitname;
    public int teamLives;
    public int usedLives;
    public int maxPlayers;
    public Pos spawnPos;
    public bool spawnSet;
    public bool joinable;
    public List<TeamPlayer> players;
    public void SetSpawnPos(Pos pos);
}

public class TeamPlayer
{
    public BasePlayer player;
    public float health;
    public float hydration;
    public float calories;
    public float bleeding;
    public Pos homePos;
    public Team team;
    public bool itemsSaved;
    public List<InvItem> items;
    public List<InvItem> kitItems;
    public List<InvItem> eventItems;
    public void SaveHealth();
    public void SavePos();
    public void SaveItems(List<InvItem> itemList);
    public void RestoreHealth();
    public void RestorePos();
    public void RestoreItems(List<InvItem> itemList, bool strip);
    public void RestoreEventItems();
    public void Strip();
    public void Heal();
    public void TeleportTo(Pos pos);
    public void StartSleeping();
    public void MoveToEventAndSave(Event teamEvent, Team playerTeam, int spawnOffset);
    public void MoveToEvent(Event teamEvent, Team playerTeam, int spawnOffset);
    public void MoveFromEvent(Event teamEvent);
    private IEnumerable<InvItem> GetItems(ItemContainer container, string containerName);
}

public class InvItem
{
    public int itemId;
    public int amount;
    public int ammo;
    public ulong skin;
    public string container;
    public float condition;
    public InvItem[] contents;
}

public class Event
{
    public bool started;
    public bool spectateTeamEnabled;
    public bool allowPlayersJoin;
    public bool allowPlayersJoinSpecificTeam;
    public bool joinInProgress;
    public bool joinSpecificTeamInProgress;
    public bool autoBalanceTeamsOnJoin;
    public bool allowTeamSwitching;
    public bool endWhenSingleTeamRemaining;
    public bool restartWhenSingleTeamRemaining;
    public bool keepEventInventoryAsReward;
    public bool allowRewardClaiming;
    public int roundRestartTimer;
    public int numberOfTopTeams;
    public List<string> topTeamRewardKits;
    public List<Team> teams;
    public Event();
    public Event(EventSettings settings);
    public Team GetTeamByName(string teamName);
    public Team GetPlayersTeam(BasePlayer player);
    public TeamPlayer GetTeamPlayer(BasePlayer player);
}

public class EventSettings
{
    public string eventName;
    public bool spectateTeamEnabled;
    public bool allowPlayersJoin;
    public bool allowPlayersJoinSpecificTeam;
    public bool joinInProgress;
    public bool joinSpecificTeamInProgress;
    public bool autoBalanceTeamsOnJoin;
    public bool allowTeamSwitching;
    public bool endWhenSingleTeamRemaining;
    public bool restartWhenSingleTeamRemaining;
    public bool keepEventInventoryAsReward;
    public bool allowRewardClaiming;
    public int roundRestartTimer;
    public int numberOfTopTeams;
    public List<string> topTeamRewardKits;
    public List<Team> teams;
    public EventSettings(Event teamEvent, string eventName);
    public EventSettings();
}

public class StoredData
{
    public List<EventSettings> eventSettings;
}

[System.Serializable]
public class Pos
{
    public float x;
    public float y;
    public float z;
    public Pos(float x, float y, float z);
    public Pos(Vector3 vec3);
    public Pos();
}


```

---

## Elevators

```csharp
using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Rust;

Oxide.Plugins
[Info("Elevators", "Reneb", "1.0.1")]
 class Elevators : RustPlugin
{
    [PluginReference]
     Plugin Waypoints;
    private static FieldInfo serverinput;
     StoredData storedData;
    static Hash<string, ElevatorInfo> elevators;
    static Dictionary<string, string> nameToBlockPrefab;
    static List<Elevator> spawnedElevators;
    static List<BaseCombatEntity> protectedBlock;
    public DamageTypeList emptyDamageType;
     object closestEnt;
     Vector3 closestHitpoint;
     Quaternion currentRot;
     class StoredData
    {
        public HashSet<ElevatorInfo> Elevators;
        public StoredData();
    }

     void SaveData();
     void LoadData();
    public class ElevatorInfo
    {
        public string Name;
        public string PrefabName;
        public string WaypointsName;
        public string rx;
        public string ry;
        public string rz;
        public string rw;
        public string Grade;
        public ElevatorInfo();
        public ElevatorInfo(BuildingBlock block, string name, string waypoints);
    }

    public class WaypointInfo
    {
        public string x;
        public string y;
        public string z;
        public string s;
         Vector3 position;
         float speed;
        public WaypointInfo(Vector3 position, float speed);
        public Vector3 GetPosition();
        public float GetSpeed();
    }

    static BuildingGrade.Enum NumToGrade(int lvl);
    static int GradeToNum(BuildingGrade.Enum lvl);
    public class Elevator : MonoBehaviour
    {
        public ElevatorInfo info;
        public List<WaypointInfo> waypoints;
        public TriggerBase trigger;
        public BuildingBlock block;
        public UnityEngine.Quaternion rotation;
        public Vector3 StartPos;
        public Vector3 EndPos;
        public Vector3 nextPos;
        public float waypointDone;
        public float secondsTaken;
        public float secondsToTake;
        public float speed;
        public int currentWaypoint;
        public List<BaseEntity> collidingPlayers;
        public Elevator();
        public void SetInfo(ElevatorInfo info);
         void Awake();
         void OnDestroy();
         void FixedUpdate();
         void Execute_Move();
         void GetNextPath();
        public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s);
        public void ActivateMovement();
        public void DeactivateMovement();
    }

     void OnEntityEnter(TriggerBase triggerbase, BaseEntity entity);
     void OnEntityLeave(TriggerBase triggerbase, BaseEntity entity);
     void NewElevator(ElevatorInfo info);
     void Loaded();
     void Unload();
     void OnServerInitialized();
    static BuildingBlock CreateBuildingBlock(string prefabname, Vector3 position, Quaternion rotation, int grade);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
     void CancelDamage(HitInfo hitinfo);
     bool hasPermission(BasePlayer player);
    static bool TryGetPlayerView(BasePlayer player, Quaternion viewAngle);
     bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, object closestEnt, Vector3 closestHitpoint);
    [ChatCommand("elevator_add")]
     void cmdChatElevatorAdd(BasePlayer player, string command, string[] args);
    [ChatCommand("elevator_reset")]
     void cmdChatElevatorReset(BasePlayer player, string command, string[] args);
    [ChatCommand("elevator_remove")]
     void cmdChatElevatorRemove(BasePlayer player, string command, string[] args);
    [ChatCommand("elevator_list")]
     void cmdChatElevatorList(BasePlayer player, string command, string[] args);
}

 class StoredData
{
    public HashSet<ElevatorInfo> Elevators;
    public StoredData();
}

public class ElevatorInfo
{
    public string Name;
    public string PrefabName;
    public string WaypointsName;
    public string rx;
    public string ry;
    public string rz;
    public string rw;
    public string Grade;
    public ElevatorInfo();
    public ElevatorInfo(BuildingBlock block, string name, string waypoints);
}

public class WaypointInfo
{
    public string x;
    public string y;
    public string z;
    public string s;
     Vector3 position;
     float speed;
    public WaypointInfo(Vector3 position, float speed);
    public Vector3 GetPosition();
    public float GetSpeed();
}

public class Elevator : MonoBehaviour
{
    public ElevatorInfo info;
    public List<WaypointInfo> waypoints;
    public TriggerBase trigger;
    public BuildingBlock block;
    public UnityEngine.Quaternion rotation;
    public Vector3 StartPos;
    public Vector3 EndPos;
    public Vector3 nextPos;
    public float waypointDone;
    public float secondsTaken;
    public float secondsToTake;
    public float speed;
    public int currentWaypoint;
    public List<BaseEntity> collidingPlayers;
    public Elevator();
    public void SetInfo(ElevatorInfo info);
     void Awake();
     void OnDestroy();
     void FixedUpdate();
     void Execute_Move();
     void GetNextPath();
    public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s);
    public void ActivateMovement();
    public void DeactivateMovement();
}


```

---

## Emote

```csharp
using Facepunch;
using Oxide.Core.Plugins;
using System;
using UnityEngine;

Oxide.Plugins
[Info("Emote", "Hirsty", "1.0.5", ResourceId = 1353)]
[Description("This will allow players to express their feelings!")]
 class Emote : RustPlugin
{
    public static string version;
    public string template;
    public string EnableEmotes;
    protected override void LoadDefaultConfig();
    private void Loaded();
    private void LoadConfigData();
    [HookMethod("CheckForEmotes")]
    public string EmoteCheck(BasePlayer player, string checkmsg);
    [ChatCommand("me")]
    private void TheFunction(BasePlayer player, string command, string[] args);
     object OnPlayerChat(ConsoleSystem.Arg arg);
     void SendChatMessage(BasePlayer player, string msg);
}


```

---

## EmptyLowFPS

```csharp

Oxide.Plugins
[Info("EmptyLowFPS", "Dezito", "0.0.3", ResourceId = 1889)]
[Description("Set low cpu usage when no players connected")]
 class EmptyLowFPS : RustPlugin
{
    private static bool UseFPSLimit;
    private static int MaxFPSLimit;
    private static int EmptyFPSLimit;
    private static bool UseTickrate;
    private static int MaxTickrate;
    private static int EmptyTickrate;
     void LoadDefaultConfig();
    private void CheckCfg(string Key, T var);
     void Init();
     void OnPlayerConnected(Network.Message packet);
     void OnPlayerDisconnected(BasePlayer player, string reason);
     void Unload();
     void ServerNotEmpty_FPSLimit();
     void ServerEmpty_FPSLimit();
     void ServerNotEmpty_Tickrate();
     void ServerEmpty_Tickrate();
}


```

---

## EnchantedCup

```csharp
using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using System.Reflection;
using System.Linq;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("EnchantedCup", "Vlad-00003", "1.0.2")]
[Description("Allow user with a permission use command, that would prevent building in the current cup zone.")]
 class EnchantedCup : RustPlugin
{
    [PluginReference]
     Plugin NoEscape;
     Plugin ServerRewards;
     Plugin Economics;
    private PluginConfig config;
    private List<uint> Upgraded;
    private Dictionary<ItemDefinition, int> ItemsPayment;
    private Collider[] colBuffer;
    private class Constants
    {
        public static string TopTierFx;
    }

    private string PanelName;
    private class Price
    {
        [JsonProperty("Список предметов(короткое имя,полное имя на английском или ID)")]
        public Dictionary<string, int> Items;
        [JsonProperty("Монеты (Оставьте 0 если не используете плагин Economics)")]
        public int coins;
        [JsonProperty("Очки наград (Оставьте 0 если не используете плагин ServerRewards)")]
        public int RP;
    }

    private class GUI
    {
        [JsonProperty("Панель. Максимальный отступ")]
        public string Amax;
        [JsonProperty("Панель. Минимальный отступ")]
        public string Amin;
        [JsonProperty("Панель. Цвет")]
        public string Color;
        [JsonProperty("Текст. Максимальный отступ")]
        public string TextAmax;
        [JsonProperty("Текст. Минимальный отступ")]
        public string TextAmin;
        [JsonProperty("Текст. Цвет текста")]
        public string TextColor;
        [JsonProperty("Текст. Размер текста")]
        public int TextSize;
        [JsonProperty("Время автоматического скрывания панели")]
        public float Hide;
    }

    private class PluginConfig
    {
        [JsonProperty("Привилегия для использования команд")]
        public string Permission;
        [JsonProperty("Чат-команда для улучшения шкафа")]
        public string UpCommand;
        [JsonProperty("Чат-команда для снятия улучшения с шкафа")]
        public string DownCommand;
        [JsonProperty("Разрешить строительство лестниц в зоне действия улучшенного шкафа")]
        public bool LadderPlacment;
        [JsonProperty("Цена улучшения")]
        public Price price;
        [JsonProperty("Процент возвращаемых ресурсов при снятии уличшения")]
        public double Refund;
        [JsonProperty("Радиус проверки на наличие шкафов")]
        public float CupRadius;
        [JsonProperty("Формат сообщения при НЕДОСТАТОЧНОМ количестве ресурсов")]
        public string NotEnoughtFormat;
        [JsonProperty("Формат сообщения при ДОСТАТОЧНОМ количестве ресурсов")]
        public string EnoughtFormat;
        [JsonProperty("Максимальное расстояние до шкафа при использовании команд")]
        public float Radius;
        [JsonProperty("Настройки графики")]
        public GUI gui;
        public static PluginConfig DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
    private void SaveData();
     void LoadData();
     void Loaded();
     void Unload();
     void OnServerInitialized();
    private void UpgradeCommand(BasePlayer player, string command, string[] args);
    private void DowngradeCommand(BasePlayer player, string command, string[] args);
     void OnEntityKill(BaseNetworkable entity);
     void OnServerSave();
    private bool Refund(BasePlayer player);
    private bool Pay(BasePlayer player);
    private bool CanPay(BasePlayer player, string price);
     object CanBuild(Planner plan, Construction prefab);
    public object BuildingBlocked(Planner plan, Construction prefab);
    private void CreateGUI(BasePlayer player, string Langkey, object[] args);
    private BuildingPrivlidge GetCup(BasePlayer player, float radius);
    private bool CanDo(BasePlayer player);
    private string GetMsg(string key, BasePlayer player);
    private bool HasPerm(BasePlayer player);
}

private class Constants
{
    public static string TopTierFx;
}

private class Price
{
    [JsonProperty("Список предметов(короткое имя,полное имя на английском или ID)")]
    public Dictionary<string, int> Items;
    [JsonProperty("Монеты (Оставьте 0 если не используете плагин Economics)")]
    public int coins;
    [JsonProperty("Очки наград (Оставьте 0 если не используете плагин ServerRewards)")]
    public int RP;
}

private class GUI
{
    [JsonProperty("Панель. Максимальный отступ")]
    public string Amax;
    [JsonProperty("Панель. Минимальный отступ")]
    public string Amin;
    [JsonProperty("Панель. Цвет")]
    public string Color;
    [JsonProperty("Текст. Максимальный отступ")]
    public string TextAmax;
    [JsonProperty("Текст. Минимальный отступ")]
    public string TextAmin;
    [JsonProperty("Текст. Цвет текста")]
    public string TextColor;
    [JsonProperty("Текст. Размер текста")]
    public int TextSize;
    [JsonProperty("Время автоматического скрывания панели")]
    public float Hide;
}

private class PluginConfig
{
    [JsonProperty("Привилегия для использования команд")]
    public string Permission;
    [JsonProperty("Чат-команда для улучшения шкафа")]
    public string UpCommand;
    [JsonProperty("Чат-команда для снятия улучшения с шкафа")]
    public string DownCommand;
    [JsonProperty("Разрешить строительство лестниц в зоне действия улучшенного шкафа")]
    public bool LadderPlacment;
    [JsonProperty("Цена улучшения")]
    public Price price;
    [JsonProperty("Процент возвращаемых ресурсов при снятии уличшения")]
    public double Refund;
    [JsonProperty("Радиус проверки на наличие шкафов")]
    public float CupRadius;
    [JsonProperty("Формат сообщения при НЕДОСТАТОЧНОМ количестве ресурсов")]
    public string NotEnoughtFormat;
    [JsonProperty("Формат сообщения при ДОСТАТОЧНОМ количестве ресурсов")]
    public string EnoughtFormat;
    [JsonProperty("Максимальное расстояние до шкафа при использовании команд")]
    public float Radius;
    [JsonProperty("Настройки графики")]
    public GUI gui;
    public static PluginConfig DefaultConfig();
}


```

---

## EnemyBar

```csharp
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using UnityEngine;
using VLB;

Oxide.Plugins
[Info("EnemyBar", "TopPlugin.ru", "1.0.2")]
public class EnemyBar : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private const string elemMain;
    private const string elemPanel;
    private static EnemyBar plugin;
    private static ConfigData configData;
    public class ConfigData
    {
        [JsonProperty("ОСНОВНЫЕ НАСТРОЙКИ")]
        public SettingBasic OptionsBasic;
        [JsonProperty("НАСТРОЙКИ ГРАФИЧЕСКОГО ИНТЕРФЕЙСА")]
        public SettingGUI OptionsGUI;
        public class SettingBasic
        {
            [JsonProperty("Разрешение для отображения интерфейса")]
            public string permUse;
            [JsonProperty("Текст в графическом интерфейсе")]
            public string woundedText;
            [JsonProperty("Интервал проверки здоровья")]
            public float healthCheckInterval;
        }

        public class SettingGUI
        {
            [JsonProperty("Позиция графического интерфейса")]
            public string position;
            [JsonProperty("Цвет фона графического интерфейса")]
            public string colorBackground;
            [JsonProperty("Цвет шкалы здоровья графического интерфейса")]
            public string colorLine;
            [JsonProperty("Размер текста в графическом интерфейсе")]
            public int textSize;
            [JsonProperty("Цвет текста в графическом интерфейсе")]
            public string textColor;
            [JsonProperty("Ссылка на изображение")]
            public string iconUrl;
            [JsonProperty("Время отображения шкалы здоровья |секунд|")]
            public int duration;
            [JsonProperty("Время принудительного удаления шкалы здоровья |секунд|")]
            public int forceDuration;
        }

    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private void Init();
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerAttack(BasePlayer player, HitInfo info);
    private void CheckPlayers();
    private void DestroyScripts();
    private void CreateGUI(BasePlayer player, float fraction, string value);
    private static void DestroyGUI(BasePlayer player);
    private void AddImage(string name, string url);
    private string GetImage(string name);
    private class HealthBar : MonoBehaviour
    {
        private BasePlayer player;
        private BaseCombatEntity target;
        private BasePlayer targetPlayer;
        private float lastHealth;
        private void Awake();
        public void OnAttacked(BaseEntity entity);
        private void CheckHealth();
        private void OnDamaged();
        private void ForceDestroy();
        private void TimedDestroy();
    }

}

public class ConfigData
{
    [JsonProperty("ОСНОВНЫЕ НАСТРОЙКИ")]
    public SettingBasic OptionsBasic;
    [JsonProperty("НАСТРОЙКИ ГРАФИЧЕСКОГО ИНТЕРФЕЙСА")]
    public SettingGUI OptionsGUI;
    public class SettingBasic
    {
        [JsonProperty("Разрешение для отображения интерфейса")]
        public string permUse;
        [JsonProperty("Текст в графическом интерфейсе")]
        public string woundedText;
        [JsonProperty("Интервал проверки здоровья")]
        public float healthCheckInterval;
    }

    public class SettingGUI
    {
        [JsonProperty("Позиция графического интерфейса")]
        public string position;
        [JsonProperty("Цвет фона графического интерфейса")]
        public string colorBackground;
        [JsonProperty("Цвет шкалы здоровья графического интерфейса")]
        public string colorLine;
        [JsonProperty("Размер текста в графическом интерфейсе")]
        public int textSize;
        [JsonProperty("Цвет текста в графическом интерфейсе")]
        public string textColor;
        [JsonProperty("Ссылка на изображение")]
        public string iconUrl;
        [JsonProperty("Время отображения шкалы здоровья |секунд|")]
        public int duration;
        [JsonProperty("Время принудительного удаления шкалы здоровья |секунд|")]
        public int forceDuration;
    }

}

public class SettingBasic
{
    [JsonProperty("Разрешение для отображения интерфейса")]
    public string permUse;
    [JsonProperty("Текст в графическом интерфейсе")]
    public string woundedText;
    [JsonProperty("Интервал проверки здоровья")]
    public float healthCheckInterval;
}

public class SettingGUI
{
    [JsonProperty("Позиция графического интерфейса")]
    public string position;
    [JsonProperty("Цвет фона графического интерфейса")]
    public string colorBackground;
    [JsonProperty("Цвет шкалы здоровья графического интерфейса")]
    public string colorLine;
    [JsonProperty("Размер текста в графическом интерфейсе")]
    public int textSize;
    [JsonProperty("Цвет текста в графическом интерфейсе")]
    public string textColor;
    [JsonProperty("Ссылка на изображение")]
    public string iconUrl;
    [JsonProperty("Время отображения шкалы здоровья |секунд|")]
    public int duration;
    [JsonProperty("Время принудительного удаления шкалы здоровья |секунд|")]
    public int forceDuration;
}

private class HealthBar : MonoBehaviour
{
    private BasePlayer player;
    private BaseCombatEntity target;
    private BasePlayer targetPlayer;
    private float lastHealth;
    private void Awake();
    public void OnAttacked(BaseEntity entity);
    private void CheckHealth();
    private void OnDamaged();
    private void ForceDestroy();
    private void TimedDestroy();
}


```

---

## EnhancedBanSystem

```csharp
using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using System.Linq;
using UnityEngine;
using Facepunch;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

Oxide.Plugins
[Info("Enhanced Ban System", "Domestos & Reneb", "3.0.8", ResourceId = 693)]
 class EnhancedBanSystem : RustPlugin
{
    [PluginReference]
     Plugin PlayerDatabase;
    static DateTime epoch;
    static double LogTime();
     void Loaded();
     void Unload();
     object CanClientLogin(Network.Connection connection);
     bool CanConnect(BanData bandata, Network.Connection connection, string reason);
    static StoredData storedData;
    static Hash<string, BanData> banLogs;
    static Hash<string, BanData> bannedIPs;
     void UpdateBannedIPs();
     class StoredData
    {
        public HashSet<BanData> BanLogs;
        public StoredData();
    }

     void OnServerSave();
     void SaveData();
     void LoadData();
    public class BanData
    {
        public string steamID;
        public string reason;
        public string name;
        public List<string> IPs;
        public int expiration;
        public BanData();
        public BanData(string steamID, string reason, string name, string IP, int duration);
    }

    static bool BroadcastBans;
    static bool BroadcastUnbans;
    static bool BroadcastKicks;
    static bool LogToConsole;
    static string ChatName;
    static string PermissionBan;
    static string PermissionKick;
    static string PermissionBanCheck;
    static string MessageKick;
    static string MessageKickBroadcast;
    static string MessageBan;
    static string MessageBanBroadcast;
    static string MessageDenyConnection;
    static string MessageDenyConnectionTemp;
    static string MessageBanCheck;
    static string DefaultBanReason;
    static string MessageNoPlayerFound;
    protected override void LoadDefaultConfig();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
     void Init();
     List<string> BannedPlayers();
     Dictionary<string, object> GetBanData(ulong userid);
     Dictionary<string, object> GetBanData(string target);
     bool hasPermission(BasePlayer player, string permissionName);
    private object FindPlayer(string arg);
    private object FindOnlinePlayer(string arg);
     void SendMessage(object source, string msg);
     void ShowBans(object source, string[] args);
     void TryKick(object source, string[] args);
     void Kick(object source, string target, string reason);
     void ExecuteKick(object source, BasePlayer target, string reason);
    static string ipPattern;
    static System.Text.RegularExpressions.Regex regex;
     void TryBanIP(object source, string[] args);
     Dictionary<string, string> FindPlayersByIP(string ipaddress);
     void RawBanIP(object source, string ipaddress, string reason, int duration);
     void AddIpToBan(object source, string targetID, string ipaddress);
     void BanIP(object source, string ipaddress, string reason, int duration);
     bool IsBannedIP(string arg);
     bool IsBannedUser(ulong userid);
     void AddIPToUserBan(string userid, string ipaddress);
     void UnbanIP(object source, string ipaddress);
     void TryBan(object source, string[] args);
     void BanID(object sourcePlayer, ulong targetID, string reason, int duration);
     void Ban(object sourcePlayer, BasePlayer player, string reason, object duration);
     void ExecuteBan(object sourcePlayer, string targetID, string targetName, string targetIP, string reason, int duration);
     void CheckBan(object sourcePlayer, string[] args);
     void TryUnban(object source, string[] args);
     object FindBanLog(string arg);
     void Unban(object source, string targetID);
     void DeleteBan(string targetID);
     void Unban(object source, ulong targetID);
    [ChatCommand("ban")]
     void cmdChatBan(BasePlayer player, string command, string[] args);
    [ChatCommand("kick")]
     void cmdChatKick(BasePlayer player, string command, string[] args);
    [ChatCommand("unban")]
     void cmdChatUnban(BasePlayer player, string command, string[] args);
    [ChatCommand("checkban")]
     void cmdChatCheckBan(BasePlayer player, string command, string[] args);
    [ConsoleCommand("player.ban")]
     void cmdConsolePlayerBan(ConsoleSystem.Arg arg);
    [ConsoleCommand("player.checkban")]
     void cmdConsolePlayerCheckBan(ConsoleSystem.Arg arg);
    [ConsoleCommand("player.kick")]
     void cmdConsolePlayerKick(ConsoleSystem.Arg arg);
    [ConsoleCommand("player.unban")]
     void cmdConsolePlayerUnban(ConsoleSystem.Arg arg);
    [ConsoleCommand("player.banlist")]
     void ccmdPlayerBanlist(ConsoleSystem.Arg arg);
    [ConsoleCommand("ebs.import")]
     void ccmdEBSImport(ConsoleSystem.Arg arg);
}

 class StoredData
{
    public HashSet<BanData> BanLogs;
    public StoredData();
}

public class BanData
{
    public string steamID;
    public string reason;
    public string name;
    public List<string> IPs;
    public int expiration;
    public BanData();
    public BanData(string steamID, string reason, string name, string IP, int duration);
}


```

---

## EnhancedHammer

```csharp
using Oxide.Game.Rust.Cui;
using Oxide.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

Oxide.Plugins
[Info("Enhanced Hammer", "Visagalis", "0.5.0", ResourceId = 1439)]
public class EnhancedHammer : RustPlugin
{
    public class PlayerDetails
    {
        public PlayerFlags flags;
        public BuildingGrade.Enum upgradeInfo;
        public int backToDefaultTimer;
    }

    private string pluginPrefix;
    public static Dictionary<ulong, PlayerDetails> playersInfo;
    public static Dictionary<ulong, Timer> playersTimers;
     void OnStructureRepair(BaseCombatEntity entity, BasePlayer player);
     void RefreshTimer(BasePlayer player);
     void OnStructureUpgrade(BaseCombatEntity block, BasePlayer player, BuildingGrade.Enum grade);
     void RenderMode(BasePlayer player, bool repair);
     void SetBackToDefault(BasePlayer player);
     void RemoveUI(BasePlayer player);
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
    public PlayerFlags GetPlayerFlags(ulong userID);
     void Init();
     void Unload();
    [ChatCommand("eh")]
    private void OnEhCommand(BasePlayer player, string command, string[] arg);
    private bool PlayerHasFlag(ulong userID, PlayerFlags flag);
    private void ModifyPlayerFlags(BasePlayer player, bool addFlag, PlayerFlags flag);
}

public class PlayerDetails
{
    public PlayerFlags flags;
    public BuildingGrade.Enum upgradeInfo;
    public int backToDefaultTimer;
}


```

---

## EntityLimit

```csharp
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using System.Linq;

Oxide.Plugins
[Info("Entity Limit", "PaiN", 0.5, ResourceId = 1947)]
 class EntityLimit : RustPlugin
{
    static EntityLimit Plugin;
    static Data data;
    static ConfigFile Cfg;
     class ConfigFile
    {
        public Dictionary<string, int> MaxLimits;
    }

     class Data
    {
        public List<PlayerLimit> Limits;
    }

     class PlayerLimit
    {
        public ulong Id;
        public List<Entities> limit;
        public static void Create(BasePlayer player, BaseEntity entity);
        public static void Modify(BasePlayer player, BaseEntity entity);
    }

     class Entities
    {
        public string Name;
        public int Count;
    }

     void Loaded();
     void Unloaded();
     void OnServerSave();
    protected override void LoadDefaultConfig();
     void LoadMessages();
     void OnEntitySpawned(BaseNetworkable entity);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo);
     void OnRemovedEntity(BaseEntity entity);
     void EntityDestroyed(BaseEntity entity);
    [ChatCommand("shortname")]
     void cmdShortName(BasePlayer player, string cmd, string[] args);
    [ChatCommand("limitswipe")]
     void cmdWipe(BasePlayer player, string cmd, string[] args);
    static void SaveData();
    static string LangMsg(string msg, string uid);
}

 class ConfigFile
{
    public Dictionary<string, int> MaxLimits;
}

 class Data
{
    public List<PlayerLimit> Limits;
}

 class PlayerLimit
{
    public ulong Id;
    public List<Entities> limit;
    public static void Create(BasePlayer player, BaseEntity entity);
    public static void Modify(BasePlayer player, BaseEntity entity);
}

 class Entities
{
    public string Name;
    public int Count;
}


```

---

## EpicLanterns

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;

Oxide.Plugins
[Info("EpicLanterns", "skyman", "0.0.1", ResourceId = 1357)]
[Description("Automatically toggles lanterns after sunrise and sunset or in other given timeframe!")]
 class EpicLanterns : RustPlugin
{
    private string _pluginPrefix;
    private bool _areCachedCorrectly;
    private bool _areTurnedOn;
    private Dictionary<string, BaseEntity> _lanterns;
    private bool _isLoaded;
    private bool _isInitialized;
    private void Init();
    protected override void LoadDefaultConfig();
    private void OnPluginLoaded(RustPlugin pluginName);
    private void OnServerInitialized();
    private void Unload();
    private void OnTick();
    private void OnItemDeployed(Deployer deployer, BaseEntity entity);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    private void OnEntityGroundMissing(BaseEntity entity);
    protected void echo(string message, MessageType messageType);
    public string getEntityId(BaseEntity entity);
    private bool badConfig(string missingKey);
    protected bool validateConfig();
    protected bool isLantern(BaseEntity entity);
    protected bool isLantern(BaseOven entity);
    protected bool hasFuel(BaseEntity entity);
    protected void createLanternsCache();
    protected void removeLanternFromCache(string entityId);
    protected void smartToggleLanterns();
}


```

---

## ESPBlocker

```csharp
using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using System.Collections;
using UnityEngine;
using Network;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System.Diagnostics;

Oxide.Plugins
[Info("ESPBlocker", "RustPlugin.RU", "1.0.0")]
 class ESPBlocker : RustPlugin
{
     class ESPPlayer : MonoBehaviour
    {
        private static int blockedLayer;
         Transform transform;
         BasePlayer player;
         List<BaseEntity> blockedEntities;
         int current;
         bool init;
         void Awake();
         float nextTick;
         float nextUpdaterStorages;
         Vector3 lastPosition;
         bool IsTimerBlock();
         void UpdateBlockedEntities();
         bool IsAFK();
         void FixedUpdate();
        public bool ContainsAny(string value, string[] args);
         bool CanVisible(Vector3 pos);
    }

     float storageRadius;
     bool adminIgnore;
     bool clansSupport;
    protected override void LoadDefaultConfig();
     T GetConfig(string name, T defaultValue);
    static ESPBlocker instance;
    static int PlayerLayer;
     Dictionary<BasePlayer, ESPPlayer> players;
     Dictionary<uint, List<ulong>> whitelists;
     void Loaded();
     bool init;
     int raycastCount;
     void OnServerInitialized();
     void Unload();
     void OnEntityKill(BaseNetworkable entity);
     void OnPlayerDisconnected(BasePlayer player);
     void OnPlayerInit(BasePlayer player);
     object CanNetworkTo(BaseNetworkable entity, BasePlayer target);
     bool IsBlockEntity(BaseEntity entity);
     void SetVisibleEntity(BaseEntity entity, ulong userID);
    [ChatCommand("clear")]
     void cmdClear(BasePlayer player);
     ESPPlayer GetEspPlayer(BasePlayer player);
     void AddEspPlayer(BasePlayer player);
     void DestroyClientEntity(BasePlayer player, BaseEntity entity);
     IEnumerator InitCore();
    public static class StopwatchUtils
    {
        static Dictionary<string, Stopwatch> watches;
        public static void StopwatchStart(string name);
        public static long StopwatchElapsedMilliseconds(string name);
        public static void StopwatchStop(string name);
    }

    public void Arrow(BasePlayer player, Vector3 from, Vector3 to);
    [PluginReference]
     Plugin Clans;
     List<ulong> GetClanMembers(ulong uid);
     DynamicConfigFile whitelistFile;
     void OnServerSave();
     void LoadData();
     void SaveData();
}

 class ESPPlayer : MonoBehaviour
{
    private static int blockedLayer;
     Transform transform;
     BasePlayer player;
     List<BaseEntity> blockedEntities;
     int current;
     bool init;
     void Awake();
     float nextTick;
     float nextUpdaterStorages;
     Vector3 lastPosition;
     bool IsTimerBlock();
     void UpdateBlockedEntities();
     bool IsAFK();
     void FixedUpdate();
    public bool ContainsAny(string value, string[] args);
     bool CanVisible(Vector3 pos);
}

public static class StopwatchUtils
{
    static Dictionary<string, Stopwatch> watches;
    public static void StopwatchStart(string name);
    public static long StopwatchElapsedMilliseconds(string name);
    public static void StopwatchStop(string name);
}


```

---

## EventBox

```csharp
using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("EventBox API", "LaserHydra", "1.0.0", ResourceId = 0)]
[Description("allows you to set up spots for boxes which other plugins can use.")]
 class EventBox : RustPlugin
{
     class Category : Dictionary<string, object>
    {
        public Category(int MinimalAmount, int MaximalAmount, bool Enabled);
    }

     class Location
    {
        public float x;
        public float y;
        public float z;
        public Location();
        internal Location(float x, float y, float z);
        internal Location(Dictionary<string, float> dic);
        internal Location(Vector3 vector);
        internal Vector3 Vector { get; set; }
    }

     class Data
    {
        public Dictionary<string, List<Location>> locations;
    }

     Data data;
     Dictionary<string, List<BaseEntity>> boxes;
     void Loaded();
     void Unloaded();
     void LoadConfig();
    protected override void LoadDefaultConfig();
     void LoadData();
     void SaveData();
    [ChatCommand("eventbox")]
     void cmdEventBox(BasePlayer player, string cmd, string[] args);
     List<string> names { get; set; }
     void AddBox(string name, Vector3 vector);
     BaseEntity BuildBox(string name, Location location, bool items);
     void AddItems(BaseEntity box);
     string BuildBoxes(string name);
     string DestroyBoxes(string name);
     Item GetRandomItem();
     object GetRandomAmount(string category);
     Item GetItem(int id, int amount);
     bool HasPermission(BasePlayer player);
     void RunAsChatCommand(ConsoleSystem.Arg arg, Action<BasePlayer, string, string[]> command);
     string ListToString(List<string> list, int first, string seperator);
     void SetConfig(object[] args);
     void BroadcastChat(string prefix, string msg);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
}

 class Category : Dictionary<string, object>
{
    public Category(int MinimalAmount, int MaximalAmount, bool Enabled);
}

 class Location
{
    public float x;
    public float y;
    public float z;
    public Location();
    internal Location(float x, float y, float z);
    internal Location(Dictionary<string, float> dic);
    internal Location(Vector3 vector);
    internal Vector3 Vector { get; set; }
}

 class Data
{
    public Dictionary<string, List<Location>> locations;
}


```

---

## EventManager

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;

Oxide.Plugins
[Info("Event Manager", "Reneb / k1lly0u", "2.0.24", ResourceId = 740)]
 class EventManager : RustPlugin
{
    [PluginReference]
     Plugin Spawns;
    [PluginReference]
     Plugin Kits;
    [PluginReference]
     Plugin ZoneManager;
    [PluginReference]
     Plugin ServerRewards;
    [PluginReference]
     Plugin Economics;
    private string EventSpawnFile;
    private string EventGameName;
    private string ZoneName;
    private string TokenType;
    private bool EventOpen;
    private bool EventStarted;
    private bool EventEnded;
    private bool EventPending;
    private int EventMaxPlayers;
    private int EventMinPlayers;
    private int EventAutoNum;
    public int PlayTimer;
    public float LastAnnounce;
    public bool AutoEventLaunched;
    public bool UseClassSelection;
    public GameMode EventMode;
    private List<string> EventGames;
    private List<EventPlayer> EventPlayers;
    public List<ulong> Godmode;
    public List<Timer> AutoArenaTimers;
    private Dictionary<ulong, Timer> KillTimers;
    private ConfigData configData;
     ClassData classData;
    private DynamicConfigFile Class_Data;
    static bool Debug;
     class EventPlayer : MonoBehaviour
    {
        public BasePlayer player;
        public float health;
        public float calories;
        public float hydration;
        public bool inEvent;
        public bool savedInventory;
        public bool savedHome;
        public bool OOB;
        public string currentClass;
        public List<EventInvItem> InvItems;
        public Vector3 Home;
         void Awake();
        public void SaveHealth();
        public void SaveHome();
        public void TeleportHome();
        public void SaveInventory();
        private IEnumerable<EventInvItem> GetItems(ItemContainer container, string containerName);
        public void RestoreInventory();
    }

     class EventInvItem
    {
        public int itemid;
        public bool bp;
        public int skin;
        public string container;
        public int amount;
        public float condition;
        public int ammo;
        public EventInvItem[] contents;
    }

     class ConfigData
    {
        public string Default_Gamemode { get; set; }
        public string Default_Spawnfile { get; set; }
        public int Battlefield_Timer { get; set; }
        public bool KillDeserters { get; set; }
        public int Required_AuthLevel { get; set; }
        public string Messaging_MainColor { get; set; }
        public string Messaging_MsgColor { get; set; }
        public bool Announce_Event { get; set; }
        public bool AnnounceDuring_Event { get; set; }
        public int AnnounceEvent_Interval { get; set; }
        public bool UseEconomicsAsTokens { get; set; }
        public bool UseClassSelector_Default { get; set; }
        public AutoEvents z_AutoEvents { get; set; }
    }

     class AutoEvents
    {
        public int GameInterval { get; set; }
        public bool AutoCancel { get; set; }
        public int AutoCancel_Timer { get; set; }
        public List<AutoEventSetup> z_AutoEventSetup { get; set; }
    }

     class AutoEventSetup
    {
        public bool UseClassSelector { get; set; }
        public string GameType { get; set; }
        public GameMode EventMode { get; set; }
        public string Spawnfile { get; set; }
        public string Kit { get; set; }
        public bool CloseOnStart { get; set; }
        public int TimeToJoin { get; set; }
        public int MinimumPlayers { get; set; }
        public int MaximumPlayers { get; set; }
        public int TimeLimit { get; set; }
        public string ZoneID { get; set; }
    }

     class ClassData
    {
        public Dictionary<string, string> ClassKits;
    }

    public class UI
    {
        static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor);
        static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
        static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
        static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
    }

     void Loaded();
     void OnServerInitialized();
     void InitializeGames();
     void Unload();
     void OnPlayerRespawned(BasePlayer player);
     void OnPlayerAttack(BasePlayer player, HitInfo hitinfo);
     void OnEntityDeath(BaseEntity entity, HitInfo hitinfo);
     void OnPlayerDisconnected(BasePlayer player);
     void OnEntityTakeDamage(BaseEntity entity, HitInfo info);
     bool hasEventStarted();
     bool isPlaying(BasePlayer player);
     object canRedeemKit(BasePlayer player);
     object canShop(BasePlayer player);
     object CanTeleport(BasePlayer player);
    private void LoadVariables();
    private void LoadConfigVariables();
    protected override void LoadDefaultConfig();
     void SaveConfig(ConfigData config);
    static List<AutoEventSetup> CreateDefaultAutoConfig();
    private void MSG(BasePlayer player, string langkey, bool title);
     void BroadcastToChat(string msg);
    private string GetMessage(string key);
    [HookMethod("BroadcastEvent")]
    public void BroadcastEvent(string msg);
     Dictionary<string, string> Messages;
    private void SelectClass(BasePlayer player);
    private void CreateClassButton(CuiElementContainer container, string panelName, string name, string kit, int number);
    [ConsoleCommand("Choose_Class")]
     void cmdChoose_Class(ConsoleSystem.Arg arg);
    private void StartTimer(int time);
    private void TimerCountdown(BasePlayer player);
    private void DestroyUI(BasePlayer player);
     bool hasAccess(ConsoleSystem.Arg arg);
    static void TPPlayer(BasePlayer player, Vector3 destination);
    static void StartSleeping(BasePlayer player);
    [HookMethod("TeleportAllPlayersToEvent")]
    public void TeleportAllPlayersToEvent();
     void TeleportPlayerToEvent(BasePlayer player);
     void SaveAllInventories();
     void SaveAllPlayerStats();
     void SaveAllHomeLocations();
     void SetAllEventPlayers();
     void RedeemInventory(BasePlayer player);
     void TeleportPlayerHome(BasePlayer player);
     void TryErasePlayer(BasePlayer player);
    [HookMethod("GivePlayerKit")]
    public void GivePlayerKit(BasePlayer player, string GiveKit);
    private void GiveClassKit(BasePlayer player);
     void EjectPlayer(BasePlayer player);
     void RestorePlayerHealth(BasePlayer player);
    [HookMethod("OpenEvent")]
    public object OpenEvent();
     void OnEventOpenPost();
     void OnEventOpenPostAutoEvent();
     object CanEventOpen();
    [HookMethod("CloseEvent")]
    public object CloseEvent();
     object AutoEventNext();
     void OnEventStartPost();
     void OnEventStartPostAutoEvent();
     void DestroyTimers();
     void CancelEvent(string reason);
     void AnnounceEvent();
     void AnnounceDuringEvent();
     object LaunchEvent();
    [HookMethod("EndEvent")]
    public object EndEvent();
     void ProcessPlayers();
     void RestorePlayer(EventPlayer p);
     void EnableGod();
     void DisableGod();
     void DestroyGame();
     object CanEventStart();
    [HookMethod("StartEvent")]
    public object StartEvent();
     void SetEventPlayer(EventPlayer player);
     object JoinEvent(BasePlayer player);
     object CanEventJoin(BasePlayer player);
     object OnEventJoinPost(BasePlayer player);
     void OnEventEndPost();
    [HookMethod("LeaveEvent")]
    public object LeaveEvent(BasePlayer player);
    [HookMethod("SelectEvent")]
    public object SelectEvent(string name);
    [HookMethod("SelectSpawnfile")]
    public object SelectSpawnfile(string name);
     object SelectKit(string kitname);
     object SelectMaxplayers(int num);
     object SelectMinplayers(int num);
     object SelectNewZone(MonoBehaviour monoplayer, string radius);
    private object CheckEventSet();
    [HookMethod("RegisterEventGame")]
    public object RegisterEventGame(string name);
     void OnExitZone(string zoneId, BasePlayer player);
     void OnEnterZone(string zoneID, BasePlayer player);
    [ChatCommand("event")]
     void cmdEvent(BasePlayer player, string command, string[] args);
    [ConsoleCommand("event")]
     void ccmdEvent(ConsoleSystem.Arg arg);
    [HookMethod("AddTokens")]
    public void AddTokens(string userid, int amount);
     void SaveData();
     void LoadData();
    static void ELog(string message);
}

 class EventPlayer : MonoBehaviour
{
    public BasePlayer player;
    public float health;
    public float calories;
    public float hydration;
    public bool inEvent;
    public bool savedInventory;
    public bool savedHome;
    public bool OOB;
    public string currentClass;
    public List<EventInvItem> InvItems;
    public Vector3 Home;
     void Awake();
    public void SaveHealth();
    public void SaveHome();
    public void TeleportHome();
    public void SaveInventory();
    private IEnumerable<EventInvItem> GetItems(ItemContainer container, string containerName);
    public void RestoreInventory();
}

 class EventInvItem
{
    public int itemid;
    public bool bp;
    public int skin;
    public string container;
    public int amount;
    public float condition;
    public int ammo;
    public EventInvItem[] contents;
}

 class ConfigData
{
    public string Default_Gamemode { get; set; }
    public string Default_Spawnfile { get; set; }
    public int Battlefield_Timer { get; set; }
    public bool KillDeserters { get; set; }
    public int Required_AuthLevel { get; set; }
    public string Messaging_MainColor { get; set; }
    public string Messaging_MsgColor { get; set; }
    public bool Announce_Event { get; set; }
    public bool AnnounceDuring_Event { get; set; }
    public int AnnounceEvent_Interval { get; set; }
    public bool UseEconomicsAsTokens { get; set; }
    public bool UseClassSelector_Default { get; set; }
    public AutoEvents z_AutoEvents { get; set; }
}

 class AutoEvents
{
    public int GameInterval { get; set; }
    public bool AutoCancel { get; set; }
    public int AutoCancel_Timer { get; set; }
    public List<AutoEventSetup> z_AutoEventSetup { get; set; }
}

 class AutoEventSetup
{
    public bool UseClassSelector { get; set; }
    public string GameType { get; set; }
    public GameMode EventMode { get; set; }
    public string Spawnfile { get; set; }
    public string Kit { get; set; }
    public bool CloseOnStart { get; set; }
    public int TimeToJoin { get; set; }
    public int MinimumPlayers { get; set; }
    public int MaximumPlayers { get; set; }
    public int TimeLimit { get; set; }
    public string ZoneID { get; set; }
}

 class ClassData
{
    public Dictionary<string, string> ClassKits;
}

public class UI
{
    static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor);
    static public void CreatePanel(CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor);
    static public void CreateLabel(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align);
    static public void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
}


```

---

## EventManagerNotifier

```csharp
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("EventManagerNotifier", "M&B-Studios", "1.0.2")]
public class EventManagerNotifier : RustPlugin
{
    private ConfigData configData;
     class EventConfig
    {
        public bool MessagesActive { get; set; }
        public string EventName { get; set; }
        public string StartCommand { get; set; }
        public string StartMessage { get; set; }
    }

     class ConfigData
    {
        public List<EventConfig> Events { get; set; }
    }

    protected override void LoadDefaultConfig();
    private void OnEventStarted(string eventname);
     void Init();
    private void cmdEventStartConsole(ConsoleSystem.Arg arg);
    private void CmdEventStart(BasePlayer player, string command, string[] args);
     void SaveConfig();
}

 class EventConfig
{
    public bool MessagesActive { get; set; }
    public string EventName { get; set; }
    public string StartCommand { get; set; }
    public string StartMessage { get; set; }
}

 class ConfigData
{
    public List<EventConfig> Events { get; set; }
}


```

---

## EventRandomizer

```csharp
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using ConVar;
using UnityEngine;

Oxide.Plugins
[Info("Event Randomizer", "Frizen", "0.0.1")]
[Description("Set random timers for server events")]
 class EventRandomizer : RustPlugin
{
    private float heliInterval;
    private float chinookInterval;
    private float cargoInterval;
    private float airdropInterval;
    private int lastHeli;
    private int lastChinook;
    private int lastCargo;
    private int lastAirdrop;
    private string permSpawnChinook;
    private string permSpawnHeli;
    private string permSpawnCargo;
    private string permSpawnAirdrop;
    private string permCheckTimer;
    private bool initialized;
    private class EventTimer
    {
        public float Min;
        public float Max;
    }

    private void LoadDefaultMessages();
    private void OnServerInitialized();
    private void OnEntitySpawned(BaseNetworkable entity);
    [ChatCommand("heli")]
    private void CmdHeli(BasePlayer player);
    [ChatCommand("chinook")]
    private void CmdChinook(BasePlayer player);
    [ChatCommand("cargo")]
    private void CmdCargo(BasePlayer player);
    [ConsoleCommand("ch47.spawn")]
    private void ConsoleCmdSpawnCh47(ConsoleSystem.Arg arg);
    [ConsoleCommand("heli.spawn")]
    private void ConsoleCmdSpawnHeli(ConsoleSystem.Arg arg);
    [ConsoleCommand("cargo.spawn")]
    private void ConsoleCmdSpawnCargo(ConsoleSystem.Arg arg);
    [ConsoleCommand("airdrop.spawn")]
    private void ConsoleCmdSpawnAirdrop(ConsoleSystem.Arg arg);
    private void SpawnCargoRandom();
    private void SpawnHeliRandom();
    private void SpawnChinookRandom();
    private void SpawnAirdropRandom();
    private string FormatTime(float seconds);
    private void SpawnAirdrop();
    private void SpawnCargo();
    private void SpawnHeli();
    private void SpawnChinook();
    private int GetUnix();
    private string Lang(string key, string id, object[] args);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Event Timers in seconds")]
        public Dictionary<string, EventTimer> EventTimers { get; set; }
        [JsonProperty(PropertyName = "Block Airdrops spawned by the server")]
        public bool blockServerAirdrops;
        [JsonProperty(PropertyName = "Block Cargo Ships spawned by the server")]
        public bool blockServerCargoShips;
        [JsonProperty(PropertyName = "Block Chinooks spawned by the server")]
        public bool blockServerChinooks;
        [JsonProperty(PropertyName = "Block Patrol Helicopters spawned by the server")]
        public bool blockServerPatrolHelicopters;
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void SaveConfig(ConfigData config);
}

private class EventTimer
{
    public float Min;
    public float Max;
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Event Timers in seconds")]
    public Dictionary<string, EventTimer> EventTimers { get; set; }
    [JsonProperty(PropertyName = "Block Airdrops spawned by the server")]
    public bool blockServerAirdrops;
    [JsonProperty(PropertyName = "Block Cargo Ships spawned by the server")]
    public bool blockServerCargoShips;
    [JsonProperty(PropertyName = "Block Chinooks spawned by the server")]
    public bool blockServerChinooks;
    [JsonProperty(PropertyName = "Block Patrol Helicopters spawned by the server")]
    public bool blockServerPatrolHelicopters;
}


```

---

## EventsCore

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using System.Globalization;
using System.Threading.Tasks;
using System.Linq;
using System.Text;
using Oxide;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("EventsCore", "BadMandarin, Ryamkk", "1.2.1")]
[Description("EventsCore")]
 class EventsCore : RustPlugin
{
    [PluginReference]
     Plugin UniversalShop;
    [PluginReference]
     Plugin ServerRewards;
    [PluginReference]
     Plugin RustShop;
    private void LoadDefaultConfig();
    private string EventName_1;
    private string EventColor_1;
    private string EventText_1;
    private int EventTime_1;
    private string EventName_2;
    private string EventColor_2;
    private string EventText_2;
    private int EventTime_2;
    private float EventAutoStart;
    private int EventMaxPlayer;
    private bool Use_RustShop;
    private bool Use_ServerRewards;
    private bool Use_UniversalShop;
    private int BalanceAmount;
    private Timer EventsTimer;
    private Timer AutoETimer;
    private int curEvent;
    private int eTimeLeft;
    private bool eActive;
     List<eInfo> EventsList;
     Dictionary<ulong, EventsScores> eUsersScore;
     BasePlayer eLastLeader;
    private void Init();
     void OnServerInitialized();
    private void Unload();
     object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private string Layer;
    private void Draw_UIEvents(BasePlayer player);
    private string NotifyLayer;
    private void ShowNotify(BasePlayer player, string text);
    private void AutoStart();
    private string GetLeader();
    private void EventStart(int eventId);
    private void EventEnd();
    [ChatCommand("ev"), Permission("eventscore.admin")]
     void CMD_StartEvent(BasePlayer player, string command, string[] args);
    private void UpdateEventKing();
    private void UpdateEventFarm();
    private static string HexToRustFormat(string hex);
    private void GetConfig(string menu, string Key, T var);
     class EventsScores
    {
        public string UserName;
        public double UserScore;
    }

}

 class EventsScores
{
    public string UserName;
    public double UserScore;
}


```

---

## Everlight

```csharp
using System;

Oxide.Plugins
[Info("Everlight", ".legaCypowers", "1.0.0")]
[Description("Disable the consumption of fuel on light items like Lantern")]
 class Everlight : RustPlugin
{
     void Init();
     void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable);
}


```

---

## EvoCop

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Rust;
using System.Linq;
using System.Globalization;

Oxide.Plugins
[Info("EvoCop", "Urust", "0.0.01", ResourceId = 0)]
 class EvoCop : RustPlugin
{
    [PluginReference]
     Plugin Spawns;
     Plugin Craft;
    private static EvoCop ins;
    const string copPrefab;
    private bool initialized;
    private void Loaded();
    private void OnServerInitialized();
    private void OnPlayerInput(BasePlayer player, InputState input);
    private BaseEntity SpawnAtLocation(Vector3 position, Quaternion rotation, bool enableSaving, bool isExternallyManaged, bool repairEnabled, bool disableFuel, bool disableSecurity, bool disableCollision);
    [ChatCommand("cop")]
     void CmdSpawnCarUser(BasePlayer player, string command, string[] args);
    private ConfigData configData;
    private ItemBlueprint bp;
    private ItemDefinition def;
     class ConfigData
    {
        [JsonProperty(PropertyName = "Options")]
        public Options options { get; set; }
        public class Options
        {
            [JsonProperty(PropertyName = "Включить крафт minicopter за ресурсы?")]
            public bool copCraft { get; set; }
            [JsonProperty(PropertyName = "Ресурсы для крафта minicopter (ShortName - Amount)")]
            public Dictionary<string, int> CraftItems;
        }

        public Oxide.Core.VersionNumber Version { get; set; }
    }

    public int Amount;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private ConfigData GetBaseConfig();
    private void UpdateConfigValues();
     string msg(string key, string playerId);
     Dictionary<string, string> Messages;
}

 class ConfigData
{
    [JsonProperty(PropertyName = "Options")]
    public Options options { get; set; }
    public class Options
    {
        [JsonProperty(PropertyName = "Включить крафт minicopter за ресурсы?")]
        public bool copCraft { get; set; }
        [JsonProperty(PropertyName = "Ресурсы для крафта minicopter (ShortName - Amount)")]
        public Dictionary<string, int> CraftItems;
    }

    public Oxide.Core.VersionNumber Version { get; set; }
}

public class Options
{
    [JsonProperty(PropertyName = "Включить крафт minicopter за ресурсы?")]
    public bool copCraft { get; set; }
    [JsonProperty(PropertyName = "Ресурсы для крафта minicopter (ShortName - Amount)")]
    public Dictionary<string, int> CraftItems;
}


```

---

## Exchanger

```csharp
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Exchanger", "Sempai#3239", "2.0.0")]
public class Exchanger : RustPlugin
{
    protected override void LoadDefaultMessages();
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty("Использовать магазин GameStore (Если OVH то ставим False)")]
        public bool UseGameStore;
        [JsonProperty("[GameStores] ID магазина")]
        public string ShopID;
        [JsonProperty("[GameStores] ID сервера")]
        public string ServerID;
        [JsonProperty("[GameStores] Секретный ключ")]
        public string SecretKey;
        [JsonProperty("Команда для открытия обменника")]
        public string OpenEX;
        [JsonProperty("Настройка обменника")]
        public Dictionary<string, CustomItem> customs;
        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class CustomItem
    {
        internal class Exchange
        {
            [JsonProperty("Обмен на какой предмет")]
            public string SecondItemName;
            [JsonProperty("Необходимое количество для обмена")]
            public int FirstAmount;
        }

        [JsonProperty("Отображаемое имя")]
        public string DisplayName;
        [JsonProperty("Название предмета который он будет заменять")]
        public string ReplaceShortName;
        [JsonProperty(PropertyName = "Контейнер тз которого может выпасть этот предмет и процент выпадения")]
        public Dictionary<string, int> containerList;
        [JsonProperty("Кол-вл выпадения")]
        public int DropAmount;
        [JsonProperty("Ссылка на изображение")]
        public string PictureURL;
        [JsonProperty("Скин ID предмета")]
        public ulong ReplaceID;
        [JsonProperty("Курс обмена предмета")]
        public Exchange ExchangeOptions;
        public int GetItemId();
        public int GetItemAmount(BasePlayer player);
        public Item Copy(int amount);
        public void CreateItem(BasePlayer player, Vector3 position, int amount);
        public bool CanExchange(BasePlayer player);
    }

    [PluginReference]
    private readonly Plugin ImageLibrary;
    private readonly Plugin IQChat;
    private static readonly System.Random Rnd;
    private void OnServerInitialized();
    private void AddEmeralds(LootContainer cont);
    private void OnLootSpawn(LootContainer container);
    private object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem);
    private object CanStackItem(Item item, Item targetItem);
    [ConsoleCommand("emerald.give")]
    private void CmdConsoleGive(ConsoleSystem.Arg args);
    [ConsoleCommand("exchangeUI")]
    private void cmdConsoleHandler(ConsoleSystem.Arg args);
    [ConsoleCommand("emeralds")]
    private void ConsoleOpenMenu(ConsoleSystem.Arg arg);
    private void cmdChatEmerald(BasePlayer player, string command, string[] args);
    private const string Layer;
    private void UI_DrawExchange(BasePlayer player);
    public void SendChat(string Descrip, string Message, BasePlayer player, Chat.ChatChannel channel);
    private string HexToRustFormat(string hex);
}

private class Configuration
{
    [JsonProperty("Использовать магазин GameStore (Если OVH то ставим False)")]
    public bool UseGameStore;
    [JsonProperty("[GameStores] ID магазина")]
    public string ShopID;
    [JsonProperty("[GameStores] ID сервера")]
    public string ServerID;
    [JsonProperty("[GameStores] Секретный ключ")]
    public string SecretKey;
    [JsonProperty("Команда для открытия обменника")]
    public string OpenEX;
    [JsonProperty("Настройка обменника")]
    public Dictionary<string, CustomItem> customs;
    public static Configuration GetNewConfiguration();
}

private class CustomItem
{
    internal class Exchange
    {
        [JsonProperty("Обмен на какой предмет")]
        public string SecondItemName;
        [JsonProperty("Необходимое количество для обмена")]
        public int FirstAmount;
    }

    [JsonProperty("Отображаемое имя")]
    public string DisplayName;
    [JsonProperty("Название предмета который он будет заменять")]
    public string ReplaceShortName;
    [JsonProperty(PropertyName = "Контейнер тз которого может выпасть этот предмет и процент выпадения")]
    public Dictionary<string, int> containerList;
    [JsonProperty("Кол-вл выпадения")]
    public int DropAmount;
    [JsonProperty("Ссылка на изображение")]
    public string PictureURL;
    [JsonProperty("Скин ID предмета")]
    public ulong ReplaceID;
    [JsonProperty("Курс обмена предмета")]
    public Exchange ExchangeOptions;
    public int GetItemId();
    public int GetItemAmount(BasePlayer player);
    public Item Copy(int amount);
    public void CreateItem(BasePlayer player, Vector3 position, int amount);
    public bool CanExchange(BasePlayer player);
}

internal class Exchange
{
    [JsonProperty("Обмен на какой предмет")]
    public string SecondItemName;
    [JsonProperty("Необходимое количество для обмена")]
    public int FirstAmount;
}


```

---

## ExplosionTracker

```csharp
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using System.Linq;
using Rust;

Oxide.Plugins
[Info("Explosion Tracker", "PaiN", 0.7, ResourceId = 1282)]
[Description("This plugin tracks every explosion that happens in the server.")]
 class ExplosionTracker : RustPlugin
{
    private bool Changed;
    private bool logtofile;
    private bool logtorcon;
     void Loaded();
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
     void OnExplosiveThrown(BasePlayer player, BaseEntity entity);
     void OnRocketLaunched(BasePlayer player, BaseEntity entity);
}


```

---

## ExplosivesModifier

```csharp
using System;
using System.Collections.Generic;
using Rust;

Oxide.Plugins
[Info("Explosives Modifier", "Mughisi", 1.3, ResourceId = 832)]
 class ExplosivesModifier : RustPlugin
{
    private bool configChanged;
    private const string DefaultChatPrefix;
    private const string DefaultChatPrefixColor;
    public string ChatPrefix { get; set; }
    public string ChatPrefixColor { get; set; }
    private const float DefaultExplosiveChargeDamageModifier;
    private const float DefaultExplosiveChargeRadiusModifier;
    public float ExplosiveChargeDamageModifier { get; set; }
    public float ExplosiveChargeRadiusModifier { get; set; }
    private const float DefaultF1GrenadeDamageModifier;
    private const float DefaultF1GrenadeRadiusModifier;
    private const bool DefaultF1GrenadeSticky;
    public float F1GrenadeDamageModifier { get; set; }
    public float F1GrenadeRadiusModifier { get; set; }
    public bool F1GrenadeSticky { get; set; }
    private const float DefaultBeancanGrenadeDamageModifier;
    private const float DefaultBeancanGrenadeRadiusModifier;
    private const bool DefaultBeancanGrenadeSticky;
    public float BeancanGrenadeDamageModifier { get; set; }
    public float BeancanGrenadeRadiusModifier { get; set; }
    public bool BeancanGrenadeSticky { get; set; }
    private const float DefaultRocketDamageModifier;
    private const float DefaultRocketRadiusModifier;
    public float RocketDamageModifier { get; set; }
    public float RocketRadiusModifier { get; set; }
    private const float DefaultExplosiveAmmoDamageModifier;
    public float ExplosiveAmmoDamageModifier { get; set; }
    private const string DefaultHelpTextPlayersExplosiveCharge;
    private const string DefaultHelpTextPlayersF1Grenade;
    private const string DefaultHelpTextPlayersBeancanGrenade;
    private const string DefaultHelpTextPlayersRocket;
    private const string DefaultHelpTextPlayersExplosiveAmmo;
    private const string DefaultHelpTextAdmins;
    private const string DefaultModified;
    private const string DefaultSticky;
    private const string DefaultNotAllowed;
    private const string DefaultInvalidArguments;
    public string HelpTextPlayersExplosiveCharge { get; set; }
    public string HelpTextPlayersF1Grenade { get; set; }
    public string HelpTextPlayersBeancanGrenade { get; set; }
    public string HelpTextPlayersRocket { get; set; }
    public string HelpTextPlayersExplosiveAmmo { get; set; }
    public string HelpTextAdmins { get; set; }
    public string Modified { get; set; }
    public string Sticky { get; set; }
    public string NotAllowed { get; set; }
    public string InvalidArguments { get; set; }
    private readonly string[] weaponDamageTypes;
    private readonly string[] weaponRadiusTypes;
    protected override void LoadDefaultConfig();
    private void Loaded();
    private void LoadConfiguration();
    [ChatCommand("explosivedamage")]
     void ExplosiveDamage(BasePlayer player, string command, string[] args);
    [ChatCommand("explosiveradius")]
     void ExplosiveRadius(BasePlayer player, string command, string[] args);
    [ChatCommand("stickygrenades")]
     void StickyGrenades(BasePlayer player, string command, string[] args);
     void ChangeExplosive(BasePlayer player, string command, string[] args, string type);
     void OnWeaponThrown(BasePlayer player, BaseEntity entity);
     void OnRocketLaunched(BasePlayer player, BaseEntity entity);
     void OnEntityTakeDamage(BaseEntity entity, HitInfo info);
     void SendHelpText(BasePlayer player);
    private bool IsValidType(string command, string type);
     void SendChatMessage(BasePlayer player, string message, object[] arguments);
     bool IsAllowed(BasePlayer player);
     T GetConfigValue(string category, string setting, T defaultValue);
     void SetConfigValue(string category, string setting, object newValue);
}


```

---

## ExplosiveWeapons

```csharp
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using ConVar;
using System.IO;
using System.Text;
using Network;
using UnityEngine;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("ExplosiveWeapons", "Cameron", "1.0.8")]
[Description("Custom rocket launchers and weapon to make sutff go boom boom, flash flash and owow")]
public class ExplosiveWeapons : CovalencePlugin
{
     int bigRocketCount;
     int littleRocketCount;
     bool jerichoBlowUp;
     bool heatSeekerBlowUp;
     bool followBlowUp;
     bool javalinBlowUp;
     int xSize;
     int ySize;
     int maxRange;
     int scatterSize;
     float flashDuration;
     ulong jericoSkin;
     ulong seekerSkin;
     ulong trackSkin;
     ulong javalin;
     ulong multiGrenadeSkin;
     ulong molatoveGrenade;
     ulong flashBangSkin;
     ulong healingSkin;
     ulong impactNadeSkin;
     ulong stunGrenadeSkin;
     int instaHealAmount;
     int passiveHealAmount;
     bool spawnFlares;
     int stunDuration;
     HashSet<ulong> skins;
    private void Init();
    protected override void LoadDefaultConfig();
    [Command("GiveJerico"),Permission("explosiveweapons.admin")]
    private void JericoGive(IPlayer iplayer, string command, string[] args);
    [Command("GiveSeeker"), Permission("explosiveweapons.admin")]
    private void GiveSeeker(IPlayer iplayer, string command, string[] args);
    [Command("GiveFollow"), Permission("explosiveweapons.admin")]
    private void GiveFollow(IPlayer iplayer, string command, string[] args);
    [Command("GiveJav"), Permission("explosiveweapons.admin")]
    private void GiveJav(IPlayer iplayer, string command, string[] args);
    [Command("givemulti"), Permission("explosiveweapons.admin")]
    private void givemulti(IPlayer iplayer, string command, string[] args);
    [Command("givemoly"), Permission("explosiveweapons.admin")]
    private void GiveMolly(IPlayer iplayer, string command, string[] args);
    [Command("giveflash"), Permission("explosiveweapons.admin")]
    private void giveflash(IPlayer iplayer, string command, string[] args);
    [Command("giveimpact"), Permission("explosiveweapons.admin")]
    private void giveimpact(IPlayer iplayer, string command, string[] args);
    [Command("givestun"), Permission("explosiveweapons.admin")]
    private void givestun(IPlayer iplayer, string command, string[] args);
    [Command("giveshealing"), Permission("explosiveweapons.admin")]
    private void givehealing(IPlayer iplayer, string command, string[] args);
    [Command("giveall"), Permission("explosiveweapons.admin")]
    private void giveallnades(IPlayer iplayer, string command, string[] args);
     void OnRocketLaunched(BasePlayer player, BaseEntity entity);
    private object OnExplosiveFuseSet(TimedExplosive ent, float fuseLength);
     object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem);
     object CanStackItem(Item item, Item targetItem);
    private void JavalinRocket(IPlayer iplayer);
    private void CursorRocket(Vector3 firePoint, Quaternion rot, BasePlayer player);
    private void TracerRocket(Vector3 firePoint, Quaternion rot, BaseCombatEntity target, BasePlayer owner);
    private List<BasePlayer> FindAllPlayersNear(Vector3 pos, float radius);
    private void HealPlayer(BasePlayer player);
    private void Jerico(IPlayer iplayer);
    private void SpawnRocket(Vector3 pos, Vector3 target, BasePlayer player, Quaternion rotation, Vector3 direction);
    private void SpawnSmallRocket(Vector3 pos, Vector3 target, BasePlayer player, ServerProjectile parentProjectile, Vector3 direction);
    private static void PlayEffect(string effect, BaseEntity entity);
    private void MakeUi(BasePlayer player);
    public class OnCollision : MonoBehaviour
    {
        public BaseEntity ent { get; set; }
         void OnCollisionEnter(Collision collision);
    }

    public class OnCollisionExplode : MonoBehaviour
    {
        public TimedExplosive ent { get; set; }
         void OnCollisionEnter(Collision collision);
    }

}

public class OnCollision : MonoBehaviour
{
    public BaseEntity ent { get; set; }
     void OnCollisionEnter(Collision collision);
}

public class OnCollisionExplode : MonoBehaviour
{
    public TimedExplosive ent { get; set; }
     void OnCollisionEnter(Collision collision);
}


```

---

## ExternalWallStack

```csharp
using System;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("ExternalWallStack", "Dyceman - Deadlaugh (Dan)", "1.0.0", ResourceId = 0)]
[Description("Allows the players to stack high external walls on top of each other.")]
 class ExternalWallStack : RustPlugin
{
    private bool HasRunPermission(BasePlayer player, string cmdPermission);
    private HashSet<ExternalWallLink> CreateStackWall(int amount, BaseEntity entity, BasePlayer player);
     T GetConfig(string name, T value);
     class ExternalWallLink
    {
         GameObject gameObject;
        public bool isRemoving;
        public ExternalWallLink(GameObject go);
        public BaseEntity entity();
    }

     class ExternalWallController : MonoBehaviour
    {
         HashSet<ExternalWallLink> links;
         void Awake();
        public HashSet<ExternalWallLink> entityLinks();
        public void addLink(ExternalWallLink linkEntity);
    }

    [PluginReference]
     Plugin RemoverTool;
     int configStackHeight;
     bool configUsePermission;
     bool configRequireMaterials;
     string pluginPermission;
     string pluginName;
     string pluginColor;
     List<BaseEntity> removingEntity;
     HashSet<ulong> playerToggleCommand;
    protected override void LoadDefaultConfig();
     void Init();
     void OnServerInitialized();
     void Unload();
     void OnPlayerDisconnected(BasePlayer player, string reason);
     void OnEntityBuilt(Planner planner, GameObject gameObject);
     void OnRemovedEntity(BaseEntity entity);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    [ChatCommand("wstack"), Permission("externalwallstack.wstack")]
    private void cmdWStack(BasePlayer player, string command, string[] args);
}

 class ExternalWallLink
{
     GameObject gameObject;
    public bool isRemoving;
    public ExternalWallLink(GameObject go);
    public BaseEntity entity();
}

 class ExternalWallController : MonoBehaviour
{
     HashSet<ExternalWallLink> links;
     void Awake();
    public HashSet<ExternalWallLink> entityLinks();
    public void addLink(ExternalWallLink linkEntity);
}


```

---

## ExtraSeating

```csharp
using System;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Extra Seating", "Pho3niX90", "1.0.8")]
[Description("Allows extra seats on minicopters and horses")]
 class ExtraSeating : RustPlugin
{
    public PluginConfig config;
    static ExtraSeating _instance;
     bool debug;
     int seats;
    protected override void LoadDefaultConfig();
    public PluginConfig GetDefaultConfig();
    public class PluginConfig
    {
        public bool EnableMiniSideSeats;
        public bool EnableMiniBackSeat;
        public bool EnableExtraHorseSeat;
    }

    private void Init();
     void LogDebug(string str);
     void OnEntitySpawned(BaseNetworkable entity);
     void AddSeat(BaseVehicle ent, Vector3 locPos, Quaternion q);
    [ChatCommand("checkmount")]
    private void cmdStats(BasePlayer player, string command, string[] args);
     BaseVehicle.MountPointInfo CreateMount(Vector3 vec, BaseVehicle.MountPointInfo exampleSeat, Vector3 rotation);
     class HorsePassenger : BaseRidableAnimal
    {
        override public void PlayerServerInput(InputState inputState, BasePlayer player);
    }

     class Seating : MonoBehaviour
    {
        public BaseVehicle entity;
         void Awake();
    }

}

public class PluginConfig
{
    public bool EnableMiniSideSeats;
    public bool EnableMiniBackSeat;
    public bool EnableExtraHorseSeat;
}

 class HorsePassenger : BaseRidableAnimal
{
    override public void PlayerServerInput(InputState inputState, BasePlayer player);
}

 class Seating : MonoBehaviour
{
    public BaseVehicle entity;
     void Awake();
}


```

---

## F1Spawn

```csharp
using System;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("F1Spawn", "Colon Blow", "1.0.3")]
[Description("Allows use of F1 Item List Spawn")]
 class F1Spawn : CovalencePlugin
{
    const string permBL1;
    const string permBL2;
    const string permAL1;
    const string permAL2;
    const string permALL;
    private void OnServerInitialized();
     bool isAllowed(BasePlayer player, string perm);
    private static PluginConfig config;
    private class PluginConfig
    {
        [JsonProperty(PropertyName = "Bypass checks if Admin ? ")]
        public bool AdminBypass { get; set; }
        [JsonProperty(PropertyName = "Bypass checks if Moderator ? ")]
        public bool ModBypass { get; set; }
        [JsonProperty(PropertyName = "Blacklist 1 Items : ")]
        public List<string> BlackListedItems1 { get; set; }
        [JsonProperty(PropertyName = "Blacklist 2 Items : ")]
        public List<string> BlackListedItems2 { get; set; }
        [JsonProperty(PropertyName = "Allowed list 1 Items : ")]
        public List<string> AllowListItems1 { get; set; }
        [JsonProperty(PropertyName = "Allowed list 2 Items : ")]
        public List<string> AllowListItems2 { get; set; }
        public static PluginConfig DefaultConfig();
    }

    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    [Command("inventory.giveid")]
     void GiveIdCommand(IPlayer player, string command, string[] args);
     object OnServerCommand(ConsoleSystem.Arg arg);
}

private class PluginConfig
{
    [JsonProperty(PropertyName = "Bypass checks if Admin ? ")]
    public bool AdminBypass { get; set; }
    [JsonProperty(PropertyName = "Bypass checks if Moderator ? ")]
    public bool ModBypass { get; set; }
    [JsonProperty(PropertyName = "Blacklist 1 Items : ")]
    public List<string> BlackListedItems1 { get; set; }
    [JsonProperty(PropertyName = "Blacklist 2 Items : ")]
    public List<string> BlackListedItems2 { get; set; }
    [JsonProperty(PropertyName = "Allowed list 1 Items : ")]
    public List<string> AllowListItems1 { get; set; }
    [JsonProperty(PropertyName = "Allowed list 2 Items : ")]
    public List<string> AllowListItems2 { get; set; }
    public static PluginConfig DefaultConfig();
}


```

---

## FastMenu

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("FastMenu", "lilmagg", "1.0.0")]
public class FastMenu : RustPlugin
{
    [PluginReference]
     Plugin ImageLibrary;
    private string Layer11;
    private string Layer;
    private string Layer1;
    private string Layer2;
    private string Layer3;
    private CuiElementContainer currentContainer;
    private void Unload();
     void OnServerInitialized();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDeath(BasePlayer player, HitInfo info);
    private void OnPlayerRespawned(BasePlayer player);
    private void UI_DrawInterface12(BasePlayer player);
    private void UI_DrawInterface123(BasePlayer player);
    private void UI_DrawInterface1(BasePlayer player);
    private void UI_DrawInterface2(BasePlayer player);
}


```

---

## FastOvens

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Fast Ovens", "Orange", "1.0.6")]
[Description("Make your ovens smelt faster")]
public class FastOvens : RustPlugin
{
    private void OnFuelConsume(BaseOven oven, Item item, ItemModBurnable burnable);
    private void SmeltItems(BaseOven oven);
    private static void Smelt(BaseOven oven, Item cookingItem, int smeltRate, ItemDefinition targetDef, int targetMultiplier);
    private int GetRate(string shortname);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Work with campfires")]
        public bool workWithCampfires;
        [JsonProperty("Stop burning food")]
        public bool stopBurningFood;
        [JsonProperty(PropertyName = "Charcoal multiplier")]
        public int charcoalMultiplier;
        [JsonProperty(PropertyName = "Rates")]
        public Dictionary<string, int> rates;
    }

    protected override void LoadConfig();
    private static void ValidateConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Work with campfires")]
    public bool workWithCampfires;
    [JsonProperty("Stop burning food")]
    public bool stopBurningFood;
    [JsonProperty(PropertyName = "Charcoal multiplier")]
    public int charcoalMultiplier;
    [JsonProperty(PropertyName = "Rates")]
    public Dictionary<string, int> rates;
}


```

---

## FauxAdmin

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("FauxAdmin", "Colon Blow", "1.0.4", ResourceId = 1933)]
 class FauxAdmin : RustPlugin
{
    public bool DisableFlyHackProtection { get; set; }
    public bool DisableNoclipProtection { get; set; }
    public bool DisableFauxAdminDemolish { get; set; }
    public bool DisableFauxAdminRotate { get; set; }
    public bool DisableFauxAdminUpgrade { get; set; }
    public bool AllowGodModeToggle { get; set; }
    public bool DisableNoclipOnNoBuild { get; set; }
     Dictionary<ulong, RestrictedData> _restricted;
     class RestrictedData
    {
        public BasePlayer player;
    }

    protected override void LoadDefaultConfig();
     void Loaded();
     Dictionary<string, string> messages;
    [ChatCommand("noclip")]
     void cmdChatnoclip(BasePlayer player, string command, string[] args);
     void OnPlayerTick(BasePlayer player);
    private void DeactivateNoClip(BasePlayer player, Vector3 newPos);
     object OnStructureDemolish(BuildingBlock block, BasePlayer player);
     object OnStructureRotate(BuildingBlock block, BasePlayer player);
     object OnStructureUpgrade(BuildingBlock block, BasePlayer player);
     void OnPlayerSleepEnded(BasePlayer player);
     bool isAllowed(BasePlayer player, string perm);
}

 class RestrictedData
{
    public BasePlayer player;
}


```

---

## FauxClip

```csharp
using System;
using Rust;
using System.Reflection;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("FauxClip", "Colon Blow", "1.3.6", ResourceId = 1299)]
 class FauxClip : RustPlugin
{
    public float GracefulLandingTime { get; set; }
    public float BaseNoClipSpeed { get; set; }
    public float SprintNoClipSpeed { get; set; }
    public float TurboNoClipSpeed { get; set; }
    public bool UseFauxClipGodMode { get; set; }
    protected override void LoadDefaultConfig();
     class PlayerData
    {
        public BasePlayer player;
        public float speed;
        public Vector3 oldPos;
        public InputState input;
    }

     class LandingData
    {
        public BasePlayer player;
    }

    private readonly Dictionary<ulong, PlayerData> _noclip;
    private readonly Dictionary<ulong, LandingData> _landing;
    private static readonly FieldInfo ServerInput;
    public static FieldInfo lastPositionValue;
     void Loaded();
     void OnFrame();
     bool noAdmin(BasePlayer player);
     bool noBuild(BasePlayer player);
     void DamageOn(BasePlayer player);
     void DamageOff(BasePlayer player);
     object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
     void Deactivatenoclip(BasePlayer player);
     void Restrictedairspace(BasePlayer player);
     void Activatenoclip(BasePlayer player, float speed);
     void Togglenoclip(BasePlayer player, float speed);
     void LandingCycleDone(BasePlayer player);
    [ChatCommand("noclip")]
     void cmdChatnolcip(BasePlayer player, string command, string[] args);
     void OnPlayerRespawned(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
     bool isAllowed(BasePlayer player, string perm);
}

 class PlayerData
{
    public BasePlayer player;
    public float speed;
    public Vector3 oldPos;
    public InputState input;
}

 class LandingData
{
    public BasePlayer player;
}


```

---

## FHitMarker

```csharp
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("FHitMarker", "Molik", "1.0.4")]
 class FHitMarker : RustPlugin
{
    private ConfigData _config;
    public class ConfigData
    {
        [JsonProperty("Использовать иконку попадания: ")]
        public bool UseHit;
        [JsonProperty("Через сколько пропадет маркер: ")]
        public float TimeToDestroy;
        [JsonProperty("Цвет которым отмечаются друзья: ")]
        public string ColorToFriend;
        public static ConfigData GetNewCong();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    [PluginReference]
    private Plugin ImageLibrary;
    private void OnServerInitialized();
     void LoadImages();
     Dictionary<string, string> Images;
    private void OnPlayerAttack(BasePlayer attacker, HitInfo info);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void OnPlayerWound(BasePlayer player);
    private void HitGUI(BasePlayer attacker, string text);
    private void HitPng(BasePlayer attacker, string png, string check);
}

public class ConfigData
{
    [JsonProperty("Использовать иконку попадания: ")]
    public bool UseHit;
    [JsonProperty("Через сколько пропадет маркер: ")]
    public float TimeToDestroy;
    [JsonProperty("Цвет которым отмечаются друзья: ")]
    public string ColorToFriend;
    public static ConfigData GetNewCong();
}


```

---

## FilterExt

```csharp
using System.Linq;
using Oxide.Game.Rust;

Oxide.Plugins
[Info("FilterExt", "Wulf/lukespragg", 0.1)]
[Description("Extension to Oxide's filter for removing unwanted messages.")]
 class FilterExt : RustPlugin
{
     void Loaded();
}


```

---

## Finder

```csharp
using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Finder", "Reneb", "3.0.2", ResourceId = 692)]
 class Finder : RustPlugin
{
    [PluginReference]
     Plugin PlayerDatabase;
     Dictionary<ulong, PlayerFinder> cachedFinder;
    static string findPermission;
    static int findAuthlevel;
    protected override void LoadDefaultConfig();
    private void CheckCfg(string Key, T var);
     void Init();
     void Loaded();
     bool hasPermission(BasePlayer player, string perm, int authLevel);
     string GetMsg(string key, BasePlayer player);
     class FindData
    {
         string Name;
        public Vector3 Pos;
         string TypeName;
        public FindData(string TypeName, Vector3 Pos, string Name);
        public override string ToString();
    }

     class PlayerFinder
    {
         string Name;
         string Id;
         bool Online;
        public List<FindData> Data;
        public PlayerFinder(string Name, string Id, bool Online);
        public void AddFind(string TypeName, Vector3 Pos, string Name);
        public override string ToString();
    }

     PlayerFinder GetPlayerInfo(ulong userID);
    private object FindPosition(ulong userID);
    private object FindPlayerID(string arg, BasePlayer source);
     string Find(BasePlayer player, string[] args);
     bool IsOwned(Item item, ulong userid);
    [ChatCommand("find")]
     void cmdChatFind(BasePlayer player, string command, string[] args);
    [ConsoleCommand("finder.find")]
     void cmdConsoleFind(ConsoleSystem.Arg arg);
}

 class FindData
{
     string Name;
    public Vector3 Pos;
     string TypeName;
    public FindData(string TypeName, Vector3 Pos, string Name);
    public override string ToString();
}

 class PlayerFinder
{
     string Name;
     string Id;
     bool Online;
    public List<FindData> Data;
    public PlayerFinder(string Name, string Id, bool Online);
    public void AddFind(string TypeName, Vector3 Pos, string Name);
    public override string ToString();
}


```

---

## FineName

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;

Oxide.Plugins
[Info("FineName", "Nimant", "1.0.7")]
 class FineName : RustPlugin
{
    private static List<string> Changed;
    private void OnServerInitialized();
    private void OnUserConnected(IPlayer player);
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    [ConsoleCommand("fn.test")]
    private void ccmdTestName(ConsoleSystem.Arg arg);
    private void CheckName(IPlayer player);
    private static bool IsNeedChangeName(string oldName, string userID, string newName, bool isSilent);
    private static string RemoveBadWord(string oldStr, string word);
    private static bool IsNeedChangeNameByBadSymbols(string name);
    private static float WeightChar(char ch);
    private static string GetRandomUserName(ulong v);
    private static string RenameHtmlBrackets(string text);
    private static string RemoveLinkText(string text);
    private void Init();
    private static ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Удалять ссылки с имен")]
        public bool IsDelLinks;
        [JsonProperty(PropertyName = "Заменять в именах угловые скобки на безопасные")]
        public bool IsNoHtmlTags;
        [JsonProperty(PropertyName = "Считать имя нормальным если есть такое число последовательных нормальных символов")]
        public int GoodLenChars;
        [JsonProperty(PropertyName = "Разрешенный процент плохих символов в имени")]
        public int BadPercent;
        [JsonProperty(PropertyName = "Запрещенные фразы")]
        public List<string> BadList;
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void SaveConfig(ConfigData config);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Удалять ссылки с имен")]
    public bool IsDelLinks;
    [JsonProperty(PropertyName = "Заменять в именах угловые скобки на безопасные")]
    public bool IsNoHtmlTags;
    [JsonProperty(PropertyName = "Считать имя нормальным если есть такое число последовательных нормальных символов")]
    public int GoodLenChars;
    [JsonProperty(PropertyName = "Разрешенный процент плохих символов в имени")]
    public int BadPercent;
    [JsonProperty(PropertyName = "Запрещенные фразы")]
    public List<string> BadList;
}


```

---

## FireArrows

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("FireArrows", "Colon Blow", "1.2.3")]
 class FireArrows : RustPlugin
{
    [PluginReference]
     Plugin ZoneManager;
     bool Changed;
     Dictionary<ulong, FireArrowData> FireArrowOn;
     Dictionary<ulong, FireBallData> FireBallOn;
     Dictionary<ulong, FireBombData> FireBombOn;
     Dictionary<ulong, string> GuiInfoFA;
     class FireArrowData
    {
        public BasePlayer player;
    }

     class FireBombData
    {
        public BasePlayer player;
    }

     class FireBallData
    {
        public BasePlayer player;
    }

     void Loaded();
     void Unload();
     void LoadDefaultConfig();
    static bool ShowArrowTypeIcon;
    static bool BlockinRestrictedZone;
    static bool UseProt;
    static float DamageFireArrow;
    static float DamageFireBall;
    static float DamageFireBomb;
    static float DamageRadius;
    static float DurationFireArrow;
    static float DurationFireBallArrow;
    static float DurationFireBombArrow;
    static string RestrictedZoneID;
    static int cloth;
    static int fuel;
    static int oil;
    static int explosives;
    private string IconFireArrow;
    private string IconFireBall;
    private string IconFireBomb;
     bool isRestricted;
    private void LoadVariables();
    private void LoadConfigVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
     object GetConfig(string menu, string datavalue, object defaultValue);
     Dictionary<string, string> messagesFA;
     void OnPlayerAttack(BasePlayer player, HitInfo hitInfo);
     void ArrowFX(BasePlayer player, HitInfo hitInfo);
     void FireArrowFX(BasePlayer player, HitInfo hitInfo);
     void FireBallFX(BasePlayer player, HitInfo hitInfo);
     void FireBombFX(BasePlayer player, HitInfo hitInfo);
     void applyBlastDamage(BasePlayer player, float damageamount, Rust.DamageType damagetype, HitInfo hitInfo);
     void playerBlastDamage(BasePlayer player, float damageamount, Rust.DamageType damagetype, HitInfo hitInfo);
     void OnPlayerInput(BasePlayer player, InputState input);
    [ChatCommand("firearrow")]
     void cmdChatfirearrow(BasePlayer player, string command, string[] args);
    [ConsoleCommand("firearrow")]
     void cmdConsolefirearrow(ConsoleSystem.Arg arg);
     void ToggleArrowType(BasePlayer player);
     void NormalArrowToggle(BasePlayer player);
     void FireArrowToggle(BasePlayer player);
     void FireBallToggle(BasePlayer player);
     void FireBombToggle(BasePlayer player);
     bool hasResources(BasePlayer player);
     void ArrowCui(BasePlayer player);
     void ArrowGui(BasePlayer player);
     bool notZoneRestricted(BasePlayer player);
     void tellNotGrantedArrow(BasePlayer player);
     void tellDoesNotHaveMaterials(BasePlayer player);
     void tellRestricted(BasePlayer player);
     bool IsAllowed(BasePlayer player, string perm);
     bool usingCorrectWeapon(BasePlayer player);
     void DestroyCui(BasePlayer player);
     void DestroyArrowData(BasePlayer player);
     void OnPlayerRespawned(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
}

 class FireArrowData
{
    public BasePlayer player;
}

 class FireBombData
{
    public BasePlayer player;
}

 class FireBallData
{
    public BasePlayer player;
}


```

---

## FireSword

```csharp
using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

Oxide.Plugins
[Info("FireSword", "ColonBlow", "1.1.8")]
public class FireSword : RustPlugin
{
     void Loaded();
     bool Changed;
     bool isAllowed(BasePlayer player, string perm);
    static Dictionary<ulong, ToggleFireData> FireOn;
     class ToggleFireData
    {
        public BasePlayer player;
    }

    [ChatCommand("firesword")]
     void chatFireSword(BasePlayer player, string command);
    [ConsoleCommand("firesword")]
     void cmdConsoleFireSword(ConsoleSystem.Arg arg);
    static float FSChance;
    static float FSHeatDamage;
    static float FSExplosionDamage;
    static float DamageRadius;
    static bool UseProt;
    static bool LootAndUse;
    static bool DamageConditionOnThrow;
    static ulong CustomSkinID;
    static bool MatsToBuild;
    static int AmountToBuild;
    static int ReqBuildItemID;
    static bool UseMats;
    static int AmountReq1;
    static int Req1ItemID;
    static int AmountReq2;
    static int Req2ItemID;
    private void LoadVariables();
     void LoadDefaultConfig();
    private void LoadConfigVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
     void CheckCfgUlong(string Key, ulong var);
     Dictionary<string, string> messagesFA;
     class FlameWeapon : MonoBehaviour
    {
         BasePlayer player;
         BaseEntity flame;
         BaseEntity playerweapon;
         FireBall fireball;
         Vector3 pos;
         Quaternion rot;
         string prefab;
         void Awake();
         void FixedUpdate();
         void SpawnFireEffects();
         bool HasItem1Mats(BasePlayer player);
         bool TakeItem1Mats(BasePlayer player);
         void OnDestroy();
    }

     void AddFireOn(BasePlayer player);
     void RemoveFireOn(BasePlayer player);
     bool ThrowWeaponHasFireOn(BasePlayer player);
    public void SpawnFireSword(ItemContainer itemContainer);
     void OnMeleeThrown(BasePlayer player, Item item);
     void OnPlayerAttack(BasePlayer player, HitInfo hitInfo);
     bool UsingSwordWeapon(BasePlayer player);
    static bool UsingFireWeapon(BasePlayer player);
     void WeaponThrowFX(BasePlayer player, Vector3 pos, HitInfo hitInfo);
     void WeaponStrikeFX(BasePlayer player, Vector3 pos, HitInfo hitInfo);
     void AddSwordDamage(BasePlayer player, float damageamount, Rust.DamageType damagetype, HitInfo hitInfo);
     void ThrowWeaponCondition(BasePlayer player, Item item);
     bool HasItem1Mats(BasePlayer player);
     bool HasItem2Mats(BasePlayer player);
     void AddFireSword(BasePlayer player);
     void ActivateWeapon(BasePlayer player);
     void ReplaceWithFireSword(BasePlayer player, Item playerweaponitem);
     bool CheckUpgradeMats(BasePlayer player, int itemID, int amount, string str);
     void ActivateFireSword(BasePlayer player, Item playerweaponitem);
     void Unload();
     void DestroyFireOnData(BasePlayer player);
    static void DestroyAll();
     void OnPlayerDisconnected(BasePlayer player, string reason);
     void OnPlayerRespawned(BasePlayer player);
}

 class ToggleFireData
{
    public BasePlayer player;
}

 class FlameWeapon : MonoBehaviour
{
     BasePlayer player;
     BaseEntity flame;
     BaseEntity playerweapon;
     FireBall fireball;
     Vector3 pos;
     Quaternion rot;
     string prefab;
     void Awake();
     void FixedUpdate();
     void SpawnFireEffects();
     bool HasItem1Mats(BasePlayer player);
     bool TakeItem1Mats(BasePlayer player);
     void OnDestroy();
}


```

---

## Fishing

```csharp
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using System.Reflection;
using Oxide.Game.Rust.Cui;
using Facepunch.Extend;

Oxide.Plugins
[Info("Fishing", "Colon Blow", "1.2.2", ResourceId = 1537)]
 class Fishing : RustPlugin
{
    public int fishchance;
    public int fishchancemodweapon;
    public int fishchancemodattire;
    public int fishchancemoditem;
    public int fishchancemodtime;
    public string FishIcon;
    public string chancetext1;
    public string chancetext2;
    public float currenttime;
    public float ghitDistance;
    public float whitDistance;
    private static int waterlayer;
    private static int groundlayer;
    private bool Changed;
     string randomlootprefab;
     Dictionary<ulong, string> GuiInfo;
     void Loaded();
     void LoadDefaultConfig();
     void OnServerInitialized();
     bool IsAllowed(BasePlayer player, string perm);
    public bool ShowFishCatchIcon;
    public bool allowrandomitemchance;
    public bool useweaponmod;
    public bool useattiremod;
    public bool useitemmod;
    public bool usetimemod;
    public int fishchancedefault;
    public int randomitemchance;
    public int fishchancemodweaponbonus;
    public int fishchancemodattirebonus;
    public int fishchancemoditembonus;
    public int fishchancemodtimebonus;
    public string iconcommonfish2;
    public string iconuncommonfish1;
    public string iconcommonfish1;
    public string iconrandomitem;
    public string iconrarefish1;
    private void LoadVariables();
    private void LoadConfigVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
     object GetConfig(string menu, string datavalue, object defaultValue);
     Dictionary<string, string> messages;
     void catchChanceMod(BasePlayer player);
     bool isLookingAtWater(BasePlayer player);
     void rollforfish(BasePlayer player, HitInfo hitInfo);
     void catchFishFX(BasePlayer player, HitInfo hitInfo);
     void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo);
     void catchFishCui(BasePlayer player);
     void FishingGui(BasePlayer player);
     void Unload();
     void DestroyCui(BasePlayer player);
    [ChatCommand("fishchance")]
     void cmdChatfishchance(BasePlayer player, string command, string[] args);
     void SpawnLootBox(BasePlayer player, HitInfo hitInfo);
}


```

---

## Fix

```csharp
using Oxide.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("Fix", "playermodel", "1.0.0")]
public class Fix : RustPlugin
{
     object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount);
}


```

---

## Flamethrower

```csharp
using Oxide.Core;
using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using System.Reflection;

Oxide.Plugins
[Info("Flamethrower", "Colon Blow", "1.2.0", ResourceId = 1498)]
 class Flamethrower : RustPlugin
{
    private float damageplayer { get; set; }
    private float damagebuilding { get; set; }
    private float damageNPC { get; set; }
    private float damageradius { get; set; }
    private bool prot { get; set; }
    private float ReloadTime { get; set; }
    private float gfminduration { get; set; }
    private float gfmaxduration { get; set; }
    private float gfspreadtime { get; set; }
    private float gfdps { get; set; }
    private float gfdamageradius { get; set; }
    private int fuel { get; set; }
    private int oil { get; set; }
    private bool weaponcanfail { get; set; }
    private float flametimer;
    private float flamestart;
    private bool addtoflamestart;
    private readonly Dictionary<ulong, PlayerData> _flamethrower;
     string entprefab;
     string fxprefab;
     string prefabweaponfailure;
     class PlayerData
    {
        public BasePlayer player;
    }

     void OnServerInitialized();
    protected override void LoadDefaultConfig();
     void Loaded();
     void LoadPermissions();
     bool IsAllowed(BasePlayer player, string perm);
     void OnPlayerInput(BasePlayer player, InputState input);
     void flameFX(BasePlayer player);
     void flamethrowerFX(BasePlayer player);
     void flameFXrepeater(BasePlayer player);
     void applyBlastDamage(BasePlayer player);
     void playerBlastDamage(BasePlayer player);
     void buildingBlastDamage(BasePlayer player);
     void npcBlastDamage(BasePlayer player);
     void chancetoFail(BasePlayer player);
}

 class PlayerData
{
    public BasePlayer player;
}


```

---

## FlashBang

```csharp
using UnityEngine;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System;
using System.Reflection;
using Oxide.Core;
using System.Linq;

Oxide.Plugins
[Info("FlashBang", "PaiN", "0.6", ResourceId = 1283)]
[Description("Replaces grenade with a flashbang grenade.")]
 class FlashBang : RustPlugin
{
     class Data
    {
        public List<FlashInfo> FlashInfo;
    }

     Data data;
     class FlashInfo
    {
        public int ID;
        public int Duration;
        public string Power;
        public int Radius;
        public FlashInfo(int num, int dur, string pow, int rad);
        public FlashInfo();
    }

     void Loaded();
     void UseUI(BasePlayer player, string strength);
     int GetNewId();
     void OnWeaponThrown(BasePlayer player, BaseEntity entity);
    [ChatCommand("fb")]
     void cmdFB(BasePlayer player, string cmd, string[] args);
     void Flash(BasePlayer player, BaseEntity entity);
     void Unloaded();
}

 class Data
{
    public List<FlashInfo> FlashInfo;
}

 class FlashInfo
{
    public int ID;
    public int Duration;
    public string Power;
    public int Radius;
    public FlashInfo(int num, int dur, string pow, int rad);
    public FlashInfo();
}


```

---

## Flaska

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Flaska", "TopPlugin.ru", "1.0.0")]
 class Flaska : RustPlugin
{
     void OnServerInitialized();
     object OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item);
     object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    [ConsoleCommand("flask_give")]
     void UraniumToolGive(ConsoleSystem.Arg args);
     Dictionary<ItemDefinition, ItemDefinition> Transmutations;
     List<string> MutationItemList;
     void MutationRegistered();
     void UseTools(BasePlayer player, Item item);
     void CreateItem(BasePlayer player);
}


```

---

## FlippableTurrets

```csharp
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Reflection;
using Network;
using ProtoBuf;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("FlippableTurrets", "DylanSMR", "1.0.4", ResourceId = 2055)]
 class FlippableTurrets : RustPlugin
{
    static int constructionColl;
    static FieldInfo serverinput;
    public InputState inputState;
    public string pf;
    public Dictionary<AutoTurret, int> turretinv;
    public Dictionary<AutoTurret, AutoPlayer> turretplayer;
    public class AutoPlayer
    {
        public List<ProtoBuf.PlayerNameID> players;
        public AutoPlayer();
    }

     void Loaded();
     Dictionary<string, string> messages;
    [ChatCommand("flipturret")]
     void cmdFlipTurret(BasePlayer player);
    [ChatCommand("unflipturret")]
     void cmdUnFlipTurret(BasePlayer player);
    private Item BuildItems(string shortname, int amount);
    static BaseEntity FindTurret(Ray ray, float distance);
    private bool flipTurreT(BaseEntity turret, BasePlayer player);
    private bool unflipTurreT(BaseEntity turret, BasePlayer player);
}

public class AutoPlayer
{
    public List<ProtoBuf.PlayerNameID> players;
    public AutoPlayer();
}


```

---

## ForestBerries

```csharp
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Forest Berries", "0xPani", "1.0.0")]
 class ForestBerries : RustPlugin
{
    private float chance;
     object OnCollectiblePickup(Item item, BasePlayer player);
}


```

---

## FortWars

```csharp
using System.Collections.Generic;
using System;
using UnityEngine;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using Rust;

Oxide.Plugins
[Info("FortWars", "Naleen", "0.3.3", ResourceId = 1618)]
 class FortWars : RustPlugin
{
    private bool BuildPhase;
    private bool StartedGame;
    private bool FWEnabled;
    private int TimeBuild;
    private int TimeFight;
    private int TimeHeli;
    private int TimeDropBuild;
    private int TimeDropFight;
    private int CraftBuild;
    private int CraftFight;
    private int HeliSpeed;
    private int HeliHP;
    private int HeliHPRudder;
    private int BuildGatherMulti;
    private int FightGatherMulti;
    private int DropBuild;
    private int DropFight;
    public string PhaseStr { get; set; }
     Dictionary<string, string> LangMessages;
    private static readonly Dictionary<string, object> DefaultGatherResourceModifiers;
    public Dictionary<string, float> GatherResourceModifiers { get; set; }
    public float CraftingRate { get; set; }
     List<ItemBlueprint> blueprintDefinitions;
    private static readonly Dictionary<string, object> DefaultIndividualRates;
    public Dictionary<string, float> Blueprints { get; set; }
    public Dictionary<string, float> IndividualRates { get; set; }
     List<ItemDefinition> itemDefinitions;
    public List<string> Items { get; set; }
    public List<Oxide.Plugins.Timer> AutoTimers;
     DateTime PhaseStart;
    public int GatherRate { get; set; }
    public float GatherPC;
    public int MinX { get; set; }
    public int MaxX { get; set; }
    public int MinY { get; set; }
    public int MaxY { get; set; }
    public int MinZ { get; set; }
    public int MaxZ { get; set; }
     void Loaded();
    private void LoadDefaultConfig();
     void OnServerInitialized();
     void LoadPermissions();
     void Unload();
    private void StartBuildPhase();
    private void StartFightPhase();
    private void StartHeliWaves();
    private void StartDropWaves();
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
     void OnEntitySpawned(BaseNetworkable entity);
    private void callHeli(int num);
    private void callDrop(int num);
    private void LoadConfigVariables();
    [ChatCommand("phase")]
    private void chatcmdPhase(BasePlayer player, string command, string[] arg);
    [ChatCommand("hell")]
    private void chatcmdHell(BasePlayer player, string command, string[] arg);
    [ChatCommand("drop")]
    private void chatcmdDrop(BasePlayer player, string command, string[] arg);
    [ConsoleCommand("fw.fight")]
     void ccmdFight(ConsoleSystem.Arg arg);
    [ConsoleCommand("fw.build")]
     void ccmdBuild(ConsoleSystem.Arg arg);
    [ConsoleCommand("fw.enable")]
     void ccmdEnable(ConsoleSystem.Arg arg);
     void UpdateGatherRate();
     void DestroyTimers();
     bool IsAllowed(BasePlayer player, string perm, bool bmsg);
     bool IsAllowed(ConsoleSystem.Arg arg, string perm, bool bmsg);
    private void CheckCfg(string Key, T var);
     T GetConfigValue(string category, string setting, T defaultValue);
     void SetConfigValue(string category, string setting, T newValue);
     bool isAuth(ConsoleSystem.Arg arg);
    private void UpdateCraftingRate();
     void BroadcastToChat(string msg);
    private void SendChatMessage(BasePlayer player, string message);
    public Vector3 GetRandomWorldPos();
}


```

---

## FoundationDrop

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Game.Rust.Libraries;
using UnityEngine;
using Random = Oxide.Core.Random;

Oxide.Plugins
[Info("Foundation Drop", "Server-rust.ru", "0.0.81")]
public class FoundationDrop : RustPlugin
{
    [PluginReference]
    private Plugin Backpack;
    private class Event
    {
        public double StartTime;
        public bool Started;
        public bool Finished;
        public int Received;
        public Timer StartTimer;
        public Timer DestroyTimer;
        public Dictionary<ulong, Vector3> PlayerConnected;
        public List<List<BaseEntity>> BlockList;
        public int EventHashID;
        public void JoinEvent(BasePlayer player);
        public void LeftEvent(BasePlayer player, bool external);
        public void HandlePlayers();
        public void StartEvent(int startDelay);
        public void InitializeEvent(int startDelay);
        public void FinishEvent(bool external);
    }

    private class Configuration
    {
        [JsonProperty("Размер арены в квадратах")]
        public int CONF_ArenaSize;
        [JsonProperty("Выдавать ли специальный пистолет для разрушения блоков")]
        public bool CONF_GivePistol;
        [JsonProperty("Количество патронов в пистолете")]
        public int CONF_GivePistolAmount;
        [JsonProperty("Интвервал между удалениями блоков")]
        public float CONF_DelayDestroy;
        [JsonProperty("Время ожидания игроков с момента объявления ивента")]
        public int CONF_WaitTime;
        [JsonProperty("Максимальное количество победителей")]
        public int CONF_MaxWinners;
        [JsonProperty("Список наград (выбирается случайно)")]
        public Dictionary<string, int> RewardList;
        public static Configuration GetConfiguration();
    }

    private Configuration config;
    private static FoundationDrop instance;
    private static Vector3 EventPosition;
    private static Event cEvent;
    private static string CONF_UI_MainLayer;
    private static string CONF_UI_SideLayer;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void Unload();
    private object OnServerCommand(ConsoleSystem.Arg arg);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnPlayerDie(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    [ConsoleCommand("UI_FE_Handler")]
    private void cmdConsoleHandler(ConsoleSystem.Arg args);
    [ConsoleCommand("fe.start")]
    private void cmdStartEvent(ConsoleSystem.Arg args);
    [ConsoleCommand("fe.stop")]
    private void cmdStopEvent(ConsoleSystem.Arg args);
    private static void SendMessage(BasePlayer player, string text);
    private static void ClearTeleport(BasePlayer player, Vector3 position);
    private void StartEvent();
    private void StopEvent(bool external);
    private IEnumerator InitializeFoundation(int startDelay);
    private void DropFoundation();
    private static void UI_DrawInfo(BasePlayer player);
    private static void UI_DrawLeftTime(BasePlayer player);
    private void UI_DrawInvite(BasePlayer player);
    private static string HexToRustFormat(string hex);
    static DateTime epoch;
    static double CurrentTime();
    private void GetConfig(string menu, string key, T varObject);
}

private class Event
{
    public double StartTime;
    public bool Started;
    public bool Finished;
    public int Received;
    public Timer StartTimer;
    public Timer DestroyTimer;
    public Dictionary<ulong, Vector3> PlayerConnected;
    public List<List<BaseEntity>> BlockList;
    public int EventHashID;
    public void JoinEvent(BasePlayer player);
    public void LeftEvent(BasePlayer player, bool external);
    public void HandlePlayers();
    public void StartEvent(int startDelay);
    public void InitializeEvent(int startDelay);
    public void FinishEvent(bool external);
}

private class Configuration
{
    [JsonProperty("Размер арены в квадратах")]
    public int CONF_ArenaSize;
    [JsonProperty("Выдавать ли специальный пистолет для разрушения блоков")]
    public bool CONF_GivePistol;
    [JsonProperty("Количество патронов в пистолете")]
    public int CONF_GivePistolAmount;
    [JsonProperty("Интвервал между удалениями блоков")]
    public float CONF_DelayDestroy;
    [JsonProperty("Время ожидания игроков с момента объявления ивента")]
    public int CONF_WaitTime;
    [JsonProperty("Максимальное количество победителей")]
    public int CONF_MaxWinners;
    [JsonProperty("Список наград (выбирается случайно)")]
    public Dictionary<string, int> RewardList;
    public static Configuration GetConfiguration();
}


```

---

## FreezeArrows

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Reflection;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("FreezeArrows", "Colon Blow", "1.0.7", ResourceId = 1601)]
 class FreezeArrows : RustPlugin
{
     bool Changed;
     Dictionary<ulong, string> GuiInfo;
     Dictionary<ulong, FreezeArrowData> isFrozen;
     Dictionary<ulong, ShotArrowData> loadArrow;
     class FreezeArrowData
    {
        public BasePlayer player;
        public Vector3 oldPos;
    }

     class ShotArrowData
    {
        public BasePlayer player;
        public int arrows;
        public bool arrowenabled;
    }

     void Loaded();
     void LoadDefaultConfig();
     bool HasPermission(BasePlayer player, string perm);
    static int FreezeTime;
    static int ReFreezeCooldown;
    static int FreezeRadius;
    static float FreezeOverlayTime;
    static int StartingArrowCount;
    static bool useFreezeOverlay;
    static bool showHitExplosionFX;
    static bool freezePlayers;
    static bool freezeNPCs;
    private void LoadVariables();
    private void LoadConfigVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
     object GetConfig(string menu, string datavalue, object defaultValue);
     Dictionary<string, string> messages;
     void OnPlayerAttack(BasePlayer player, HitInfo hitInfo, Vector3 newPos, int arrows, bool arrowenabled);
     bool usingCorrectWeapon(BasePlayer player);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo, int arrows);
     void findTarget(BasePlayer player, HitInfo hitInfo, Vector3 newPos);
     void repeater(BasePlayer p, HitInfo hitInfo, Vector3 newPos);
     void freezeposition(BasePlayer p, HitInfo hitInfo, Vector3 newPos);
     void FrozenGui(BasePlayer player);
    [ChatCommand("freezearrow")]
     void cmdChatfreezearrow(BasePlayer player, string command, string[] args, int arrows, bool arrowenabled);
    [ChatCommand("freezecount")]
     void cmdChatfreezecount(BasePlayer player, string command, string[] args, int arrows);
     void Unload();
     void DestroyCui(BasePlayer player);
     void OnPlayerSleepEnded(BasePlayer player);
     void OnPlayerRespawned(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
}

 class FreezeArrowData
{
    public BasePlayer player;
    public Vector3 oldPos;
}

 class ShotArrowData
{
    public BasePlayer player;
    public int arrows;
    public bool arrowenabled;
}


```

---

## FriendlyFire

```csharp
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

Oxide.Plugins
[Info(FF, "Nogrod", "2.0.1", ResourceId = 687)]
public class FriendlyFire : RustPlugin
{
    private const string FF;
    private readonly HashSet<ulong> bypass;
    private readonly Dictionary<string, int> times;
    private Dictionary<ulong, bool> ffData;
    private ConfigData configData;
    [PluginReference]
    private Plugin Friends;
    [PluginReference]
    private Plugin Clans;
     class ConfigData
    {
        public bool FriendlyFire { get; set; }
    }

    protected override void LoadDefaultConfig();
    private string _(string msgId, BasePlayer player, object[] args);
    private bool FriendlyFireEnabled(ulong userId);
    private void EnableFriendlyFire(ulong userId);
    private void DisableFriendlyFire(ulong userId);
    private void Init();
    private object OnAttackInternal(BasePlayer attacker, BasePlayer victim, HitInfo hit);
     void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo);
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    [ConsoleCommand("ff.toggle")]
    private void ccmdFFToggle(ConsoleSystem.Arg arg);
    [ChatCommand("ff")]
    private void cmdChatFF(BasePlayer player, string command, string[] args);
    private void SendHelpText(BasePlayer player);
    private bool EnableBypass(object userId);
    private bool DisableBypass(object userId);
}

 class ConfigData
{
    public bool FriendlyFire { get; set; }
}


```

---

## Friends

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using Newtonsoft.Json;

Oxide.Plugins
[Info("Friends", "ServerRust.ru", "1.1.12", ResourceId = 686)]
public class Friends : CovalencePlugin
{
    private ConfigData configData;
    public Timer mytimer;
    private Dictionary<ulong, PlayerData> FriendsData;
    private readonly Dictionary<ulong, HashSet<ulong>> ReverseData;
    private static readonly DateTime Epoch;
    private Dictionary<string, double> userCooldowns;
    private class ConfigData
    {
        [JsonProperty("Максимально друзей")]
        public int MaxFriends { get; set; }
        [JsonProperty("Задержка на добавление в друзья (КД)")]
        public double FriendCooldown { get; set; }
        [JsonProperty("Включить настройку авторизации друзей в замках для игрока")]
        public bool ShareCodeLocks { get; set; }
        [JsonProperty("Включить настройку авторизации друзей в турреляъ для игрока")]
        public bool ShareAutoTurrets { get; set; }
        [JsonProperty("Время кэширования")]
        public int CacheTime { get; set; }
    }

    private class PlayerData
    {
        public bool TurrentAuthorization;
        public bool AttackFriend;
        public bool CodeAuthorization;
        public string Name { get; set; }
        public HashSet<ulong> Friends { get; set; }
        public Dictionary<ulong, int> Cached { get; set; }
        public bool IsCached(ulong userId);
    }

    protected override void LoadDefaultConfig();
    private Dictionary<string, string> Messages;
    private void OnServerInitialized();
     void OnServerSave();
     void Unload();
    private object OnTurretTarget(AutoTurret turret, BaseCombatEntity targ);
     object CanUseLockedEntity(BasePlayer player, BaseLock @lock);
    public Dictionary<BasePlayer, int> CooldownList;
     void OnEntityTakeDamage(BaseCombatEntity vic, HitInfo info);
    private void SaveFriends();
    private bool AddFriend(ulong playerId, ulong friendId);
    private bool AddFriendS(string playerS, string friendS);
    private bool RemoveFriend(ulong playerId, ulong friendId);
    private bool RemoveFriendS(string playerS, string friendS);
    private bool HasFriend(ulong playerId, ulong friendId);
    private bool HasFriendS(string playerS, string friendS);
    private bool HadFriend(ulong playerId, ulong friendId);
    private bool HadFriendS(string playerS, string friendS);
    private bool AreFriends(ulong playerId, ulong friendId);
    private bool AreFriendsS(string playerS, string friendS);
    private bool WereFriends(ulong playerId, ulong friendId);
    private bool WereFriendsS(string playerS, string friendS);
    private bool IsFriend(ulong playerId, ulong friendId);
    private bool IsFriendS(string playerS, string friendS);
    private bool WasFriend(ulong playerId, ulong friendId);
    private bool WasFriendS(string playerS, string friendS);
    private ulong[] GetFriends(ulong playerId);
    private string[] GetFriendsS(string playerS);
    private string[] GetFriendList(ulong playerId);
    private string[] GetFriendListS(string playerS);
    private ulong[] IsFriendOf(ulong playerId);
    private string[] IsFriendOfS(string playerS);
    private PlayerData GetPlayerData(ulong playerId);
    private double GrabCurrentTime();
    private string FormatTime(double time);
    private Dictionary<ulong, ulong> pendings;
    [Command("friend")]
    private void FriendCommand(IPlayer player, string command, string[] args);
    private void PendingAdd(IPlayer sender, IPlayer target);
    private void Reply(IPlayer player, string langKey, object[] args);
    private void SendHelpText(object obj);
    private void AddFriendReverse(ulong playerId, ulong friendId);
    private ulong FindFriend(string friend);
}

private class ConfigData
{
    [JsonProperty("Максимально друзей")]
    public int MaxFriends { get; set; }
    [JsonProperty("Задержка на добавление в друзья (КД)")]
    public double FriendCooldown { get; set; }
    [JsonProperty("Включить настройку авторизации друзей в замках для игрока")]
    public bool ShareCodeLocks { get; set; }
    [JsonProperty("Включить настройку авторизации друзей в турреляъ для игрока")]
    public bool ShareAutoTurrets { get; set; }
    [JsonProperty("Время кэширования")]
    public int CacheTime { get; set; }
}

private class PlayerData
{
    public bool TurrentAuthorization;
    public bool AttackFriend;
    public bool CodeAuthorization;
    public string Name { get; set; }
    public HashSet<ulong> Friends { get; set; }
    public Dictionary<ulong, int> Cached { get; set; }
    public bool IsCached(ulong userId);
}


```

---

## Friends (2)

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Friends", "Sempai#3239", "1.21.1")]
[Description("Adds a friends system with a visual interface for quick interaction")]
public class Friends : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private Plugin Notifications;
    private Plugin PlayerList;
    private Plugin PlayerDatabase;
    private const string Layer;
    private static Friends _instance;
    private readonly Dictionary<ulong, EntityEntry> _playerEntities;
    private class EntityEntry
    {
        public HashSet<AutoTurret> AutoTurrets;
        public HashSet<BuildingPrivlidge> BuildingPrivileges;
    }

    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Добавлять в команду | Add to team")]
        public readonly bool AddTeam;
        [JsonProperty(PropertyName = "Максимальное кол-во друзей | Max Friends")]
        public readonly int MaxFriendsAmount;
        [JsonProperty(PropertyName = "Задержка между сообщениями FF | Delay between FF messages")]
        public readonly float FFDelay;
        [JsonProperty(PropertyName =
                "Закрывать интерфейс после нажатия на кнопку | Close the interface after clicking on the button")]
        public bool AutoClose;
        [JsonProperty(PropertyName = "Огонь по друзьям | Friendly Fire")]
        public bool FriendlyFire;
        [JsonProperty(PropertyName = "Двери | Doors")]
        public readonly bool Doors;
        [JsonProperty(PropertyName = "Турели | Turrets")]
        public readonly bool Turrets;
        [JsonProperty(PropertyName = "Шкаф | Cupboard")]
        public readonly bool Cupboard;
        [JsonProperty(PropertyName = "Ящики | Containers")]
        public readonly bool Containers;
        [JsonProperty(PropertyName = "ПВО | SAMs")]
        public bool SAMs;
        [JsonProperty(PropertyName = "Добавлять друга к остальным друзьям? | Add a friend to other friends?")]
        public bool UseTeams;
        [JsonProperty(PropertyName = "Включить логирование в консоль? | Enable logging to the console?")]
        public readonly bool LogToConsole;
        [JsonProperty(PropertyName = "Включить логирование в файл? | Enable logging to the file?")]
        public readonly bool LogToFile;
        [JsonProperty(PropertyName = "Фон | Background")]
        public readonly IPanel Background;
        [JsonProperty(PropertyName = "Заглавие | Title")]
        public readonly IText Title;
        [JsonProperty(PropertyName = "Закрыть | Close")]
        public readonly IText Close;
        [JsonProperty(PropertyName = "Ошибка | Error")]
        public readonly IText Error;
        [JsonProperty(PropertyName = "Назад | Back")]
        public readonly IText Back;
        [JsonProperty(PropertyName = "Вперёд | Next")]
        public readonly IText Next;
        [JsonProperty(PropertyName = "Настройка интерфейса | Interface Settings")]
        public readonly IFriendPanel Panel;
        [JsonProperty(PropertyName = "Приглашение в друзья | Friend Invite")]
        public readonly INotify FriendInvite;
        [JsonProperty(PropertyName = "Оповещение | Notification")]
        public readonly INotify Notify;
        [JsonProperty(PropertyName = "Найти друга | Find a Friend")]
        public readonly INotifyButton FindFriendBtn;
        [JsonProperty(PropertyName = "PlayerDatabase")]
        public readonly PlayerDatabaseConf PlayerDatabase;
        public VersionNumber Version;
    }

    private class PlayerDatabaseConf
    {
        [JsonProperty(PropertyName = "Включено")]
        public readonly bool Enabled;
        [JsonProperty(PropertyName = "Поле")]
        public readonly string Field;
        public PlayerDatabaseConf(bool enabled, string field);
    }

    private class NickName : IText
    {
        [JsonProperty(PropertyName = "Максимальная длина | Max Lenght")]
        public int MaxLength;
        public new void Get(CuiElementContainer container, string parent, string name, string text);
    }

    private class INotify
    {
        [JsonProperty(PropertyName = "Ключ изображения | Image Key")]
        public string Image;
        [JsonProperty(PropertyName = "Ссылка на изображение | Image Url")]
        public string Url;
        [JsonProperty(PropertyName = "Время показа | Show Time")]
        public float Delay;
        [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<INotifyButton> Buttons;
    }

    private class INotifyButton : IText
    {
        [JsonProperty(PropertyName = "Цвет | Color")]
        public IColor BColor;
        [JsonProperty(PropertyName = "Ключ языкового файла | Lang Key")]
        public string Msg;
        [JsonProperty(PropertyName = "Команда | Command")]
        public string Command;
        public void Get(CuiElementContainer container, BasePlayer player, string name, string parent);
    }

    private abstract class IAnchors
    {
        public string AnchorMin;
        public string AnchorMax;
    }

    private class InterfacePosition : IAnchors
    {
        public string OffsetMin;
        public string OffsetMax;
    }

    private class IFriendPanel : IAnchors
    {
        [JsonProperty(PropertyName = "Высота | Height")]
        public float Height;
        [JsonProperty(PropertyName = "Ширина | Width")]
        public float Width;
        [JsonProperty(PropertyName = "Отступ | Margin")]
        public float Margin;
        [JsonProperty(PropertyName = "Количество на странице | Count On Page")]
        public int Count;
        [JsonProperty(PropertyName = "Цвет | Color")]
        public IColor Color;
        [JsonProperty(PropertyName = "Аватарка | Avatar")]
        public InterfacePosition Avatar;
        [JsonProperty(PropertyName = "Никнейм | Nickname")]
        public NickName Nickname;
        [JsonProperty(PropertyName = "Статус | Status")]
        public SText Status;
        [JsonProperty(PropertyName = "Кнопка | Button")]
        public IButton Button;
        [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<FButton> Buttons;
        public void Get(CuiElementContainer container, BasePlayer player, FriendData data, string parent, string name, string oMin, string oMax, int page, string mainParent);
    }

    private class IPanel : InterfacePosition
    {
        [JsonProperty(PropertyName = "Изображение | Image")]
        public string Image;
        [JsonProperty(PropertyName = "Цвет | Color")]
        public IColor Color;
        [JsonProperty(PropertyName = "Сохранять цвет изображения? | Save Image Color")]
        public bool isRaw;
        [JsonProperty(PropertyName = "Sprite")]
        public string Sprite;
        [JsonProperty(PropertyName = "Material")]
        public string Material;
        public void Get(CuiElementContainer container, string parent, string name, bool cursor);
    }

    private class FButton
    {
        [JsonProperty(PropertyName = "Тип | Type")]
        [JsonConverter(typeof(StringEnumConverter))]
        public BtnType Type;
        [JsonProperty(PropertyName = "Текст | Text")]
        public string Text;
        [JsonProperty(PropertyName = "Команда | Command")]
        public string Command;
        [JsonProperty(PropertyName = "Активный Цвет | Active Color")]
        public IColor ActiveColor;
        [JsonProperty(PropertyName = "Неактивный Цвет | Disactive Color")]
        public IColor DisactiveColor;
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Text Color")]
        public IColor TColor;
        public void Get(CuiElementContainer container, FriendData data, string parent, string name, string aMin, string aMax, string oMin, string oMax, int page, string mainParent);
    }

    private class IButton : IAnchors
    {
        [JsonProperty(PropertyName = "Высота | Height")]
        public float Height;
        [JsonProperty(PropertyName = "Ширина | Width")]
        public float Width;
        [JsonProperty(PropertyName = "Отступ | Margin")]
        public float Margin;
    }

    private class SText : InterfacePosition
    {
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Цвет игрока онлайн | Online Color")]
        public IColor Color;
        [JsonProperty(PropertyName = "Цвет игрока оффлайн | Offline Color")]
        public IColor OfflineColor;
        public void Get(CuiElementContainer container, bool online, string parent, string name, string text);
    }

    private class IText : InterfacePosition
    {
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Text Color")]
        public IColor Color;
        public void Get(CuiElementContainer container, string parent, string name, string text);
    }

    private class IColor
    {
        [JsonProperty(PropertyName = "HEX")]
        public string HEX;
        [JsonProperty(PropertyName = "Непрозрачность | Opacity (0 - 100)")]
        public readonly float Alpha;
        public string Get();
        public IColor(string hex, float alpha);
    }

    protected override void LoadConfig();
    private void UpdateConfigValues();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private static PluginData _data;
    private Dictionary<ulong, PlayerData> _playersData;
    private void SaveData();
    private void SaveDatabaseData();
    private void SaveFilesData();
    private void SaveData(ulong userId, PlayerData data);
    private void LoadData();
    private void LoadFilesData();
    private void LoadPlayerData(ulong userId);
    private class PluginData
    {
        [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<ulong, PlayerData> Players;
    }

    private class PlayerData
    {
        [JsonProperty(PropertyName = "Display Name")]
        public string DisplayName;
        [JsonProperty(PropertyName = "UserId")]
        public ulong UserId;
        [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public readonly List<FriendData> Friends;
        [JsonProperty(PropertyName = "Removed Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public readonly List<ulong> RemovedFriends;
        public bool IsFriend(ulong friend);
        public FriendData GetFriend(ulong friend);
        public void AddFriend(ulong friend);
        public void RemoveFriend(ulong friend);
    }

    private class FriendData
    {
        [JsonProperty(PropertyName = "UserId")]
        public ulong UserId;
        [JsonProperty(PropertyName = "FriendlyFire")]
        public bool FriendlyFire;
        [JsonProperty(PropertyName = "Doors")]
        public bool Doors;
        [JsonProperty(PropertyName = "Turrets")]
        public bool Turrets;
        [JsonProperty(PropertyName = "Cupboard")]
        public bool Cupboard;
        [JsonProperty(PropertyName = "Containers")]
        public bool Containers;
        [JsonProperty(PropertyName = "SAMs")]
        public bool SAMs;
    }

    private static PlayerData GetPlayerData(BasePlayer player);
    private static PlayerData GetPlayerData(ulong userId);
    private static PlayerData FindPlayerData(string user);
    private void Init();
    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnEntityTakeDamage(BasePlayer player, HitInfo info);
    private void OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer player);
    private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer player);
    private void OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer player, ulong target);
    private void OnTeamInvite(BasePlayer inviter, BasePlayer target);
    private void OnTeamRejectInvite(BasePlayer rejector, RelationshipManager.PlayerTeam team);
    private void UpdateTeamAuthList(List<ulong> teamMembers);
    private object OnSamSiteTarget(SamSite samSite, BaseVehicle vehicle);
    private void CmdFriends(IPlayer cov, string command, string[] args);
    [ConsoleCommand("UI_Friends")]
    private void ConsoleCmdFriends(ConsoleSystem.Arg arg);
    [ConsoleCommand("friendssendcmd")]
    private void SendCommand(ConsoleSystem.Arg args);
    [ConsoleCommand("friends.migrate")]
    private void CmdConsoleMigrate(ConsoleSystem.Arg arg);
    private void MainUi(BasePlayer player, string parent, int page);
    private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player);
    private void OnEntitySpawned(BaseEntity entity);
    private void CheckEntity(BaseEntity entity, bool justCreated);
    private void OnEntityKill(BaseEntity entity);
    private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock);
    private void UpdateAuthList(ulong playerID, AutoAuthType autoAuthType);
    private void AuthToCupboard(HashSet<BuildingPrivlidge> cupboards, ulong playerID);
    private void AuthToTurret(HashSet<AutoTurret> autoTurrets, ulong playerID);
    private List<PlayerNameID> GetPlayerNameIDs(ulong playerId, AutoAuthType autoAuthType);
    private HashSet<ulong> GetAuthList(ulong playerID, AutoAuthType autoAuthType);
    private void Log(string filename, string text);
    private readonly Regex _regex;
    private void GetAvatar(ulong userId, Action<string> callback);
    private string GetPlayerName(ulong target);
    private void TimeHandle();
    private BasePlayer FindPlayer(List<FriendData> friendDatas);
    private BasePlayer FindPlayer(ulong user);
    private List<BasePlayer> FindPlayer(string steamOrIdOrName);
    private List<PlayerData> FindRemoveFriend(BasePlayer player, string friend);
    private void RemoveFriend(BasePlayer player, ulong friend);
    private RelationshipManager.PlayerTeam GetOrCreateTeam(BasePlayer player);
    private class Invite
    {
        public readonly BasePlayer Inviter;
        public readonly BasePlayer Target;
        public readonly string Guid;
        public readonly float Cooldown;
        public Invite(BasePlayer inviter, BasePlayer target, string guid);
    }

    private readonly List<Invite> _invites;
    private void SendInvite(BasePlayer inviter, BasePlayer target);
    private void AcceptInvite(BasePlayer target);
    private List<ulong> GetTeamList(ulong user);
    private void CancelInvite(BasePlayer player);
    private const string UITitle;
    private const string Online;
    private const string Offline;
    private const string NotifyTitle;
    private const string Pending;
    private const string AlreadyPending;
    private const string PendingBusy;
    private const string PendingSuccessSend;
    private const string PendingNotFound;
    private const string AlreadyFriends;
    private const string CantAddSelf;
    private const string MaxFriends;
    private const string TargetMaxFriends;
    private const string TimeLose;
    private const string TargetTimeLose;
    private const string FriendAdded;
    private const string FriendCancel;
    private const string InviterFriendCancel;
    private const string NoFriends;
    private const string FriendList;
    private const string IsNotFriend;
    private const string FriendRemoved;
    private const string NotFound;
    private const string FF;
    private const string FFOn;
    private const string FFOff;
    private const string FFErrorSyntax;
    private const string ErrorSyntax;
    private const string SamsOn;
    private const string SamsOff;
    private const string DoorsOn;
    private const string DoorsOff;
    private const string TurretsOn;
    private const string TurretsOff;
    private const string CupboardOn;
    private const string CupboardOff;
    private const string ContainersOn;
    private const string ContainersOff;
    private const string Accept;
    private const string Cancel;
    private const string FindFriend;
    private const string Help;
    private const string MultipleFound;
    protected override void LoadDefaultMessages();
    private void Notify(BasePlayer player, float delay, string title, string description, string image);
    private void RemoveNotify(BasePlayer player, string guid);
    private void Reply(BasePlayer player, string key, object[] obj);
    private string Msg(string key, string userid, object[] obj);
    private readonly Dictionary<ulong, float> _cooldown;
    private bool IsCd(ulong user);
    private int GetCd(ulong user);
    private void SetCd(ulong user);
    private ulong[] GetFriends(string playerId);
    private ulong[] GetFriends(ulong playerId);
    private ulong[] GetFriendList(string playerId);
    private ulong[] GetFriendList(ulong playerId);
    private bool AreFriends(string playerId, string friendId);
    private bool AreFriends(ulong playerId, ulong friendId);
    private bool HasFriend(string playerId, string friendId);
    private bool HasFriend(ulong playerId, ulong friendId);
    private bool HasFriends(string playerId, string friendId);
    private bool HasFriends(ulong playerId, ulong friendId);
    private bool IsFriend(string playerId, string friendId);
    private bool IsFriend(ulong playerId, ulong friendId);
    private bool WasFriend(string playerId, string friendId);
    private bool WasFriend(ulong playerId, ulong friendId);
    private int GetMaxFriends();
}

private class EntityEntry
{
    public HashSet<AutoTurret> AutoTurrets;
    public HashSet<BuildingPrivlidge> BuildingPrivileges;
}

private class Configuration
{
    [JsonProperty(PropertyName = "Добавлять в команду | Add to team")]
    public readonly bool AddTeam;
    [JsonProperty(PropertyName = "Максимальное кол-во друзей | Max Friends")]
    public readonly int MaxFriendsAmount;
    [JsonProperty(PropertyName = "Задержка между сообщениями FF | Delay between FF messages")]
    public readonly float FFDelay;
    [JsonProperty(PropertyName =
                "Закрывать интерфейс после нажатия на кнопку | Close the interface after clicking on the button")]
    public bool AutoClose;
    [JsonProperty(PropertyName = "Огонь по друзьям | Friendly Fire")]
    public bool FriendlyFire;
    [JsonProperty(PropertyName = "Двери | Doors")]
    public readonly bool Doors;
    [JsonProperty(PropertyName = "Турели | Turrets")]
    public readonly bool Turrets;
    [JsonProperty(PropertyName = "Шкаф | Cupboard")]
    public readonly bool Cupboard;
    [JsonProperty(PropertyName = "Ящики | Containers")]
    public readonly bool Containers;
    [JsonProperty(PropertyName = "ПВО | SAMs")]
    public bool SAMs;
    [JsonProperty(PropertyName = "Добавлять друга к остальным друзьям? | Add a friend to other friends?")]
    public bool UseTeams;
    [JsonProperty(PropertyName = "Включить логирование в консоль? | Enable logging to the console?")]
    public readonly bool LogToConsole;
    [JsonProperty(PropertyName = "Включить логирование в файл? | Enable logging to the file?")]
    public readonly bool LogToFile;
    [JsonProperty(PropertyName = "Фон | Background")]
    public readonly IPanel Background;
    [JsonProperty(PropertyName = "Заглавие | Title")]
    public readonly IText Title;
    [JsonProperty(PropertyName = "Закрыть | Close")]
    public readonly IText Close;
    [JsonProperty(PropertyName = "Ошибка | Error")]
    public readonly IText Error;
    [JsonProperty(PropertyName = "Назад | Back")]
    public readonly IText Back;
    [JsonProperty(PropertyName = "Вперёд | Next")]
    public readonly IText Next;
    [JsonProperty(PropertyName = "Настройка интерфейса | Interface Settings")]
    public readonly IFriendPanel Panel;
    [JsonProperty(PropertyName = "Приглашение в друзья | Friend Invite")]
    public readonly INotify FriendInvite;
    [JsonProperty(PropertyName = "Оповещение | Notification")]
    public readonly INotify Notify;
    [JsonProperty(PropertyName = "Найти друга | Find a Friend")]
    public readonly INotifyButton FindFriendBtn;
    [JsonProperty(PropertyName = "PlayerDatabase")]
    public readonly PlayerDatabaseConf PlayerDatabase;
    public VersionNumber Version;
}

private class PlayerDatabaseConf
{
    [JsonProperty(PropertyName = "Включено")]
    public readonly bool Enabled;
    [JsonProperty(PropertyName = "Поле")]
    public readonly string Field;
    public PlayerDatabaseConf(bool enabled, string field);
}

private class NickName : IText
{
    [JsonProperty(PropertyName = "Максимальная длина | Max Lenght")]
    public int MaxLength;
    public new void Get(CuiElementContainer container, string parent, string name, string text);
}

private class INotify
{
    [JsonProperty(PropertyName = "Ключ изображения | Image Key")]
    public string Image;
    [JsonProperty(PropertyName = "Ссылка на изображение | Image Url")]
    public string Url;
    [JsonProperty(PropertyName = "Время показа | Show Time")]
    public float Delay;
    [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<INotifyButton> Buttons;
}

private class INotifyButton : IText
{
    [JsonProperty(PropertyName = "Цвет | Color")]
    public IColor BColor;
    [JsonProperty(PropertyName = "Ключ языкового файла | Lang Key")]
    public string Msg;
    [JsonProperty(PropertyName = "Команда | Command")]
    public string Command;
    public void Get(CuiElementContainer container, BasePlayer player, string name, string parent);
}

private abstract class IAnchors
{
    public string AnchorMin;
    public string AnchorMax;
}

private class InterfacePosition : IAnchors
{
    public string OffsetMin;
    public string OffsetMax;
}

private class IFriendPanel : IAnchors
{
    [JsonProperty(PropertyName = "Высота | Height")]
    public float Height;
    [JsonProperty(PropertyName = "Ширина | Width")]
    public float Width;
    [JsonProperty(PropertyName = "Отступ | Margin")]
    public float Margin;
    [JsonProperty(PropertyName = "Количество на странице | Count On Page")]
    public int Count;
    [JsonProperty(PropertyName = "Цвет | Color")]
    public IColor Color;
    [JsonProperty(PropertyName = "Аватарка | Avatar")]
    public InterfacePosition Avatar;
    [JsonProperty(PropertyName = "Никнейм | Nickname")]
    public NickName Nickname;
    [JsonProperty(PropertyName = "Статус | Status")]
    public SText Status;
    [JsonProperty(PropertyName = "Кнопка | Button")]
    public IButton Button;
    [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<FButton> Buttons;
    public void Get(CuiElementContainer container, BasePlayer player, FriendData data, string parent, string name, string oMin, string oMax, int page, string mainParent);
}

private class IPanel : InterfacePosition
{
    [JsonProperty(PropertyName = "Изображение | Image")]
    public string Image;
    [JsonProperty(PropertyName = "Цвет | Color")]
    public IColor Color;
    [JsonProperty(PropertyName = "Сохранять цвет изображения? | Save Image Color")]
    public bool isRaw;
    [JsonProperty(PropertyName = "Sprite")]
    public string Sprite;
    [JsonProperty(PropertyName = "Material")]
    public string Material;
    public void Get(CuiElementContainer container, string parent, string name, bool cursor);
}

private class FButton
{
    [JsonProperty(PropertyName = "Тип | Type")]
    [JsonConverter(typeof(StringEnumConverter))]
    public BtnType Type;
    [JsonProperty(PropertyName = "Текст | Text")]
    public string Text;
    [JsonProperty(PropertyName = "Команда | Command")]
    public string Command;
    [JsonProperty(PropertyName = "Активный Цвет | Active Color")]
    public IColor ActiveColor;
    [JsonProperty(PropertyName = "Неактивный Цвет | Disactive Color")]
    public IColor DisactiveColor;
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Text Color")]
    public IColor TColor;
    public void Get(CuiElementContainer container, FriendData data, string parent, string name, string aMin, string aMax, string oMin, string oMax, int page, string mainParent);
}

private class IButton : IAnchors
{
    [JsonProperty(PropertyName = "Высота | Height")]
    public float Height;
    [JsonProperty(PropertyName = "Ширина | Width")]
    public float Width;
    [JsonProperty(PropertyName = "Отступ | Margin")]
    public float Margin;
}

private class SText : InterfacePosition
{
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Цвет игрока онлайн | Online Color")]
    public IColor Color;
    [JsonProperty(PropertyName = "Цвет игрока оффлайн | Offline Color")]
    public IColor OfflineColor;
    public void Get(CuiElementContainer container, bool online, string parent, string name, string text);
}

private class IText : InterfacePosition
{
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Text Color")]
    public IColor Color;
    public void Get(CuiElementContainer container, string parent, string name, string text);
}

private class IColor
{
    [JsonProperty(PropertyName = "HEX")]
    public string HEX;
    [JsonProperty(PropertyName = "Непрозрачность | Opacity (0 - 100)")]
    public readonly float Alpha;
    public string Get();
    public IColor(string hex, float alpha);
}

private class PluginData
{
    [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<ulong, PlayerData> Players;
}

private class PlayerData
{
    [JsonProperty(PropertyName = "Display Name")]
    public string DisplayName;
    [JsonProperty(PropertyName = "UserId")]
    public ulong UserId;
    [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public readonly List<FriendData> Friends;
    [JsonProperty(PropertyName = "Removed Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public readonly List<ulong> RemovedFriends;
    public bool IsFriend(ulong friend);
    public FriendData GetFriend(ulong friend);
    public void AddFriend(ulong friend);
    public void RemoveFriend(ulong friend);
}

private class FriendData
{
    [JsonProperty(PropertyName = "UserId")]
    public ulong UserId;
    [JsonProperty(PropertyName = "FriendlyFire")]
    public bool FriendlyFire;
    [JsonProperty(PropertyName = "Doors")]
    public bool Doors;
    [JsonProperty(PropertyName = "Turrets")]
    public bool Turrets;
    [JsonProperty(PropertyName = "Cupboard")]
    public bool Cupboard;
    [JsonProperty(PropertyName = "Containers")]
    public bool Containers;
    [JsonProperty(PropertyName = "SAMs")]
    public bool SAMs;
}

private class Invite
{
    public readonly BasePlayer Inviter;
    public readonly BasePlayer Target;
    public readonly string Guid;
    public readonly float Cooldown;
    public Invite(BasePlayer inviter, BasePlayer target, string guid);
}


```

---

## Friends-1.22.2

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Friends", "Mevent", "1.22.2")]
[Description("Adds a friends system with a visual interface for quick interaction")]
public class Friends : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private Plugin Notifications;
    private Plugin PlayerList;
    private Plugin PlayerDatabase;
    private Plugin Bank;
    private const string Layer;
    private static Friends _instance;
    private readonly Dictionary<ulong, EntityEntry> _playerEntities;
    private class EntityEntry
    {
        public HashSet<AutoTurret> AutoTurrets;
        public HashSet<BuildingPrivlidge> BuildingPrivileges;
        public HashSet<CodeLock> CodeLocks;
    }

    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Добавлять в команду | Add to team")]
        public bool AddTeam;
        [JsonProperty(PropertyName = "Максимальное кол-во друзей | Max Friends")]
        public int MaxFriendsAmount;
        [JsonProperty(PropertyName = "Задержка между сообщениями FF | Delay between FF messages")]
        public float FFDelay;
        [JsonProperty(PropertyName =
				"Закрывать интерфейс после нажатия на кнопку | Close the interface after clicking on the button")]
        public bool AutoClose;
        [JsonProperty(PropertyName = "Огонь по друзьям | Friendly Fire")]
        public bool FriendlyFire;
        [JsonProperty(PropertyName = "Двери | Doors")]
        public bool Doors;
        [JsonProperty(PropertyName = "Турели | Turrets")]
        public bool Turrets;
        [JsonProperty(PropertyName = "Шкаф | Cupboard")]
        public bool Cupboard;
        [JsonProperty(PropertyName = "Ящики | Containers")]
        public bool Containers;
        [JsonProperty(PropertyName = "ПВО | SAMs")]
        public bool SAMs;
        [JsonProperty(PropertyName = "Добавлять друга к остальным друзьям? | Add a friend to other friends?")]
        public bool UseTeams;
        [JsonProperty(PropertyName = "Включить логирование в консоль? | Enable logging to the console?")]
        public bool LogToConsole;
        [JsonProperty(PropertyName = "Включить логирование в файл? | Enable logging to the file?")]
        public bool LogToFile;
        [JsonProperty(PropertyName = "Фон | Background")]
        public IPanel Background;
        [JsonProperty(PropertyName = "Заглавие | Title")]
        public IText Title;
        [JsonProperty(PropertyName = "Закрыть | Close")]
        public IText Close;
        [JsonProperty(PropertyName = "Ошибка | Error")]
        public IText Error;
        [JsonProperty(PropertyName = "Назад | Back")]
        public IText Back;
        [JsonProperty(PropertyName = "Вперёд | Next")]
        public IText Next;
        [JsonProperty(PropertyName = "Настройка интерфейса | Interface Settings")]
        public IFriendPanel Panel;
        [JsonProperty(PropertyName = "Приглашение в друзья | Friend Invite")]
        public INotify FriendInvite;
        [JsonProperty(PropertyName = "Оповещение | Notification")]
        public INotify Notify;
        [JsonProperty(PropertyName = "Найти друга | Find a Friend")]
        public INotifyButton FindFriendBtn;
        [JsonProperty(PropertyName = "PlayerDatabase")]
        public PlayerDatabaseConf PlayerDatabase;
        public VersionNumber Version;
    }

    private class PlayerDatabaseConf
    {
        [JsonProperty(PropertyName = "Включено")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Поле")]
        public string Field;
        public PlayerDatabaseConf(bool enabled, string field);
    }

    private class NickName : IText
    {
        [JsonProperty(PropertyName = "Максимальная длина | Max Lenght")]
        public int MaxLength;
        public new void Get(CuiElementContainer container, string parent, string name, string text);
    }

    private class INotify
    {
        [JsonProperty(PropertyName = "Ключ изображения | Image Key")]
        public string Image;
        [JsonProperty(PropertyName = "Ссылка на изображение | Image Url")]
        public string Url;
        [JsonProperty(PropertyName = "Время показа | Show Time")]
        public float Delay;
        [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<INotifyButton> Buttons;
    }

    private class INotifyButton : IText
    {
        [JsonProperty(PropertyName = "Цвет | Color")]
        public IColor BColor;
        [JsonProperty(PropertyName = "Ключ языкового файла | Lang Key")]
        public string Msg;
        [JsonProperty(PropertyName = "Команда | Command")]
        public string Command;
        public void Get(CuiElementContainer container, BasePlayer player, string name, string parent);
    }

    private abstract class IAnchors
    {
        public string AnchorMin;
        public string AnchorMax;
    }

    private class InterfacePosition : IAnchors
    {
        public string OffsetMin;
        public string OffsetMax;
    }

    private class IFriendPanel : IAnchors
    {
        [JsonProperty(PropertyName = "Высота | Height")]
        public float Height;
        [JsonProperty(PropertyName = "Ширина | Width")]
        public float Width;
        [JsonProperty(PropertyName = "Отступ | Margin")]
        public float Margin;
        [JsonProperty(PropertyName = "Количество на странице | Count On Page")]
        public int Count;
        [JsonProperty(PropertyName = "Цвет | Color")]
        public IColor Color;
        [JsonProperty(PropertyName = "Аватарка | Avatar")]
        public InterfacePosition Avatar;
        [JsonProperty(PropertyName = "Никнейм | Nickname")]
        public NickName Nickname;
        [JsonProperty(PropertyName = "Статус | Status")]
        public SText Status;
        [JsonProperty(PropertyName = "Кнопка | Button")]
        public IButton Button;
        [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<FButton> Buttons;
        public void Get(CuiElementContainer container, BasePlayer player, FriendData data, string parent, string name, string oMin, string oMax, int page, string mainParent);
    }

    private class IPanel : InterfacePosition
    {
        [JsonProperty(PropertyName = "Изображение | Image")]
        public string Image;
        [JsonProperty(PropertyName = "Цвет | Color")]
        public IColor Color;
        [JsonProperty(PropertyName = "Сохранять цвет изображения? | Save Image Color")]
        public bool isRaw;
        [JsonProperty(PropertyName = "Sprite")]
        public string Sprite;
        [JsonProperty(PropertyName = "Material")]
        public string Material;
        public void Get(CuiElementContainer container, string parent, string name, bool cursor);
    }

    private class FButton
    {
        [JsonProperty(PropertyName = "Тип | Type")]
        [JsonConverter(typeof(StringEnumConverter))]
        public BtnType Type;
        [JsonProperty(PropertyName = "Текст | Text")]
        public string Text;
        [JsonProperty(PropertyName = "Команда | Command")]
        public string Command;
        [JsonProperty(PropertyName = "Активный Цвет | Active Color")]
        public IColor ActiveColor;
        [JsonProperty(PropertyName = "Неактивный Цвет | Disactive Color")]
        public IColor DisactiveColor;
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Text Color")]
        public IColor TColor;
        public void Get(CuiElementContainer container, FriendData data, string parent, string name, string aMin, string aMax, string oMin, string oMax, int page, string mainParent);
    }

    private class IButton : IAnchors
    {
        [JsonProperty(PropertyName = "Высота | Height")]
        public float Height;
        [JsonProperty(PropertyName = "Ширина | Width")]
        public float Width;
        [JsonProperty(PropertyName = "Отступ | Margin")]
        public float Margin;
    }

    private class SText : InterfacePosition
    {
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Цвет игрока онлайн | Online Color")]
        public IColor Color;
        [JsonProperty(PropertyName = "Цвет игрока оффлайн | Offline Color")]
        public IColor OfflineColor;
        public void Get(CuiElementContainer container, bool online, string parent, string name, string text);
    }

    private class IText : InterfacePosition
    {
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Font")]
        public string Font;
        [JsonProperty(PropertyName = "Align")]
        [JsonConverter(typeof(StringEnumConverter))]
        public TextAnchor Align;
        [JsonProperty(PropertyName = "Text Color")]
        public IColor Color;
        public void Get(CuiElementContainer container, string parent, string name, string text);
    }

    private class IColor
    {
        [JsonProperty(PropertyName = "HEX")]
        public string HEX;
        [JsonProperty(PropertyName = "Непрозрачность | Opacity (0 - 100)")]
        public float Alpha;
        public string Get();
        public IColor(string hex, float alpha);
    }

    protected override void LoadConfig();
    private void UpdateConfigValues();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private Dictionary<string, PlayerData> _usersData;
    private ListHashSet<ulong> _changedPlayers;
    private PlayerData LoadPlayerDatabaseData(string userId);
    private void SavePlayerDatabaseData(string userId, PlayerData data);
    private class PlayerData
    {
        [JsonProperty(PropertyName = "Display Name")]
        public string DisplayName;
        [JsonProperty(PropertyName = "UserId")]
        public ulong UserID;
        [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<FriendData> Friends;
        [JsonProperty(PropertyName = "Removed Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public HashSet<ulong> RemovedFriends;
        public bool IsFriend(ulong friend);
        public FriendData GetFriend(ulong friend);
        public void AddFriend(ulong friend);
        public void RemoveFriend(ulong friend);
        private static string BaseFolder();
        public static string[] GetFiles();
        public static string[] GetFiles(string baseFolder);
        public static PlayerData GetOrLoad(string userId);
        public static PlayerData GetNotLoad(string userId);
        public static PlayerData GetOrLoad(string baseFolder, string userId, bool load);
        public static PlayerData GetOrCreate(string userId);
        public static bool IsLoaded(string userId);
        public static void Save();
        public static void Save(string userId);
        public static void SaveAndUnload(string userId);
        public static void Unload(string userId);
        private static PlayerData ReadOnlyObject(string name);
        public void OnChanged();
    }

    private class FriendData
    {
        [JsonProperty(PropertyName = "UserId")]
        public ulong UserId;
        [JsonProperty(PropertyName = "FriendlyFire")]
        public bool FriendlyFire;
        [JsonProperty(PropertyName = "Doors")]
        public bool Doors;
        [JsonProperty(PropertyName = "Turrets")]
        public bool Turrets;
        [JsonProperty(PropertyName = "Cupboard")]
        public bool Cupboard;
        [JsonProperty(PropertyName = "Containers")]
        public bool Containers;
        [JsonProperty(PropertyName = "SAMs")]
        public bool SAMs;
    }

    private Coroutine _saveCoroutine;
    private void StartSaveCoroutine();
    private void StopSaveCoroutine();
    private IEnumerator HandleChangedPlayers();
    private static PlayerData FindPlayerData(string user);
    private Coroutine _playersMigration;
    private IEnumerator StartOnAllPlayers(string[] players, Action<string> callback, Action onFinish);
    private void Init();
    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnEntityTakeDamage(BasePlayer player, HitInfo info);
    private void OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer player);
    private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer player);
    private void OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer player, ulong target);
    private void OnTeamInvite(BasePlayer inviter, BasePlayer target);
    private void OnTeamRejectInvite(BasePlayer rejector, RelationshipManager.PlayerTeam team);
    private void UpdateTeamAuthList(List<ulong> teamMembers);
    private object OnSamSiteTarget(SamSite samSite, BaseVehicle vehicle);
    private void CmdFriends(IPlayer cov, string command, string[] args);
    [ConsoleCommand("UI_Friends")]
    private void ConsoleCmdFriends(ConsoleSystem.Arg arg);
    [ConsoleCommand("friendssendcmd")]
    private void SendCommand(ConsoleSystem.Arg args);
    [ConsoleCommand("friends.migrate")]
    private void CmdConsoleMigrate(ConsoleSystem.Arg arg);
    private void MainUi(BasePlayer player, string parent, int page);
    private void OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player);
    private void OnEntitySpawned(BaseEntity entity);
    private void CheckEntity(BaseEntity entity, bool justCreated);
    private void OnEntityKill(BaseEntity entity);
    private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock);
    private void CanChangeCode(BasePlayer player, CodeLock codeLock, string code, bool isGuest);
    private void UpdateAuthList(ulong playerID, AutoAuthType autoAuthType);
    private void AuthToCodeLock(HashSet<CodeLock> codeLocks, ulong playerID);
    private void AuthToCupboard(HashSet<BuildingPrivlidge> cupboards, ulong playerID);
    private void AuthToTurret(HashSet<AutoTurret> autoTurrets, ulong playerID);
    private List<PlayerNameID> GetPlayerNameIDs(ulong playerId, AutoAuthType autoAuthType);
    private HashSet<ulong> GetAuthList(ulong playerID, AutoAuthType autoAuthType);
    private Coroutine _friendsConvertation;
    [ConsoleCommand("friends.convert")]
    private void CmdConsoleConvert(ConsoleSystem.Arg arg);
    private OldPluginClasses.PluginData LoadOldPluginData();
    private IEnumerator StartConvertOldData(KeyValuePair<ulong, OldPluginClasses.PluginData.PlayerData>[] players, Action onFinish);
    private class OldPluginClasses
    {
        public class PluginData
        {
            [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<ulong, PlayerData> Players;
            public class PlayerData
            {
                [JsonProperty(PropertyName = "Display Name")]
                public string DisplayName;
                [JsonProperty(PropertyName = "UserId")]
                public ulong UserID;
                [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<FriendData> Friends;
                [JsonProperty(PropertyName = "Removed Friends",
						ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<ulong> RemovedFriends;
            }

        }

    }

    private bool IsBankBox(BaseNetworkable entity);
    private void Log(string filename, string text);
    private readonly Regex _regex;
    private void GetAvatar(ulong userId, Action<string> callback);
    private string GetPlayerName(ulong target);
    private void TimeHandle();
    private BasePlayer FindPlayer(List<FriendData> friendDatas);
    private BasePlayer FindPlayer(ulong user);
    private List<BasePlayer> FindPlayer(string steamOrIdOrName);
    private List<PlayerData> FindRemoveFriend(BasePlayer player, string friend);
    private void RemoveFriend(BasePlayer player, ulong friend);
    private RelationshipManager.PlayerTeam GetOrCreateTeam(BasePlayer player);
    private class Invite
    {
        public BasePlayer Inviter;
        public BasePlayer Target;
        public string Guid;
        public float Cooldown;
        public Invite(BasePlayer inviter, BasePlayer target, string guid);
    }

    private readonly List<Invite> _invites;
    private void SendInvite(BasePlayer inviter, BasePlayer target);
    private void AcceptInvite(BasePlayer target);
    private List<ulong> GetTeamList(ulong user);
    private void CancelInvite(BasePlayer player);
    private const string UITitle;
    private const string Online;
    private const string Offline;
    private const string NotifyTitle;
    private const string Pending;
    private const string AlreadyPending;
    private const string PendingBusy;
    private const string PendingSuccessSend;
    private const string PendingNotFound;
    private const string AlreadyFriends;
    private const string CantAddSelf;
    private const string MaxFriends;
    private const string TargetMaxFriends;
    private const string TimeLose;
    private const string TargetTimeLose;
    private const string FriendAdded;
    private const string FriendCancel;
    private const string InviterFriendCancel;
    private const string NoFriends;
    private const string FriendList;
    private const string IsNotFriend;
    private const string FriendRemoved;
    private const string NotFound;
    private const string FF;
    private const string FFOn;
    private const string FFOff;
    private const string FFErrorSyntax;
    private const string ErrorSyntax;
    private const string SamsOn;
    private const string SamsOff;
    private const string DoorsOn;
    private const string DoorsOff;
    private const string TurretsOn;
    private const string TurretsOff;
    private const string CupboardOn;
    private const string CupboardOff;
    private const string ContainersOn;
    private const string ContainersOff;
    private const string Accept;
    private const string Cancel;
    private const string FindFriend;
    private const string Help;
    private const string MultipleFound;
    protected override void LoadDefaultMessages();
    private void Notify(BasePlayer player, float delay, string title, string description, string image);
    private void RemoveNotify(BasePlayer player, string guid);
    private void Reply(BasePlayer player, string key, object[] obj);
    private string Msg(string key, string userid, object[] obj);
    private readonly Dictionary<ulong, float> _cooldown;
    private bool IsCd(ulong user);
    private int GetCd(ulong user);
    private void SetCd(ulong user);
    private ulong[] GetFriends(string playerId);
    private ulong[] GetFriends(ulong playerId);
    private ulong[] GetFriendList(string playerId);
    private ulong[] GetFriendList(ulong playerId);
    private bool AreFriends(string playerId, string friendId);
    private bool AreFriends(ulong playerId, ulong friendId);
    private bool HasFriend(string playerId, string friendId);
    private bool HasFriend(ulong playerId, ulong friendId);
    private bool HasFriends(string playerId, string friendId);
    private bool HasFriends(ulong playerId, ulong friendId);
    private bool IsFriend(string playerId, string friendId);
    private bool IsFriend(ulong playerId, ulong friendId);
    private bool WasFriend(string playerId, string friendId);
    private bool WasFriend(ulong playerId, ulong friendId);
    private int GetMaxFriends();
}

private class EntityEntry
{
    public HashSet<AutoTurret> AutoTurrets;
    public HashSet<BuildingPrivlidge> BuildingPrivileges;
    public HashSet<CodeLock> CodeLocks;
}

private class Configuration
{
    [JsonProperty(PropertyName = "Добавлять в команду | Add to team")]
    public bool AddTeam;
    [JsonProperty(PropertyName = "Максимальное кол-во друзей | Max Friends")]
    public int MaxFriendsAmount;
    [JsonProperty(PropertyName = "Задержка между сообщениями FF | Delay between FF messages")]
    public float FFDelay;
    [JsonProperty(PropertyName =
				"Закрывать интерфейс после нажатия на кнопку | Close the interface after clicking on the button")]
    public bool AutoClose;
    [JsonProperty(PropertyName = "Огонь по друзьям | Friendly Fire")]
    public bool FriendlyFire;
    [JsonProperty(PropertyName = "Двери | Doors")]
    public bool Doors;
    [JsonProperty(PropertyName = "Турели | Turrets")]
    public bool Turrets;
    [JsonProperty(PropertyName = "Шкаф | Cupboard")]
    public bool Cupboard;
    [JsonProperty(PropertyName = "Ящики | Containers")]
    public bool Containers;
    [JsonProperty(PropertyName = "ПВО | SAMs")]
    public bool SAMs;
    [JsonProperty(PropertyName = "Добавлять друга к остальным друзьям? | Add a friend to other friends?")]
    public bool UseTeams;
    [JsonProperty(PropertyName = "Включить логирование в консоль? | Enable logging to the console?")]
    public bool LogToConsole;
    [JsonProperty(PropertyName = "Включить логирование в файл? | Enable logging to the file?")]
    public bool LogToFile;
    [JsonProperty(PropertyName = "Фон | Background")]
    public IPanel Background;
    [JsonProperty(PropertyName = "Заглавие | Title")]
    public IText Title;
    [JsonProperty(PropertyName = "Закрыть | Close")]
    public IText Close;
    [JsonProperty(PropertyName = "Ошибка | Error")]
    public IText Error;
    [JsonProperty(PropertyName = "Назад | Back")]
    public IText Back;
    [JsonProperty(PropertyName = "Вперёд | Next")]
    public IText Next;
    [JsonProperty(PropertyName = "Настройка интерфейса | Interface Settings")]
    public IFriendPanel Panel;
    [JsonProperty(PropertyName = "Приглашение в друзья | Friend Invite")]
    public INotify FriendInvite;
    [JsonProperty(PropertyName = "Оповещение | Notification")]
    public INotify Notify;
    [JsonProperty(PropertyName = "Найти друга | Find a Friend")]
    public INotifyButton FindFriendBtn;
    [JsonProperty(PropertyName = "PlayerDatabase")]
    public PlayerDatabaseConf PlayerDatabase;
    public VersionNumber Version;
}

private class PlayerDatabaseConf
{
    [JsonProperty(PropertyName = "Включено")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Поле")]
    public string Field;
    public PlayerDatabaseConf(bool enabled, string field);
}

private class NickName : IText
{
    [JsonProperty(PropertyName = "Максимальная длина | Max Lenght")]
    public int MaxLength;
    public new void Get(CuiElementContainer container, string parent, string name, string text);
}

private class INotify
{
    [JsonProperty(PropertyName = "Ключ изображения | Image Key")]
    public string Image;
    [JsonProperty(PropertyName = "Ссылка на изображение | Image Url")]
    public string Url;
    [JsonProperty(PropertyName = "Время показа | Show Time")]
    public float Delay;
    [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<INotifyButton> Buttons;
}

private class INotifyButton : IText
{
    [JsonProperty(PropertyName = "Цвет | Color")]
    public IColor BColor;
    [JsonProperty(PropertyName = "Ключ языкового файла | Lang Key")]
    public string Msg;
    [JsonProperty(PropertyName = "Команда | Command")]
    public string Command;
    public void Get(CuiElementContainer container, BasePlayer player, string name, string parent);
}

private abstract class IAnchors
{
    public string AnchorMin;
    public string AnchorMax;
}

private class InterfacePosition : IAnchors
{
    public string OffsetMin;
    public string OffsetMax;
}

private class IFriendPanel : IAnchors
{
    [JsonProperty(PropertyName = "Высота | Height")]
    public float Height;
    [JsonProperty(PropertyName = "Ширина | Width")]
    public float Width;
    [JsonProperty(PropertyName = "Отступ | Margin")]
    public float Margin;
    [JsonProperty(PropertyName = "Количество на странице | Count On Page")]
    public int Count;
    [JsonProperty(PropertyName = "Цвет | Color")]
    public IColor Color;
    [JsonProperty(PropertyName = "Аватарка | Avatar")]
    public InterfacePosition Avatar;
    [JsonProperty(PropertyName = "Никнейм | Nickname")]
    public NickName Nickname;
    [JsonProperty(PropertyName = "Статус | Status")]
    public SText Status;
    [JsonProperty(PropertyName = "Кнопка | Button")]
    public IButton Button;
    [JsonProperty(PropertyName = "Кнопки | Buttons", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<FButton> Buttons;
    public void Get(CuiElementContainer container, BasePlayer player, FriendData data, string parent, string name, string oMin, string oMax, int page, string mainParent);
}

private class IPanel : InterfacePosition
{
    [JsonProperty(PropertyName = "Изображение | Image")]
    public string Image;
    [JsonProperty(PropertyName = "Цвет | Color")]
    public IColor Color;
    [JsonProperty(PropertyName = "Сохранять цвет изображения? | Save Image Color")]
    public bool isRaw;
    [JsonProperty(PropertyName = "Sprite")]
    public string Sprite;
    [JsonProperty(PropertyName = "Material")]
    public string Material;
    public void Get(CuiElementContainer container, string parent, string name, bool cursor);
}

private class FButton
{
    [JsonProperty(PropertyName = "Тип | Type")]
    [JsonConverter(typeof(StringEnumConverter))]
    public BtnType Type;
    [JsonProperty(PropertyName = "Текст | Text")]
    public string Text;
    [JsonProperty(PropertyName = "Команда | Command")]
    public string Command;
    [JsonProperty(PropertyName = "Активный Цвет | Active Color")]
    public IColor ActiveColor;
    [JsonProperty(PropertyName = "Неактивный Цвет | Disactive Color")]
    public IColor DisactiveColor;
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Text Color")]
    public IColor TColor;
    public void Get(CuiElementContainer container, FriendData data, string parent, string name, string aMin, string aMax, string oMin, string oMax, int page, string mainParent);
}

private class IButton : IAnchors
{
    [JsonProperty(PropertyName = "Высота | Height")]
    public float Height;
    [JsonProperty(PropertyName = "Ширина | Width")]
    public float Width;
    [JsonProperty(PropertyName = "Отступ | Margin")]
    public float Margin;
}

private class SText : InterfacePosition
{
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Цвет игрока онлайн | Online Color")]
    public IColor Color;
    [JsonProperty(PropertyName = "Цвет игрока оффлайн | Offline Color")]
    public IColor OfflineColor;
    public void Get(CuiElementContainer container, bool online, string parent, string name, string text);
}

private class IText : InterfacePosition
{
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Font")]
    public string Font;
    [JsonProperty(PropertyName = "Align")]
    [JsonConverter(typeof(StringEnumConverter))]
    public TextAnchor Align;
    [JsonProperty(PropertyName = "Text Color")]
    public IColor Color;
    public void Get(CuiElementContainer container, string parent, string name, string text);
}

private class IColor
{
    [JsonProperty(PropertyName = "HEX")]
    public string HEX;
    [JsonProperty(PropertyName = "Непрозрачность | Opacity (0 - 100)")]
    public float Alpha;
    public string Get();
    public IColor(string hex, float alpha);
}

private class PlayerData
{
    [JsonProperty(PropertyName = "Display Name")]
    public string DisplayName;
    [JsonProperty(PropertyName = "UserId")]
    public ulong UserID;
    [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<FriendData> Friends;
    [JsonProperty(PropertyName = "Removed Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public HashSet<ulong> RemovedFriends;
    public bool IsFriend(ulong friend);
    public FriendData GetFriend(ulong friend);
    public void AddFriend(ulong friend);
    public void RemoveFriend(ulong friend);
    private static string BaseFolder();
    public static string[] GetFiles();
    public static string[] GetFiles(string baseFolder);
    public static PlayerData GetOrLoad(string userId);
    public static PlayerData GetNotLoad(string userId);
    public static PlayerData GetOrLoad(string baseFolder, string userId, bool load);
    public static PlayerData GetOrCreate(string userId);
    public static bool IsLoaded(string userId);
    public static void Save();
    public static void Save(string userId);
    public static void SaveAndUnload(string userId);
    public static void Unload(string userId);
    private static PlayerData ReadOnlyObject(string name);
    public void OnChanged();
}

private class FriendData
{
    [JsonProperty(PropertyName = "UserId")]
    public ulong UserId;
    [JsonProperty(PropertyName = "FriendlyFire")]
    public bool FriendlyFire;
    [JsonProperty(PropertyName = "Doors")]
    public bool Doors;
    [JsonProperty(PropertyName = "Turrets")]
    public bool Turrets;
    [JsonProperty(PropertyName = "Cupboard")]
    public bool Cupboard;
    [JsonProperty(PropertyName = "Containers")]
    public bool Containers;
    [JsonProperty(PropertyName = "SAMs")]
    public bool SAMs;
}

private class OldPluginClasses
{
    public class PluginData
    {
        [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<ulong, PlayerData> Players;
        public class PlayerData
        {
            [JsonProperty(PropertyName = "Display Name")]
            public string DisplayName;
            [JsonProperty(PropertyName = "UserId")]
            public ulong UserID;
            [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<FriendData> Friends;
            [JsonProperty(PropertyName = "Removed Friends",
						ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> RemovedFriends;
        }

    }

}

public class PluginData
{
    [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<ulong, PlayerData> Players;
    public class PlayerData
    {
        [JsonProperty(PropertyName = "Display Name")]
        public string DisplayName;
        [JsonProperty(PropertyName = "UserId")]
        public ulong UserID;
        [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<FriendData> Friends;
        [JsonProperty(PropertyName = "Removed Friends",
						ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<ulong> RemovedFriends;
    }

}

public class PlayerData
{
    [JsonProperty(PropertyName = "Display Name")]
    public string DisplayName;
    [JsonProperty(PropertyName = "UserId")]
    public ulong UserID;
    [JsonProperty(PropertyName = "Friends", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<FriendData> Friends;
    [JsonProperty(PropertyName = "Removed Friends",
						ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<ulong> RemovedFriends;
}

private class Invite
{
    public BasePlayer Inviter;
    public BasePlayer Target;
    public string Guid;
    public float Cooldown;
    public Invite(BasePlayer inviter, BasePlayer target, string guid);
}


```

---

## Friendsbyfermens

```csharp
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using ProtoBuf;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using ru = Oxide.Game.Rust;

Oxide.Plugins
[Info("Friendsbyfermens", "fermens", "0.1.42")]
[Description("Система друзей и FF")]
 class Friendsbyfermens : RustPlugin
{
    private PluginConfig config;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class PluginConfig
    {
        [JsonProperty("Максимальное количество игроков в команде")]
        public int maxcount;
        [JsonProperty("Префикс")]
        public string prefix;
        [JsonProperty("Максимальное количество символов в теге команды")]
        public int max;
        [JsonProperty("Минимальное количество символов в теге команды")]
        public int min;
        [JsonProperty("Запрещенные названия в теге команде")]
        public string[] blacklist;
        public static PluginConfig DefaultConfig();
    }

    [PluginReference]
    private Plugin OneVSOne;
    private Plugin Battles;
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
     void clear(HitInfo info);
     Dictionary<SamSite, BuildingPrivlidge> samsites;
    private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target);
    private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity);
    private static PlayerNameID GetPlayerNameId(BasePlayer player);
    private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock);
    private void Save();
    private void Unload();
    private void initializeset(ulong id);
    private static Dictionary<ulong, PLAYERTEAM> teams;
     class PLAYERTEAM
    {
        public string teamName;
        public ulong teamLeader;
        public List<ulong> members;
    }

    private void OnServerInitialized();
    private void OnPlayerConnected(BasePlayer player);
     Dictionary<ulong, settings> setplayers;
     class settings
    {
        public bool ff;
        public bool turret;
        public bool codelock;
    }

     void CmdConsolecommandinvite(ConsoleSystem.Arg arg);
    private void COMMANDER(BasePlayer player, string command, string[] args);
    private bool IsPvp(ulong id);
    private bool IsTurret(ulong id);
    private bool IsCodelock(ulong id);
     string onoff(bool on);
}

private class PluginConfig
{
    [JsonProperty("Максимальное количество игроков в команде")]
    public int maxcount;
    [JsonProperty("Префикс")]
    public string prefix;
    [JsonProperty("Максимальное количество символов в теге команды")]
    public int max;
    [JsonProperty("Минимальное количество символов в теге команды")]
    public int min;
    [JsonProperty("Запрещенные названия в теге команде")]
    public string[] blacklist;
    public static PluginConfig DefaultConfig();
}

 class PLAYERTEAM
{
    public string teamName;
    public ulong teamLeader;
    public List<ulong> members;
}

 class settings
{
    public bool ff;
    public bool turret;
    public bool codelock;
}


```

---

## FurnaceSort

```csharp
using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("FurnaceSort", "bazuka5801", "1.2.0")]
 class FurnaceSort : RustPlugin
{
     List<ulong> usePlayers;
    static List<ulong> activePlayers;
     Dictionary<BaseOven, BasePlayer> ovens;
    private string furnacePanelMin;
    private string furnacePanelMax;
    private string furnaceTextMin;
    private string furnaceTextMax;
    private string furnaceBigPanelMin;
    private string furnaceBigPanelMax;
    private string furnaceBigTextMin;
    private string furnaceBigTextMax;
     void OnServerInitialized();
     void Unload();
     void OnLootEntity(BasePlayer player, BaseEntity lootable);
     void DrawUI(BasePlayer player, bool bigFurnace);
    private bool work;
     void OnItemAddedToContainer(ItemContainer container, Item item);
    [ConsoleCommand("furnacesort.switch")]
     void cmdSwitch(ConsoleSystem.Arg arg);
     class UIDestroyer : MonoBehaviour
    {
        public BasePlayer player;
         void PlayerStoppedLooting(BasePlayer player);
        public void Dest();
    }

    private DynamicConfigFile saveFile;
     void LoadData();
     void OnServerSave();
     void SaveData();
}

 class UIDestroyer : MonoBehaviour
{
    public BasePlayer player;
     void PlayerStoppedLooting(BasePlayer player);
    public void Dest();
}


```

---

## FurnaceSorter

```csharp
using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("FurnaceSorter", "Absolut & PsychoTea", "1.0.15", ResourceId = 23)]
 class FurnaceSorter : RustPlugin
{
    const string permAllow;
     bool _debuggingMode;
     Dictionary<string, Timer> _timers;
     Dictionary<ulong, BaseOven> _uiInfo;
     string _panelSorter;
     string _panelOnScreen;
     List<ulong> _enabled;
     List<ItemContainer> _sorting;
    public class UI
    {
        public static CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor);
        public static void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
        public static void CreateTextOutline(CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align);
    }

     void RegisterLang();
     Dictionary<string, string> _messages;
     float _default_minX;
     float _default_minY;
     float _default_maxX;
     float _defeault_maxY;
     ConfigData _configData;
     class ConfigData
    {
        public float minx { get; set; }
        public float miny { get; set; }
        public float maxx { get; set; }
        public float maxy { get; set; }
    }

     void LoadConfigData();
     void LoadConfigVariables();
     void SaveConfig(ConfigData config);
    protected override void LoadDefaultConfig();
     void Init();
     void Unload();
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void OnPlayerRespawned(BasePlayer player);
     void OnLootEntity(BasePlayer player, BaseEntity entity);
     void OnPlayerLootEnd(PlayerLoot looter);
     object CanAcceptItem(ItemContainer container, Item item);
    private Item FindBurnable(BaseOven oven);
    [ConsoleCommand("UI_ToggleSorter")]
     void UIToggleSorterConsoleCommand(ConsoleSystem.Arg arg);
     void SorterUI(BasePlayer player);
     void OnScreen(BasePlayer player, string msg);
     void CloseUI(BasePlayer player);
     void SortFurnace(BasePlayer player, ItemContainer container, Item originalItem, int stackAmount, List<Item> existingItems, string shortname, int remainder, int newSlots);
     void SendMessage(BasePlayer player, string key, object[] args);
     string GetMessage(string key, BasePlayer player, object[] args);
     void DebugMessage(string message);
     bool HasPerm(BasePlayer player, string perm);
}

public class UI
{
    public static CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor);
    public static void CreateButton(CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align);
    public static void CreateTextOutline(CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align);
}

 class ConfigData
{
    public float minx { get; set; }
    public float miny { get; set; }
    public float maxx { get; set; }
    public float maxy { get; set; }
}


```

---

## FurnaceSplitter

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Furnace Splitter", "Skipcast", "2.1.7", ResourceId = 2406)]
[Description("Splits up resources in furnaces automatically and shows useful furnace information")]
public class FurnaceSplitter : RustPlugin
{
    private class OvenSlot
    {
        public Item Item;
        public int? Position;
        public int Index;
        public int DeltaAmount;
    }

    public class OvenInfo
    {
        public float ETA;
        public float FuelNeeded;
    }

    private class StoredData
    {
        public Dictionary<ulong, PlayerOptions> AllPlayerOptions { get; set; }
    }

    private class PluginConfig
    {
        public Vector2 UiPosition { get; set; }
    }

    private class PlayerOptions
    {
        public bool Enabled;
        public Dictionary<string, int> TotalStacks;
    }

    private class Vector2Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private Dictionary<ulong, PlayerOptions> allPlayerOptions { get; set; }
    private PluginConfig config;
    private StoredData storedData;
    private const string permUse;
    private readonly Dictionary<ulong, string> openUis;
    private readonly Dictionary<BaseOven, List<BasePlayer>> looters;
    private readonly Stack<BaseOven> queuedUiUpdates;
    private readonly string[] compatibleOvens;
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnPlayerInit(BasePlayer player);
    private void Init();
    private void Loaded();
    protected override void LoadDefaultConfig();
    private void OnServerInitialized();
    private void OnServerSave();
    private void SaveData();
    private void InitPlayer(BasePlayer player);
    private void OnTick();
    public OvenInfo GetOvenInfo(BaseOven oven);
    private void Unload();
    private bool GetEnabled(BasePlayer player);
    private void SetEnabled(BasePlayer player, bool enabled);
    private bool IsSlotCompatible(Item item, BaseOven oven, ItemDefinition itemDefinition);
    private void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable);
    private List<BasePlayer> GetLooters(BaseOven oven);
    private void AddLooter(BaseOven oven, BasePlayer player);
    private void RemoveLooter(BaseOven oven, BasePlayer player);
    private object CanMoveItem(Item item, PlayerInventory inventory, uint targetContainer, int targetSlot);
    private MoveResult MoveSplitItem(Item item, BaseOven oven, int totalSlots);
    private void AutoAddFuel(PlayerInventory playerInventory, BaseOven oven);
    private int FindMatchingSlotIndex(ItemContainer container, Item existingItem, ItemDefinition itemType, List<int> indexBlacklist);
    private void OnLootEntity(BasePlayer player, BaseEntity entity);
    private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
    private void OnEntityKill(BaseNetworkable networkable);
    private void OnOvenToggle(BaseOven oven, BasePlayer player);
    private void CreateUiIfFurnaceOpen(BasePlayer player);
    private CuiElementContainer CreateUi(BasePlayer player, BaseOven oven, OvenInfo ovenInfo);
    private string FormatTime(float totalSeconds);
    private Dictionary<ItemDefinition, float> GetSmeltTimes(BaseOven oven);
    private bool CanCook(ItemModCookable cookable, BaseOven oven);
    private float GetSmeltTime(ItemModCookable cookable, int amount);
    private int? GetTotalStacksOption(BasePlayer player, BaseOven oven);
    private void DestroyUI(BasePlayer player);
    private void DestroyOvenUI(BaseOven oven);
    [ConsoleCommand("furnacesplitter.enabled")]
    private void ConsoleCommand_Toggle(ConsoleSystem.Arg arg);
    [ConsoleCommand("furnacesplitter.totalstacks")]
    private void ConsoleCommand_TotalStacks(ConsoleSystem.Arg arg);
    [ConsoleCommand("furnacesplitter.trim")]
    private void ConsoleCommand_Trim(ConsoleSystem.Arg arg);
    private bool HasPermission(BasePlayer player);
    [HookMethod("MoveSplitItem")]
    public string Hook_MoveSplitItem(Item item, BaseOven oven, int totalSlots);
    [HookMethod("GetOvenInfo")]
    public JObject Hook_GetOvenInfo(BaseOven oven);
}

private class OvenSlot
{
    public Item Item;
    public int? Position;
    public int Index;
    public int DeltaAmount;
}

public class OvenInfo
{
    public float ETA;
    public float FuelNeeded;
}

private class StoredData
{
    public Dictionary<ulong, PlayerOptions> AllPlayerOptions { get; set; }
}

private class PluginConfig
{
    public Vector2 UiPosition { get; set; }
}

private class PlayerOptions
{
    public bool Enabled;
    public Dictionary<string, int> TotalStacks;
}

private class Vector2Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}


```

---

## GalaxyChest

```csharp
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

Oxide.Plugins
[Info("GalaxyChest", "123", "1.0.0")]
[Description("GalaxyChest")]
 class GalaxyChest : RustPlugin
{
    private class PluginConfig
    {
        public ulong ChestSkin;
        public ulong DustSkin;
        public float TimeOpen;
        public Dictionary<string, DustSett> dustDrops;
        public Dictionary<string, PrizeSett> prizeSett;
    }

    private class DustSett
    {
        public int Amount;
        public int Chance;
    }

    private class ChestData
    {
        public double OpenTime;
        public uint NetId;
    }

    private class PrizeSett
    {
        public int MinValue;
        public int MaxValue;
        public double Chance;
    }

    private Dictionary<ulong, ChestData> chestsData;
    private PluginConfig config;
    private string DataPath;
    static GalaxyChest instance;
     GameObject controller;
    private void Init();
     void OnServerInitialized();
     void Unload();
     void OnItemAddedToContainer(ItemContainer container, Item item);
     object CanLootEntity(BasePlayer player, StorageContainer container);
     void OnItemRemovedFromContainer(ItemContainer container, Item item);
     bool CanStackItem(Item item, Item targetItem);
    private void OnLootSpawn(LootContainer container);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    [ConsoleCommand("test")]
    private void Console_Test(ConsoleSystem.Arg arg);
    [ChatCommand("test")]
     void Chat_Test(BasePlayer player, string command, string[] args);
    private static void DrawMarker(BasePlayer player, Vector3 position, string text, int length);
    private static double GetCurrentTime();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    private class ChestUpdator : MonoBehaviour
    {
        private void Awake();
        private void UpdateInfo();
        private void CheckChest(BasePlayer player);
        private bool CheckDistance(BasePlayer player, BaseEntity ent);
        private void OnDestroy();
    }

}

private class PluginConfig
{
    public ulong ChestSkin;
    public ulong DustSkin;
    public float TimeOpen;
    public Dictionary<string, DustSett> dustDrops;
    public Dictionary<string, PrizeSett> prizeSett;
}

private class DustSett
{
    public int Amount;
    public int Chance;
}

private class ChestData
{
    public double OpenTime;
    public uint NetId;
}

private class PrizeSett
{
    public int MinValue;
    public int MaxValue;
    public double Chance;
}

private class ChestUpdator : MonoBehaviour
{
    private void Awake();
    private void UpdateInfo();
    private void CheckChest(BasePlayer player);
    private bool CheckDistance(BasePlayer player, BaseEntity ent);
    private void OnDestroy();
}


```

---

## GameStoresRUST

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

Oxide.Plugins
[Info("GameStoresRUST", "HOUGAN # GAMESTORES", "0.2.8")]
public class GameStoresRUST : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private static class Delays
    {
        [JsonProperty("Игроки с активными запросами к АПИ")]
        public static List<ulong> ItemList;
        [JsonProperty("Количество запросов за последнюю секунду")]
        public static int RequestPerSecond;
        [JsonProperty("Ограничение запросов в секунду")]
        public static int RequestPerSecondLimit;
        public static bool CanRequest(BasePlayer player);
        public static void FinishRequest(BasePlayer player);
        public static IEnumerator MakeRequest(BasePlayer player);
    }

    private class Stats
    {
    }

    private class Configuration
    {
        public class API
        {
            [JsonProperty("ИД магазина в сервисе")]
            public string ShopID;
            [JsonProperty("ИД сервера в сервисе")]
            public string ServerID;
            [JsonProperty("Секретный ключ (не распространяйте его)")]
            public string SecretKey;
        }

        public class Interface
        {
            [JsonProperty("Включить изображение корзины")]
            public bool BucketEnable;
            [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
            public string BucketURL;
            [JsonProperty("Количество предметов на строке")]
            public int ItemOnString;
            [JsonProperty("Количество строк в интерфейсе")]
            public int StringAmount;
            [JsonProperty("Сторона одного предмета")]
            public int ItemSide;
            [JsonProperty("Отступ между предметами")]
            public int ItemMargin;
        }

        public class TOP
        {
            [JsonProperty("Отправлять данные топа игроков")]
            public bool UseTop;
        }

        [JsonProperty("Настройки API плагина")]
        public API APISettings;
        [JsonProperty("Настройки интерфейса плагина")]
        public Interface InterfaceSettings;
        [JsonProperty("Настройки статистики сервера")]
        public TOP TOPSettings;
    }

    private class WItem
    {
        public string ID;
        public string Name;
        public int ItemID;
        public int Amount;
        public string ShortName;
        public string Command;
        public string ImageUrl;
        public bool Blocked;
        public double Block_Date;
        public bool IsBlueprint;
        public bool IsCommand;
        public bool IsItem;
        public WItem(Dictionary<string, object> data, bool show);
    }

    private static bool Initialized;
    private static GameStoresRUST instance;
    private static Configuration Settings;
    private string ShopURL;
    private int StartBalance;
    public string NoImageID;
    public string LoadingImageID;
    private Coroutine LoadingCoroutine;
    private string BaseRequest { get; set; }
    private void OnServerInitialized();
    private IEnumerator WaitForLoad();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void Unload();
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnPlayerInit(BasePlayer player);
    private static class StatHandler
    {
        internal class Stat
        {
            [JsonProperty("dataType")]
            public string DataType;
        }

        internal class KillStat : Stat
        {
            [JsonProperty("player_id")]
            public string PlayerUserId;
            [JsonProperty("victim_id")]
            public string VictimUserID;
            [JsonProperty("type")]
            public string Type;
            [JsonProperty("time")]
            public string Time;
        }

        internal class TimeStat : Stat
        {
            [JsonProperty("player_id")]
            public string PlayerID;
            [JsonProperty("username")]
            public string PlayerName;
            [JsonProperty("played")]
            public string Played;
            [JsonProperty("time")]
            public string Time;
            public TimeStat(BasePlayer player);
        }

        private static List<Stat> Stats;
        public static void AddStat(Stat stat);
        public static void SendStats();
    }

    [ConsoleCommand("sendtop")]
    private void CmdSendTop(ConsoleSystem.Arg args);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
    [ChatCommand("store")]
    private void CmdChatStore(BasePlayer player, string command, string[] args);
    [ConsoleCommand("UI_GameStoresRUST")]
    private void CmdConsoleCommand(ConsoleSystem.Arg args);
    private static string StoreLayer;
    private void InitializeStore(BasePlayer player, int page, bool first);
    private string IconLayer;
    private void InitializeIcon(BasePlayer player);
    private void ShowNotify(BasePlayer player, string text);
    private void ProcessTake(BasePlayer player, Dictionary<string, object> obj);
    private static readonly Dictionary<int,string> IDToShortName;
    private void UI_RecountPosition(double xSwitch, double ySwitch, int count, int max);
    private void FetchShopUrl();
    private static void Request(string ask, Action<int, string> callback, BasePlayer player, bool cancel);
    private void LogPlayerAction(BasePlayer player, string text);
    private static double CurrentTime();
}

private static class Delays
{
    [JsonProperty("Игроки с активными запросами к АПИ")]
    public static List<ulong> ItemList;
    [JsonProperty("Количество запросов за последнюю секунду")]
    public static int RequestPerSecond;
    [JsonProperty("Ограничение запросов в секунду")]
    public static int RequestPerSecondLimit;
    public static bool CanRequest(BasePlayer player);
    public static void FinishRequest(BasePlayer player);
    public static IEnumerator MakeRequest(BasePlayer player);
}

private class Stats
{
}

private class Configuration
{
    public class API
    {
        [JsonProperty("ИД магазина в сервисе")]
        public string ShopID;
        [JsonProperty("ИД сервера в сервисе")]
        public string ServerID;
        [JsonProperty("Секретный ключ (не распространяйте его)")]
        public string SecretKey;
    }

    public class Interface
    {
        [JsonProperty("Включить изображение корзины")]
        public bool BucketEnable;
        [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
        public string BucketURL;
        [JsonProperty("Количество предметов на строке")]
        public int ItemOnString;
        [JsonProperty("Количество строк в интерфейсе")]
        public int StringAmount;
        [JsonProperty("Сторона одного предмета")]
        public int ItemSide;
        [JsonProperty("Отступ между предметами")]
        public int ItemMargin;
    }

    public class TOP
    {
        [JsonProperty("Отправлять данные топа игроков")]
        public bool UseTop;
    }

    [JsonProperty("Настройки API плагина")]
    public API APISettings;
    [JsonProperty("Настройки интерфейса плагина")]
    public Interface InterfaceSettings;
    [JsonProperty("Настройки статистики сервера")]
    public TOP TOPSettings;
}

public class API
{
    [JsonProperty("ИД магазина в сервисе")]
    public string ShopID;
    [JsonProperty("ИД сервера в сервисе")]
    public string ServerID;
    [JsonProperty("Секретный ключ (не распространяйте его)")]
    public string SecretKey;
}

public class Interface
{
    [JsonProperty("Включить изображение корзины")]
    public bool BucketEnable;
    [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
    public string BucketURL;
    [JsonProperty("Количество предметов на строке")]
    public int ItemOnString;
    [JsonProperty("Количество строк в интерфейсе")]
    public int StringAmount;
    [JsonProperty("Сторона одного предмета")]
    public int ItemSide;
    [JsonProperty("Отступ между предметами")]
    public int ItemMargin;
}

public class TOP
{
    [JsonProperty("Отправлять данные топа игроков")]
    public bool UseTop;
}

private class WItem
{
    public string ID;
    public string Name;
    public int ItemID;
    public int Amount;
    public string ShortName;
    public string Command;
    public string ImageUrl;
    public bool Blocked;
    public double Block_Date;
    public bool IsBlueprint;
    public bool IsCommand;
    public bool IsItem;
    public WItem(Dictionary<string, object> data, bool show);
}

private static class StatHandler
{
    internal class Stat
    {
        [JsonProperty("dataType")]
        public string DataType;
    }

    internal class KillStat : Stat
    {
        [JsonProperty("player_id")]
        public string PlayerUserId;
        [JsonProperty("victim_id")]
        public string VictimUserID;
        [JsonProperty("type")]
        public string Type;
        [JsonProperty("time")]
        public string Time;
    }

    internal class TimeStat : Stat
    {
        [JsonProperty("player_id")]
        public string PlayerID;
        [JsonProperty("username")]
        public string PlayerName;
        [JsonProperty("played")]
        public string Played;
        [JsonProperty("time")]
        public string Time;
        public TimeStat(BasePlayer player);
    }

    private static List<Stat> Stats;
    public static void AddStat(Stat stat);
    public static void SendStats();
}

internal class Stat
{
    [JsonProperty("dataType")]
    public string DataType;
}

internal class KillStat : Stat
{
    [JsonProperty("player_id")]
    public string PlayerUserId;
    [JsonProperty("victim_id")]
    public string VictimUserID;
    [JsonProperty("type")]
    public string Type;
    [JsonProperty("time")]
    public string Time;
}

internal class TimeStat : Stat
{
    [JsonProperty("player_id")]
    public string PlayerID;
    [JsonProperty("username")]
    public string PlayerName;
    [JsonProperty("played")]
    public string Played;
    [JsonProperty("time")]
    public string Time;
    public TimeStat(BasePlayer player);
}


```

---

## GatherControl

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;

Oxide.Plugins
[Info("GatherControl", "CaseMan", "1.6.0", ResourceId = 2477)]
[Description("Control gather rates by day and night with permissions")]
 class GatherControl : RustPlugin
{
    [PluginReference]
     Plugin GUIAnnouncements;
    static GatherControl GC;
     bool IsDay;
     bool UseZeroIndexForDefaultGroup;
     bool UseMessageBroadcast;
     bool UseGUIAnnouncements;
     bool AdminMode;
     string BannerColor;
     string TextColor;
    public Dictionary<ulong, int> Temp;
     float Sunrise;
     float Sunset;
     float DayRateMultStaticQuarry;
     float NightRateMultStaticQuarry;
     string PLPerm;
     string AdmPerm;
     string BypassPerm;
     class PermData
    {
        public Dictionary<int, PermGroups> PermissionsGroups;
        public PermData();
    }

     class PermGroups
    {
        public float DayRateMultQuarry;
        public float DayRateMultPickup;
        public float DayRateMultResource;
        public float DayRateMultResourceBonus;
        public float DayRateMultResourceHQM;
        public float DayRateMultCropGather;
        public float NightRateMultQuarry;
        public float NightRateMultPickup;
        public float NightRateMultResource;
        public float NightRateMultResourceBonus;
        public float NightRateMultResourceHQM;
        public float NightRateMultCropGather;
        public Dictionary<string, string> CustomRateMultQuarry;
        public Dictionary<string, string> CustomRateMultPickup;
        public Dictionary<string, string> CustomRateMultResource;
        public Dictionary<string, string> CustomRateMultResourceBonus;
        public Dictionary<string, string> CustomRateMultCropGather;
        public Dictionary<string, string> ToolMultiplier;
        public string PermGroup;
        public PermGroups();
    }

     PermData permData;
     void Init();
     void LoadDefaultData();
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
    protected override void LoadDefaultConfig();
     void LoadDefaultMessages();
    private void CheckDay();
    private void CheckPlayers();
    private void CheckPlayer(BasePlayer player);
    private int CheckPlayerPerm(BasePlayer player, int index);
    private void CustomList(Item item, string str);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
     void OnCollectiblePickup(Item item, BasePlayer player);
     void OnQuarryGather(MiningQuarry quarry, Item item);
     void OnCropGather(PlantEntity plant, Item item, BasePlayer player);
    private int CheckPlayerPerms(BasePlayer player);
    private void GatherMultiplier(Item item, float daymult, float nightmult);
     void OnTick();
     void OnUserPermissionGranted(string id, string permis);
     void OnUserPermissionRevoked(string id, string permis);
     void OnUserGroupAdded(string id, string name);
     void OnUserGroupRemoved(string id, string name);
     void OnGroupPermissionGranted(string name, string permis);
     void OnGroupPermissionRevoked(string name, string permis);
    private void OnChangePermsGroup(string permis);
    private void OnChangePermsUser(string id, string permis);
    private void OnChangeUserGroup(string id);
    [ChatCommand("showrate")]
     void ShowRate(BasePlayer player, string command, string[] args);
    [ConsoleCommand("showrate")]
    private void conShowRate(ConsoleSystem.Arg arg);
     T GetConfig(string name, T defaultValue);
     void MessageToAll(string key);
    private string GatherInfo(BasePlayer player, int gr);
    private void ParseFromString(string str, float day, float night);
}

 class PermData
{
    public Dictionary<int, PermGroups> PermissionsGroups;
    public PermData();
}

 class PermGroups
{
    public float DayRateMultQuarry;
    public float DayRateMultPickup;
    public float DayRateMultResource;
    public float DayRateMultResourceBonus;
    public float DayRateMultResourceHQM;
    public float DayRateMultCropGather;
    public float NightRateMultQuarry;
    public float NightRateMultPickup;
    public float NightRateMultResource;
    public float NightRateMultResourceBonus;
    public float NightRateMultResourceHQM;
    public float NightRateMultCropGather;
    public Dictionary<string, string> CustomRateMultQuarry;
    public Dictionary<string, string> CustomRateMultPickup;
    public Dictionary<string, string> CustomRateMultResource;
    public Dictionary<string, string> CustomRateMultResourceBonus;
    public Dictionary<string, string> CustomRateMultCropGather;
    public Dictionary<string, string> ToolMultiplier;
    public string PermGroup;
    public PermGroups();
}


```

---

## GatherMultiplier

```csharp
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Gather Multiplier", "RustPlugin.ru", "0.1.0")]
public class GatherMultiplier : RustPlugin
{
    public static int START_TIME;
    public Dictionary<int, int> BONUSES;
    public Dictionary<string, int> BONUSMULTIPLIER;
    public class GatherData
    {
        public int Time;
        public int TotalAmount;
        public string shortname;
        public int amount;
    }

    readonly DynamicConfigFile dataFile;
     Dictionary<BasePlayer, int> notifierLasthit;
     Dictionary<BasePlayer, int> bonuses;
     Dictionary<string, string> itemsLoaclization;
     Dictionary<int, int> gatherBonuses;
     Dictionary<BasePlayer, GatherData> gathers;
    protected override void LoadDefaultConfig();
     void OnServerInitialized();
     void OnPluginLoaded(Plugin name);
     void Unload();
     void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void UpdateTimer(BasePlayer player, GatherData data);
     void GatherTimerLoop();
     void BonusTimerLoop();
     void NotifierLasthitLoop();
     Dictionary<string,int> itemIDS;
     void GiveBonus(BasePlayer player, int bonusKey);
    public string GetBonusType();
    public bool GetBonus(int lastAmount, int newAmount, int bonusKey);
     void UIDrawNotifier(BasePlayer player, GatherData data, bool destroy);
    public Timer mytimer;
     void UIDrawNotifierLast(BasePlayer player, GatherData data, bool destroy);
     int Time { get; set; }
     void UIDrawBonus(BasePlayer player, int bonusKey, string item);
     string HandleArgs(string json, object[] args);
     Dictionary<string, string> Images;
     string GUI;
     string GUINot;
     string GUILastHit;
     void DestroyUI(BasePlayer player);
     void DestroyUILoop(BasePlayer player);
     T GetConfig(T defaultValue, string firstKey, string secondKey, string thirdKey);
     IEnumerator LoadImages();
    private GameObject FileManagerObject;
    private FileManager m_FileManager;
     void InitFileManager();
     class FileManager : MonoBehaviour
    {
         int loaded;
         int needed;
        public bool IsFinished { get; set; }
        const ulong MaxActiveLoads;
         Dictionary<string, FileInfo> files;
        private class FileInfo
        {
            public string Url;
            public string Png;
        }

        public string GetPng(string name);
        public IEnumerator LoadFile(string name, string url, int size);
         IEnumerator LoadImageCoroutine(string name, string url, int size);
        static byte[] Resize(byte[] bytes, int size);
    }

}

public class GatherData
{
    public int Time;
    public int TotalAmount;
    public string shortname;
    public int amount;
}

 class FileManager : MonoBehaviour
{
     int loaded;
     int needed;
    public bool IsFinished { get; set; }
    const ulong MaxActiveLoads;
     Dictionary<string, FileInfo> files;
    private class FileInfo
    {
        public string Url;
        public string Png;
    }

    public string GetPng(string name);
    public IEnumerator LoadFile(string name, string url, int size);
     IEnumerator LoadImageCoroutine(string name, string url, int size);
    static byte[] Resize(byte[] bytes, int size);
}

private class FileInfo
{
    public string Url;
    public string Png;
}


```

---

## GatherPlus

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using Newtonsoft.Json;

Oxide.Plugins
[Info("GatherPlus", "TopPlugin.ru", "1.0.7")]
 class GatherPlus : RustPlugin
{
    private Dictionary<ulong, List<string>> TYReHSqOfhKNYycZjKGW;
    private bool xMdWdaMcelnqZnUuvuOsHR;
    private void Init();
    private void OnPlayerConnected(BasePlayer ruBBmSHSLwcJlcApwXQPCmW);
    private void OnPlayerDisconnected(BasePlayer ruBBmSHSLwcJlcApwXQPCmW, string TvglATzKckIYnDyotjfjlwWP);
    private void OnServerInitialized();
    private void OnDispenserGather(ResourceDispenser WmxvpKiWoq, BaseEntity CAjbiFlusXCJXaPjS, Item LbDHbbXgOVNBHbagtiQtViVd);
    private void OnDispenserBonus(ResourceDispenser WmxvpKiWoq, BasePlayer ruBBmSHSLwcJlcApwXQPCmW, Item LbDHbbXgOVNBHbagtiQtViVd);
    private void OnCollectiblePickup(Item LbDHbbXgOVNBHbagtiQtViVd, BasePlayer ruBBmSHSLwcJlcApwXQPCmW);
    private void OnGrowableGathered(GrowableEntity GSpwrTFFoifcdL, Item LbDHbbXgOVNBHbagtiQtViVd, BasePlayer ruBBmSHSLwcJlcApwXQPCmW);
    private void OnQuarryGather(MiningQuarry qizRzFxlkyVUceOYIblgn, Item LbDHbbXgOVNBHbagtiQtViVd);
    private void OnExcavatorGather(ExcavatorArm TzPOMJoGKgdmq, Item LbDHbbXgOVNBHbagtiQtViVd);
    private void OnUserPermissionGranted(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD);
    private void OnUserPermissionRevoked(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD);
    private void OnUserGroupAdded(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string FGCfNoxvlvTdiPTFSlJQGcC);
    private void OnUserGroupRemoved(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string FGCfNoxvlvTdiPTFSlJQGcC);
    private void OnGroupPermissionGranted(string FGCfNoxvlvTdiPTFSlJQGcC, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD);
    private void OnGroupPermissionRevoked(string FGCfNoxvlvTdiPTFSlJQGcC, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD);
    private void VAIOrIBMFBRDzWjWcreirermt(Item LbDHbbXgOVNBHbagtiQtViVd);
    private Item PGrbPtTOXSARhfHLPNQjQdLhjfH(BasePlayer ruBBmSHSLwcJlcApwXQPCmW);
    private void UzfOPDWISeexjvRnZ(Item LbDHbbXgOVNBHbagtiQtViVd);
    private void oetGHOimIAMYUTjlYTNKYPuneezp(Item LbDHbbXgOVNBHbagtiQtViVd);
    private void sfqFhPZYku(Item LbDHbbXgOVNBHbagtiQtViVd);
    private void kBDzvmUtgW(Item LbDHbbXgOVNBHbagtiQtViVd, float lFUwovWtRpPgCfhBepAylcyZoDot, float teaAmount);
    private float uczyrWoSXbuADxECLN();
    private int cIfJbJRDtwIgyvMifYLP(ResourceDispenser WmxvpKiWoq, BasePlayer ruBBmSHSLwcJlcApwXQPCmW, Item LbDHbbXgOVNBHbagtiQtViVd);
    private float zFxEtHNxxGJUxewKBKvGvBFGvJqcw(ulong OYlWblKfCabL);
    private float mTAoUXIVPGCaZ(ulong OYlWblKfCabL);
    private float cQeERfeDlJmMbJiER(ulong OYlWblKfCabL);
    private float GetExcavRate();
    private void yiVutxeRQI(string userIdString);
    private void hiIKXJeifXPCnjFYcqanjwOAIllrA(string ETuMRfpoSrvIVoYhvLNZUxSDnr);
    private void UTrMSfubwzyW(bool IzXApdAULxQtJtU);
    private void iJGFmNSmzpjUPoBfd();
    private void LoadDefaultMessages();
    private string WgbDnqHgVcxHNhYVbjUcAkzZbvyXeq(string XYhtZLHwaUvxZvIuoNLeQrMjTh, string OVLwWvZjBTWQaofxEAsAiu);
    private static YKvNVAlKVtyHgdQMSBDjkjAHqMbYf SPHgwVuINoiDcmDXsr;
    private class NgMeCAQtKwjHNgNNmahvyzlMdIU
    {
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов")]
        public float sGegktmleMXZOZVqD;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов ночью")]
        public float oaGDCSwHhwXSImaGtwdFTxVCo;
        [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов")]
        public float efujbsOqvXjaRW;
        [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов ночью")]
        public float BxEvRbOqskmfFblXoZUJuDWuJY;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере")]
        public float pugEOypuxzZsmZdSKZFOf;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере ночью")]
        public float rpbtmOeqLYReRbJVPb;
    }

    private class YKvNVAlKVtyHgdQMSBDjkjAHqMbYf
    {
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов")]
        public float sGegktmleMXZOZVqD;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов ночью")]
        public float oaGDCSwHhwXSImaGtwdFTxVCo;
        [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов")]
        public Dictionary<string, float> NFkuMJTnoGvVUuvZrXThjErqHaUBC;
        [JsonProperty(PropertyName = "Стандартные рейты инструментов добычи")]
        public Dictionary<string, float> wLlCIDXEeclqeiFSXKo;
        [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов")]
        public float efujbsOqvXjaRW;
        [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов ночью")]
        public float BxEvRbOqskmfFblXoZUJuDWuJY;
        [JsonProperty(PropertyName = "Стандартные рейты поднимаемых ресурсов")]
        public Dictionary<string, float> HqoCWvBbWlkfIIU;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере")]
        public float pugEOypuxzZsmZdSKZFOf;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере ночью")]
        public float rpbtmOeqLYReRbJVPb;
        [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов в карьере")]
        public Dictionary<string, float> PxUYNMKyKGoBvuROafdhXXXUjYN;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов экскаватором")]
        public float YePbxylRVLx;
        [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов экскаватором ночью")]
        public float aiuVXFJwFIcdLiNxGeGGBAfI;
        [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов экскаватором")]
        public Dictionary<string, float> CqIOOIesPdbhnhrMuKHyq;
        [JsonProperty(PropertyName = "Общий рейт рудного и древесного чая")]
        public float XNtQFnLuUtBJXwyQhATerGZll;
        [JsonProperty(PropertyName = "Общий рейт рудного и древесного чая ночью")]
        public float WiWfZmecQrreCVAYHyiMnWgbl;
        [JsonProperty(PropertyName = "Включить разделение рейтов на ночной и дневной режим")]
        public bool zsoHZjExDiuKdluUKGKsqYO;
        [JsonProperty(PropertyName = "Час игрового времени с которого включается ночной режим")]
        public int CbJjGmeaiukgaHAUDJSKaaYoPQtFgU;
        [JsonProperty(PropertyName = "Час игрового времени с которого выключается ночной режим")]
        public int RMtJfnKgpztlkNICsjOffkcI;
        [JsonProperty(PropertyName = "Выводить оповещение в чат при смене ночного и дневного режима")]
        public bool AEOqiUuRmzSfvIIw;
        [JsonProperty(PropertyName = "Изменение рейтов для игроков с привилегиями")]
        public Dictionary<string, NgMeCAQtKwjHNgNNmahvyzlMdIU> pxFhJnupSKinwQZGDfugRjs;
    }

    private void jZoFNoouxQhUThiNJqLltoHJD();
    protected override void LoadDefaultConfig();
    private void hjsHLbYXjEvKDwaSsfAyDa(YKvNVAlKVtyHgdQMSBDjkjAHqMbYf nYKhIMflMNqcGkCGZDbwWxIaGWeK);
}

private class NgMeCAQtKwjHNgNNmahvyzlMdIU
{
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов")]
    public float sGegktmleMXZOZVqD;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов ночью")]
    public float oaGDCSwHhwXSImaGtwdFTxVCo;
    [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов")]
    public float efujbsOqvXjaRW;
    [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов ночью")]
    public float BxEvRbOqskmfFblXoZUJuDWuJY;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере")]
    public float pugEOypuxzZsmZdSKZFOf;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере ночью")]
    public float rpbtmOeqLYReRbJVPb;
}

private class YKvNVAlKVtyHgdQMSBDjkjAHqMbYf
{
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов")]
    public float sGegktmleMXZOZVqD;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов ночью")]
    public float oaGDCSwHhwXSImaGtwdFTxVCo;
    [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов")]
    public Dictionary<string, float> NFkuMJTnoGvVUuvZrXThjErqHaUBC;
    [JsonProperty(PropertyName = "Стандартные рейты инструментов добычи")]
    public Dictionary<string, float> wLlCIDXEeclqeiFSXKo;
    [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов")]
    public float efujbsOqvXjaRW;
    [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов ночью")]
    public float BxEvRbOqskmfFblXoZUJuDWuJY;
    [JsonProperty(PropertyName = "Стандартные рейты поднимаемых ресурсов")]
    public Dictionary<string, float> HqoCWvBbWlkfIIU;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере")]
    public float pugEOypuxzZsmZdSKZFOf;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере ночью")]
    public float rpbtmOeqLYReRbJVPb;
    [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов в карьере")]
    public Dictionary<string, float> PxUYNMKyKGoBvuROafdhXXXUjYN;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов экскаватором")]
    public float YePbxylRVLx;
    [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов экскаватором ночью")]
    public float aiuVXFJwFIcdLiNxGeGGBAfI;
    [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов экскаватором")]
    public Dictionary<string, float> CqIOOIesPdbhnhrMuKHyq;
    [JsonProperty(PropertyName = "Общий рейт рудного и древесного чая")]
    public float XNtQFnLuUtBJXwyQhATerGZll;
    [JsonProperty(PropertyName = "Общий рейт рудного и древесного чая ночью")]
    public float WiWfZmecQrreCVAYHyiMnWgbl;
    [JsonProperty(PropertyName = "Включить разделение рейтов на ночной и дневной режим")]
    public bool zsoHZjExDiuKdluUKGKsqYO;
    [JsonProperty(PropertyName = "Час игрового времени с которого включается ночной режим")]
    public int CbJjGmeaiukgaHAUDJSKaaYoPQtFgU;
    [JsonProperty(PropertyName = "Час игрового времени с которого выключается ночной режим")]
    public int RMtJfnKgpztlkNICsjOffkcI;
    [JsonProperty(PropertyName = "Выводить оповещение в чат при смене ночного и дневного режима")]
    public bool AEOqiUuRmzSfvIIw;
    [JsonProperty(PropertyName = "Изменение рейтов для игроков с привилегиями")]
    public Dictionary<string, NgMeCAQtKwjHNgNNmahvyzlMdIU> pxFhJnupSKinwQZGDfugRjs;
}


```

---

## Give

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Give", "Reneb", "2.1.2", ResourceId = 666)]
 class Give : RustPlugin
{
    private bool Changed;
    private int giveBasic;
    private int giveAll;
    private int giveKit;
    private string itemNotFound;
    private string multiplePlayersFound;
    private string noPlayersFound;
    private string noAccess;
    private bool logAdmins;
    private bool Stackable;
    private Dictionary<string,string> displaynameToShortname;
    [PluginReference]
     Plugin Kits;
     void Loaded();
     void OnServerInitialized();
    private void InitializeTable();
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private void LoadVariables();
    protected override void LoadDefaultConfig();
     bool hasAccess(BasePlayer player, string ttype);
    private object FindPlayerByID(ulong steamid);
    private object FindPlayer(string tofind);
    public object GiveItem(BasePlayer player, string itemname, int amount, ItemContainer pref, string description);
     bool hasKit(string args);
     void GiveKit(object source, string[] Args, string ttype);
     void SendTheReply(object source, string message);
     void GivePlayer(object source, string[] Args);
     void GiveSelf(object source, BasePlayer player, string[] Args);
    private void GiveToAll(ConsoleSystem.Arg arg);
    [ChatCommand("give")]
     void cmdChatGivePlayer(BasePlayer player, string command, string[] args);
    [ChatCommand("giveme")]
     void cmdChatGiveMe(BasePlayer player, string command, string[] args);
    [ConsoleCommand("inv.giveplayer")]
     void cmdConsoleGivePlayer(ConsoleSystem.Arg arg);
    [ConsoleCommand("inv.give")]
     void cmdConsoleGive(ConsoleSystem.Arg arg);
    [ConsoleCommand("inv.giveall")]
     void cmdConsoleGiveAll(ConsoleSystem.Arg arg);
}


```

---

## GiveServerMsg

```csharp

Oxide.Plugins
[Info("GiveServerMsg", "EcoSmile", "1.0.0", ResourceId = 2336)]
[Description("Hide server give message")]
 class GiveServerMsg : RustPlugin
{
     object OnServerMessage(string m, string n);
}


```

---

## Godmode

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust;
using Rust;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Godmode", "Wulf/lukespragg/Arainrr/dFxPhoeniX", "4.2.14")]
[Description("Allows players with permission to be invulnerable and god-like")]
internal class Godmode : RustPlugin
{
    private const string PermAdmin;
    private const string PermInvulnerable;
    private const string PermLootPlayers;
    private const string PermLootProtection;
    private const string PermNoAttacking;
    private const string PermToggle;
    private const string PermUntiring;
    private const string PermAutoEnable;
    private readonly object _false;
    private readonly object _true;
    private Dictionary<ulong, float> _informHistory;
    private readonly StoredMetabolism _storedMetabolism;
    private void Init();
    private void OnServerInitialized();
    private void OnServerSave();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private void Unload();
    private object CanBeWounded(BasePlayer player);
    private object CanLootPlayer(BasePlayer target, BasePlayer looter);
    private object OnEntityTakeDamage(BasePlayer player, HitInfo info);
    private object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player, float delta);
    private void CheckHooks();
    private void InformPlayers(BasePlayer victim, BasePlayer attacker);
    private bool? ToggleGodmode(BasePlayer target, BasePlayer player);
    private bool EnableGodmode(string playerId, bool isInit);
    private bool DisableGodmode(string playerId, bool isUnload);
    private void PlayerRename(BasePlayer player, bool isGod);
    private void Rename(BasePlayer player, string newName);
    private void ModifyMetabolism(BasePlayer player, bool isGod);
    private class StoredMetabolism
    {
        public bool FetchDefaultMetabolism();
        private Attribute calories;
        private Attribute hydration;
        private Attribute heartrate;
        private Attribute temperature;
        private Attribute poison;
        private Attribute radiation_level;
        private Attribute radiation_poison;
        private Attribute wetness;
        private Attribute dirtyness;
        private Attribute oxygen;
        private Attribute bleeding;
        public float GetMaxHydration();
        public void Store(PlayerMetabolism playerMetabolism);
        public void Unlimited(PlayerMetabolism playerMetabolism);
        public void Restore(PlayerMetabolism playerMetabolism);
    }

    private static void NullifyDamage(HitInfo info);
    private static string GetPayerOriginalName(ulong playerId);
    private bool EnableGodmode(IPlayer iPlayer);
    private bool EnableGodmode(ulong playerId);
    private bool DisableGodmode(IPlayer iPlayer);
    private bool DisableGodmode(ulong playerId);
    private bool IsGod(ulong playerId);
    private bool IsGod(BasePlayer player);
    private bool IsGod(string playerId);
    private string[] AllGods(string playerId);
    private string[] AllGods();
    private void GodCommand(IPlayer iPlayer, string command, string[] args);
    private void GodsCommand(IPlayer iPlayer, string command, string[] args);
    private ConfigData configData;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Inform On Attack (true/false)")]
        public bool informOnAttack;
        [JsonProperty(PropertyName = "Inform Interval (Seconds)")]
        public float informInterval;
        [JsonProperty(PropertyName = "Show Name Prefix (true/false)")]
        public bool showNamePrefix;
        [JsonProperty(PropertyName = "Name Prefix (Default [God])")]
        public string namePrefix;
        [JsonProperty(PropertyName = "Time Limit (Seconds, 0 to Disable)")]
        public float timeLimit;
        [JsonProperty(PropertyName = "Disable godmode after disconnect (true/false)")]
        public bool disconnectDisable;
        [JsonProperty(PropertyName = "Chat Prefix")]
        public string prefix;
        [JsonProperty(PropertyName = "Chat Prefix color")]
        public string prefixColor;
        [JsonProperty(PropertyName = "Chat steamID icon")]
        public ulong steamIDIcon;
        [JsonProperty(PropertyName = "God commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] godCommand;
        [JsonProperty(PropertyName = "Gods commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] godsCommand;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private StoredData storedData;
    private class StoredData
    {
        public readonly HashSet<string> godPlayers;
    }

    private void LoadData();
    private void SaveData();
    private void ClearData();
    private void Print(IPlayer iPlayer, string message);
    private void Print(BasePlayer player, string message);
    private string Lang(string key, string id, object[] args);
    protected override void LoadDefaultMessages();
}

private class StoredMetabolism
{
    public bool FetchDefaultMetabolism();
    private Attribute calories;
    private Attribute hydration;
    private Attribute heartrate;
    private Attribute temperature;
    private Attribute poison;
    private Attribute radiation_level;
    private Attribute radiation_poison;
    private Attribute wetness;
    private Attribute dirtyness;
    private Attribute oxygen;
    private Attribute bleeding;
    public float GetMaxHydration();
    public void Store(PlayerMetabolism playerMetabolism);
    public void Unlimited(PlayerMetabolism playerMetabolism);
    public void Restore(PlayerMetabolism playerMetabolism);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Inform On Attack (true/false)")]
    public bool informOnAttack;
    [JsonProperty(PropertyName = "Inform Interval (Seconds)")]
    public float informInterval;
    [JsonProperty(PropertyName = "Show Name Prefix (true/false)")]
    public bool showNamePrefix;
    [JsonProperty(PropertyName = "Name Prefix (Default [God])")]
    public string namePrefix;
    [JsonProperty(PropertyName = "Time Limit (Seconds, 0 to Disable)")]
    public float timeLimit;
    [JsonProperty(PropertyName = "Disable godmode after disconnect (true/false)")]
    public bool disconnectDisable;
    [JsonProperty(PropertyName = "Chat Prefix")]
    public string prefix;
    [JsonProperty(PropertyName = "Chat Prefix color")]
    public string prefixColor;
    [JsonProperty(PropertyName = "Chat steamID icon")]
    public ulong steamIDIcon;
    [JsonProperty(PropertyName = "God commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] godCommand;
    [JsonProperty(PropertyName = "Gods commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] godsCommand;
}

private class StoredData
{
    public readonly HashSet<string> godPlayers;
}


```

---

## GoldCard

```csharp
using System;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("GoldCard", "", "1.0.4")]
[Description("")]
 class GoldCard : RustPlugin
{
    private const string Shortname;
    [PluginReference]
     Plugin IQChat;
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty("SkinID для предмета")]
        public ulong SkinID;
        [JsonProperty("DisplayName для предмета")]
        public string DisplayName;
        [JsonProperty("Как быстро будет ломаться предмет ? (1.0 стандарт)")]
        public float condition;
        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
     void CreateItem(BasePlayer player);
    public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel);
    private Item OnItemSplit(Item item, int amount);
     object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem);
     object CanStackItem(Item item, Item targetItem);
    private object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player);
    [ConsoleCommand("card")]
     void CardCommand(ConsoleSystem.Arg arg);
}

private class Configuration
{
    [JsonProperty("SkinID для предмета")]
    public ulong SkinID;
    [JsonProperty("DisplayName для предмета")]
    public string DisplayName;
    [JsonProperty("Как быстро будет ломаться предмет ? (1.0 стандарт)")]
    public float condition;
    public static Configuration GetNewConfiguration();
}


```

---

## GoldenFish

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("GoldenFish", "Mercury & DezLife", "1.0.831")]
[Description("RF")]
 class GoldenFish : RustPlugin
{
    public class CustomItem
    {
        [JsonProperty("Отображаемое имя", Order = 0)]
        public string DisplayName;
        [JsonProperty("Этот парамтр менять не нужно", Order = 1)]
        public string ShortName;
        [JsonProperty("Шанс выпадения", Order = 2)]
        public int DropChance;
        [JsonProperty("Кол-вл выпадения", Order = 3)]
        public int DropAmount;
        [JsonProperty("Скин ID рыбки", Order = 4)]
        public ulong SkinId;
        [JsonProperty("Призы за переработку", Order = 5)]
        public List<ItemGiveInfo> GiveItems;
        public Item Copy(int amount);
        public Item CreateItem(int amount);
    }

    public class ItemGiveInfo
    {
        [JsonProperty("Шортнейм предмета")]
        public string shortname;
        [JsonProperty("СкинИД предмета")]
        public ulong skinID;
        [JsonProperty("Минимальное количество предметов")]
        public int Minamount;
        [JsonProperty("Максимальное количество предметов")]
        public int Maxamount;
    }

    private Configuration _CFG;
    public class Configuration
    {
        [JsonProperty("Настройка плагина")]
        public CustomItem customItem;
    }

    protected override void LoadDefaultConfig();
     void SaveConfig(Configuration config);
    public void LoadConfigVars();
    [ChatCommand("gf.give")]
    private void CmdChatDebugGoldfSpawn(BasePlayer player, string command, string[] args);
     void OnServerInitialized();
    private Item OnItemSplit(Item item, int amount);
     object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem);
     object CanStackItem(Item item, Item targetItem);
     List<ulong> Players;
     object CanLootEntity(BasePlayer player, StorageContainer container);
     void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
     void OnItemAddedToContainer(ItemContainer container, Item item);
     object OnItemAction(Item item, string action, BasePlayer player);
    private static void ItemRemovalThink(Item item, BasePlayer player, int itemsToTake);
}

public class CustomItem
{
    [JsonProperty("Отображаемое имя", Order = 0)]
    public string DisplayName;
    [JsonProperty("Этот парамтр менять не нужно", Order = 1)]
    public string ShortName;
    [JsonProperty("Шанс выпадения", Order = 2)]
    public int DropChance;
    [JsonProperty("Кол-вл выпадения", Order = 3)]
    public int DropAmount;
    [JsonProperty("Скин ID рыбки", Order = 4)]
    public ulong SkinId;
    [JsonProperty("Призы за переработку", Order = 5)]
    public List<ItemGiveInfo> GiveItems;
    public Item Copy(int amount);
    public Item CreateItem(int amount);
}

public class ItemGiveInfo
{
    [JsonProperty("Шортнейм предмета")]
    public string shortname;
    [JsonProperty("СкинИД предмета")]
    public ulong skinID;
    [JsonProperty("Минимальное количество предметов")]
    public int Minamount;
    [JsonProperty("Максимальное количество предметов")]
    public int Maxamount;
}

public class Configuration
{
    [JsonProperty("Настройка плагина")]
    public CustomItem customItem;
}


```

---

## Goldenskull

```csharp


```

---

## GradeDestroy

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("GradeDestroy", "Hougan", "1.2.0")]
public class GradeDestroy : RustPlugin
{
    private class CurrentGrade
    {
        [JsonProperty("Текущий индекс улучшения")]
        public int Grade;
        [JsonProperty("Время до де-активации")]
        public int DeActivateTime;
        [JsonProperty("Таймер обновления")]
        public Timer DeTimer;
        public void UpdateTime(BasePlayer player, int time);
        public void UpGrade(BasePlayer player, int time);
        public void Activate(BasePlayer player, int grade, int time);
        public void DeActivate(BasePlayer player);
    }

    private static string CONF_RemovePermission;
    private static bool CONF_RemoveActivated;
    private static int CONF_RemoveTime;
    private static int CONF_RemoveDefaultTime;
    private static int CONF_RemoveHitTime;
    private static bool CONF_RemoveGameFriends;
    private static bool CONF_RemoveFriends;
    private static bool CONF_RemoveClans;
    private static bool CONF_RemoveByCup;
    private static bool CONF_RemoveOneHit;
    private static bool CONF_BlockRemoveOnRaid;
    private static bool CONF_UpActivated;
    private static string CONF_UpPermission;
    private static bool CONF_BlockUpgradeOnRaid;
    private static bool CONF_EnableOnHit;
    private static List<string> CONF_GradeNames;
    [PluginReference]
    private Plugin Friends;
    private Plugin Clans;
    private Plugin NoEscape;
    private string Layer;
    private static GradeDestroy instance;
     Dictionary<uint, double> removeTimers;
    private Dictionary<ulong, CurrentGrade> playerGrades;
    private void OnServerInitialized();
    private void Unload();
    private void SaveData();
    protected override void LoadDefaultConfig();
    private string TryRemove(BasePlayer player, BaseEntity entity);
    private string TryUpgrade(BasePlayer player, BuildingBlock block, CurrentGrade currentGrade);
    private void UpdateTimer(BasePlayer player);
    [ChatCommand("remove")]
    private void cmdChatRemove(BasePlayer player, string command, string[] args);
    [ChatCommand("up")]
    private void cmdChatUpgrade(BasePlayer player, string command, string[] args);
    private void OnEntityBuilt(Planner plan, GameObject go);
     void OnHammerHit(BasePlayer player, HitInfo info);
     object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade);
    private void OnPlayerInit(BasePlayer player);
    private static string HexToRustFormat(string hex);
    public static string FormatTime(TimeSpan time, int maxSubstr, string language);
    public bool Initializated();
    private static string Format(int units, string form1, string form2, string form3);
    private bool GetConfig(string mainMenu, string key, T var);
    private static DateTime epoch;
    private static double LogTime();
}

private class CurrentGrade
{
    [JsonProperty("Текущий индекс улучшения")]
    public int Grade;
    [JsonProperty("Время до де-активации")]
    public int DeActivateTime;
    [JsonProperty("Таймер обновления")]
    public Timer DeTimer;
    public void UpdateTime(BasePlayer player, int time);
    public void UpGrade(BasePlayer player, int time);
    public void Activate(BasePlayer player, int grade, int time);
    public void DeActivate(BasePlayer player);
}


```

---

## GrandRustPanel

```csharp
using System;
using System.Globalization;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;

Oxide.Plugins
[Info("GrandRustPanel", "", "2.0.0")]
public class GrandRustPanel : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    public Dictionary<ulong, bool> PanelVisibility;
     string Layer;
     string Layer1;
    private PluginConfig cfg;
    public class PluginConfig
    {
        [JsonProperty("Основные настройки")]
        public Settings MainSettings;
        [JsonProperty("Эвенты")]
        public ESettings EventSets;
        [JsonProperty("Сообщения")]
        public MessageSettings SettingsMessages;
        public class Settings
        {
            [JsonProperty("Включить показ кнопки магазина?")]
            public bool EnableStore;
            [JsonProperty("Время обновления поля времени сервера")]
            public float RefreshTimer;
        }

        public class ESettings
        {
            [JsonProperty("Показывать эвент \"танк\"?")]
            public bool EnableTank;
        }

        public class MessageSettings
        {
            [JsonProperty("Время обновления сообщений")]
            public float RefreshTimer;
            [JsonProperty("Размер текста для автосообщений")]
            public int TextSize;
            [JsonProperty("Список сообщений", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Messages;
        }

    }

    private void Init();
    protected override void LoadDefaultConfig();
     Dictionary<string, string> Messages;
     void InitializeLang();
    private void OnServerInitialized();
     void Unload();
     void OnEntityKill(BaseNetworkable entity);
    private void OnPlayerConnected(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
     void OnEntitySpawned(BaseNetworkable entity);
     bool HasHeli();
     bool HasPlane();
     bool HasCargo();
     bool HasCh47();
     bool HasBradley();
    [ChatCommand("panel")]
     void PanelCommand(BasePlayer player, string command, string[] args);
    [ConsoleCommand("panel")]
     void PanelConsoleCommand(ConsoleSystem.Arg args);
     void DrawNewMessage();
     void UpdateTime();
     void DrawEvents(BasePlayer player, string name);
    private void DrawStoreMenu(BasePlayer player);
    private void UpdateClose(BasePlayer player);
    private void DrawMenu(BasePlayer player);
     void DrawMessage(BasePlayer player);
    private static string HexToRustFormat(string hex);
}

public class PluginConfig
{
    [JsonProperty("Основные настройки")]
    public Settings MainSettings;
    [JsonProperty("Эвенты")]
    public ESettings EventSets;
    [JsonProperty("Сообщения")]
    public MessageSettings SettingsMessages;
    public class Settings
    {
        [JsonProperty("Включить показ кнопки магазина?")]
        public bool EnableStore;
        [JsonProperty("Время обновления поля времени сервера")]
        public float RefreshTimer;
    }

    public class ESettings
    {
        [JsonProperty("Показывать эвент \"танк\"?")]
        public bool EnableTank;
    }

    public class MessageSettings
    {
        [JsonProperty("Время обновления сообщений")]
        public float RefreshTimer;
        [JsonProperty("Размер текста для автосообщений")]
        public int TextSize;
        [JsonProperty("Список сообщений", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> Messages;
    }

}

public class Settings
{
    [JsonProperty("Включить показ кнопки магазина?")]
    public bool EnableStore;
    [JsonProperty("Время обновления поля времени сервера")]
    public float RefreshTimer;
}

public class ESettings
{
    [JsonProperty("Показывать эвент \"танк\"?")]
    public bool EnableTank;
}

public class MessageSettings
{
    [JsonProperty("Время обновления сообщений")]
    public float RefreshTimer;
    [JsonProperty("Размер текста для автосообщений")]
    public int TextSize;
    [JsonProperty("Список сообщений", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<string> Messages;
}


```

---

## Grow

```csharp
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

Oxide.Plugins
[Info("Grow", "Doldak", "1.2.2")]
[Description(
        "Allows players to grow plants instantly using ServerRewards, Economics, or Scrap as currency"
    )]
 class Grow : RustPlugin
{
    [PluginReference]
     Plugin ServerRewards;
     Plugin Economics;
    const string _growUse;
    private ConfigData config;
    private class ConfigData
    {
        [JsonProperty("currency active?")]
        public bool SRA;
        [JsonProperty("if currency true = ServerRewards")]
        public bool UseServerRewards;
        [JsonProperty("if currency true = Economics")]
        public bool UseEconomics;
        [JsonProperty("if currency true = Scrap")]
        public bool UseScrap;
        [JsonProperty("cost")]
        public int cost;
    }

    private ConfigData GenerateConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultMessages();
     void OnServerInitialized();
    [ChatCommand("grow")]
    private void growcomand(BasePlayer player);
    private string GetCurrencyName();
    private string GetCurrencyCostMessageKey();
    public void GrowAll(BasePlayer player);
     bool CheckBalance(BasePlayer player, int cost);
    public void BalanceTake(BasePlayer player, int cost);
     string Lang(string key, string id, object[] args);
}

private class ConfigData
{
    [JsonProperty("currency active?")]
    public bool SRA;
    [JsonProperty("if currency true = ServerRewards")]
    public bool UseServerRewards;
    [JsonProperty("if currency true = Economics")]
    public bool UseEconomics;
    [JsonProperty("if currency true = Scrap")]
    public bool UseScrap;
    [JsonProperty("cost")]
    public int cost;
}


```

---

## Guardian

```csharp
using Facepunch;
using Facepunch.Math;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

Oxide.Plugins
[Info("Guardian", "WhiteDragon", "1.7.9")]
[Description("Protects the server from various annoyances, cheats, and macro attacks.")]
 class Guardian : CovalencePlugin
{
    [PluginReference]
    private Plugin Friends;
    private Plugin PlaytimeTracker;
    private static Guardian _instance;
    private class ActionQueue
    {
        private Queue<Action> actions;
        public ActionQueue(float interval);
        public void Clear();
        public void Enqueue(Action callback);
        private void Scan();
    }

    private class Admin
    {
        public class Settings
        {
            public bool Broadcast;
            public bool Bypass;
            public Settings();
        }

    }

    private class AntiCheat
    {
        public class Settings
        {
            public Aim.Settings Aim;
            public FireRate.Settings FireRate;
            public Gravity.Settings Gravity;
            public MeleeRate.Settings MeleeRate;
            public Recoil.Settings Recoil;
            public Server.Settings Server;
            public Stash.Settings Stash;
            public Trajectory.Settings Trajectory;
            public WallHack.Settings WallHack;
            public Settings();
            public void Validate();
        }

        private const Key category;
        private const float epsilon;
        public static void Configure();
        public static void Unload();
        public class Aim
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public AimTrigger Trigger;
                public bool Warn;
                public Settings();
                public class AimTrigger
                {
                    public bool Animal;
                    public bool Bradley;
                    public bool Helicopter;
                    public bool NPC;
                }

                public void Validate();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            private static float aim_distance;
            private static float headshot_scale;
            private static float hit_scale;
            private static float pvp_distance;
            private static float sensitivity_lo;
            private static float sensitivity_hi;
            private static float spin_angle;
            private static float swing_angle;
            private class History
            {
                public HitArea boneArea;
                public Counter headshot;
                public Counter hit;
                public HashSet<int> hits;
                public Counter repeat;
                private static readonly Dictionary<ulong, History> histories;
                private History();
                public static void Clear();
                public static bool Contains(ulong userid);
                public static History Get(ulong userid);
            }

            public static void Configure();
            public static void Trigger(BaseEntity entity, HitInfo info);
            public static void Unload();
            public static void Update(Weapon weapon);
        }

        public class FireRate
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            private static float sensitivity;
            private class History
            {
                public int entity;
                public DateTime fired;
                public float repeat;
                private static readonly Dictionary<ulong, History> histories;
                private History();
                public static void Clear();
                public static History Get(ulong userid);
            }

            public static void Configure();
            private static uint Percent(float min, float delay, float max);
            public static void Trigger(BaseEntity entity, HitInfo info);
            public static void Unload();
        }

        public class Gravity
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            private static float sensitivity_lo;
            private static float sensitivity_md;
            private static float sensitivity_hi;
            private class History
            {
                private static readonly Dictionary<ulong, float> histories;
                public static void Clear();
                public static float Set(ulong userid, float new_value);
            }

            public static void Configure();
            private static bool Check(BasePlayer player);
            public static void Scan();
            public static void Trigger(BasePlayer player, float amount, bool scanned);
            public static void Unload();
        }

        public class MeleeRate
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            private static float sensitivity;
            private class History
            {
                private static readonly Dictionary<ulong, DateTime> histories;
                public static void Clear();
                public static float Set(ulong userid, DateTime new_value);
            }

            public static void Configure();
            private static uint Percent(float delay, float max);
            public static void Trigger(BasePlayer player, HitInfo info);
            public static void Unload();
        }

        public class Recoil
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const float latency_min;
            private const float latency_max;
            private const float recoil_max;
            private const float recoil_range;
            private const float recoil_scale;
            private const float repeat_interval;
            private const Key type;
            private static readonly Violation violation;
            private static ulong reset_limit;
            private static float sensitivity;
            private class History
            {
                public Counter count_r;
                public Counter count_x;
                public Counter count_y;
                public DateTime fired;
                public ulong repeats;
                private static readonly Dictionary<ulong, History> histories;
                private History();
                public static void Clear();
                public static History Get(BasePlayer player);
            }

            public static void Configure();
            private static float Latency(BasePlayer player, Weapon weapon);
            private static uint Percent(float value);
            public static void Trigger(BasePlayer player, Weapon weapon);
            public static void Unload();
        }

        public class Server
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private static Vector3 sensitivity;
            private const Key type;
            private static readonly Violation violation;
            public static void Configure();
            public static void Scan();
            public static void Trigger(BasePlayer player, AntiHackType ahtype, float amount);
            public static void Unload();
        }

        public class Stash
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            private class History
            {
                private static readonly Dictionary<ulong, List<Vector3>> histories;
                public static void Clear();
                public static float Set(ulong userid, Vector3 position);
            }

            private static float sensitivity;
            public static void Configure();
            public static void Subscribe();
            public static void Trigger(BasePlayer player, StashContainer stash);
            public static void Unload();
        }

        public class Trajectory
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            private static float sensitivity;
            private static float sensitivity_lo;
            private static float sensitivity_hi;
            public static void Configure();
            private static float Ratio(float a, float b);
            private static uint Percent(float value);
            public static void Trigger(BaseCombatEntity entity, HitInfo info);
            public static void Unload();
        }

        public class WallHack
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            public static void Configure();
            public static void Trigger(BasePlayer player, HitInfo info);
            public static void Unload();
        }

    }

    private class AntiFlood
    {
        public class Settings
        {
            public Chat.Settings Chat;
            public Command.Settings Command;
            public ItemDrop.Settings ItemDrop;
            public Settings();
            public void Validate();
        }

        private const Key category;
        public static void Configure();
        public static void Unload();
        public class Chat
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            public static void Configure();
            public static ulong Cooldown(ulong playerid);
            public static void Subscribe();
            public static bool Trigger(ulong playerid);
            public static void Unload();
            public static void Violation(BasePlayer player, string details);
        }

        public class Command
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            public static void Configure();
            public static ulong Cooldown(ulong playerid);
            public static void Subscribe();
            public static bool Trigger(ulong playerid);
            public static void Unload();
            public static void Violation(BasePlayer player, string details);
        }

        public class ItemDrop
        {
            public class Settings
            {
                public bool Ban;
                public ulong Cooldown;
                public bool Enabled;
                public float Sensitivity;
                public bool Warn;
                public Settings();
                public Violation.Settings Validate(ulong max);
            }

            private const Key type;
            private static readonly Violation violation;
            private static readonly Dictionary<ulong, int> history;
            public static void Configure();
            public static ulong CoolDown(ulong playerid, int itemid);
            public static void Subscribe();
            public static bool Trigger(ulong playerid, int itemid);
            public static void Unload();
            public static void Violation(BasePlayer player, string details);
        }

    }

    public class API
    {
        public class Settings
        {
            public string ApiKey;
            public bool Enabled;
            public Settings();
            public void Validate();
        }

    }

    public class Ban
    {
        public class Settings
        {
            public bool Inherit;
            public bool Teleport;
            public BanTime Time;
            public Settings();
            public class BanTime
            {
                public bool Enforce;
                public bool Multiply;
                public ulong Seconds;
            }

            public void Validate();
        }

    }

    private class Chat
    {
        public static void Admin(Key key, Dictionary<string, string> parameters);
        public static void Broadcast(Key key, Dictionary<string, string> parameters);
        public static void Console(BasePlayer player, Key key, Dictionary<string, string> parameters);
        public static void Reply(IPlayer iplayer, Key key, Dictionary<string, string> parameters);
        public static void Send(BasePlayer player, Key key, Dictionary<string, string> parameters);
    }

    private void CommandReceive(IPlayer iplayer, string command, string[] args);
    private class Command
    {
        private static readonly Dictionary<string, Info> commands;
        private static List<Info> info;
        private class Info
        {
            public Action<IPlayer, string, string[]> Action { get; set; }
            public List<string> Aliases { get; set; }
            public Key Title { get; set; }
            public Info(Action<IPlayer, string, string[]> action, Key title, string[] aliases);
        }

        public static void Load();
        public static void Receive(IPlayer iplayer, string command, string[] args);
        public static void Unload();
        private static void Config(IPlayer iplayer, string command, string[] args);
        private static string Config(string subsection);
        private static bool Config(IPlayer iplayer, string[] args, string setting, T value, Action callback);
        private static void Help(IPlayer iplayer, string command, string[] args);
        private static void Ip(IPlayer iplayer, string command, string[] args);
        private static void Ip(IPlayer iplayer, Key key, IP.NetworkInfo network, bool add);
        private static void Ip(IPlayer iplayer, Key key, List<string> list);
        private static void Log(IPlayer iplayer, string command, string[] args);
        private static void Server(IPlayer iplayer, string command, string[] args);
        private static void Teleport(IPlayer iplayer, string command, string[] args);
        private static void Users(IPlayer iplayer, string command, string[] args);
        private static void Users(IPlayer iplayer, Key key, HashSet<ulong> userids);
        private static void Vpn(IPlayer iplayer, string command, string[] args);
        private static void Vpn(IPlayer iplayer, Key key, string address);
    }

    private static Configuration config;
    private class Configuration
    {
        public Admin.Settings Admin;
        public AntiCheat.Settings AntiCheat;
        public AntiFlood.Settings AntiFlood;
        public Ban.Settings Ban;
        public Cripple.Settings Cripple;
        public Discord.Settings Discord;
        public Entity.Settings Entity;
        public IP.Settings IP;
        public Log.Settings Log;
        public Steam.Settings Steam;
        public User.Settings User;
        public Version.Settings Version;
        public Violation.Settings Violation;
        public VPN.Settings VPN;
        private static bool corrupt;
        private static bool dirty;
        private static bool upgraded;
        public static void Clamp(T value, T min, T max);
        public static void Load();
        public static void Save();
        public static void SetDirty();
        public static void SetUpgrade(bool upgrade);
        public static void Unload();
        public static bool Upgraded();
        public static void Validate(T value, Func<T> initializer, Action validator);
        private static void Validate();
    }

    private class Counter
    {
        private uint count;
        private uint delay;
        public Counter();
        public void Decrement();
        public void Increment();
        public uint Percent();
        public float Ratio(bool inverse);
        public float Ratio(float scale, bool inverse);
        public ulong Total();
    }

    public class Cripple
    {
        public class Settings
        {
            public bool Heal;
            public bool Inherit;
            public Settings();
        }

    }

    private class Data
    {
        private static DataFileSystem data;
        private static string path;
        public static void Close();
        public static bool Exists(string name);
        public static void Open();
        public static T ReadObject(string name);
        public static void WriteObject(string name, T value);
    }

    private class DataFile
    {
        private readonly Dictionary<TKey, TValue> data;
        private bool dirty;
        private string name;
        public DataFile(string name);
        public void Add(TKey key, TValue value);
        public bool Contains(TKey key);
        public void Clear();
        public bool Exists();
        public void ForEach(Action<TKey, TValue> action);
        public TValue Get(TKey key, TValue default_value);
        public bool IsDirty();
        public bool IsEmpty();
        public void Load();
        public void Load(string name);
        public void Remove(TKey key);
        public void Save();
        public void Save(string name);
        public void SetDirty(bool value);
        public void SetName(string name);
        public void Unload();
    }

    private class Discord
    {
        public class Settings
        {
            public bool Enabled;
            public string WebHook;
            public DiscordFilters Filters;
            public Settings();
            public class DiscordFilter
            {
                public bool Enabled;
                public string WebHook;
                public DiscordFilter();
                public string URL();
                public void Validate();
            }

            public class DiscordFilters
            {
                public DiscordFilter AntiCheat;
                public DiscordFilter AntiFlood;
                public DiscordFilter IP;
                public DiscordFilter Steam;
                public DiscordFilter VPN;
                public DiscordFilters();
                public void Validate();
            }

            public void Validate();
        }

        public static void Send(string category, Dictionary<string, object> message);
        private static string Select(string category);
        public static void Subscribe();
    }

    private class Entity
    {
        public class Settings
        {
            public EntityDamage Damage;
            public Settings();
            public class EntityDamage
            {
                public float Animal;
                public float Bradley;
                public float Building;
                public float Entity;
                public float Friend;
                public float Helicopter;
                public float NPC;
                public float Player;
                public float Team;
                public float Trap;
                public EntityDamage();
                public void Validate();
            }

            public void Validate();
        }

        public class Damage
        {
            private static readonly DamageTypeList cleared;
            public static void Cancel(HitInfo info);
            public static object Scale(HitInfo info, BasePlayer attacker, BaseCombatEntity victim);
            private static object Scale(HitInfo info, BasePlayer attacker, BasePlayer victim);
            private static object Scale(HitInfo info, float scale);
        }

        public static BasePlayer GetAttacker(BaseCombatEntity entity, HitInfo info);
        public static string GetName(BaseEntity entity);
        private static string GetName(BaseEntity entity, Type type);
        private static string GetPrefabName(BaseEntity entity);
        public static Type GetType(BaseEntity entity, string name);
        public static Type GetType(BaseEntity entity);
        public class Health
        {
            private static readonly Dictionary<int, float> health;
            public static bool Changed(BaseEntity entity);
            public static void Clear();
            public static void Clear(BaseEntity entity);
        }

        public static void Unload();
    }

    private class Fire
    {
        private static Dictionary<int, BasePlayer> fires;
        public static void Ignite(FireBall fire, BasePlayer initiator);
        public static BasePlayer Initiator(FireBall fire);
        public static void Spread(FireBall fire, FireBall spread);
        public static void Quench(FireBall fire);
        public static void Unload();
    }

    private class Generic
    {
        public static T Clamp(T value, T min, T max);
    }

    private new class Hooks
    {
        private static HashSet<string> subscribed;
        private static HashSet<string> unsubscribed;
        public class Base
        {
            public static void Subscribe();
        }

        public class Core
        {
            public static void Subscribe();
        }

        public class Dynamic
        {
            public static void Subscribe();
        }

        public static void Load();
        public static void Subscribe(string hook);
        public static void Unload();
        private static void Unsubscribe();
        public static void Unsubscribe(string hook);
    }

    private void Init();
    private void Loaded();
    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
    private void OnServerInitialized();
    private void OnServerSave();
    private void Unload();
    private object CanBypassQueue(Connection connection);
    private object CanCraft(ItemCrafter crafter, ItemBlueprint bp, int amount);
    private object CanLootEntity(BasePlayer looter, DroppedItemContainer target);
    private object CanLootEntity(BasePlayer looter, LootableCorpse target);
    private object CanLootPlayer(BasePlayer target, BasePlayer looter);
    private object CanSeeStash(BasePlayer player, StashContainer stash);
    private object CanUserLogin(string name, string id, string address);
    private void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void OnEntityKill(BaseNetworkable entity);
    private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo info);
    private void OnFireBallSpread(FireBall fireball, BaseEntity entity);
    private void OnFlameExplosion(FlameExplosive explosive, BaseEntity entity);
    private void OnFlameThrowerBurn(FlameThrower flamethrower, BaseEntity entity);
    private void OnGroupPermissionGranted(string name, string perm);
    private void OnGroupPermissionRevoked(string name, string perm);
    private void OnGuardianViolation(string playerid, Dictionary<string, string> details);
    private void OnItemDropped(Item item, BaseEntity entity);
    private void OnLootEntity(BasePlayer looter, BaseEntity target);
    private void OnLootPlayer(BasePlayer looter, BasePlayer target);
    private object OnPlayerAttack(BasePlayer player, HitInfo info);
    private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel);
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private object OnPlayerViolation(BasePlayer player, AntiHackType ahtype, float amount);
    private void OnRocketLaunched(BasePlayer player, BaseEntity entity);
    private object OnServerCommand(ConsoleSystem.Arg arg);
    private void OnUserBanned(string playername, string playerid, string playerip, string reason);
    private void OnUserPermissionGranted(string id, string perm);
    private void OnUserPermissionRevoked(string id, string perm);
    private void OnUserUnbanned(string playername, string playerid, string playerip);
    private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemmod, ProtoBuf.ProjectileShoot projectiles);
    private class IP
    {
        public class Settings
        {
            public IpFilter Filter;
            public IpViolation Violation;
            public Settings();
            public class IpFilter
            {
                public ulong Cooldown;
                public IpFilter();
                public void Validate();
            }

            public class IpViolation
            {
                public bool Ban;
                public bool Enabled;
                public IpViolation();
            }

            public void Validate();
        }

        private static readonly DataFile<string, uint> allows;
        private static readonly DataFile<string, bool> blocks;
        private static readonly DataFile<string, uint> denies;
        private static readonly HashSet<ulong> empty;
        private static readonly DataFile<string, DateTime> filter;
        private static TimeSpan filter_cooldown;
        private static readonly DataFile<string, HashSet<ulong>> users;
        private static readonly Violation violation;
        public class NetworkInfo
        {
            public string Address { get; set; }
            public uint Bits { get; set; }
            public NetworkInfo(string address, uint bits);
        }

        private static uint Bits(string address);
        public static void Block(NetworkInfo network);
        public static void Block(string address, ulong userid);
        public static void Bypass(NetworkInfo network);
        public static void Bypass(string address);
        private static uint Decimal(string address);
        public static bool Cooldown(string address);
        public static void Configure();
        public static bool Filter(string address, ulong userid);
        public static HashSet<ulong> Find(string address);
        private static List<string> Get(DataFile<string, uint> data, string address);
        public static List<string> GetAllows(string address);
        public static List<string> GetDenies(string address);
        public static bool IsAllowed(string address);
        public static bool IsBlocked(string address);
        public static bool IsDenied(string address);
        private static bool IsMatched(DataFile<string, uint> data, string address);
        public static bool IsValid(string address, bool full, bool wildcard);
        public static void Load();
        private static bool Match(uint ip, uint network, uint bits);
        private static List<string> Match(NetworkInfo network);
        public static NetworkInfo Network(string address);
        public static string Parse(string address);
        public static void Save();
        private static bool Set(DataFile<string, uint> data, NetworkInfo network, bool add);
        public static bool SetAllow(NetworkInfo network, bool add);
        public static bool SetDeny(NetworkInfo network, bool add);
        public static string ToString(uint ip);
        public static void Unblock(NetworkInfo network);
        public static void Unblock(string address);
        public static void Unload();
        public static void Update(string address, ulong userid);
        private static void Violation(string address, ulong userid);
    }

    private new class Log
    {
        public class Settings
        {
            public LogAntiCheat AntiCheat;
            public LogAntiFlood AntiFlood;
            public LogIp IP;
            public LogProjectile Projectile;
            public LogUser User;
            public LogVpn VPN;
            public Settings();
            public class LogAntiCheat
            {
                public bool Aim;
                public bool Gravity;
                public bool MeleeRate;
                public bool Recoil;
                public bool Server;
                public bool Stash;
                public bool Trajectory;
            }

            public class LogAntiFlood
            {
                public bool ItemDrop;
            }

            public class LogIp
            {
                public bool Filter;
                public LogIp();
            }

            public class LogProjectile
            {
                public bool Collapse;
                public bool Verbose;
                public LogProjectile();
            }

            public class LogUser
            {
                public bool Bypass;
                public bool Connect;
                public LogUser();
            }

            public class LogVpn
            {
                public bool Check;
                public LogVpn();
            }

            public void Validate();
        }

        public static void Console(Key key, Dictionary<string, string> parameters);
        public static void Error(string message);
        public static void Warning(string message);
    }

    private class Map
    {
        public class Building
        {
            public static bool HasPrivilege(DecayEntity entity);
            public static bool InFoundation(Vector3 position);
            public static bool IsNearby(Vector3 position, bool check_privilege);
        }

        public class Cave
        {
            public static bool IsInside(Vector3 position);
        }

        public class Collider
        {
            public static string Info(Vector3 position);
        }

        public class Entities
        {
            public static bool InRange(Vector3 position, float radius);
        }

        public static string Grid(Vector3 position);
        private class Hit
        {
            private static string Collider(RaycastHit hit);
            public static bool IsBunker(RaycastHit hit);
            public static bool IsBunker(string collider);
            public static bool IsCave(RaycastHit hit);
            public static bool IsCave(string collider);
            public static bool IsCorridor(RaycastHit hit);
            public static bool IsCorridor(string collider);
            public static bool IsDuct(RaycastHit hit);
            public static bool IsDuct(string collider);
            public static bool IsFoundation(RaycastHit hit);
            public static bool IsFoundation(string collider);
            public static bool IsMine(RaycastHit hit);
            public static bool IsMine(string collider);
            public static bool IsRoad(RaycastHit hit);
            public static bool IsRoad(string collider);
            public static bool IsRock(RaycastHit hit);
            public static bool IsRock(string collider);
            public static bool IsStairwell(RaycastHit hit);
            public static bool IsStairwell(string collider);
            public static bool IsTunnel(RaycastHit hit);
            public static bool IsTunnel(string collider);
            public static bool IsUnderground(RaycastHit hit);
            public static bool IsUnderground(string collider);
        }

        public static bool InRange(Vector3 a, Vector3 b, float distance);
        public static bool InRange2D(Vector3 a, Vector3 b, float distance);
        public static void Load();
        public class Monument
        {
            private static SparseMap global;
            private static SparseMap tunnel;
            public static bool IsNearby(Vector3 position);
            public static bool IsTunnel(Vector3 position);
            public static void Load();
            private static float Range(MonumentInfo monument);
            public static void Unload();
        }

        public class Position
        {
            private static bool HasCheck(Check checks, Check check);
            public static Vector3 Random(Check checks);
            private static Vector3 Random(float min_x, float max_x, float min_z, float max_z);
        }

        public class Road
        {
            public static bool IsNearby(Vector3 position);
        }

        public class Rock
        {
            public static bool IsInside(Vector3 position, bool check_cave);
        }

        public static Vector3 Surface(Vector3 position, float offset);
        public class Terrain
        {
            public static float Height(Vector3 position);
            public static bool IsInside(Vector3 position, bool check_cave);
            public static bool IsSurface(Vector3 position);
            public static Vector3 Level(Vector3 position, float offset);
        }

        public class Underground
        {
            public static bool IsInside(Vector3 position);
        }

        public static void Unload();
        public class Water
        {
            public static float Height(Vector3 position);
            public static bool IsSurface(Vector3 position);
            public static Vector3 Level(Vector3 position, float offset);
        }

    }

    private class Permissions
    {
        private static string PERMISSION_ADMIN;
        private static string PERMISSION_ALL;
        private static string PERMISSION_IGNORE;
        private static string PERMISSION_PREFIX;
        private static readonly HashSet<ulong> all;
        private static readonly HashSet<ulong> admin;
        private static readonly HashSet<ulong> ignore;
        public static bool Admin(ulong userid, bool forced);
        public static bool All(ulong userid, bool forced);
        public class Bypass
        {
            private static string PERMISSION_PREFIX;
            private static string PERMISSION_STEAM;
            private static string PERMISSION_VPN;
            private static readonly HashSet<ulong> steam;
            private static readonly HashSet<ulong> vpn;
            public class AntiCheat
            {
                private static readonly HashSet<ulong> aim;
                private static readonly HashSet<ulong> firerate;
                private static readonly HashSet<ulong> gravity;
                private static readonly HashSet<ulong> meleerate;
                private static readonly HashSet<ulong> recoil;
                private static readonly HashSet<ulong> server;
                private static readonly HashSet<ulong> stash;
                private static readonly HashSet<ulong> trajectory;
                private static readonly HashSet<ulong> wallhack;
                private static string PERMISSION_AIM;
                private static string PERMISSION_FIRERATE;
                private static string PERMISSION_GRAVITY;
                private static string PERMISSION_MELEERATE;
                private static string PERMISSION_PREFIX;
                private static string PERMISSION_RECOIL;
                private static string PERMISSION_SERVER;
                private static string PERMISSION_STASH;
                private static string PERMISSION_TRAJECTORY;
                private static string PERMISSION_WALLHACK;
                public static void Load();
                public static bool Aim(ulong userid, bool forced);
                public static bool FireRate(ulong userid, bool forced);
                public static bool Gravity(ulong userid, bool forced);
                public static bool MeleeRate(ulong userid, bool forced);
                public static bool Recoil(ulong userid, bool forced);
                public static void Reset(ulong userid);
                public static bool Server(ulong userid, bool forced);
                public static bool Stash(ulong userid, bool forced);
                public static bool Trajectory(ulong userid, bool forced);
                public static void Unload();
                public static void Update(ulong userid);
                public static bool WallHack(ulong userid, bool forced);
            }

            public static void Load();
            public static void Reset(ulong userid);
            public static bool Steam(ulong userid, bool forced);
            public static void Unload();
            public static void Update(ulong userid);
            public static bool Vpn(ulong userid, bool forced);
        }

        public class Command
        {
            private static readonly HashSet<ulong> config;
            private static readonly HashSet<ulong> ip;
            private static readonly HashSet<ulong> server;
            private static readonly HashSet<ulong> tp;
            private static readonly HashSet<ulong> vpn;
            private static string PERMISSION_CONFIG;
            private static string PERMISSION_IP;
            private static string PERMISSION_PREFIX;
            private static string PERMISSION_SERVER;
            private static string PERMISSION_TP;
            private static string PERMISSION_VPN;
            public static void Load();
            public static bool Config(ulong userid, bool forced);
            public static bool Ip(ulong userid, bool forced);
            public static void Reset(ulong userid);
            public static bool Server(ulong userid, bool forced);
            public static bool Tp(ulong userid, bool forced);
            public static void Unload();
            public static void Update(ulong userid);
            public static bool Vpn(ulong userid, bool forced);
        }

        public static string[] Groups(ulong userid);
        private static bool HasPermission(ulong userid, string permission);
        public static bool HasPrefix(string permission);
        public static bool Ignore(ulong userid, bool forced);
        public static void Load();
        public static void Reset(ulong userid);
        public static void Unload();
        public static void Update(ulong userid);
        private static bool Update(ulong userid, string permission, HashSet<ulong> cache);
    }

    private class Projectile
    {
        public class Log
        {
            private static readonly Queue<Entry> expired;
            private static readonly Dictionary<ulong, Queue<Entry>> history;
            private static readonly Dictionary<ulong, Dictionary<int, Entry>> pending;
            private static readonly Queue<Request> request;
            private static readonly Queue<Entry> reserve;
            static readonly StringBuilder buffer;
            private class Entry
            {
                public float aim_angle;
                public float aim_pvp;
                public float aim_range;
                public ulong aim_violations;
                public string attacker;
                public ulong attacker_id;
                public ulong firerate_violations;
                public float hit_distance;
                public HitArea hit_location;
                public bool pvp;
                public float recoil_pitch;
                public ulong recoil_repeats;
                public float recoil_swing;
                public ulong recoil_violations;
                public float recoil_yaw;
                public bool ricochet;
                public float speed;
                public DateTime timestamp;
                public float trajectory;
                public ulong trajectory_violations;
                public string victim;
                public bool violations;
                public ulong wallhack_violations;
                public string weapon;
                private static readonly Queue<Entry> pool;
                private Entry(DateTime timestamp);
                private Entry Default();
                public string Format(bool collapse, bool id, bool time);
                public static Entry Get(DateTime timestamp);
                public void Release();
                private Entry Set(DateTime timestamp);
                public static void Unload();
            }

            private class Request
            {
                public IPlayer actor;
                public int lines;
                public ulong userid;
            }

            public static void Add(Weapon weapon);
            public static void Expire(Weapon weapon);
            public static void Get(IPlayer actor, ulong userid, int lines);
            public static float GetAimAngle(ulong userid, int id);
            public static bool GetAimPvp(ulong userid, int id);
            public static float GetHitDistance(ulong userid, int id);
            public static HitArea GetHitLocation(ulong userid, int id);
            public static bool GetRicochet(ulong userid, int id);
            public static string GetVictim(ulong userid, int id);
            public static void Send();
            public static void SetAim(ulong userid, int id, float aim_angle, float aim_pvp, float aim_range, bool pvp, bool ricochet);
            public static void SetAimViolations(ulong userid, int id, ulong aim_violations, bool add);
            public static void SetAttacker(ulong userid, int id, string attacker, ulong attaker_id);
            public static void SetFireRateViolations(ulong userid, int id, ulong firerate_violations);
            public static void SetHit(ulong userid, int id, float hit_distance, HitArea hit_location);
            public static void SetRecoil(ulong userid, int id, float recoil_pitch, ulong recoil_repeats, float recoil_yaw, float recoil_swing);
            public static void SetRecoilViolations(ulong userid, int id, ulong recoil_violations);
            public static void SetTrajectory(ulong userid, int id, float trajectory);
            public static void SetTrajectoryViolations(ulong userid, int id, ulong trajectory_violations);
            public static void SetVictim(ulong userid, int id, string victim);
            public static void SetWallHackViolations(ulong userid, int id, ulong wallhack_violations);
            public static void SetWeapon(ulong userid, int id, float speed, string weapon);
            private static void TrySetEntry(ulong userid, int id, Action<Entry> set);
            public static void Unload();
        }

        private static readonly List<Weapon> expired;
        private static readonly Dictionary<ulong, Dictionary<int, Weapon>> reverse;
        private static readonly Dictionary<ulong, Queue<Weapon>> weapons;
        public static void Add(Weapon weapon);
        public static void Load();
        public static void Unload();
        public static Weapon Weapon(ulong userid, int projectileid);
    }

    private class SparseMap
    {
        private Dictionary<Texel, Cell> map;
        private float map_scale;
        public SparseMap(float scale);
        public void Clear();
        public int Count();
        public void Reset(float scale);
        private void Reset(Pixel pixel);
        public void Reset(Vector3 position);
        public float Scale();
        private int Scale(float n);
        private void Set(Pixel pixel);
        public void Set(Vector3 position);
        public int Set(Vector3 origin, float range);
        private void SetScale(float scale);
        private bool Test(Pixel pixel);
        public bool Test(Vector3 position);
    }

    private class Steam
    {
        public class Settings
        {
            public API.Settings API;
            public SteamBan Ban;
            public SteamGame Game;
            public SteamProfile Profile;
            public SteamShare Share;
            public SteamViolation Violation;
            public Settings();
            public class SteamBan
            {
                public bool Active;
                public bool Community;
                public ulong Days;
                public bool Economy;
                public ulong Game;
                public ulong VAC;
            }

            public class SteamGame
            {
                public ulong Count;
                public ulong Hours;
            }

            public class SteamProfile
            {
                public bool Invalid;
                public bool Limited;
                public bool Private;
            }

            public class SteamShare
            {
                public bool Family;
            }

            public class SteamViolation
            {
                public bool Ban;
                public bool Enabled;
                public bool Warn;
                public SteamViolation();
            }

            public void Validate();
        }

        private static uint appid;
        private static ActionQueue checks;
        private static readonly Violation violation;
        public static void Check(ulong userid);
        public static void Configure();
        public static void Load();
        public static void Unload();
        private static void Violation(ulong userid, Key type, string details, bool ban);
        private class Ban
        {
            [JsonProperty("players")]
            public Player[] Players;
            public class Player
            {
                [JsonProperty("CommunityBanned")]
                public bool CommunityBanned;
                [JsonProperty("VACBanned")]
                public bool VacBanned;
                [JsonProperty("NumberOfVACBans")]
                public ulong NumberOfVacBans;
                [JsonProperty("DaysSinceLastBan")]
                public ulong DaysSinceLastBan;
                [JsonProperty("NumberOfGameBans")]
                public ulong NumberOfGameBans;
                [JsonProperty("EconomyBan")]
                public string EconomyBan;
            }

            [JsonIgnore]
            private static readonly string api;
            [JsonIgnore]
            public static bool check;
            public static void Check(ulong userid);
        }

        private class Game
        {
            [JsonProperty("response")]
            public Content Response;
            public class Content
            {
                [JsonProperty("game_count")]
                public ulong GameCount;
                [JsonProperty("games")]
                public Game[] Games;
                public class Game
                {
                    [JsonProperty("appid")]
                    public uint AppId;
                    [JsonProperty("playtime_forever")]
                    public ulong PlaytimeForever;
                }

            }

            [JsonIgnore]
            private static readonly string api;
            [JsonIgnore]
            public static bool check;
            public static void Check(ulong userid, bool private_profile, bool is_sharing);
        }

        private class Profile
        {
            private static readonly string api;
            public static bool check;
            public static void Check(ulong userid, bool private_profile);
        }

        private class Share
        {
            [JsonProperty("response")]
            public Content Response;
            public class Content
            {
                [JsonProperty("lender_steamid")]
                public ulong LenderSteamId;
            }

            [JsonIgnore]
            private static readonly string api;
            [JsonIgnore]
            public static bool check;
            public static void Check(ulong userid, bool private_profile);
        }

        private class Summaries
        {
            [JsonProperty("response")]
            public Content Response;
            public class Content
            {
                [JsonProperty("players")]
                public Player[] Players;
                public class Player
                {
                    [JsonProperty("communityvisibilitystate")]
                    public int CommunityVisibilityState;
                }

            }

            [JsonIgnore]
            private static readonly string api;
            [JsonIgnore]
            public static bool check;
            public static void Check(ulong userid);
        }

    }

    private class Text
    {
        private static readonly Dictionary<string, Dictionary<Key, string>> decorated;
        private static readonly Dictionary<string, Dictionary<Key, string>> unadorned;
        private static string server_language;
        private class RegEx
        {
            public static Regex clean1;
            public static Regex clean2;
            public static Regex clean3;
            public static Regex markup;
            public static Regex spaces;
            public static void Load();
            public static void Unload();
        }

        public static string Actor(IPlayer actor);
        public static string Actor(IPlayer actor, BasePlayer player);
        public static string Actor(IPlayer actor, IPlayer iplayer);
        public static string Actor(IPlayer actor, ulong userid);
        public static string Actor(IPlayer actor, string language);
        public static string BodyPart(HitArea area);
        public static string BodyPart(HitArea area, BasePlayer player);
        public static string BodyPart(HitArea area, IPlayer iplayer);
        public static string BodyPart(HitArea area, ulong userid);
        public static string BodyPart(HitArea area, string language);
        public class Duration
        {
            public static string Hours(TimeSpan time);
            public static string Hours(TimeSpan time, BasePlayer player);
            public static string Hours(TimeSpan time, IPlayer iplayer);
            public static string Hours(TimeSpan time, ulong userid);
            public static string Hours(TimeSpan time, string language);
            public static string Short(TimeSpan time);
            public static string Short(TimeSpan time, BasePlayer player);
            public static string Short(TimeSpan time, IPlayer iplayer);
            public static string Short(TimeSpan time, ulong userid);
            public static string Short(TimeSpan time, string language);
        }

        public static string Get(Key key, Dictionary<string, string> parameters);
        public static string Get(Key key, BasePlayer player, Dictionary<string, string> parameters);
        public static string Get(Key key, IPlayer iplayer, Dictionary<string, string> parameters);
        public static string Get(Key key, ulong userid, Dictionary<string, string> parameters);
        public static string Get(Key key, string language, Dictionary<string, string> parameters);
        private static string Get(Key key, Dictionary<Key, string> cache, Dictionary<string, string> parameters);
        public static string GetPlain(Key key, Dictionary<string, string> parameters);
        public static string GetPlain(Key key, BasePlayer player, Dictionary<string, string> parameters);
        public static string GetPlain(Key key, IPlayer iplayer, Dictionary<string, string> parameters);
        public static string GetPlain(Key key, ulong userid, Dictionary<string, string> parameters);
        public static string GetPlain(Key key, string language, Dictionary<string, string> parameters);
        public static string Language(string userid);
        public static void Load();
        private static Dictionary<Key, string> Messages(Dictionary<string, Dictionary<Key, string>> cache, string language);
        public static bool ParseTime(string message, ulong seconds);
        private static void RegisterMessages();
        private static string Replace(string message, Dictionary<string, string> parameters);
        private static string Strip(string message);
        public static string Sanitize(string message);
        private static string Trim(string message);
        public static void Unload();
    }

    private class Timers
    {
        private static readonly List<Timer> timers;
        public static void Add(float interval, Action callback);
        public static void Destroy();
    }

    private class User
    {
        public class Settings
        {
            public UserBypass Bypass;
            public UserFriend Friend;
            public UserTeam Team;
            public Settings();
            public class UserBypass
            {
                public ulong DaysSinceBan;
                public bool Enabled;
                public ulong HoursPlayed;
                public bool Multiply;
                public UserBypass();
                public void Validate();
            }

            public class UserFriend
            {
                public bool Damage;
            }

            public class UserTeam
            {
                public bool Damage;
            }

            public void Validate();
        }

        private class Info
        {
            public ulong userid;
            public string name;
            public HashSet<string> names;
            public string address;
            public HashSet<string> addresses;
            public DateTime time_connected;
            public DateTime time_disconnected;
            public TimeSpan time_played;
            public ulong ban_count;
            public string ban_reason;
            public DateTime ban_time;
            public DateTime ban_timer;
            public bool is_banned;
            public ulong cripple_count;
            public string cripple_reason;
            public DateTime cripple_time;
            public DateTime cripple_timer;
            public bool is_crippled;
            public Vector3 l_position;
            public Vector3 v_position;
            [JsonIgnore]
            public DateTime access_time;
            [JsonIgnore]
            public ulong attacked;
            [JsonIgnore]
            public ulong attacker;
            [JsonIgnore]
            public bool dirty;
            [JsonIgnore]
            public BasePlayer player;
            [JsonIgnore]
            public Stack<ulong> teleport;
            [JsonIgnore]
            public List<ulong> victims;
            public Info();
        }

        private static readonly DataFile<string, HashSet<ulong>> names;
        private static ActionQueue teleport;
        private static readonly Dictionary<ulong, Info> users;
        private static void Action(IPlayer actor, Key action, Info user);
        public static string Address(ulong userid);
        public static void AssignAttacker(BasePlayer attacker, BasePlayer victim);
        public static void AssignVictim(BasePlayer victim);
        private static void AssignVictims(Info user);
        public static void Ban(ulong userid, string reason, ulong seconds, IPlayer actor);
        public static ulong BanCount(ulong userid);
        private static void BanInherit(ulong userid, string name, string address, Info copy);
        public static void BanReset(ulong userid, IPlayer actor);
        private static void BanTeleport(Info user, ulong count);
        public static DateTime BanTime(ulong userid);
        private static void BanTimeEnforce(Info user);
        private static bool CanBypass(Info user);
        public static object CanConnect(string name, string id, string address);
        public static bool CanFly(BasePlayer player);
        private static bool CanLoot(ulong userid, ulong targetid);
        public static object CanLoot(BasePlayer player, ulong targetid);
        public static void Cripple(ulong userid, string reason, ulong seconds, IPlayer actor);
        private static void CrippleInherit(ulong userid, string name, string address, Info copy);
        public static void CrippleReset(ulong userid, IPlayer actor);
        public static bool Exists(ulong userid);
        public static HashSet<ulong> Find(string text);
        public static Vector3 GetLastSeenPosition(ulong userid);
        public static Vector3 GetViolationPosition(ulong userid);
        public static bool HasAuthLevel(BasePlayer player);
        public static bool HasAdminFlag(BasePlayer player);
        private static bool HasConnected(Info user);
        public static bool HasDeveloperFlag(BasePlayer player);
        public static bool HasParent(BasePlayer player);
        public static string InfoText(ulong userid);
        public static string InfoText(ulong userid, BasePlayer player);
        public static string InfoText(ulong userid, IPlayer iplayer);
        public static string InfoText(ulong userid, ulong playerid);
        public static string InfoText(ulong userid, string language);
        public static bool IsBanned(ulong userid);
        private static bool IsConnected(Info user);
        public static bool IsConnected(ulong userid);
        public static bool IsCrippled(ulong userid);
        public static bool IsFriend(BasePlayer a, BasePlayer b);
        public static bool IsFriend(BasePlayer player, ulong userid);
        public static bool IsInactive(BasePlayer player);
        private static bool IsStale(Info user);
        public static bool IsTeamMate(BasePlayer a, BasePlayer b);
        public static bool IsTeamMate(BasePlayer player, ulong userid);
        public static void Kick(ulong userid, string reason, IPlayer actor);
        public static void Load();
        private static Info Load(ulong userid);
        public static string Name(ulong userid);
        public static void OnBanned(ulong userid, bool banned);
        public static void OnConnected(BasePlayer player);
        public static void OnDisconnected(BasePlayer player);
        public static void OnLoot(BasePlayer player, ulong targetid);
        public static void Pardon(ulong userid, IPlayer actor);
        public static void Pardon(IPlayer actor);
        private static void Pardon(Queue<ulong> userid, IPlayer actor, int total);
        private static void Pardon(Info user, IPlayer actor, bool broadcast);
        public static void Save();
        private static void Save(Info user);
        private static void Scan();
        private static void SetLastSeenPosition(Info user, Vector3 position);
        private static void SetViolationPosition(Info user, Vector3 position);
        public static void SetViolationPosition(ulong userid);
        public static bool ShouldIgnore(BasePlayer player);
        public static string StatusText(ulong userid);
        public static string StatusText(ulong userid, BasePlayer player);
        public static string StatusText(ulong userid, IPlayer iplayer);
        public static string StatusText(ulong userid, ulong playerid);
        public static string StatusText(ulong userid, string language);
        private static string StatusText(Info user, string language);
        public static List<ulong> Team(ulong userid);
        public static TimeSpan TimeBanned(ulong userid);
        private static TimeSpan TimeBanned(Info user);
        public static TimeSpan TimeCrippled(ulong userid);
        private static TimeSpan TimeCrippled(Info user);
        private static TimeSpan TimeRemaining(DateTime time);
        public static TimeSpan TimeOffline(ulong userid);
        private static TimeSpan TimeOffline(Info user);
        public static TimeSpan TimeOnline(ulong userid);
        private static TimeSpan TimeOnline(Info user);
        private static TimeSpan TimeSpent(DateTime time);
        public static TimeSpan TimePlayed(ulong userid);
        private static TimeSpan TimePlayed(Info user);
        public static void Unban(ulong userid, bool manual, IPlayer actor);
        public static void Unban(IPlayer actor);
        private static void Unban(Info user, bool manual, IPlayer actor, bool broadcast);
        public static void Uncripple(ulong userid, bool manual, IPlayer actor);
        public static void Uncripple(IPlayer actor);
        private static void Uncripple(Info user, bool manual, IPlayer actor, bool broadcast);
        public static void Unload();
        public static void Update();
        private static void Update(Info user, string name, string address);
    }

    private new class Version
    {
        public class Settings
        {
            public int Major;
            public int Minor;
            public int Patch;
            public Settings();
            public int Compare(int major, int minor, int patch);
            public void Validate();
        }

        public static string String { get; set; }
    }

    private class Violation
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public float Sensitivity;
            public bool Warn;
            public Settings(bool ban, ulong cooldown, float sensitivity, bool warn);
            public ulong Count(ulong min, ulong max, bool squared);
            public Settings Validate(ulong max);
        }

        private bool ban;
        private Key category;
        private ulong cooldown;
        private ulong count;
        private TimeSpan rate;
        private bool warn;
        private Dictionary<ulong, History> histories;
        private static readonly Dictionary<string, Key> categories;
        private static ActionQueue triggers;
        private static readonly Violation violation;
        private class History
        {
            public DateTime cooldown;
            public ulong count;
            public DateTime time;
            public DateTime warned;
            public ulong warnings;
            public History();
        }

        public Violation(Key category);
        private void Broadcast(ulong userid, Key action, Key type, string details, Dictionary<string, string> hook_details);
        public static Key Category(string category);
        public static void Configure();
        public void Configure(Settings settings, ulong trigger_min, ulong trigger_max, ulong trigger_rate);
        public ulong Cooldown(ulong userid);
        public void Clear();
        private History Get(ulong userid);
        private bool IsFlooding(ulong userid);
        public static void Load();
        private void Reduce(ulong userid);
        private void Reset(ulong userid);
        public bool Trigger(ulong userid);
        public void Trigger(ulong userid, Key type, string details, bool kick, Dictionary<string, string> hook_details);
        public void Trigger(ulong userid, Key type, string details, ulong violations, bool kick, Dictionary<string, string> hook_details);
        private void Triggered(ulong userid, Key type, string details, ulong violations, bool kick, Dictionary<string, string> hook_details);
        public static void Unload();
        public void Warning(ulong userid, Key type, string details, Dictionary<string, string> hook_details);
        public void Zero(ulong userid);
    }

    private class VPN
    {
        public class Settings
        {
            public VpnApi API;
            public VpnCache Cache;
            public VpnCheck Check;
            public VpnViolation Violation;
            public Settings();
            public class VpnApi
            {
                public Guardian.API.Settings GetIpIntel;
                public Guardian.API.Settings IpApi;
                public Guardian.API.Settings IpHub;
                public Guardian.API.Settings IpQualityScore;
                public VpnApi();
                public void Validate();
            }

            public class VpnCache
            {
                public ulong Hours;
                public VpnCache();
            }

            public class VpnCheck
            {
                public bool Enabled;
                public bool Strict;
            }

            public class VpnViolation
            {
                public bool Ban;
                public bool Enabled;
                public bool Warn;
                public VpnViolation();
            }

            public void Validate();
        }

        private static ActionQueue checks;
        private static readonly Violation violation;
        public class API
        {
            public class GetIpIntel
            {
                [JsonProperty("message")]
                public string Message { get; set; }
                [JsonProperty("result")]
                public float Result { get; set; }
                [JsonProperty("status")]
                public string Status { get; set; }
                private const string api;
                public static void Check(string address, ulong userid);
            }

            public class IpApi
            {
                [JsonProperty("hosting")]
                public bool Hosting { get; set; }
                [JsonProperty("proxy")]
                public bool Proxy { get; set; }
                [JsonProperty("status")]
                public string Status { get; set; }
                private const string api;
                public static void Check(string address, ulong userid);
            }

            public class IpHub
            {
                [JsonProperty("block")]
                public int Block { get; set; }
                [JsonIgnore]
                private static readonly Dictionary<string, string> headers;
                private const string api;
                public static void Check(string address, ulong userid);
                public static void Configure();
                public static void Unload();
            }

            public class IpQualityScore
            {
                [JsonProperty("fraud_score")]
                public int FraudScore { get; set; }
                [JsonProperty("message")]
                public string Message { get; set; }
                [JsonProperty("proxy")]
                public bool Proxy { get; set; }
                [JsonProperty("recent_abuse")]
                public bool RecentAbuse { get; set; }
                [JsonProperty("success")]
                public bool Success { get; set; }
                [JsonProperty("vpn")]
                public bool VPN { get; set; }
                private const string api;
                public static void Check(string address, ulong userid);
            }

            public static void Configure();
            public static void Unload();
        }

        private class Cache
        {
            private static readonly DataFile<string, DateTime> blocks;
            private static readonly DataFile<string, DateTime> bypass;
            public static void Block(string address);
            public static void Bypass(string address, ulong _reserved);
            public static bool IsBlocked(string address);
            public static bool IsBypassed(string address);
            private static bool IsCached(DataFile<string, DateTime> cache, string address);
            private static bool IsExpired(DateTime timestamp, DateTime check);
            public static void Load();
            public static void Save();
            public static void Unblock(string address);
            public static void Unload();
            private static void Update();
            private static void Update(DataFile<string, DateTime> cache, DateTime current);
        }

        public static void Bypass(string address);
        public static void Check(string address, ulong userid);
        private static void Check(string address, ulong userid, float delay);
        private static void Check(float delay, string address, ulong userid, Action<string, ulong> callback);
        public static void Configure();
        public static bool IsBlocked(string address);
        public static bool IsBypassed(string address);
        public static void Load();
        public static void Save();
        public static void Unblock(string address);
        public static void Unload();
        private static void Violation(string address, ulong userid, string api);
    }

    private class Weapon
    {
        public float Accuracy { get; set; }
        public Vector3 AimAngle { get; set; }
        public float AimCone { get; set; }
        public float AimSway { get; set; }
        public string AmmoName { get; set; }
        public List<string> Attachments { get; set; }
        public bool Automatic { get; set; }
        public DateTime Fired { get; set; }
        public string Name { get; set; }
        public float Pitch { get; set; }
        public BasePlayer Player { get; set; }
        public Vector3 Position { get; set; }
        public List<int> Projectiles { get; set; }
        public float Range { get; set; }
        public float Repeat { get; set; }
        public bool Shell { get; set; }
        public string ShortName { get; set; }
        public float Speed { get; set; }
        public bool Spread { get; set; }
        public float Swing { get; set; }
        public float Velocity { get; set; }
        public float Yaw { get; set; }
        public float Zoom { get; set; }
        private static readonly Queue<Weapon> pool;
        private static readonly int ArrowBone;
        private static readonly int ArrowFire;
        private static readonly int ArrowHV;
        private static readonly int ArrowWooden;
        private static readonly int GrenadeHE;
        private static readonly int GrenadeShotgun;
        private static readonly int GrenadeSmoke;
        private static readonly int NailgunNails;
        private static readonly int PistolBullet;
        private static readonly int PistolHV;
        private static readonly int PistolIncendiary;
        private static readonly int RifleAmmo;
        private static readonly int RifleExplosive;
        private static readonly int RifleHV;
        private static readonly int RifleIncendiary;
        private static readonly int Rocket;
        private static readonly int RocketHV;
        private static readonly int RocketIncendiary;
        private static readonly int ShellBuckshot;
        private static readonly int ShellHandmade;
        private static readonly int ShellIncendiary;
        private static readonly int ShellSlug;
        private static readonly int AssaultRifle;
        private static readonly int BoltActionRifle;
        private static readonly int CompoundBow;
        private static readonly int Crossbow;
        private static readonly int CustomSMG;
        private static readonly int DoubleBarrelShotgun;
        private static readonly int EokaPistol;
        private static readonly int HuntingBow;
        private static readonly int L96Rifle;
        private static readonly int LR300AssaultRifle;
        private static readonly int M249;
        private static readonly int M39Rifle;
        private static readonly int M92Pistol;
        private static readonly int MP5A4;
        private static readonly int MultipleGrenadeLauncher;
        private static readonly int Nailgun;
        private static readonly int PumpShotgun;
        private static readonly int PythonRevolver;
        private static readonly int Revolver;
        private static readonly int RocketLauncher;
        private static readonly int SemiAutomaticPistol;
        private static readonly int SemiAutomaticRifle;
        private static readonly int Spas12Shotgun;
        private static readonly int Thompson;
        private static readonly int WaterpipeShotgun;
        private class Ammo
        {
            public float AimCone { get; set; }
            public float Range { get; set; }
            public float Velocity { get; set; }
            public Ammo(float aimcone, float range, float velocity);
        }

        private class Info
        {
            public float Accuracy { get; set; }
            public Dictionary<int, Ammo> Ammo { get; set; }
            public bool Automatic { get; set; }
            public string Name { get; set; }
            public Recoil Recoil { get; set; }
            public float Repeat { get; set; }
        }

        private class Recoil
        {
            public float Pitch { get; set; }
            public float Yaw { get; set; }
            public Recoil(float pitch, float yaw);
        }

        private static Dictionary<int, Info> weapons;
        private Weapon();
        private static Weapon Get();
        public static Weapon Get(ulong userid, int projectileid);
        public static Weapon Get(BaseProjectile weapon_fired, BasePlayer player, ProtoBuf.ProjectileShoot fired);
        public static bool IsValid(Item item);
        public static void Load();
        public void Release();
        public void SetSwing(float amount);
        public static void Unload();
    }

    private class WebHook
    {
        public static void Send(string url, string category, string message);
    }

}

private class ActionQueue
{
    private Queue<Action> actions;
    public ActionQueue(float interval);
    public void Clear();
    public void Enqueue(Action callback);
    private void Scan();
}

private class Admin
{
    public class Settings
    {
        public bool Broadcast;
        public bool Bypass;
        public Settings();
    }

}

public class Settings
{
    public bool Broadcast;
    public bool Bypass;
    public Settings();
}

private class AntiCheat
{
    public class Settings
    {
        public Aim.Settings Aim;
        public FireRate.Settings FireRate;
        public Gravity.Settings Gravity;
        public MeleeRate.Settings MeleeRate;
        public Recoil.Settings Recoil;
        public Server.Settings Server;
        public Stash.Settings Stash;
        public Trajectory.Settings Trajectory;
        public WallHack.Settings WallHack;
        public Settings();
        public void Validate();
    }

    private const Key category;
    private const float epsilon;
    public static void Configure();
    public static void Unload();
    public class Aim
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public AimTrigger Trigger;
            public bool Warn;
            public Settings();
            public class AimTrigger
            {
                public bool Animal;
                public bool Bradley;
                public bool Helicopter;
                public bool NPC;
            }

            public void Validate();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        private static float aim_distance;
        private static float headshot_scale;
        private static float hit_scale;
        private static float pvp_distance;
        private static float sensitivity_lo;
        private static float sensitivity_hi;
        private static float spin_angle;
        private static float swing_angle;
        private class History
        {
            public HitArea boneArea;
            public Counter headshot;
            public Counter hit;
            public HashSet<int> hits;
            public Counter repeat;
            private static readonly Dictionary<ulong, History> histories;
            private History();
            public static void Clear();
            public static bool Contains(ulong userid);
            public static History Get(ulong userid);
        }

        public static void Configure();
        public static void Trigger(BaseEntity entity, HitInfo info);
        public static void Unload();
        public static void Update(Weapon weapon);
    }

    public class FireRate
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        private static float sensitivity;
        private class History
        {
            public int entity;
            public DateTime fired;
            public float repeat;
            private static readonly Dictionary<ulong, History> histories;
            private History();
            public static void Clear();
            public static History Get(ulong userid);
        }

        public static void Configure();
        private static uint Percent(float min, float delay, float max);
        public static void Trigger(BaseEntity entity, HitInfo info);
        public static void Unload();
    }

    public class Gravity
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        private static float sensitivity_lo;
        private static float sensitivity_md;
        private static float sensitivity_hi;
        private class History
        {
            private static readonly Dictionary<ulong, float> histories;
            public static void Clear();
            public static float Set(ulong userid, float new_value);
        }

        public static void Configure();
        private static bool Check(BasePlayer player);
        public static void Scan();
        public static void Trigger(BasePlayer player, float amount, bool scanned);
        public static void Unload();
    }

    public class MeleeRate
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        private static float sensitivity;
        private class History
        {
            private static readonly Dictionary<ulong, DateTime> histories;
            public static void Clear();
            public static float Set(ulong userid, DateTime new_value);
        }

        public static void Configure();
        private static uint Percent(float delay, float max);
        public static void Trigger(BasePlayer player, HitInfo info);
        public static void Unload();
    }

    public class Recoil
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const float latency_min;
        private const float latency_max;
        private const float recoil_max;
        private const float recoil_range;
        private const float recoil_scale;
        private const float repeat_interval;
        private const Key type;
        private static readonly Violation violation;
        private static ulong reset_limit;
        private static float sensitivity;
        private class History
        {
            public Counter count_r;
            public Counter count_x;
            public Counter count_y;
            public DateTime fired;
            public ulong repeats;
            private static readonly Dictionary<ulong, History> histories;
            private History();
            public static void Clear();
            public static History Get(BasePlayer player);
        }

        public static void Configure();
        private static float Latency(BasePlayer player, Weapon weapon);
        private static uint Percent(float value);
        public static void Trigger(BasePlayer player, Weapon weapon);
        public static void Unload();
    }

    public class Server
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private static Vector3 sensitivity;
        private const Key type;
        private static readonly Violation violation;
        public static void Configure();
        public static void Scan();
        public static void Trigger(BasePlayer player, AntiHackType ahtype, float amount);
        public static void Unload();
    }

    public class Stash
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        private class History
        {
            private static readonly Dictionary<ulong, List<Vector3>> histories;
            public static void Clear();
            public static float Set(ulong userid, Vector3 position);
        }

        private static float sensitivity;
        public static void Configure();
        public static void Subscribe();
        public static void Trigger(BasePlayer player, StashContainer stash);
        public static void Unload();
    }

    public class Trajectory
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        private static float sensitivity;
        private static float sensitivity_lo;
        private static float sensitivity_hi;
        public static void Configure();
        private static float Ratio(float a, float b);
        private static uint Percent(float value);
        public static void Trigger(BaseCombatEntity entity, HitInfo info);
        public static void Unload();
    }

    public class WallHack
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        public static void Configure();
        public static void Trigger(BasePlayer player, HitInfo info);
        public static void Unload();
    }

}

public class Settings
{
    public Aim.Settings Aim;
    public FireRate.Settings FireRate;
    public Gravity.Settings Gravity;
    public MeleeRate.Settings MeleeRate;
    public Recoil.Settings Recoil;
    public Server.Settings Server;
    public Stash.Settings Stash;
    public Trajectory.Settings Trajectory;
    public WallHack.Settings WallHack;
    public Settings();
    public void Validate();
}

public class Aim
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public AimTrigger Trigger;
        public bool Warn;
        public Settings();
        public class AimTrigger
        {
            public bool Animal;
            public bool Bradley;
            public bool Helicopter;
            public bool NPC;
        }

        public void Validate();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    private static float aim_distance;
    private static float headshot_scale;
    private static float hit_scale;
    private static float pvp_distance;
    private static float sensitivity_lo;
    private static float sensitivity_hi;
    private static float spin_angle;
    private static float swing_angle;
    private class History
    {
        public HitArea boneArea;
        public Counter headshot;
        public Counter hit;
        public HashSet<int> hits;
        public Counter repeat;
        private static readonly Dictionary<ulong, History> histories;
        private History();
        public static void Clear();
        public static bool Contains(ulong userid);
        public static History Get(ulong userid);
    }

    public static void Configure();
    public static void Trigger(BaseEntity entity, HitInfo info);
    public static void Unload();
    public static void Update(Weapon weapon);
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public AimTrigger Trigger;
    public bool Warn;
    public Settings();
    public class AimTrigger
    {
        public bool Animal;
        public bool Bradley;
        public bool Helicopter;
        public bool NPC;
    }

    public void Validate();
    public Violation.Settings Validate(ulong max);
}

public class AimTrigger
{
    public bool Animal;
    public bool Bradley;
    public bool Helicopter;
    public bool NPC;
}

private class History
{
    public HitArea boneArea;
    public Counter headshot;
    public Counter hit;
    public HashSet<int> hits;
    public Counter repeat;
    private static readonly Dictionary<ulong, History> histories;
    private History();
    public static void Clear();
    public static bool Contains(ulong userid);
    public static History Get(ulong userid);
}

public class FireRate
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    private static float sensitivity;
    private class History
    {
        public int entity;
        public DateTime fired;
        public float repeat;
        private static readonly Dictionary<ulong, History> histories;
        private History();
        public static void Clear();
        public static History Get(ulong userid);
    }

    public static void Configure();
    private static uint Percent(float min, float delay, float max);
    public static void Trigger(BaseEntity entity, HitInfo info);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

private class History
{
    public int entity;
    public DateTime fired;
    public float repeat;
    private static readonly Dictionary<ulong, History> histories;
    private History();
    public static void Clear();
    public static History Get(ulong userid);
}

public class Gravity
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    private static float sensitivity_lo;
    private static float sensitivity_md;
    private static float sensitivity_hi;
    private class History
    {
        private static readonly Dictionary<ulong, float> histories;
        public static void Clear();
        public static float Set(ulong userid, float new_value);
    }

    public static void Configure();
    private static bool Check(BasePlayer player);
    public static void Scan();
    public static void Trigger(BasePlayer player, float amount, bool scanned);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

private class History
{
    private static readonly Dictionary<ulong, float> histories;
    public static void Clear();
    public static float Set(ulong userid, float new_value);
}

public class MeleeRate
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    private static float sensitivity;
    private class History
    {
        private static readonly Dictionary<ulong, DateTime> histories;
        public static void Clear();
        public static float Set(ulong userid, DateTime new_value);
    }

    public static void Configure();
    private static uint Percent(float delay, float max);
    public static void Trigger(BasePlayer player, HitInfo info);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

private class History
{
    private static readonly Dictionary<ulong, DateTime> histories;
    public static void Clear();
    public static float Set(ulong userid, DateTime new_value);
}

public class Recoil
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const float latency_min;
    private const float latency_max;
    private const float recoil_max;
    private const float recoil_range;
    private const float recoil_scale;
    private const float repeat_interval;
    private const Key type;
    private static readonly Violation violation;
    private static ulong reset_limit;
    private static float sensitivity;
    private class History
    {
        public Counter count_r;
        public Counter count_x;
        public Counter count_y;
        public DateTime fired;
        public ulong repeats;
        private static readonly Dictionary<ulong, History> histories;
        private History();
        public static void Clear();
        public static History Get(BasePlayer player);
    }

    public static void Configure();
    private static float Latency(BasePlayer player, Weapon weapon);
    private static uint Percent(float value);
    public static void Trigger(BasePlayer player, Weapon weapon);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

private class History
{
    public Counter count_r;
    public Counter count_x;
    public Counter count_y;
    public DateTime fired;
    public ulong repeats;
    private static readonly Dictionary<ulong, History> histories;
    private History();
    public static void Clear();
    public static History Get(BasePlayer player);
}

public class Server
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private static Vector3 sensitivity;
    private const Key type;
    private static readonly Violation violation;
    public static void Configure();
    public static void Scan();
    public static void Trigger(BasePlayer player, AntiHackType ahtype, float amount);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

public class Stash
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    private class History
    {
        private static readonly Dictionary<ulong, List<Vector3>> histories;
        public static void Clear();
        public static float Set(ulong userid, Vector3 position);
    }

    private static float sensitivity;
    public static void Configure();
    public static void Subscribe();
    public static void Trigger(BasePlayer player, StashContainer stash);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

private class History
{
    private static readonly Dictionary<ulong, List<Vector3>> histories;
    public static void Clear();
    public static float Set(ulong userid, Vector3 position);
}

public class Trajectory
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    private static float sensitivity;
    private static float sensitivity_lo;
    private static float sensitivity_hi;
    public static void Configure();
    private static float Ratio(float a, float b);
    private static uint Percent(float value);
    public static void Trigger(BaseCombatEntity entity, HitInfo info);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

public class WallHack
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    public static void Configure();
    public static void Trigger(BasePlayer player, HitInfo info);
    public static void Unload();
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

private class AntiFlood
{
    public class Settings
    {
        public Chat.Settings Chat;
        public Command.Settings Command;
        public ItemDrop.Settings ItemDrop;
        public Settings();
        public void Validate();
    }

    private const Key category;
    public static void Configure();
    public static void Unload();
    public class Chat
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        public static void Configure();
        public static ulong Cooldown(ulong playerid);
        public static void Subscribe();
        public static bool Trigger(ulong playerid);
        public static void Unload();
        public static void Violation(BasePlayer player, string details);
    }

    public class Command
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        public static void Configure();
        public static ulong Cooldown(ulong playerid);
        public static void Subscribe();
        public static bool Trigger(ulong playerid);
        public static void Unload();
        public static void Violation(BasePlayer player, string details);
    }

    public class ItemDrop
    {
        public class Settings
        {
            public bool Ban;
            public ulong Cooldown;
            public bool Enabled;
            public float Sensitivity;
            public bool Warn;
            public Settings();
            public Violation.Settings Validate(ulong max);
        }

        private const Key type;
        private static readonly Violation violation;
        private static readonly Dictionary<ulong, int> history;
        public static void Configure();
        public static ulong CoolDown(ulong playerid, int itemid);
        public static void Subscribe();
        public static bool Trigger(ulong playerid, int itemid);
        public static void Unload();
        public static void Violation(BasePlayer player, string details);
    }

}

public class Settings
{
    public Chat.Settings Chat;
    public Command.Settings Command;
    public ItemDrop.Settings ItemDrop;
    public Settings();
    public void Validate();
}

public class Chat
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    public static void Configure();
    public static ulong Cooldown(ulong playerid);
    public static void Subscribe();
    public static bool Trigger(ulong playerid);
    public static void Unload();
    public static void Violation(BasePlayer player, string details);
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

public class Command
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    public static void Configure();
    public static ulong Cooldown(ulong playerid);
    public static void Subscribe();
    public static bool Trigger(ulong playerid);
    public static void Unload();
    public static void Violation(BasePlayer player, string details);
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

public class ItemDrop
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public bool Enabled;
        public float Sensitivity;
        public bool Warn;
        public Settings();
        public Violation.Settings Validate(ulong max);
    }

    private const Key type;
    private static readonly Violation violation;
    private static readonly Dictionary<ulong, int> history;
    public static void Configure();
    public static ulong CoolDown(ulong playerid, int itemid);
    public static void Subscribe();
    public static bool Trigger(ulong playerid, int itemid);
    public static void Unload();
    public static void Violation(BasePlayer player, string details);
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public bool Enabled;
    public float Sensitivity;
    public bool Warn;
    public Settings();
    public Violation.Settings Validate(ulong max);
}

public class API
{
    public class Settings
    {
        public string ApiKey;
        public bool Enabled;
        public Settings();
        public void Validate();
    }

}

public class Settings
{
    public string ApiKey;
    public bool Enabled;
    public Settings();
    public void Validate();
}

public class Ban
{
    public class Settings
    {
        public bool Inherit;
        public bool Teleport;
        public BanTime Time;
        public Settings();
        public class BanTime
        {
            public bool Enforce;
            public bool Multiply;
            public ulong Seconds;
        }

        public void Validate();
    }

}

public class Settings
{
    public bool Inherit;
    public bool Teleport;
    public BanTime Time;
    public Settings();
    public class BanTime
    {
        public bool Enforce;
        public bool Multiply;
        public ulong Seconds;
    }

    public void Validate();
}

public class BanTime
{
    public bool Enforce;
    public bool Multiply;
    public ulong Seconds;
}

private class Chat
{
    public static void Admin(Key key, Dictionary<string, string> parameters);
    public static void Broadcast(Key key, Dictionary<string, string> parameters);
    public static void Console(BasePlayer player, Key key, Dictionary<string, string> parameters);
    public static void Reply(IPlayer iplayer, Key key, Dictionary<string, string> parameters);
    public static void Send(BasePlayer player, Key key, Dictionary<string, string> parameters);
}

private class Command
{
    private static readonly Dictionary<string, Info> commands;
    private static List<Info> info;
    private class Info
    {
        public Action<IPlayer, string, string[]> Action { get; set; }
        public List<string> Aliases { get; set; }
        public Key Title { get; set; }
        public Info(Action<IPlayer, string, string[]> action, Key title, string[] aliases);
    }

    public static void Load();
    public static void Receive(IPlayer iplayer, string command, string[] args);
    public static void Unload();
    private static void Config(IPlayer iplayer, string command, string[] args);
    private static string Config(string subsection);
    private static bool Config(IPlayer iplayer, string[] args, string setting, T value, Action callback);
    private static void Help(IPlayer iplayer, string command, string[] args);
    private static void Ip(IPlayer iplayer, string command, string[] args);
    private static void Ip(IPlayer iplayer, Key key, IP.NetworkInfo network, bool add);
    private static void Ip(IPlayer iplayer, Key key, List<string> list);
    private static void Log(IPlayer iplayer, string command, string[] args);
    private static void Server(IPlayer iplayer, string command, string[] args);
    private static void Teleport(IPlayer iplayer, string command, string[] args);
    private static void Users(IPlayer iplayer, string command, string[] args);
    private static void Users(IPlayer iplayer, Key key, HashSet<ulong> userids);
    private static void Vpn(IPlayer iplayer, string command, string[] args);
    private static void Vpn(IPlayer iplayer, Key key, string address);
}

private class Info
{
    public Action<IPlayer, string, string[]> Action { get; set; }
    public List<string> Aliases { get; set; }
    public Key Title { get; set; }
    public Info(Action<IPlayer, string, string[]> action, Key title, string[] aliases);
}

private class Configuration
{
    public Admin.Settings Admin;
    public AntiCheat.Settings AntiCheat;
    public AntiFlood.Settings AntiFlood;
    public Ban.Settings Ban;
    public Cripple.Settings Cripple;
    public Discord.Settings Discord;
    public Entity.Settings Entity;
    public IP.Settings IP;
    public Log.Settings Log;
    public Steam.Settings Steam;
    public User.Settings User;
    public Version.Settings Version;
    public Violation.Settings Violation;
    public VPN.Settings VPN;
    private static bool corrupt;
    private static bool dirty;
    private static bool upgraded;
    public static void Clamp(T value, T min, T max);
    public static void Load();
    public static void Save();
    public static void SetDirty();
    public static void SetUpgrade(bool upgrade);
    public static void Unload();
    public static bool Upgraded();
    public static void Validate(T value, Func<T> initializer, Action validator);
    private static void Validate();
}

private class Counter
{
    private uint count;
    private uint delay;
    public Counter();
    public void Decrement();
    public void Increment();
    public uint Percent();
    public float Ratio(bool inverse);
    public float Ratio(float scale, bool inverse);
    public ulong Total();
}

public class Cripple
{
    public class Settings
    {
        public bool Heal;
        public bool Inherit;
        public Settings();
    }

}

public class Settings
{
    public bool Heal;
    public bool Inherit;
    public Settings();
}

private class Data
{
    private static DataFileSystem data;
    private static string path;
    public static void Close();
    public static bool Exists(string name);
    public static void Open();
    public static T ReadObject(string name);
    public static void WriteObject(string name, T value);
}

private class DataFile
{
    private readonly Dictionary<TKey, TValue> data;
    private bool dirty;
    private string name;
    public DataFile(string name);
    public void Add(TKey key, TValue value);
    public bool Contains(TKey key);
    public void Clear();
    public bool Exists();
    public void ForEach(Action<TKey, TValue> action);
    public TValue Get(TKey key, TValue default_value);
    public bool IsDirty();
    public bool IsEmpty();
    public void Load();
    public void Load(string name);
    public void Remove(TKey key);
    public void Save();
    public void Save(string name);
    public void SetDirty(bool value);
    public void SetName(string name);
    public void Unload();
}

private class Discord
{
    public class Settings
    {
        public bool Enabled;
        public string WebHook;
        public DiscordFilters Filters;
        public Settings();
        public class DiscordFilter
        {
            public bool Enabled;
            public string WebHook;
            public DiscordFilter();
            public string URL();
            public void Validate();
        }

        public class DiscordFilters
        {
            public DiscordFilter AntiCheat;
            public DiscordFilter AntiFlood;
            public DiscordFilter IP;
            public DiscordFilter Steam;
            public DiscordFilter VPN;
            public DiscordFilters();
            public void Validate();
        }

        public void Validate();
    }

    public static void Send(string category, Dictionary<string, object> message);
    private static string Select(string category);
    public static void Subscribe();
}

public class Settings
{
    public bool Enabled;
    public string WebHook;
    public DiscordFilters Filters;
    public Settings();
    public class DiscordFilter
    {
        public bool Enabled;
        public string WebHook;
        public DiscordFilter();
        public string URL();
        public void Validate();
    }

    public class DiscordFilters
    {
        public DiscordFilter AntiCheat;
        public DiscordFilter AntiFlood;
        public DiscordFilter IP;
        public DiscordFilter Steam;
        public DiscordFilter VPN;
        public DiscordFilters();
        public void Validate();
    }

    public void Validate();
}

public class DiscordFilter
{
    public bool Enabled;
    public string WebHook;
    public DiscordFilter();
    public string URL();
    public void Validate();
}

public class DiscordFilters
{
    public DiscordFilter AntiCheat;
    public DiscordFilter AntiFlood;
    public DiscordFilter IP;
    public DiscordFilter Steam;
    public DiscordFilter VPN;
    public DiscordFilters();
    public void Validate();
}

private class Entity
{
    public class Settings
    {
        public EntityDamage Damage;
        public Settings();
        public class EntityDamage
        {
            public float Animal;
            public float Bradley;
            public float Building;
            public float Entity;
            public float Friend;
            public float Helicopter;
            public float NPC;
            public float Player;
            public float Team;
            public float Trap;
            public EntityDamage();
            public void Validate();
        }

        public void Validate();
    }

    public class Damage
    {
        private static readonly DamageTypeList cleared;
        public static void Cancel(HitInfo info);
        public static object Scale(HitInfo info, BasePlayer attacker, BaseCombatEntity victim);
        private static object Scale(HitInfo info, BasePlayer attacker, BasePlayer victim);
        private static object Scale(HitInfo info, float scale);
    }

    public static BasePlayer GetAttacker(BaseCombatEntity entity, HitInfo info);
    public static string GetName(BaseEntity entity);
    private static string GetName(BaseEntity entity, Type type);
    private static string GetPrefabName(BaseEntity entity);
    public static Type GetType(BaseEntity entity, string name);
    public static Type GetType(BaseEntity entity);
    public class Health
    {
        private static readonly Dictionary<int, float> health;
        public static bool Changed(BaseEntity entity);
        public static void Clear();
        public static void Clear(BaseEntity entity);
    }

    public static void Unload();
}

public class Settings
{
    public EntityDamage Damage;
    public Settings();
    public class EntityDamage
    {
        public float Animal;
        public float Bradley;
        public float Building;
        public float Entity;
        public float Friend;
        public float Helicopter;
        public float NPC;
        public float Player;
        public float Team;
        public float Trap;
        public EntityDamage();
        public void Validate();
    }

    public void Validate();
}

public class EntityDamage
{
    public float Animal;
    public float Bradley;
    public float Building;
    public float Entity;
    public float Friend;
    public float Helicopter;
    public float NPC;
    public float Player;
    public float Team;
    public float Trap;
    public EntityDamage();
    public void Validate();
}

public class Damage
{
    private static readonly DamageTypeList cleared;
    public static void Cancel(HitInfo info);
    public static object Scale(HitInfo info, BasePlayer attacker, BaseCombatEntity victim);
    private static object Scale(HitInfo info, BasePlayer attacker, BasePlayer victim);
    private static object Scale(HitInfo info, float scale);
}

public class Health
{
    private static readonly Dictionary<int, float> health;
    public static bool Changed(BaseEntity entity);
    public static void Clear();
    public static void Clear(BaseEntity entity);
}

private class Fire
{
    private static Dictionary<int, BasePlayer> fires;
    public static void Ignite(FireBall fire, BasePlayer initiator);
    public static BasePlayer Initiator(FireBall fire);
    public static void Spread(FireBall fire, FireBall spread);
    public static void Quench(FireBall fire);
    public static void Unload();
}

private class Generic
{
    public static T Clamp(T value, T min, T max);
}

private new class Hooks
{
    private static HashSet<string> subscribed;
    private static HashSet<string> unsubscribed;
    public class Base
    {
        public static void Subscribe();
    }

    public class Core
    {
        public static void Subscribe();
    }

    public class Dynamic
    {
        public static void Subscribe();
    }

    public static void Load();
    public static void Subscribe(string hook);
    public static void Unload();
    private static void Unsubscribe();
    public static void Unsubscribe(string hook);
}

public class Base
{
    public static void Subscribe();
}

public class Core
{
    public static void Subscribe();
}

public class Dynamic
{
    public static void Subscribe();
}

private class IP
{
    public class Settings
    {
        public IpFilter Filter;
        public IpViolation Violation;
        public Settings();
        public class IpFilter
        {
            public ulong Cooldown;
            public IpFilter();
            public void Validate();
        }

        public class IpViolation
        {
            public bool Ban;
            public bool Enabled;
            public IpViolation();
        }

        public void Validate();
    }

    private static readonly DataFile<string, uint> allows;
    private static readonly DataFile<string, bool> blocks;
    private static readonly DataFile<string, uint> denies;
    private static readonly HashSet<ulong> empty;
    private static readonly DataFile<string, DateTime> filter;
    private static TimeSpan filter_cooldown;
    private static readonly DataFile<string, HashSet<ulong>> users;
    private static readonly Violation violation;
    public class NetworkInfo
    {
        public string Address { get; set; }
        public uint Bits { get; set; }
        public NetworkInfo(string address, uint bits);
    }

    private static uint Bits(string address);
    public static void Block(NetworkInfo network);
    public static void Block(string address, ulong userid);
    public static void Bypass(NetworkInfo network);
    public static void Bypass(string address);
    private static uint Decimal(string address);
    public static bool Cooldown(string address);
    public static void Configure();
    public static bool Filter(string address, ulong userid);
    public static HashSet<ulong> Find(string address);
    private static List<string> Get(DataFile<string, uint> data, string address);
    public static List<string> GetAllows(string address);
    public static List<string> GetDenies(string address);
    public static bool IsAllowed(string address);
    public static bool IsBlocked(string address);
    public static bool IsDenied(string address);
    private static bool IsMatched(DataFile<string, uint> data, string address);
    public static bool IsValid(string address, bool full, bool wildcard);
    public static void Load();
    private static bool Match(uint ip, uint network, uint bits);
    private static List<string> Match(NetworkInfo network);
    public static NetworkInfo Network(string address);
    public static string Parse(string address);
    public static void Save();
    private static bool Set(DataFile<string, uint> data, NetworkInfo network, bool add);
    public static bool SetAllow(NetworkInfo network, bool add);
    public static bool SetDeny(NetworkInfo network, bool add);
    public static string ToString(uint ip);
    public static void Unblock(NetworkInfo network);
    public static void Unblock(string address);
    public static void Unload();
    public static void Update(string address, ulong userid);
    private static void Violation(string address, ulong userid);
}

public class Settings
{
    public IpFilter Filter;
    public IpViolation Violation;
    public Settings();
    public class IpFilter
    {
        public ulong Cooldown;
        public IpFilter();
        public void Validate();
    }

    public class IpViolation
    {
        public bool Ban;
        public bool Enabled;
        public IpViolation();
    }

    public void Validate();
}

public class IpFilter
{
    public ulong Cooldown;
    public IpFilter();
    public void Validate();
}

public class IpViolation
{
    public bool Ban;
    public bool Enabled;
    public IpViolation();
}

public class NetworkInfo
{
    public string Address { get; set; }
    public uint Bits { get; set; }
    public NetworkInfo(string address, uint bits);
}

private new class Log
{
    public class Settings
    {
        public LogAntiCheat AntiCheat;
        public LogAntiFlood AntiFlood;
        public LogIp IP;
        public LogProjectile Projectile;
        public LogUser User;
        public LogVpn VPN;
        public Settings();
        public class LogAntiCheat
        {
            public bool Aim;
            public bool Gravity;
            public bool MeleeRate;
            public bool Recoil;
            public bool Server;
            public bool Stash;
            public bool Trajectory;
        }

        public class LogAntiFlood
        {
            public bool ItemDrop;
        }

        public class LogIp
        {
            public bool Filter;
            public LogIp();
        }

        public class LogProjectile
        {
            public bool Collapse;
            public bool Verbose;
            public LogProjectile();
        }

        public class LogUser
        {
            public bool Bypass;
            public bool Connect;
            public LogUser();
        }

        public class LogVpn
        {
            public bool Check;
            public LogVpn();
        }

        public void Validate();
    }

    public static void Console(Key key, Dictionary<string, string> parameters);
    public static void Error(string message);
    public static void Warning(string message);
}

public class Settings
{
    public LogAntiCheat AntiCheat;
    public LogAntiFlood AntiFlood;
    public LogIp IP;
    public LogProjectile Projectile;
    public LogUser User;
    public LogVpn VPN;
    public Settings();
    public class LogAntiCheat
    {
        public bool Aim;
        public bool Gravity;
        public bool MeleeRate;
        public bool Recoil;
        public bool Server;
        public bool Stash;
        public bool Trajectory;
    }

    public class LogAntiFlood
    {
        public bool ItemDrop;
    }

    public class LogIp
    {
        public bool Filter;
        public LogIp();
    }

    public class LogProjectile
    {
        public bool Collapse;
        public bool Verbose;
        public LogProjectile();
    }

    public class LogUser
    {
        public bool Bypass;
        public bool Connect;
        public LogUser();
    }

    public class LogVpn
    {
        public bool Check;
        public LogVpn();
    }

    public void Validate();
}

public class LogAntiCheat
{
    public bool Aim;
    public bool Gravity;
    public bool MeleeRate;
    public bool Recoil;
    public bool Server;
    public bool Stash;
    public bool Trajectory;
}

public class LogAntiFlood
{
    public bool ItemDrop;
}

public class LogIp
{
    public bool Filter;
    public LogIp();
}

public class LogProjectile
{
    public bool Collapse;
    public bool Verbose;
    public LogProjectile();
}

public class LogUser
{
    public bool Bypass;
    public bool Connect;
    public LogUser();
}

public class LogVpn
{
    public bool Check;
    public LogVpn();
}

private class Map
{
    public class Building
    {
        public static bool HasPrivilege(DecayEntity entity);
        public static bool InFoundation(Vector3 position);
        public static bool IsNearby(Vector3 position, bool check_privilege);
    }

    public class Cave
    {
        public static bool IsInside(Vector3 position);
    }

    public class Collider
    {
        public static string Info(Vector3 position);
    }

    public class Entities
    {
        public static bool InRange(Vector3 position, float radius);
    }

    public static string Grid(Vector3 position);
    private class Hit
    {
        private static string Collider(RaycastHit hit);
        public static bool IsBunker(RaycastHit hit);
        public static bool IsBunker(string collider);
        public static bool IsCave(RaycastHit hit);
        public static bool IsCave(string collider);
        public static bool IsCorridor(RaycastHit hit);
        public static bool IsCorridor(string collider);
        public static bool IsDuct(RaycastHit hit);
        public static bool IsDuct(string collider);
        public static bool IsFoundation(RaycastHit hit);
        public static bool IsFoundation(string collider);
        public static bool IsMine(RaycastHit hit);
        public static bool IsMine(string collider);
        public static bool IsRoad(RaycastHit hit);
        public static bool IsRoad(string collider);
        public static bool IsRock(RaycastHit hit);
        public static bool IsRock(string collider);
        public static bool IsStairwell(RaycastHit hit);
        public static bool IsStairwell(string collider);
        public static bool IsTunnel(RaycastHit hit);
        public static bool IsTunnel(string collider);
        public static bool IsUnderground(RaycastHit hit);
        public static bool IsUnderground(string collider);
    }

    public static bool InRange(Vector3 a, Vector3 b, float distance);
    public static bool InRange2D(Vector3 a, Vector3 b, float distance);
    public static void Load();
    public class Monument
    {
        private static SparseMap global;
        private static SparseMap tunnel;
        public static bool IsNearby(Vector3 position);
        public static bool IsTunnel(Vector3 position);
        public static void Load();
        private static float Range(MonumentInfo monument);
        public static void Unload();
    }

    public class Position
    {
        private static bool HasCheck(Check checks, Check check);
        public static Vector3 Random(Check checks);
        private static Vector3 Random(float min_x, float max_x, float min_z, float max_z);
    }

    public class Road
    {
        public static bool IsNearby(Vector3 position);
    }

    public class Rock
    {
        public static bool IsInside(Vector3 position, bool check_cave);
    }

    public static Vector3 Surface(Vector3 position, float offset);
    public class Terrain
    {
        public static float Height(Vector3 position);
        public static bool IsInside(Vector3 position, bool check_cave);
        public static bool IsSurface(Vector3 position);
        public static Vector3 Level(Vector3 position, float offset);
    }

    public class Underground
    {
        public static bool IsInside(Vector3 position);
    }

    public static void Unload();
    public class Water
    {
        public static float Height(Vector3 position);
        public static bool IsSurface(Vector3 position);
        public static Vector3 Level(Vector3 position, float offset);
    }

}

public class Building
{
    public static bool HasPrivilege(DecayEntity entity);
    public static bool InFoundation(Vector3 position);
    public static bool IsNearby(Vector3 position, bool check_privilege);
}

public class Cave
{
    public static bool IsInside(Vector3 position);
}

public class Collider
{
    public static string Info(Vector3 position);
}

public class Entities
{
    public static bool InRange(Vector3 position, float radius);
}

private class Hit
{
    private static string Collider(RaycastHit hit);
    public static bool IsBunker(RaycastHit hit);
    public static bool IsBunker(string collider);
    public static bool IsCave(RaycastHit hit);
    public static bool IsCave(string collider);
    public static bool IsCorridor(RaycastHit hit);
    public static bool IsCorridor(string collider);
    public static bool IsDuct(RaycastHit hit);
    public static bool IsDuct(string collider);
    public static bool IsFoundation(RaycastHit hit);
    public static bool IsFoundation(string collider);
    public static bool IsMine(RaycastHit hit);
    public static bool IsMine(string collider);
    public static bool IsRoad(RaycastHit hit);
    public static bool IsRoad(string collider);
    public static bool IsRock(RaycastHit hit);
    public static bool IsRock(string collider);
    public static bool IsStairwell(RaycastHit hit);
    public static bool IsStairwell(string collider);
    public static bool IsTunnel(RaycastHit hit);
    public static bool IsTunnel(string collider);
    public static bool IsUnderground(RaycastHit hit);
    public static bool IsUnderground(string collider);
}

public class Monument
{
    private static SparseMap global;
    private static SparseMap tunnel;
    public static bool IsNearby(Vector3 position);
    public static bool IsTunnel(Vector3 position);
    public static void Load();
    private static float Range(MonumentInfo monument);
    public static void Unload();
}

public class Position
{
    private static bool HasCheck(Check checks, Check check);
    public static Vector3 Random(Check checks);
    private static Vector3 Random(float min_x, float max_x, float min_z, float max_z);
}

public class Road
{
    public static bool IsNearby(Vector3 position);
}

public class Rock
{
    public static bool IsInside(Vector3 position, bool check_cave);
}

public class Terrain
{
    public static float Height(Vector3 position);
    public static bool IsInside(Vector3 position, bool check_cave);
    public static bool IsSurface(Vector3 position);
    public static Vector3 Level(Vector3 position, float offset);
}

public class Underground
{
    public static bool IsInside(Vector3 position);
}

public class Water
{
    public static float Height(Vector3 position);
    public static bool IsSurface(Vector3 position);
    public static Vector3 Level(Vector3 position, float offset);
}

private class Permissions
{
    private static string PERMISSION_ADMIN;
    private static string PERMISSION_ALL;
    private static string PERMISSION_IGNORE;
    private static string PERMISSION_PREFIX;
    private static readonly HashSet<ulong> all;
    private static readonly HashSet<ulong> admin;
    private static readonly HashSet<ulong> ignore;
    public static bool Admin(ulong userid, bool forced);
    public static bool All(ulong userid, bool forced);
    public class Bypass
    {
        private static string PERMISSION_PREFIX;
        private static string PERMISSION_STEAM;
        private static string PERMISSION_VPN;
        private static readonly HashSet<ulong> steam;
        private static readonly HashSet<ulong> vpn;
        public class AntiCheat
        {
            private static readonly HashSet<ulong> aim;
            private static readonly HashSet<ulong> firerate;
            private static readonly HashSet<ulong> gravity;
            private static readonly HashSet<ulong> meleerate;
            private static readonly HashSet<ulong> recoil;
            private static readonly HashSet<ulong> server;
            private static readonly HashSet<ulong> stash;
            private static readonly HashSet<ulong> trajectory;
            private static readonly HashSet<ulong> wallhack;
            private static string PERMISSION_AIM;
            private static string PERMISSION_FIRERATE;
            private static string PERMISSION_GRAVITY;
            private static string PERMISSION_MELEERATE;
            private static string PERMISSION_PREFIX;
            private static string PERMISSION_RECOIL;
            private static string PERMISSION_SERVER;
            private static string PERMISSION_STASH;
            private static string PERMISSION_TRAJECTORY;
            private static string PERMISSION_WALLHACK;
            public static void Load();
            public static bool Aim(ulong userid, bool forced);
            public static bool FireRate(ulong userid, bool forced);
            public static bool Gravity(ulong userid, bool forced);
            public static bool MeleeRate(ulong userid, bool forced);
            public static bool Recoil(ulong userid, bool forced);
            public static void Reset(ulong userid);
            public static bool Server(ulong userid, bool forced);
            public static bool Stash(ulong userid, bool forced);
            public static bool Trajectory(ulong userid, bool forced);
            public static void Unload();
            public static void Update(ulong userid);
            public static bool WallHack(ulong userid, bool forced);
        }

        public static void Load();
        public static void Reset(ulong userid);
        public static bool Steam(ulong userid, bool forced);
        public static void Unload();
        public static void Update(ulong userid);
        public static bool Vpn(ulong userid, bool forced);
    }

    public class Command
    {
        private static readonly HashSet<ulong> config;
        private static readonly HashSet<ulong> ip;
        private static readonly HashSet<ulong> server;
        private static readonly HashSet<ulong> tp;
        private static readonly HashSet<ulong> vpn;
        private static string PERMISSION_CONFIG;
        private static string PERMISSION_IP;
        private static string PERMISSION_PREFIX;
        private static string PERMISSION_SERVER;
        private static string PERMISSION_TP;
        private static string PERMISSION_VPN;
        public static void Load();
        public static bool Config(ulong userid, bool forced);
        public static bool Ip(ulong userid, bool forced);
        public static void Reset(ulong userid);
        public static bool Server(ulong userid, bool forced);
        public static bool Tp(ulong userid, bool forced);
        public static void Unload();
        public static void Update(ulong userid);
        public static bool Vpn(ulong userid, bool forced);
    }

    public static string[] Groups(ulong userid);
    private static bool HasPermission(ulong userid, string permission);
    public static bool HasPrefix(string permission);
    public static bool Ignore(ulong userid, bool forced);
    public static void Load();
    public static void Reset(ulong userid);
    public static void Unload();
    public static void Update(ulong userid);
    private static bool Update(ulong userid, string permission, HashSet<ulong> cache);
}

public class Bypass
{
    private static string PERMISSION_PREFIX;
    private static string PERMISSION_STEAM;
    private static string PERMISSION_VPN;
    private static readonly HashSet<ulong> steam;
    private static readonly HashSet<ulong> vpn;
    public class AntiCheat
    {
        private static readonly HashSet<ulong> aim;
        private static readonly HashSet<ulong> firerate;
        private static readonly HashSet<ulong> gravity;
        private static readonly HashSet<ulong> meleerate;
        private static readonly HashSet<ulong> recoil;
        private static readonly HashSet<ulong> server;
        private static readonly HashSet<ulong> stash;
        private static readonly HashSet<ulong> trajectory;
        private static readonly HashSet<ulong> wallhack;
        private static string PERMISSION_AIM;
        private static string PERMISSION_FIRERATE;
        private static string PERMISSION_GRAVITY;
        private static string PERMISSION_MELEERATE;
        private static string PERMISSION_PREFIX;
        private static string PERMISSION_RECOIL;
        private static string PERMISSION_SERVER;
        private static string PERMISSION_STASH;
        private static string PERMISSION_TRAJECTORY;
        private static string PERMISSION_WALLHACK;
        public static void Load();
        public static bool Aim(ulong userid, bool forced);
        public static bool FireRate(ulong userid, bool forced);
        public static bool Gravity(ulong userid, bool forced);
        public static bool MeleeRate(ulong userid, bool forced);
        public static bool Recoil(ulong userid, bool forced);
        public static void Reset(ulong userid);
        public static bool Server(ulong userid, bool forced);
        public static bool Stash(ulong userid, bool forced);
        public static bool Trajectory(ulong userid, bool forced);
        public static void Unload();
        public static void Update(ulong userid);
        public static bool WallHack(ulong userid, bool forced);
    }

    public static void Load();
    public static void Reset(ulong userid);
    public static bool Steam(ulong userid, bool forced);
    public static void Unload();
    public static void Update(ulong userid);
    public static bool Vpn(ulong userid, bool forced);
}

public class AntiCheat
{
    private static readonly HashSet<ulong> aim;
    private static readonly HashSet<ulong> firerate;
    private static readonly HashSet<ulong> gravity;
    private static readonly HashSet<ulong> meleerate;
    private static readonly HashSet<ulong> recoil;
    private static readonly HashSet<ulong> server;
    private static readonly HashSet<ulong> stash;
    private static readonly HashSet<ulong> trajectory;
    private static readonly HashSet<ulong> wallhack;
    private static string PERMISSION_AIM;
    private static string PERMISSION_FIRERATE;
    private static string PERMISSION_GRAVITY;
    private static string PERMISSION_MELEERATE;
    private static string PERMISSION_PREFIX;
    private static string PERMISSION_RECOIL;
    private static string PERMISSION_SERVER;
    private static string PERMISSION_STASH;
    private static string PERMISSION_TRAJECTORY;
    private static string PERMISSION_WALLHACK;
    public static void Load();
    public static bool Aim(ulong userid, bool forced);
    public static bool FireRate(ulong userid, bool forced);
    public static bool Gravity(ulong userid, bool forced);
    public static bool MeleeRate(ulong userid, bool forced);
    public static bool Recoil(ulong userid, bool forced);
    public static void Reset(ulong userid);
    public static bool Server(ulong userid, bool forced);
    public static bool Stash(ulong userid, bool forced);
    public static bool Trajectory(ulong userid, bool forced);
    public static void Unload();
    public static void Update(ulong userid);
    public static bool WallHack(ulong userid, bool forced);
}

public class Command
{
    private static readonly HashSet<ulong> config;
    private static readonly HashSet<ulong> ip;
    private static readonly HashSet<ulong> server;
    private static readonly HashSet<ulong> tp;
    private static readonly HashSet<ulong> vpn;
    private static string PERMISSION_CONFIG;
    private static string PERMISSION_IP;
    private static string PERMISSION_PREFIX;
    private static string PERMISSION_SERVER;
    private static string PERMISSION_TP;
    private static string PERMISSION_VPN;
    public static void Load();
    public static bool Config(ulong userid, bool forced);
    public static bool Ip(ulong userid, bool forced);
    public static void Reset(ulong userid);
    public static bool Server(ulong userid, bool forced);
    public static bool Tp(ulong userid, bool forced);
    public static void Unload();
    public static void Update(ulong userid);
    public static bool Vpn(ulong userid, bool forced);
}

private class Projectile
{
    public class Log
    {
        private static readonly Queue<Entry> expired;
        private static readonly Dictionary<ulong, Queue<Entry>> history;
        private static readonly Dictionary<ulong, Dictionary<int, Entry>> pending;
        private static readonly Queue<Request> request;
        private static readonly Queue<Entry> reserve;
        static readonly StringBuilder buffer;
        private class Entry
        {
            public float aim_angle;
            public float aim_pvp;
            public float aim_range;
            public ulong aim_violations;
            public string attacker;
            public ulong attacker_id;
            public ulong firerate_violations;
            public float hit_distance;
            public HitArea hit_location;
            public bool pvp;
            public float recoil_pitch;
            public ulong recoil_repeats;
            public float recoil_swing;
            public ulong recoil_violations;
            public float recoil_yaw;
            public bool ricochet;
            public float speed;
            public DateTime timestamp;
            public float trajectory;
            public ulong trajectory_violations;
            public string victim;
            public bool violations;
            public ulong wallhack_violations;
            public string weapon;
            private static readonly Queue<Entry> pool;
            private Entry(DateTime timestamp);
            private Entry Default();
            public string Format(bool collapse, bool id, bool time);
            public static Entry Get(DateTime timestamp);
            public void Release();
            private Entry Set(DateTime timestamp);
            public static void Unload();
        }

        private class Request
        {
            public IPlayer actor;
            public int lines;
            public ulong userid;
        }

        public static void Add(Weapon weapon);
        public static void Expire(Weapon weapon);
        public static void Get(IPlayer actor, ulong userid, int lines);
        public static float GetAimAngle(ulong userid, int id);
        public static bool GetAimPvp(ulong userid, int id);
        public static float GetHitDistance(ulong userid, int id);
        public static HitArea GetHitLocation(ulong userid, int id);
        public static bool GetRicochet(ulong userid, int id);
        public static string GetVictim(ulong userid, int id);
        public static void Send();
        public static void SetAim(ulong userid, int id, float aim_angle, float aim_pvp, float aim_range, bool pvp, bool ricochet);
        public static void SetAimViolations(ulong userid, int id, ulong aim_violations, bool add);
        public static void SetAttacker(ulong userid, int id, string attacker, ulong attaker_id);
        public static void SetFireRateViolations(ulong userid, int id, ulong firerate_violations);
        public static void SetHit(ulong userid, int id, float hit_distance, HitArea hit_location);
        public static void SetRecoil(ulong userid, int id, float recoil_pitch, ulong recoil_repeats, float recoil_yaw, float recoil_swing);
        public static void SetRecoilViolations(ulong userid, int id, ulong recoil_violations);
        public static void SetTrajectory(ulong userid, int id, float trajectory);
        public static void SetTrajectoryViolations(ulong userid, int id, ulong trajectory_violations);
        public static void SetVictim(ulong userid, int id, string victim);
        public static void SetWallHackViolations(ulong userid, int id, ulong wallhack_violations);
        public static void SetWeapon(ulong userid, int id, float speed, string weapon);
        private static void TrySetEntry(ulong userid, int id, Action<Entry> set);
        public static void Unload();
    }

    private static readonly List<Weapon> expired;
    private static readonly Dictionary<ulong, Dictionary<int, Weapon>> reverse;
    private static readonly Dictionary<ulong, Queue<Weapon>> weapons;
    public static void Add(Weapon weapon);
    public static void Load();
    public static void Unload();
    public static Weapon Weapon(ulong userid, int projectileid);
}

public class Log
{
    private static readonly Queue<Entry> expired;
    private static readonly Dictionary<ulong, Queue<Entry>> history;
    private static readonly Dictionary<ulong, Dictionary<int, Entry>> pending;
    private static readonly Queue<Request> request;
    private static readonly Queue<Entry> reserve;
    static readonly StringBuilder buffer;
    private class Entry
    {
        public float aim_angle;
        public float aim_pvp;
        public float aim_range;
        public ulong aim_violations;
        public string attacker;
        public ulong attacker_id;
        public ulong firerate_violations;
        public float hit_distance;
        public HitArea hit_location;
        public bool pvp;
        public float recoil_pitch;
        public ulong recoil_repeats;
        public float recoil_swing;
        public ulong recoil_violations;
        public float recoil_yaw;
        public bool ricochet;
        public float speed;
        public DateTime timestamp;
        public float trajectory;
        public ulong trajectory_violations;
        public string victim;
        public bool violations;
        public ulong wallhack_violations;
        public string weapon;
        private static readonly Queue<Entry> pool;
        private Entry(DateTime timestamp);
        private Entry Default();
        public string Format(bool collapse, bool id, bool time);
        public static Entry Get(DateTime timestamp);
        public void Release();
        private Entry Set(DateTime timestamp);
        public static void Unload();
    }

    private class Request
    {
        public IPlayer actor;
        public int lines;
        public ulong userid;
    }

    public static void Add(Weapon weapon);
    public static void Expire(Weapon weapon);
    public static void Get(IPlayer actor, ulong userid, int lines);
    public static float GetAimAngle(ulong userid, int id);
    public static bool GetAimPvp(ulong userid, int id);
    public static float GetHitDistance(ulong userid, int id);
    public static HitArea GetHitLocation(ulong userid, int id);
    public static bool GetRicochet(ulong userid, int id);
    public static string GetVictim(ulong userid, int id);
    public static void Send();
    public static void SetAim(ulong userid, int id, float aim_angle, float aim_pvp, float aim_range, bool pvp, bool ricochet);
    public static void SetAimViolations(ulong userid, int id, ulong aim_violations, bool add);
    public static void SetAttacker(ulong userid, int id, string attacker, ulong attaker_id);
    public static void SetFireRateViolations(ulong userid, int id, ulong firerate_violations);
    public static void SetHit(ulong userid, int id, float hit_distance, HitArea hit_location);
    public static void SetRecoil(ulong userid, int id, float recoil_pitch, ulong recoil_repeats, float recoil_yaw, float recoil_swing);
    public static void SetRecoilViolations(ulong userid, int id, ulong recoil_violations);
    public static void SetTrajectory(ulong userid, int id, float trajectory);
    public static void SetTrajectoryViolations(ulong userid, int id, ulong trajectory_violations);
    public static void SetVictim(ulong userid, int id, string victim);
    public static void SetWallHackViolations(ulong userid, int id, ulong wallhack_violations);
    public static void SetWeapon(ulong userid, int id, float speed, string weapon);
    private static void TrySetEntry(ulong userid, int id, Action<Entry> set);
    public static void Unload();
}

private class Entry
{
    public float aim_angle;
    public float aim_pvp;
    public float aim_range;
    public ulong aim_violations;
    public string attacker;
    public ulong attacker_id;
    public ulong firerate_violations;
    public float hit_distance;
    public HitArea hit_location;
    public bool pvp;
    public float recoil_pitch;
    public ulong recoil_repeats;
    public float recoil_swing;
    public ulong recoil_violations;
    public float recoil_yaw;
    public bool ricochet;
    public float speed;
    public DateTime timestamp;
    public float trajectory;
    public ulong trajectory_violations;
    public string victim;
    public bool violations;
    public ulong wallhack_violations;
    public string weapon;
    private static readonly Queue<Entry> pool;
    private Entry(DateTime timestamp);
    private Entry Default();
    public string Format(bool collapse, bool id, bool time);
    public static Entry Get(DateTime timestamp);
    public void Release();
    private Entry Set(DateTime timestamp);
    public static void Unload();
}

private class Request
{
    public IPlayer actor;
    public int lines;
    public ulong userid;
}

private class SparseMap
{
    private Dictionary<Texel, Cell> map;
    private float map_scale;
    public SparseMap(float scale);
    public void Clear();
    public int Count();
    public void Reset(float scale);
    private void Reset(Pixel pixel);
    public void Reset(Vector3 position);
    public float Scale();
    private int Scale(float n);
    private void Set(Pixel pixel);
    public void Set(Vector3 position);
    public int Set(Vector3 origin, float range);
    private void SetScale(float scale);
    private bool Test(Pixel pixel);
    public bool Test(Vector3 position);
}

private class Steam
{
    public class Settings
    {
        public API.Settings API;
        public SteamBan Ban;
        public SteamGame Game;
        public SteamProfile Profile;
        public SteamShare Share;
        public SteamViolation Violation;
        public Settings();
        public class SteamBan
        {
            public bool Active;
            public bool Community;
            public ulong Days;
            public bool Economy;
            public ulong Game;
            public ulong VAC;
        }

        public class SteamGame
        {
            public ulong Count;
            public ulong Hours;
        }

        public class SteamProfile
        {
            public bool Invalid;
            public bool Limited;
            public bool Private;
        }

        public class SteamShare
        {
            public bool Family;
        }

        public class SteamViolation
        {
            public bool Ban;
            public bool Enabled;
            public bool Warn;
            public SteamViolation();
        }

        public void Validate();
    }

    private static uint appid;
    private static ActionQueue checks;
    private static readonly Violation violation;
    public static void Check(ulong userid);
    public static void Configure();
    public static void Load();
    public static void Unload();
    private static void Violation(ulong userid, Key type, string details, bool ban);
    private class Ban
    {
        [JsonProperty("players")]
        public Player[] Players;
        public class Player
        {
            [JsonProperty("CommunityBanned")]
            public bool CommunityBanned;
            [JsonProperty("VACBanned")]
            public bool VacBanned;
            [JsonProperty("NumberOfVACBans")]
            public ulong NumberOfVacBans;
            [JsonProperty("DaysSinceLastBan")]
            public ulong DaysSinceLastBan;
            [JsonProperty("NumberOfGameBans")]
            public ulong NumberOfGameBans;
            [JsonProperty("EconomyBan")]
            public string EconomyBan;
        }

        [JsonIgnore]
        private static readonly string api;
        [JsonIgnore]
        public static bool check;
        public static void Check(ulong userid);
    }

    private class Game
    {
        [JsonProperty("response")]
        public Content Response;
        public class Content
        {
            [JsonProperty("game_count")]
            public ulong GameCount;
            [JsonProperty("games")]
            public Game[] Games;
            public class Game
            {
                [JsonProperty("appid")]
                public uint AppId;
                [JsonProperty("playtime_forever")]
                public ulong PlaytimeForever;
            }

        }

        [JsonIgnore]
        private static readonly string api;
        [JsonIgnore]
        public static bool check;
        public static void Check(ulong userid, bool private_profile, bool is_sharing);
    }

    private class Profile
    {
        private static readonly string api;
        public static bool check;
        public static void Check(ulong userid, bool private_profile);
    }

    private class Share
    {
        [JsonProperty("response")]
        public Content Response;
        public class Content
        {
            [JsonProperty("lender_steamid")]
            public ulong LenderSteamId;
        }

        [JsonIgnore]
        private static readonly string api;
        [JsonIgnore]
        public static bool check;
        public static void Check(ulong userid, bool private_profile);
    }

    private class Summaries
    {
        [JsonProperty("response")]
        public Content Response;
        public class Content
        {
            [JsonProperty("players")]
            public Player[] Players;
            public class Player
            {
                [JsonProperty("communityvisibilitystate")]
                public int CommunityVisibilityState;
            }

        }

        [JsonIgnore]
        private static readonly string api;
        [JsonIgnore]
        public static bool check;
        public static void Check(ulong userid);
    }

}

public class Settings
{
    public API.Settings API;
    public SteamBan Ban;
    public SteamGame Game;
    public SteamProfile Profile;
    public SteamShare Share;
    public SteamViolation Violation;
    public Settings();
    public class SteamBan
    {
        public bool Active;
        public bool Community;
        public ulong Days;
        public bool Economy;
        public ulong Game;
        public ulong VAC;
    }

    public class SteamGame
    {
        public ulong Count;
        public ulong Hours;
    }

    public class SteamProfile
    {
        public bool Invalid;
        public bool Limited;
        public bool Private;
    }

    public class SteamShare
    {
        public bool Family;
    }

    public class SteamViolation
    {
        public bool Ban;
        public bool Enabled;
        public bool Warn;
        public SteamViolation();
    }

    public void Validate();
}

public class SteamBan
{
    public bool Active;
    public bool Community;
    public ulong Days;
    public bool Economy;
    public ulong Game;
    public ulong VAC;
}

public class SteamGame
{
    public ulong Count;
    public ulong Hours;
}

public class SteamProfile
{
    public bool Invalid;
    public bool Limited;
    public bool Private;
}

public class SteamShare
{
    public bool Family;
}

public class SteamViolation
{
    public bool Ban;
    public bool Enabled;
    public bool Warn;
    public SteamViolation();
}

private class Ban
{
    [JsonProperty("players")]
    public Player[] Players;
    public class Player
    {
        [JsonProperty("CommunityBanned")]
        public bool CommunityBanned;
        [JsonProperty("VACBanned")]
        public bool VacBanned;
        [JsonProperty("NumberOfVACBans")]
        public ulong NumberOfVacBans;
        [JsonProperty("DaysSinceLastBan")]
        public ulong DaysSinceLastBan;
        [JsonProperty("NumberOfGameBans")]
        public ulong NumberOfGameBans;
        [JsonProperty("EconomyBan")]
        public string EconomyBan;
    }

    [JsonIgnore]
    private static readonly string api;
    [JsonIgnore]
    public static bool check;
    public static void Check(ulong userid);
}

public class Player
{
    [JsonProperty("CommunityBanned")]
    public bool CommunityBanned;
    [JsonProperty("VACBanned")]
    public bool VacBanned;
    [JsonProperty("NumberOfVACBans")]
    public ulong NumberOfVacBans;
    [JsonProperty("DaysSinceLastBan")]
    public ulong DaysSinceLastBan;
    [JsonProperty("NumberOfGameBans")]
    public ulong NumberOfGameBans;
    [JsonProperty("EconomyBan")]
    public string EconomyBan;
}

private class Game
{
    [JsonProperty("response")]
    public Content Response;
    public class Content
    {
        [JsonProperty("game_count")]
        public ulong GameCount;
        [JsonProperty("games")]
        public Game[] Games;
        public class Game
        {
            [JsonProperty("appid")]
            public uint AppId;
            [JsonProperty("playtime_forever")]
            public ulong PlaytimeForever;
        }

    }

    [JsonIgnore]
    private static readonly string api;
    [JsonIgnore]
    public static bool check;
    public static void Check(ulong userid, bool private_profile, bool is_sharing);
}

public class Content
{
    [JsonProperty("game_count")]
    public ulong GameCount;
    [JsonProperty("games")]
    public Game[] Games;
    public class Game
    {
        [JsonProperty("appid")]
        public uint AppId;
        [JsonProperty("playtime_forever")]
        public ulong PlaytimeForever;
    }

}

public class Game
{
    [JsonProperty("appid")]
    public uint AppId;
    [JsonProperty("playtime_forever")]
    public ulong PlaytimeForever;
}

private class Profile
{
    private static readonly string api;
    public static bool check;
    public static void Check(ulong userid, bool private_profile);
}

private class Share
{
    [JsonProperty("response")]
    public Content Response;
    public class Content
    {
        [JsonProperty("lender_steamid")]
        public ulong LenderSteamId;
    }

    [JsonIgnore]
    private static readonly string api;
    [JsonIgnore]
    public static bool check;
    public static void Check(ulong userid, bool private_profile);
}

public class Content
{
    [JsonProperty("lender_steamid")]
    public ulong LenderSteamId;
}

private class Summaries
{
    [JsonProperty("response")]
    public Content Response;
    public class Content
    {
        [JsonProperty("players")]
        public Player[] Players;
        public class Player
        {
            [JsonProperty("communityvisibilitystate")]
            public int CommunityVisibilityState;
        }

    }

    [JsonIgnore]
    private static readonly string api;
    [JsonIgnore]
    public static bool check;
    public static void Check(ulong userid);
}

public class Content
{
    [JsonProperty("players")]
    public Player[] Players;
    public class Player
    {
        [JsonProperty("communityvisibilitystate")]
        public int CommunityVisibilityState;
    }

}

public class Player
{
    [JsonProperty("communityvisibilitystate")]
    public int CommunityVisibilityState;
}

private class Text
{
    private static readonly Dictionary<string, Dictionary<Key, string>> decorated;
    private static readonly Dictionary<string, Dictionary<Key, string>> unadorned;
    private static string server_language;
    private class RegEx
    {
        public static Regex clean1;
        public static Regex clean2;
        public static Regex clean3;
        public static Regex markup;
        public static Regex spaces;
        public static void Load();
        public static void Unload();
    }

    public static string Actor(IPlayer actor);
    public static string Actor(IPlayer actor, BasePlayer player);
    public static string Actor(IPlayer actor, IPlayer iplayer);
    public static string Actor(IPlayer actor, ulong userid);
    public static string Actor(IPlayer actor, string language);
    public static string BodyPart(HitArea area);
    public static string BodyPart(HitArea area, BasePlayer player);
    public static string BodyPart(HitArea area, IPlayer iplayer);
    public static string BodyPart(HitArea area, ulong userid);
    public static string BodyPart(HitArea area, string language);
    public class Duration
    {
        public static string Hours(TimeSpan time);
        public static string Hours(TimeSpan time, BasePlayer player);
        public static string Hours(TimeSpan time, IPlayer iplayer);
        public static string Hours(TimeSpan time, ulong userid);
        public static string Hours(TimeSpan time, string language);
        public static string Short(TimeSpan time);
        public static string Short(TimeSpan time, BasePlayer player);
        public static string Short(TimeSpan time, IPlayer iplayer);
        public static string Short(TimeSpan time, ulong userid);
        public static string Short(TimeSpan time, string language);
    }

    public static string Get(Key key, Dictionary<string, string> parameters);
    public static string Get(Key key, BasePlayer player, Dictionary<string, string> parameters);
    public static string Get(Key key, IPlayer iplayer, Dictionary<string, string> parameters);
    public static string Get(Key key, ulong userid, Dictionary<string, string> parameters);
    public static string Get(Key key, string language, Dictionary<string, string> parameters);
    private static string Get(Key key, Dictionary<Key, string> cache, Dictionary<string, string> parameters);
    public static string GetPlain(Key key, Dictionary<string, string> parameters);
    public static string GetPlain(Key key, BasePlayer player, Dictionary<string, string> parameters);
    public static string GetPlain(Key key, IPlayer iplayer, Dictionary<string, string> parameters);
    public static string GetPlain(Key key, ulong userid, Dictionary<string, string> parameters);
    public static string GetPlain(Key key, string language, Dictionary<string, string> parameters);
    public static string Language(string userid);
    public static void Load();
    private static Dictionary<Key, string> Messages(Dictionary<string, Dictionary<Key, string>> cache, string language);
    public static bool ParseTime(string message, ulong seconds);
    private static void RegisterMessages();
    private static string Replace(string message, Dictionary<string, string> parameters);
    private static string Strip(string message);
    public static string Sanitize(string message);
    private static string Trim(string message);
    public static void Unload();
}

private class RegEx
{
    public static Regex clean1;
    public static Regex clean2;
    public static Regex clean3;
    public static Regex markup;
    public static Regex spaces;
    public static void Load();
    public static void Unload();
}

public class Duration
{
    public static string Hours(TimeSpan time);
    public static string Hours(TimeSpan time, BasePlayer player);
    public static string Hours(TimeSpan time, IPlayer iplayer);
    public static string Hours(TimeSpan time, ulong userid);
    public static string Hours(TimeSpan time, string language);
    public static string Short(TimeSpan time);
    public static string Short(TimeSpan time, BasePlayer player);
    public static string Short(TimeSpan time, IPlayer iplayer);
    public static string Short(TimeSpan time, ulong userid);
    public static string Short(TimeSpan time, string language);
}

private class Timers
{
    private static readonly List<Timer> timers;
    public static void Add(float interval, Action callback);
    public static void Destroy();
}

private class User
{
    public class Settings
    {
        public UserBypass Bypass;
        public UserFriend Friend;
        public UserTeam Team;
        public Settings();
        public class UserBypass
        {
            public ulong DaysSinceBan;
            public bool Enabled;
            public ulong HoursPlayed;
            public bool Multiply;
            public UserBypass();
            public void Validate();
        }

        public class UserFriend
        {
            public bool Damage;
        }

        public class UserTeam
        {
            public bool Damage;
        }

        public void Validate();
    }

    private class Info
    {
        public ulong userid;
        public string name;
        public HashSet<string> names;
        public string address;
        public HashSet<string> addresses;
        public DateTime time_connected;
        public DateTime time_disconnected;
        public TimeSpan time_played;
        public ulong ban_count;
        public string ban_reason;
        public DateTime ban_time;
        public DateTime ban_timer;
        public bool is_banned;
        public ulong cripple_count;
        public string cripple_reason;
        public DateTime cripple_time;
        public DateTime cripple_timer;
        public bool is_crippled;
        public Vector3 l_position;
        public Vector3 v_position;
        [JsonIgnore]
        public DateTime access_time;
        [JsonIgnore]
        public ulong attacked;
        [JsonIgnore]
        public ulong attacker;
        [JsonIgnore]
        public bool dirty;
        [JsonIgnore]
        public BasePlayer player;
        [JsonIgnore]
        public Stack<ulong> teleport;
        [JsonIgnore]
        public List<ulong> victims;
        public Info();
    }

    private static readonly DataFile<string, HashSet<ulong>> names;
    private static ActionQueue teleport;
    private static readonly Dictionary<ulong, Info> users;
    private static void Action(IPlayer actor, Key action, Info user);
    public static string Address(ulong userid);
    public static void AssignAttacker(BasePlayer attacker, BasePlayer victim);
    public static void AssignVictim(BasePlayer victim);
    private static void AssignVictims(Info user);
    public static void Ban(ulong userid, string reason, ulong seconds, IPlayer actor);
    public static ulong BanCount(ulong userid);
    private static void BanInherit(ulong userid, string name, string address, Info copy);
    public static void BanReset(ulong userid, IPlayer actor);
    private static void BanTeleport(Info user, ulong count);
    public static DateTime BanTime(ulong userid);
    private static void BanTimeEnforce(Info user);
    private static bool CanBypass(Info user);
    public static object CanConnect(string name, string id, string address);
    public static bool CanFly(BasePlayer player);
    private static bool CanLoot(ulong userid, ulong targetid);
    public static object CanLoot(BasePlayer player, ulong targetid);
    public static void Cripple(ulong userid, string reason, ulong seconds, IPlayer actor);
    private static void CrippleInherit(ulong userid, string name, string address, Info copy);
    public static void CrippleReset(ulong userid, IPlayer actor);
    public static bool Exists(ulong userid);
    public static HashSet<ulong> Find(string text);
    public static Vector3 GetLastSeenPosition(ulong userid);
    public static Vector3 GetViolationPosition(ulong userid);
    public static bool HasAuthLevel(BasePlayer player);
    public static bool HasAdminFlag(BasePlayer player);
    private static bool HasConnected(Info user);
    public static bool HasDeveloperFlag(BasePlayer player);
    public static bool HasParent(BasePlayer player);
    public static string InfoText(ulong userid);
    public static string InfoText(ulong userid, BasePlayer player);
    public static string InfoText(ulong userid, IPlayer iplayer);
    public static string InfoText(ulong userid, ulong playerid);
    public static string InfoText(ulong userid, string language);
    public static bool IsBanned(ulong userid);
    private static bool IsConnected(Info user);
    public static bool IsConnected(ulong userid);
    public static bool IsCrippled(ulong userid);
    public static bool IsFriend(BasePlayer a, BasePlayer b);
    public static bool IsFriend(BasePlayer player, ulong userid);
    public static bool IsInactive(BasePlayer player);
    private static bool IsStale(Info user);
    public static bool IsTeamMate(BasePlayer a, BasePlayer b);
    public static bool IsTeamMate(BasePlayer player, ulong userid);
    public static void Kick(ulong userid, string reason, IPlayer actor);
    public static void Load();
    private static Info Load(ulong userid);
    public static string Name(ulong userid);
    public static void OnBanned(ulong userid, bool banned);
    public static void OnConnected(BasePlayer player);
    public static void OnDisconnected(BasePlayer player);
    public static void OnLoot(BasePlayer player, ulong targetid);
    public static void Pardon(ulong userid, IPlayer actor);
    public static void Pardon(IPlayer actor);
    private static void Pardon(Queue<ulong> userid, IPlayer actor, int total);
    private static void Pardon(Info user, IPlayer actor, bool broadcast);
    public static void Save();
    private static void Save(Info user);
    private static void Scan();
    private static void SetLastSeenPosition(Info user, Vector3 position);
    private static void SetViolationPosition(Info user, Vector3 position);
    public static void SetViolationPosition(ulong userid);
    public static bool ShouldIgnore(BasePlayer player);
    public static string StatusText(ulong userid);
    public static string StatusText(ulong userid, BasePlayer player);
    public static string StatusText(ulong userid, IPlayer iplayer);
    public static string StatusText(ulong userid, ulong playerid);
    public static string StatusText(ulong userid, string language);
    private static string StatusText(Info user, string language);
    public static List<ulong> Team(ulong userid);
    public static TimeSpan TimeBanned(ulong userid);
    private static TimeSpan TimeBanned(Info user);
    public static TimeSpan TimeCrippled(ulong userid);
    private static TimeSpan TimeCrippled(Info user);
    private static TimeSpan TimeRemaining(DateTime time);
    public static TimeSpan TimeOffline(ulong userid);
    private static TimeSpan TimeOffline(Info user);
    public static TimeSpan TimeOnline(ulong userid);
    private static TimeSpan TimeOnline(Info user);
    private static TimeSpan TimeSpent(DateTime time);
    public static TimeSpan TimePlayed(ulong userid);
    private static TimeSpan TimePlayed(Info user);
    public static void Unban(ulong userid, bool manual, IPlayer actor);
    public static void Unban(IPlayer actor);
    private static void Unban(Info user, bool manual, IPlayer actor, bool broadcast);
    public static void Uncripple(ulong userid, bool manual, IPlayer actor);
    public static void Uncripple(IPlayer actor);
    private static void Uncripple(Info user, bool manual, IPlayer actor, bool broadcast);
    public static void Unload();
    public static void Update();
    private static void Update(Info user, string name, string address);
}

public class Settings
{
    public UserBypass Bypass;
    public UserFriend Friend;
    public UserTeam Team;
    public Settings();
    public class UserBypass
    {
        public ulong DaysSinceBan;
        public bool Enabled;
        public ulong HoursPlayed;
        public bool Multiply;
        public UserBypass();
        public void Validate();
    }

    public class UserFriend
    {
        public bool Damage;
    }

    public class UserTeam
    {
        public bool Damage;
    }

    public void Validate();
}

public class UserBypass
{
    public ulong DaysSinceBan;
    public bool Enabled;
    public ulong HoursPlayed;
    public bool Multiply;
    public UserBypass();
    public void Validate();
}

public class UserFriend
{
    public bool Damage;
}

public class UserTeam
{
    public bool Damage;
}

private class Info
{
    public ulong userid;
    public string name;
    public HashSet<string> names;
    public string address;
    public HashSet<string> addresses;
    public DateTime time_connected;
    public DateTime time_disconnected;
    public TimeSpan time_played;
    public ulong ban_count;
    public string ban_reason;
    public DateTime ban_time;
    public DateTime ban_timer;
    public bool is_banned;
    public ulong cripple_count;
    public string cripple_reason;
    public DateTime cripple_time;
    public DateTime cripple_timer;
    public bool is_crippled;
    public Vector3 l_position;
    public Vector3 v_position;
    [JsonIgnore]
    public DateTime access_time;
    [JsonIgnore]
    public ulong attacked;
    [JsonIgnore]
    public ulong attacker;
    [JsonIgnore]
    public bool dirty;
    [JsonIgnore]
    public BasePlayer player;
    [JsonIgnore]
    public Stack<ulong> teleport;
    [JsonIgnore]
    public List<ulong> victims;
    public Info();
}

private new class Version
{
    public class Settings
    {
        public int Major;
        public int Minor;
        public int Patch;
        public Settings();
        public int Compare(int major, int minor, int patch);
        public void Validate();
    }

    public static string String { get; set; }
}

public class Settings
{
    public int Major;
    public int Minor;
    public int Patch;
    public Settings();
    public int Compare(int major, int minor, int patch);
    public void Validate();
}

private class Violation
{
    public class Settings
    {
        public bool Ban;
        public ulong Cooldown;
        public float Sensitivity;
        public bool Warn;
        public Settings(bool ban, ulong cooldown, float sensitivity, bool warn);
        public ulong Count(ulong min, ulong max, bool squared);
        public Settings Validate(ulong max);
    }

    private bool ban;
    private Key category;
    private ulong cooldown;
    private ulong count;
    private TimeSpan rate;
    private bool warn;
    private Dictionary<ulong, History> histories;
    private static readonly Dictionary<string, Key> categories;
    private static ActionQueue triggers;
    private static readonly Violation violation;
    private class History
    {
        public DateTime cooldown;
        public ulong count;
        public DateTime time;
        public DateTime warned;
        public ulong warnings;
        public History();
    }

    public Violation(Key category);
    private void Broadcast(ulong userid, Key action, Key type, string details, Dictionary<string, string> hook_details);
    public static Key Category(string category);
    public static void Configure();
    public void Configure(Settings settings, ulong trigger_min, ulong trigger_max, ulong trigger_rate);
    public ulong Cooldown(ulong userid);
    public void Clear();
    private History Get(ulong userid);
    private bool IsFlooding(ulong userid);
    public static void Load();
    private void Reduce(ulong userid);
    private void Reset(ulong userid);
    public bool Trigger(ulong userid);
    public void Trigger(ulong userid, Key type, string details, bool kick, Dictionary<string, string> hook_details);
    public void Trigger(ulong userid, Key type, string details, ulong violations, bool kick, Dictionary<string, string> hook_details);
    private void Triggered(ulong userid, Key type, string details, ulong violations, bool kick, Dictionary<string, string> hook_details);
    public static void Unload();
    public void Warning(ulong userid, Key type, string details, Dictionary<string, string> hook_details);
    public void Zero(ulong userid);
}

public class Settings
{
    public bool Ban;
    public ulong Cooldown;
    public float Sensitivity;
    public bool Warn;
    public Settings(bool ban, ulong cooldown, float sensitivity, bool warn);
    public ulong Count(ulong min, ulong max, bool squared);
    public Settings Validate(ulong max);
}

private class History
{
    public DateTime cooldown;
    public ulong count;
    public DateTime time;
    public DateTime warned;
    public ulong warnings;
    public History();
}

private class VPN
{
    public class Settings
    {
        public VpnApi API;
        public VpnCache Cache;
        public VpnCheck Check;
        public VpnViolation Violation;
        public Settings();
        public class VpnApi
        {
            public Guardian.API.Settings GetIpIntel;
            public Guardian.API.Settings IpApi;
            public Guardian.API.Settings IpHub;
            public Guardian.API.Settings IpQualityScore;
            public VpnApi();
            public void Validate();
        }

        public class VpnCache
        {
            public ulong Hours;
            public VpnCache();
        }

        public class VpnCheck
        {
            public bool Enabled;
            public bool Strict;
        }

        public class VpnViolation
        {
            public bool Ban;
            public bool Enabled;
            public bool Warn;
            public VpnViolation();
        }

        public void Validate();
    }

    private static ActionQueue checks;
    private static readonly Violation violation;
    public class API
    {
        public class GetIpIntel
        {
            [JsonProperty("message")]
            public string Message { get; set; }
            [JsonProperty("result")]
            public float Result { get; set; }
            [JsonProperty("status")]
            public string Status { get; set; }
            private const string api;
            public static void Check(string address, ulong userid);
        }

        public class IpApi
        {
            [JsonProperty("hosting")]
            public bool Hosting { get; set; }
            [JsonProperty("proxy")]
            public bool Proxy { get; set; }
            [JsonProperty("status")]
            public string Status { get; set; }
            private const string api;
            public static void Check(string address, ulong userid);
        }

        public class IpHub
        {
            [JsonProperty("block")]
            public int Block { get; set; }
            [JsonIgnore]
            private static readonly Dictionary<string, string> headers;
            private const string api;
            public static void Check(string address, ulong userid);
            public static void Configure();
            public static void Unload();
        }

        public class IpQualityScore
        {
            [JsonProperty("fraud_score")]
            public int FraudScore { get; set; }
            [JsonProperty("message")]
            public string Message { get; set; }
            [JsonProperty("proxy")]
            public bool Proxy { get; set; }
            [JsonProperty("recent_abuse")]
            public bool RecentAbuse { get; set; }
            [JsonProperty("success")]
            public bool Success { get; set; }
            [JsonProperty("vpn")]
            public bool VPN { get; set; }
            private const string api;
            public static void Check(string address, ulong userid);
        }

        public static void Configure();
        public static void Unload();
    }

    private class Cache
    {
        private static readonly DataFile<string, DateTime> blocks;
        private static readonly DataFile<string, DateTime> bypass;
        public static void Block(string address);
        public static void Bypass(string address, ulong _reserved);
        public static bool IsBlocked(string address);
        public static bool IsBypassed(string address);
        private static bool IsCached(DataFile<string, DateTime> cache, string address);
        private static bool IsExpired(DateTime timestamp, DateTime check);
        public static void Load();
        public static void Save();
        public static void Unblock(string address);
        public static void Unload();
        private static void Update();
        private static void Update(DataFile<string, DateTime> cache, DateTime current);
    }

    public static void Bypass(string address);
    public static void Check(string address, ulong userid);
    private static void Check(string address, ulong userid, float delay);
    private static void Check(float delay, string address, ulong userid, Action<string, ulong> callback);
    public static void Configure();
    public static bool IsBlocked(string address);
    public static bool IsBypassed(string address);
    public static void Load();
    public static void Save();
    public static void Unblock(string address);
    public static void Unload();
    private static void Violation(string address, ulong userid, string api);
}

public class Settings
{
    public VpnApi API;
    public VpnCache Cache;
    public VpnCheck Check;
    public VpnViolation Violation;
    public Settings();
    public class VpnApi
    {
        public Guardian.API.Settings GetIpIntel;
        public Guardian.API.Settings IpApi;
        public Guardian.API.Settings IpHub;
        public Guardian.API.Settings IpQualityScore;
        public VpnApi();
        public void Validate();
    }

    public class VpnCache
    {
        public ulong Hours;
        public VpnCache();
    }

    public class VpnCheck
    {
        public bool Enabled;
        public bool Strict;
    }

    public class VpnViolation
    {
        public bool Ban;
        public bool Enabled;
        public bool Warn;
        public VpnViolation();
    }

    public void Validate();
}

public class VpnApi
{
    public Guardian.API.Settings GetIpIntel;
    public Guardian.API.Settings IpApi;
    public Guardian.API.Settings IpHub;
    public Guardian.API.Settings IpQualityScore;
    public VpnApi();
    public void Validate();
}

public class VpnCache
{
    public ulong Hours;
    public VpnCache();
}

public class VpnCheck
{
    public bool Enabled;
    public bool Strict;
}

public class VpnViolation
{
    public bool Ban;
    public bool Enabled;
    public bool Warn;
    public VpnViolation();
}

public class API
{
    public class GetIpIntel
    {
        [JsonProperty("message")]
        public string Message { get; set; }
        [JsonProperty("result")]
        public float Result { get; set; }
        [JsonProperty("status")]
        public string Status { get; set; }
        private const string api;
        public static void Check(string address, ulong userid);
    }

    public class IpApi
    {
        [JsonProperty("hosting")]
        public bool Hosting { get; set; }
        [JsonProperty("proxy")]
        public bool Proxy { get; set; }
        [JsonProperty("status")]
        public string Status { get; set; }
        private const string api;
        public static void Check(string address, ulong userid);
    }

    public class IpHub
    {
        [JsonProperty("block")]
        public int Block { get; set; }
        [JsonIgnore]
        private static readonly Dictionary<string, string> headers;
        private const string api;
        public static void Check(string address, ulong userid);
        public static void Configure();
        public static void Unload();
    }

    public class IpQualityScore
    {
        [JsonProperty("fraud_score")]
        public int FraudScore { get; set; }
        [JsonProperty("message")]
        public string Message { get; set; }
        [JsonProperty("proxy")]
        public bool Proxy { get; set; }
        [JsonProperty("recent_abuse")]
        public bool RecentAbuse { get; set; }
        [JsonProperty("success")]
        public bool Success { get; set; }
        [JsonProperty("vpn")]
        public bool VPN { get; set; }
        private const string api;
        public static void Check(string address, ulong userid);
    }

    public static void Configure();
    public static void Unload();
}

public class GetIpIntel
{
    [JsonProperty("message")]
    public string Message { get; set; }
    [JsonProperty("result")]
    public float Result { get; set; }
    [JsonProperty("status")]
    public string Status { get; set; }
    private const string api;
    public static void Check(string address, ulong userid);
}

public class IpApi
{
    [JsonProperty("hosting")]
    public bool Hosting { get; set; }
    [JsonProperty("proxy")]
    public bool Proxy { get; set; }
    [JsonProperty("status")]
    public string Status { get; set; }
    private const string api;
    public static void Check(string address, ulong userid);
}

public class IpHub
{
    [JsonProperty("block")]
    public int Block { get; set; }
    [JsonIgnore]
    private static readonly Dictionary<string, string> headers;
    private const string api;
    public static void Check(string address, ulong userid);
    public static void Configure();
    public static void Unload();
}

public class IpQualityScore
{
    [JsonProperty("fraud_score")]
    public int FraudScore { get; set; }
    [JsonProperty("message")]
    public string Message { get; set; }
    [JsonProperty("proxy")]
    public bool Proxy { get; set; }
    [JsonProperty("recent_abuse")]
    public bool RecentAbuse { get; set; }
    [JsonProperty("success")]
    public bool Success { get; set; }
    [JsonProperty("vpn")]
    public bool VPN { get; set; }
    private const string api;
    public static void Check(string address, ulong userid);
}

private class Cache
{
    private static readonly DataFile<string, DateTime> blocks;
    private static readonly DataFile<string, DateTime> bypass;
    public static void Block(string address);
    public static void Bypass(string address, ulong _reserved);
    public static bool IsBlocked(string address);
    public static bool IsBypassed(string address);
    private static bool IsCached(DataFile<string, DateTime> cache, string address);
    private static bool IsExpired(DateTime timestamp, DateTime check);
    public static void Load();
    public static void Save();
    public static void Unblock(string address);
    public static void Unload();
    private static void Update();
    private static void Update(DataFile<string, DateTime> cache, DateTime current);
}

private class Weapon
{
    public float Accuracy { get; set; }
    public Vector3 AimAngle { get; set; }
    public float AimCone { get; set; }
    public float AimSway { get; set; }
    public string AmmoName { get; set; }
    public List<string> Attachments { get; set; }
    public bool Automatic { get; set; }
    public DateTime Fired { get; set; }
    public string Name { get; set; }
    public float Pitch { get; set; }
    public BasePlayer Player { get; set; }
    public Vector3 Position { get; set; }
    public List<int> Projectiles { get; set; }
    public float Range { get; set; }
    public float Repeat { get; set; }
    public bool Shell { get; set; }
    public string ShortName { get; set; }
    public float Speed { get; set; }
    public bool Spread { get; set; }
    public float Swing { get; set; }
    public float Velocity { get; set; }
    public float Yaw { get; set; }
    public float Zoom { get; set; }
    private static readonly Queue<Weapon> pool;
    private static readonly int ArrowBone;
    private static readonly int ArrowFire;
    private static readonly int ArrowHV;
    private static readonly int ArrowWooden;
    private static readonly int GrenadeHE;
    private static readonly int GrenadeShotgun;
    private static readonly int GrenadeSmoke;
    private static readonly int NailgunNails;
    private static readonly int PistolBullet;
    private static readonly int PistolHV;
    private static readonly int PistolIncendiary;
    private static readonly int RifleAmmo;
    private static readonly int RifleExplosive;
    private static readonly int RifleHV;
    private static readonly int RifleIncendiary;
    private static readonly int Rocket;
    private static readonly int RocketHV;
    private static readonly int RocketIncendiary;
    private static readonly int ShellBuckshot;
    private static readonly int ShellHandmade;
    private static readonly int ShellIncendiary;
    private static readonly int ShellSlug;
    private static readonly int AssaultRifle;
    private static readonly int BoltActionRifle;
    private static readonly int CompoundBow;
    private static readonly int Crossbow;
    private static readonly int CustomSMG;
    private static readonly int DoubleBarrelShotgun;
    private static readonly int EokaPistol;
    private static readonly int HuntingBow;
    private static readonly int L96Rifle;
    private static readonly int LR300AssaultRifle;
    private static readonly int M249;
    private static readonly int M39Rifle;
    private static readonly int M92Pistol;
    private static readonly int MP5A4;
    private static readonly int MultipleGrenadeLauncher;
    private static readonly int Nailgun;
    private static readonly int PumpShotgun;
    private static readonly int PythonRevolver;
    private static readonly int Revolver;
    private static readonly int RocketLauncher;
    private static readonly int SemiAutomaticPistol;
    private static readonly int SemiAutomaticRifle;
    private static readonly int Spas12Shotgun;
    private static readonly int Thompson;
    private static readonly int WaterpipeShotgun;
    private class Ammo
    {
        public float AimCone { get; set; }
        public float Range { get; set; }
        public float Velocity { get; set; }
        public Ammo(float aimcone, float range, float velocity);
    }

    private class Info
    {
        public float Accuracy { get; set; }
        public Dictionary<int, Ammo> Ammo { get; set; }
        public bool Automatic { get; set; }
        public string Name { get; set; }
        public Recoil Recoil { get; set; }
        public float Repeat { get; set; }
    }

    private class Recoil
    {
        public float Pitch { get; set; }
        public float Yaw { get; set; }
        public Recoil(float pitch, float yaw);
    }

    private static Dictionary<int, Info> weapons;
    private Weapon();
    private static Weapon Get();
    public static Weapon Get(ulong userid, int projectileid);
    public static Weapon Get(BaseProjectile weapon_fired, BasePlayer player, ProtoBuf.ProjectileShoot fired);
    public static bool IsValid(Item item);
    public static void Load();
    public void Release();
    public void SetSwing(float amount);
    public static void Unload();
}

private class Ammo
{
    public float AimCone { get; set; }
    public float Range { get; set; }
    public float Velocity { get; set; }
    public Ammo(float aimcone, float range, float velocity);
}

private class Info
{
    public float Accuracy { get; set; }
    public Dictionary<int, Ammo> Ammo { get; set; }
    public bool Automatic { get; set; }
    public string Name { get; set; }
    public Recoil Recoil { get; set; }
    public float Repeat { get; set; }
}

private class Recoil
{
    public float Pitch { get; set; }
    public float Yaw { get; set; }
    public Recoil(float pitch, float yaw);
}

private class WebHook
{
    public static void Send(string url, string category, string message);
}


```

---

## GuessTheNumber

```csharp
using Random=System.Random;
using System;
using Rust.Xp;
using System.Collections.Generic;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("Guess The Number", "Dora", "1.2.1", ResourceId = 2023)]
[Description("Rewards the user with XP when they say the correct number.")]
 class GuessTheNumber : RustPlugin
{
     Random rng;
     int number;
     bool hasEconomics;
     bool hasServerRewards;
     Timer endEventTimer;
     Timer autoRepeatTimer;
    [PluginReference]
     Plugin Economics;
    [PluginReference]
     Plugin ServerRewards;
    public class LimitTries
    {
        public int attemptedTries;
    }

    public static Dictionary<ulong, LimitTries> playerInfo;
    private void OnServerInitialized();
    private void repeatNumberEvent();
    private void GuessNumberEvent(int minNumber, int maxNumber);
    [ChatCommand("startNumber")]
    private void startGuessNumberEvent(BasePlayer player, string cmd, string[] args);
    [ChatCommand("endNumber")]
    private void stopGuessNumberEvent(BasePlayer player);
    [ChatCommand("number")]
    private void numberReply(BasePlayer player, string cmd, string[] args);
    private void endEvent();
    private void sendChatMessage(BasePlayer player, string prefix, string msg);
    private void broadcastChat(string prefix, string msg);
    private bool hasPermission(BasePlayer player, string perm);
    private ConfigData configData;
     class ConfigData
    {
        public bool autoEventEnabler { get; set; }
        public int autoEventInterval { get; set; }
        public int minNumber { get; set; }
        public int maxNumber { get; set; }
        public bool xpEnabler { get; set; }
        public bool xpPercentEnabler { get; set; }
        public float xpPercentToGive { get; set; }
        public int xpToGive { get; set; }
        public bool economicsEnabler { get; set; }
        public int economicsWinReward { get; set; }
        public bool serverRewardsEnabler { get; set; }
        public int serverRewardsPoints { get; set; }
        public bool maxAttemptsEnabler { get; set; }
        public int maxAttempts { get; set; }
        public bool autoEndEventEnabler { get; set; }
        public int autoEndEventTimer { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
     void LoadDefaultMessages();
     string Lang(string key, string id, object[] args);
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
}

public class LimitTries
{
    public int attemptedTries;
}

 class ConfigData
{
    public bool autoEventEnabler { get; set; }
    public int autoEventInterval { get; set; }
    public int minNumber { get; set; }
    public int maxNumber { get; set; }
    public bool xpEnabler { get; set; }
    public bool xpPercentEnabler { get; set; }
    public float xpPercentToGive { get; set; }
    public int xpToGive { get; set; }
    public bool economicsEnabler { get; set; }
    public int economicsWinReward { get; set; }
    public bool serverRewardsEnabler { get; set; }
    public int serverRewardsPoints { get; set; }
    public bool maxAttemptsEnabler { get; set; }
    public int maxAttempts { get; set; }
    public bool autoEndEventEnabler { get; set; }
    public int autoEndEventTimer { get; set; }
}


```

---

## GUIAnnouncements

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
using UnityEngine;
using Oxide.Core;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("GUIAnnouncements", "JoeSheep", "1.17.48", ResourceId = 1222)]
[Description("Creates announcements with custom messages by command across the top of every player's screen in a banner.")]
public class GUIAnnouncements : RustPlugin
{
    const string PermAnnounce;
    const string PermAnnounceToggle;
    private string AnnouncementGUI;
    private string AnnouncementText;
    private Dictionary<ulong, string> Exclusions;
    private List<ulong> JustJoined;
    private List<ulong> GlobalTimerList;
    private Dictionary<BasePlayer, Timer> PrivateTimers;
    private Dictionary<BasePlayer, Timer> NewPlayerPrivateTimers;
    private Dictionary<BasePlayer, Timer> PlayerRespawnedTimers;
    private Timer PlayerTimer;
    private Timer GlobalTimer;
    private Timer NewPlayerTimer;
    private Timer PlayerRespawnedTimer;
    private Timer RealTimeTimer;
    private Timer SixtySecondsTimer;
    private Timer AutomaticAnnouncementsTimer;
    private string LastHitPlayer;
    private bool ConfigUpdated;
    private List<DateTime> RestartTimes;
    private Dictionary<DateTime, TimeSpan> CalcNextRestartDict;
    private DateTime NextRestart;
    private int LastHour;
    private int LastMinute;
    private bool RestartCountdown;
    private IEnumerator<string> ATALEnum;
    private bool RestartJustScheduled;
    private bool RestartScheduled;
    private List<string> RestartAnnouncementsWhenStrings;
    private DateTime ScheduledRestart;
    private TimeSpan AutomaticTimedAnnouncementsRepeat;
    private bool RestartSuspended;
     string BannerTintGrey;
     string BannerTintRed;
     string BannerTintGreen;
     string TextYellow;
     string TextOrange;
     string TextWhite;
     string BannerAnchorMaxX();
     string BannerAnchorMaxY;
     string BannerAnchorMinX();
     string BannerAnchorMinY;
     string TextAnchorMaxX;
     string TextAnchorMaxY;
     string TextAnchorMinX;
     string TextAnchorMinY;
    public float announcementDuration { get; set; }
    public float welcomeAnnouncementDuration { get; set; }
    public int fontSize { get; set; }
    public float fadeOutTime { get; set; }
    public float fadeInTime { get; set; }
    public bool automaticTimedAnnouncements { get; set; }
    public static List<object> automaticTimedAnnouncementsList { get; set; }
    public string automaticTimedAnnouncementsRepeat { get; set; }
    public bool helicopterAnnouncement { get; set; }
    public bool helicopterDeathAnnouncement { get; set; }
    public bool helicopterDeathAnnouncementWithKiller { get; set; }
    public bool airdropAnnouncement { get; set; }
    public bool airdropAnnouncementLocation { get; set; }
    public bool welcomeAnnouncement { get; set; }
    public bool welcomeBackAnnouncement { get; set; }
    public bool newPlayerAnnouncements { get; set; }
    public int newPlayerAnnouncementsShowTimes { get; set; }
    public List<object> newPlayerAnnouncementsList { get; set; }
    public bool respawnAnnouncements { get; set; }
    public List<object> respawnAnnouncementsList { get; set; }
    public bool restartAnnouncements { get; set; }
    public List<object> restartTimes { get; set; }
    public List<object> restartAnnouncementsWhen { get; set; }
    public bool restartServer { get; set; }
    public bool doNotOverlayLustyMap { get; set; }
    public string lustyMapPosition { get; set; }
    private void LoadGUIAnnouncementsConfig();
    protected override void LoadDefaultConfig();
    private T GetConfig(string category, string setting, T defaultValue);
    private List<string> ConvertList(object value);
     void SaveData();
     void LoadSavedData();
     class StoredData
    {
        public Dictionary<ulong, PlayerData> PlayerData;
        public StoredData();
    }

     class PlayerData
    {
        public string Name;
        public string UserID;
        public int TimesJoined;
        public bool Dead;
        public PlayerData();
    }

     void CreatePlayerData(BasePlayer player);
     StoredData storedData;
     void OnServerSave();
     void LoadDefaultMessages();
     void OnServerInitialized();
    public void CreateMsgGUI(string Msg, string bannerTintColor, string textColor, BasePlayer player, bool isWelcomeAnnouncement, bool isRestartAnnouncement);
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void OnPlayerSleepEnded(BasePlayer player);
     void destroyAllGUI();
     void destroyGlobalGUI();
     void destroyPrivateGUI(BasePlayer player);
     void Unload();
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private static BasePlayer FindPlayer(string IDName);
    private bool hasPermission(BasePlayer player, string perm);
     void RestartAnnouncementsStart();
     void GetNextRestart(List<DateTime> DateTimes);
     string Lang(string key, string userId);
     void RestartAnnouncements(List<TimeSpan> RestartAnnouncementsWhen);
     void OnEntitySpawned(BaseNetworkable entity);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void OnAirdrop(CargoPlane plane, Vector3 location);
     void WelcomeAnnouncement(BasePlayer player);
     void NewPlayerAnnouncements(BasePlayer player);
     void RespawnedAnnouncements(BasePlayer player);
     void AutomaticTimedAnnouncements();
     void cmdAnnounce(BasePlayer player, string cmd, string[] args);
     void ccmdAnnounce(ConsoleSystem.Arg arg);
     void cmdAnnounceTo(BasePlayer player, string cmd, string[] args);
     void ccmdAnnounceTo(ConsoleSystem.Arg arg, string[] args);
     void cmdAnnounceTest(BasePlayer player, string cmd);
     void cmdDestroyAnnouncement(BasePlayer player, string cmd);
     void ccmdAnnounceDestroy(ConsoleSystem.Arg arg);
     void cmdAnnouncementsToggle(BasePlayer player, string cmd, string[] args);
     void ccmdAnnouncementsToggle(ConsoleSystem.Arg arg, string[] args);
     void cmdScheduleRestart(BasePlayer player, string cmd, string[] args);
     void ccmdScheduleRestart(ConsoleSystem.Arg arg, string[] args);
     void cmdCancelScheduledRestart(BasePlayer player, string cmd);
     void ccmdCancelScheduledRestart(ConsoleSystem.Arg arg, string cmd);
     void cmdSuspendRestart(BasePlayer player, string cmd);
     void ccmdSuspendRestart(ConsoleSystem.Arg arg, string cmd);
     void cmdResumeRestart(BasePlayer player, string cmd);
     void ccmdResumeRestart(ConsoleSystem.Arg arg, string cmd);
     void cmdGetNextRestart(BasePlayer player, string cmd);
     void ccmdGetNextRestart(ConsoleSystem.Arg arg, string cmd);
     void cmdCancelRestart(BasePlayer player, string cmd);
     void ccmdCancelRestart(ConsoleSystem.Arg arg);
     void cmdAnnounceHelp(BasePlayer player, string cmd);
     void ccmdAnnounceHelp(ConsoleSystem.Arg arg);
}

 class StoredData
{
    public Dictionary<ulong, PlayerData> PlayerData;
    public StoredData();
}

 class PlayerData
{
    public string Name;
    public string UserID;
    public int TimesJoined;
    public bool Dead;
    public PlayerData();
}


```

---

## GUIShop

```csharp
using System.Collections.Generic;
using System;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("GUIShop", "Reneb", "1.4.1", ResourceId = 1319)]
 class GUIShop : RustPlugin
{
    private const string ShopOverlayName;
    private const string ShopContentName;
    private const string ShopDescOverlay;
    private readonly int[] steps;
     int playersMask;
    [PluginReference]
     Plugin Economics;
    [PluginReference]
     Plugin Kits;
    [PluginReference]
     Plugin ImageCache;
     void OnServerInitialized();
     void LoadDefaultConfig();
    private void CheckCfg(string Key, T var);
     class ItemData
    {
        public string Shortname { get; set; }
        public double Cooldown { get; set; }
        public double Buy { get; set; }
        public double Sell { get; set; }
        public bool Fixed { get; set; }
        public List<string> Cmd { get; set; }
        public string Img { get; set; }
    }

    private Dictionary<string, ItemData> ShopCategories;
    private Dictionary<string, object> Shops;
    private bool Balance;
    private bool Logging;
    private string IconUrl;
     string MessageShowNoEconomics;
     string MessageBought;
     string MessageSold;
     string MessageErrorCooldown;
     string MessageErrorCooldownAmount;
     string MessageErrorInventoryFull;
     string MessageErrorInventorySlots;
     string MessageErrorNoShop;
     string MessageErrorNoActionShop;
     string MessageErrorNoNPC;
     string MessageErrorNoActionItem;
     string MessageErrorItemItem;
     string MessageErrorItemNoValid;
     string MessageErrorRedeemKit;
     string MessageErrorBuyCmd;
     string MessageErrorBuyPrice;
     string MessageErrorSellPrice;
     string MessageErrorNotEnoughMoney;
     string MessageErrorNotEnoughSell;
     string MessageErrorNotNothing;
     string MessageErrorItemNoExist;
     string MessageErrorNPCRange;
     string MessageErrorBuildingBlocked;
     void Init();
     void LoadData();
     void SaveData();
     void Unload();
     void OnServerSave();
     void OnServerShutdown();
    static int CurrentTime();
    static Dictionary<string, object> DefaultShops();
    static Dictionary<string, object> DefaultShopCategories();
    readonly Dictionary<string, string> displaynameToShortname;
     void Loaded();
     void OnUseNPC(BasePlayer npc, BasePlayer player);
    private static CuiElementContainer CreateShopOverlay(string shopname);
    private readonly CuiLabel shopDescription;
    private CuiElementContainer CreateShopItemEntry(string price, float ymax, float ymin, string shop, string item, string color, bool sell, bool cooldown);
    private CuiElementContainer CreateShopItemIcon(string name, float ymax, float ymin, ItemData data);
    private static CuiElementContainer CreateShopChangePage(string currentshop, int shoppageminus, int shoppageplus);
    readonly Hash<ulong, int> shopPage;
    private Dictionary<ulong, Dictionary<string, double>> cooldowns;
    private Dictionary<string, ulong> buyed;
    private Dictionary<string, ulong> selled;
    private bool configChanged;
     void ShowShop(BasePlayer player, string shopid, int from, bool fullPaint, bool refreshMoney);
     double GetBuyPrice(ItemData data);
     double GetSellPrice(ItemData data);
     double GetFactor(ItemData data);
    private static string FormatTime(long seconds);
     object CanDoAction(BasePlayer player, string shop, string item, string ttype);
     bool CanFindNPC(Vector3 pos, string npcid);
     object CanShop(BasePlayer player, string shopname);
     object TryShopBuy(BasePlayer player, string shop, string item, int amount);
     object TryGive(BasePlayer player, string item, int amount);
    private int GetAmountBuy(BasePlayer player, string item);
    private object GiveItem(BasePlayer player, ItemData data, int amount, ItemContainer pref);
     object CanBuy(BasePlayer player, string item, int amount);
     object TryShopSell(BasePlayer player, string shop, string item, int amount);
     object TrySell(BasePlayer player, string item, int amount);
    private int GetAmountSell(BasePlayer player, string item);
    private object TakeItem(BasePlayer player, ItemData data, int amount);
     object CanSell(BasePlayer player, string item, int amount);
     void DestroyUi(BasePlayer player, bool full);
    [ChatCommand("shop")]
     void cmdShop(BasePlayer player, string command, string[] args);
    [ConsoleCommand("shop.show")]
     void ccmdShopShow(ConsoleSystem.Arg arg);
    [ConsoleCommand("shop.buy")]
     void ccmdShopBuy(ConsoleSystem.Arg arg);
    [ConsoleCommand("shop.sell")]
     void ccmdShopSell(ConsoleSystem.Arg arg);
}

 class ItemData
{
    public string Shortname { get; set; }
    public double Cooldown { get; set; }
    public double Buy { get; set; }
    public double Sell { get; set; }
    public bool Fixed { get; set; }
    public List<string> Cmd { get; set; }
    public string Img { get; set; }
}


```

---

## GunGame

```csharp
using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Rust;

Oxide.Plugins
[Info("Gun Game", "k1lly0u", "0.3.52", ResourceId = 1485)]
 class GunGame : RustPlugin
{
    [PluginReference]
     EventManager EventManager;
    private bool useThisEventGG;
    private bool GGStarted;
    private List<GunGamePlayer> GunGamePlayers;
    private ConfigData configData;
    private Dictionary<string, ItemDefinition> _itemsDict;
     class ConfigData
    {
        public string EventName { get; set; }
        public string SpawnFile { get; set; }
        public string ZoneName { get; set; }
        public string ArmourType { get; set; }
        public float StartHealth { get; set; }
        public bool UseMachete { get; set; }
        public bool UseArmour { get; set; }
        public bool UseMeds { get; set; }
        public bool CloseEventAtStart { get; set; }
        public int RankLimit { get; set; }
        public int TokensPerKill { get; set; }
        public int TokensOnWin { get; set; }
        public Gear DowngradeWeapon { get; set; }
        public List<Gear> Meds { get; set; }
        public List<Gear> PlayerGear { get; set; }
        public Dictionary<int, RankItem> Weapons { get; set; }
    }

     class GunGamePlayer : MonoBehaviour
    {
        public BasePlayer player;
        public int kills;
        public int level;
         void Awake();
    }

    internal class RankItem
    {
        public string name;
        public string shortname;
        public int skin;
        public string container;
        public int amount;
        public int ammo;
        public string ammoType;
        public string[] contents;
    }

     class Gear
    {
        public string name;
        public string shortname;
        public int skin;
        public int amount;
        public string container;
    }

     void OnServerInitialized();
     void RegisterGame();
    protected override void LoadDefaultConfig();
     void SaveConfig(ConfigData config);
     void Unload();
    private void DestroyEvent();
     Dictionary<string, object> EventZoneConfig;
     string EventMessageWon;
     string EventMessageNoMorePlayers;
     string GGMessageKill;
     string EventMessageOpenBroadcast;
    private void LoadVariables();
    private void LoadConfigVariables();
     class LeaderBoard
    {
        public string Name;
        public int Kills;
    }

    private List<GunGamePlayer> SortScores();
    private string PlayerMsg(int key, GunGamePlayer player);
    private CuiElementContainer CreateScoreboard(BasePlayer player);
    private void RefreshSB();
    private void AddUI(BasePlayer player);
    private void DestroyUI(BasePlayer player);
     void OnSelectEventGamePost(string name);
     void OnEventPlayerSpawn(BasePlayer player);
     object OnSelectSpawnFile(string name);
     void OnSelectEventZone(MonoBehaviour monoplayer, string radius);
     void OnPostZoneCreate(string name);
     object CanEventOpen();
     object CanEventStart();
     object OnEventOpenPost();
     object OnEventCancel();
     object OnEventClosePost();
     object OnEventEndPre();
     object OnEventEndPost();
     object OnEventStartPre();
     object OnEventStartPost();
     object CanEventJoin();
     object OnSelectKit(string kitname);
     object OnEventJoinPost(BasePlayer player);
     object OnEventLeavePost(BasePlayer player);
     void OnEventPlayerAttack(BasePlayer attacker, HitInfo hitinfo);
     void OnEventPlayerDeath(BasePlayer victim, HitInfo hitinfo);
     object EventChooseSpawn(BasePlayer player, Vector3 destination);
     object OnRequestZoneName();
    private void notifyMachete(BasePlayer player);
    private void stripGive(BasePlayer player);
    public void GiveRankKit(BasePlayer player, int rank);
    private ItemDefinition FindItemDefinition(string shortname);
    private Item BuildItem(string shortname);
    public void GiveItem(BasePlayer player, RankItem rankItem);
    public void GiveItem(BasePlayer player, string shortname, string container, int amount, int skin);
    private string GetWeapon(HitInfo hitInfo, string def);
     void AddKill(BasePlayer player, BasePlayer victim, string shortname);
     void CheckScores(BasePlayer player, bool leveled, bool timelimitreached);
     void Winner(BasePlayer player);
    [ChatCommand("gg")]
    private void cmdGunGame(BasePlayer player, string command, string[] args);
    private bool isAuth(BasePlayer player);
    private void SaveWeapon(BasePlayer player, int rank, int ammo);
    private void SetPlayerKit(BasePlayer player);
    private void SaveItem(Item item, string cont, bool data);
}

 class ConfigData
{
    public string EventName { get; set; }
    public string SpawnFile { get; set; }
    public string ZoneName { get; set; }
    public string ArmourType { get; set; }
    public float StartHealth { get; set; }
    public bool UseMachete { get; set; }
    public bool UseArmour { get; set; }
    public bool UseMeds { get; set; }
    public bool CloseEventAtStart { get; set; }
    public int RankLimit { get; set; }
    public int TokensPerKill { get; set; }
    public int TokensOnWin { get; set; }
    public Gear DowngradeWeapon { get; set; }
    public List<Gear> Meds { get; set; }
    public List<Gear> PlayerGear { get; set; }
    public Dictionary<int, RankItem> Weapons { get; set; }
}

 class GunGamePlayer : MonoBehaviour
{
    public BasePlayer player;
    public int kills;
    public int level;
     void Awake();
}

internal class RankItem
{
    public string name;
    public string shortname;
    public int skin;
    public string container;
    public int amount;
    public int ammo;
    public string ammoType;
    public string[] contents;
}

 class Gear
{
    public string name;
    public string shortname;
    public int skin;
    public int amount;
    public string container;
}

 class LeaderBoard
{
    public string Name;
    public int Kills;
}


```

---

## HackCrateSettings

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("HackCrateSettings", "CRACED", "1.0.2")]
public class HackCrateSettings : RustPlugin
{
    private ConfigData cfg { get; set; }
    private class ConfigData
    {
        [JsonProperty("Время открытия ящика в сек(900 стандарт)")]
        public Dictionary<string, float> HackTimeList;
        [JsonProperty("Лутать ящик может только тот кто начал взлом?")]
        public bool hackOwner;
        [JsonProperty("Если включен параметр выше. Друзья могут лутать?(Только SoFriends)")]
        public bool friendsLoot;
        [JsonProperty("Если включен параметр выше. Люди из зеленой команды могут лутать?")]
        public bool teamLoot;
        public static ConfigData GetNewConf();
    }

    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    protected override void LoadConfig();
     void OnEntityKill(HackableLockedCrate entity);
     Dictionary<ulong, ulong> hackList;
     object CanHackCrate(BasePlayer player, HackableLockedCrate crate);
     object CanLootEntity(BasePlayer player, StorageContainer container);
    private float GetTime(ulong uid);
    private void OnServerInitialized();
    [PluginReference]
    public Plugin SoFriends;
    private bool IsFriends(ulong owner, ulong player);
}

private class ConfigData
{
    [JsonProperty("Время открытия ящика в сек(900 стандарт)")]
    public Dictionary<string, float> HackTimeList;
    [JsonProperty("Лутать ящик может только тот кто начал взлом?")]
    public bool hackOwner;
    [JsonProperty("Если включен параметр выше. Друзья могут лутать?(Только SoFriends)")]
    public bool friendsLoot;
    [JsonProperty("Если включен параметр выше. Люди из зеленой команды могут лутать?")]
    public bool teamLoot;
    public static ConfigData GetNewConf();
}


```

---

## HandyMan

```csharp
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust;
using Oxide.Plugins;
using UnityEngine;
using Facepunch;

Oxide.Plugins
[Info("HandyMan", "MrMan", "1.0.2.1")]
[Description("Provides AOE repair functionality to the player. Repair is only possible where you can build. HandyMan can be turned on or off.")]
public class HandyMan : RustPlugin
{
    readonly DynamicConfigFile dataFile;
     Dictionary<ulong, bool> playerPrefs_IsActive;
    private ConfigData configData;
    private PluginTimers RepairMessageTimer;
    private bool _allowHandyManFixMessage;
    private bool _allowAOERepair;
    private string _ChatmessagePrefix;
     class ConfigData
    {
        public float RepairRange { get; set; }
        public bool DefaultHandyManOn { get; set; }
        public Dictionary<string, HashSet<string>> Categories { get; set; }
        public float HandyManChatInterval { get; set; }
    }

    protected override void LoadDefaultConfig();
    internal void LoadAffectedStructures();
    private void Init();
    private void Loaded();
     void LoadMessages();
     void OnHammerHit(BasePlayer player, HitInfo info);
    [HookMethod("SendHelpText")]
    private void SendHelpText(BasePlayer player);
     void Repair(BaseCombatEntity block, BasePlayer player);
    private void RepairAOE(BaseCombatEntity block, BasePlayer player);
    private void ConfigureMessageTimer();
    private void RepairMessageTimer_Elapsed();
    [ChatCommand("HandyMan")]
    private void ChatCommand_HandyMan(BasePlayer player, string command, string[] args);
    [ConsoleCommand("HealthCheck")]
    private void ConsoleCommand_HealthCheck();
     string GetMsg(string key, object userID);
    private void SendChatMessage(BasePlayer player, string prefix, string msg);
}

 class ConfigData
{
    public float RepairRange { get; set; }
    public bool DefaultHandyManOn { get; set; }
    public Dictionary<string, HashSet<string>> Categories { get; set; }
    public float HandyManChatInterval { get; set; }
}


```

---

## HardcoreDeath

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

Oxide.Plugins
[Info("HardcoreDeath", "Reynostrum", "1.0.1")]
[Description("Unlearn a random blueprint on death.")]
 class HardcoreDeath : RustPlugin
{
     bool ProtectAdmin { get; set; }
     string Prefix { get; set; }
    protected override void LoadDefaultConfig();
     void Loaded();
     void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo);
     T GetConfig(string name, T defaultValue);
     string Lang(string key, string id, object[] args);
     bool HasPermission(BasePlayer player, string perm);
     Dictionary<string, string> Messages;
}


```

---

## HardcoreWorkbench

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("Hardcore Workbench", "Marat", "1.0.3")]
[Description("Removes tech tree from workbenches")]
public class HardcoreWorkbench : RustPlugin
{
    private const string WorkbenchLayer;
    private const string permissionName;
    private readonly Dictionary<BasePlayer, WorkbenchBehavior> benchOpen;
    private List<BaseEntity> vendingMachine;
    private void OnServerInitialized();
    private void Unload();
    private void OnPlayerConnected(BasePlayer player);
    private void CanLootEntity(BasePlayer player, Workbench container);
    private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
    private void OnEntityLeave(TriggerWorkbench trigger, BasePlayer player);
    private object OnEntityVisibilityCheck(ResearchTable table, BasePlayer player);
    private void OnOpenBox(BasePlayer player);
    private void OnCloseBox(BasePlayer player);
    private class PluginConfig
    {
        [JsonProperty("Use workbench menu")]
        public bool useMenuWorkbench;
        [JsonProperty("Remove need for workbench")]
        public bool disableCraftMode;
        [JsonProperty("Time to research item")]
        public float itemResearchTime;
        [JsonProperty("Add vehicles parts vending machine")]
        public bool addVehiclesParts;
        [JsonProperty("Use permission to open workbench")]
        public bool usePermission;
    }

    protected override void LoadDefaultConfig();
    private static PluginConfig config;
    protected override void SaveConfig();
    protected override void LoadConfig();
    [ConsoleCommand("UI_Workbench")]
    private void CmdWorkbenchUI(ConsoleSystem.Arg arg);
    private void OpenWorkbench(BasePlayer player);
    public class WorkbenchBehavior : FacepunchBehaviour
    {
        private ResearchTable container;
        public void Awake();
        public void Open(BasePlayer player);
        public void Close(BasePlayer player);
        public void Destroy();
        public static ResearchTable CreateTable(BasePlayer player);
        public void StartLoot(BasePlayer player);
    }

    protected override void LoadDefaultMessages();
    private string GetMessage(string key, string steamID);
    private StoredData storedData;
    private class StoredData
    {
        public Dictionary<string, int> cachedLevel;
    }

    private void SaveData();
    private void LoadData();
}

private class PluginConfig
{
    [JsonProperty("Use workbench menu")]
    public bool useMenuWorkbench;
    [JsonProperty("Remove need for workbench")]
    public bool disableCraftMode;
    [JsonProperty("Time to research item")]
    public float itemResearchTime;
    [JsonProperty("Add vehicles parts vending machine")]
    public bool addVehiclesParts;
    [JsonProperty("Use permission to open workbench")]
    public bool usePermission;
}

public class WorkbenchBehavior : FacepunchBehaviour
{
    private ResearchTable container;
    public void Awake();
    public void Open(BasePlayer player);
    public void Close(BasePlayer player);
    public void Destroy();
    public static ResearchTable CreateTable(BasePlayer player);
    public void StartLoot(BasePlayer player);
}

private class StoredData
{
    public Dictionary<string, int> cachedLevel;
}


```

---

## Harvester

```csharp
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEngine;

Oxide.Plugins
[Info ( "Harvester", "TopPlugin.ru", "1.2.0" )]
[Description ( "Use a harvester to cut your crops when they fully grow." )]
public class Harvester : RustPlugin
{
    public static Harvester Instance { get; set; }
    public bool IsInitialized { get; set; }
    [PluginReference]
    public Plugin Friends;
    [PluginReference]
    public Plugin Clans;
    private void RefreshPlugins();
    private void Init();
    private void Loaded();
    private void Unload();
    private void OnServerInitialized();
    private void OnServerSave();
    private bool CanPickupEntity(BasePlayer player, FuelGenerator entity);
    private void OnEntityKill(FuelGenerator entity);
    private void OnEntityDeath(FuelGenerator entity, HitInfo info);
    private void OnServerShutdown();
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private object OnPlayerSleep(BasePlayer player);
    private object OnHammerHit(BasePlayer player, HitInfo info);
    private void OnPluginLoaded(Plugin name);
    private void OnPluginUnloaded(Plugin name);
    private void InitiateHarvesters();
    private void ResetConfig();
    public void Print(object message, BasePlayer player);
    public HarvesterManager HarvesterManagerBehaviour { get; set; }
    private void CreateBehaviour();
    private void ClearBehaviour();
    public class HarvesterManager : MonoBehaviour
    {
    }

    private IEnumerator CheckPlanters();
    public void RefreshHarvesters();
    private static bool TryGetPlayerView(BasePlayer player, Quaternion viewAngle);
    private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, object closestEnt, Vector3 closestHitpoint);
    private bool ValidDistance(ulong playerId, BaseEntity entity, RootConfig.Harvester harvester, float distance, RootConfig.Setting setting);
    public const string AdminPerm;
    public const string UsePerm;
    private void InstallPermissions();
    private bool HasPermission(BasePlayer player, string perm);
    private RootConfig.Setting GetIdealSetting(ulong player);
    [ChatCommand ( "allowteamaccess" )]
    private void AllowTeamAccess(BasePlayer player, string command, string [] args);
    [ChatCommand ( "allowfriendsaccess" )]
    private void AllowFriendsAccess(BasePlayer player, string command, string [] args);
    [ChatCommand ( "allowclanaccess" )]
    private void AllowClanAccess(BasePlayer player, string command, string [] args);
    [ChatCommand ( "setharvester" )]
    private void SetHarvester(BasePlayer player, string command, string [] args);
    [ChatCommand ( "unsetharvester" )]
    private void UnsetHarvester(BasePlayer player, string command, string [] args);
    [ChatCommand ( "setoutput" )]
    private void SetOutputContainer(BasePlayer player, string command, string [] args);
    [ChatCommand ( "unsetoutput" )]
    private void UnsetOutputContainer(BasePlayer player, string command, string [] args);
    public bool StartEditing(ulong playerId, FuelGenerator generator);
    public bool StopEditing(ulong playerId);
    public bool IsEditing(ulong playerId);
    public bool IsEditing(ulong playerId, RootConfig.Harvester harvester);
    public RootConfig.Harvester GetEdit(ulong playerId);
    public RootConfig.Harvester GetEdit(BasePlayer player);
    public Core.Configuration.DynamicConfigFile ConfigFile { get; set; }
    public new RootConfig Config { get; set; }
    public Dictionary<ulong, uint> Editor { get; set; }
    public Dictionary<ulong, Timer> EditorTimer { get; set; }
    public class RootConfig
    {
        public bool HarvestDyingPlants { get; set; }
        public Dictionary<string, Setting> Settings { get; set; }
        public OutputContainerSkins GeneratorOnSkin { get; set; }
        public OutputContainerSkins GeneratorOffSkin { get; set; }
        public List<Harvester> Harvesters { get; set; }
        public class OutputContainerSkins
        {
            public ulong WoodStorageBox { get; set; }
            public ulong LargeWoodBox { get; set; }
            public OutputContainerSkins();
            public OutputContainerSkins(ulong woodStorageBoxSkin, ulong largeWoodBoxSkin);
        }

        public class Harvester
        {
            public Harvester();
            public Harvester(BasePlayer player, FuelGenerator generator);
            public ulong OwnerPlayerId { get; set; }
            public uint GeneratorId { get; set; }
            public uint OutputContainerId { get; set; }
            public List<Planter> Planters { get; set; }
            public bool AllowTeamToManage { get; set; }
            public bool AllowFriendsToManage { get; set; }
            public bool AllowClanToManage { get; set; }
            public FuelGeneratorSettings PreviousGeneratorSettings { get; set; }
            public ulong PreviousOutputContainerSkinId { get; set; }
            public void BackSettingsUp();
            public void LoadBackupSettings();
            private FuelGenerator _generator { get; set; }
            private StorageContainer _storageContainer { get; set; }
            private PlanterBox [] _planters { get; set; }
            private GrowableEntity [] _planterGrowables { get; set; }
            public FuelGenerator GetGenerator();
            public StorageContainer GetOutputContainer();
            public PlanterBox [] GetPlanters();
            public GrowableEntity [] GetPlanterGrowables();
            public bool HasOutputContainerAssigned();
            public IEnumerator RefreshEverything();
            public IEnumerator RefreshPlanterGrowables();
            public IEnumerator ApplyOutputContainerSkin();
            public IEnumerator RemoveOutputContainerSkin();
            public bool IsGeneratorRunning();
            public class FuelGeneratorSettings
            {
                public bool IsOn { get; set; }
                public int OutputEnergy { get; set; }
                public float FuelPerSecond { get; set; }
            }

        }

        public class Planter
        {
            public uint PlanterId { get; set; }
            public ulong OwnerPlayerId { get; set; }
            public Planter();
            public Planter(uint planterId, ulong ownerPlayerId);
        }

        public class Setting
        {
            public int MaximumHarvesters { get; set; }
            public int PlantersPerHarvester { get; set; }
            public float FuelPerSecond { get; set; }
            public float PlanterDistance { get; set; }
            public float EditorTimeout { get; set; }
        }

    }

}

public class HarvesterManager : MonoBehaviour
{
}

public class RootConfig
{
    public bool HarvestDyingPlants { get; set; }
    public Dictionary<string, Setting> Settings { get; set; }
    public OutputContainerSkins GeneratorOnSkin { get; set; }
    public OutputContainerSkins GeneratorOffSkin { get; set; }
    public List<Harvester> Harvesters { get; set; }
    public class OutputContainerSkins
    {
        public ulong WoodStorageBox { get; set; }
        public ulong LargeWoodBox { get; set; }
        public OutputContainerSkins();
        public OutputContainerSkins(ulong woodStorageBoxSkin, ulong largeWoodBoxSkin);
    }

    public class Harvester
    {
        public Harvester();
        public Harvester(BasePlayer player, FuelGenerator generator);
        public ulong OwnerPlayerId { get; set; }
        public uint GeneratorId { get; set; }
        public uint OutputContainerId { get; set; }
        public List<Planter> Planters { get; set; }
        public bool AllowTeamToManage { get; set; }
        public bool AllowFriendsToManage { get; set; }
        public bool AllowClanToManage { get; set; }
        public FuelGeneratorSettings PreviousGeneratorSettings { get; set; }
        public ulong PreviousOutputContainerSkinId { get; set; }
        public void BackSettingsUp();
        public void LoadBackupSettings();
        private FuelGenerator _generator { get; set; }
        private StorageContainer _storageContainer { get; set; }
        private PlanterBox [] _planters { get; set; }
        private GrowableEntity [] _planterGrowables { get; set; }
        public FuelGenerator GetGenerator();
        public StorageContainer GetOutputContainer();
        public PlanterBox [] GetPlanters();
        public GrowableEntity [] GetPlanterGrowables();
        public bool HasOutputContainerAssigned();
        public IEnumerator RefreshEverything();
        public IEnumerator RefreshPlanterGrowables();
        public IEnumerator ApplyOutputContainerSkin();
        public IEnumerator RemoveOutputContainerSkin();
        public bool IsGeneratorRunning();
        public class FuelGeneratorSettings
        {
            public bool IsOn { get; set; }
            public int OutputEnergy { get; set; }
            public float FuelPerSecond { get; set; }
        }

    }

    public class Planter
    {
        public uint PlanterId { get; set; }
        public ulong OwnerPlayerId { get; set; }
        public Planter();
        public Planter(uint planterId, ulong ownerPlayerId);
    }

    public class Setting
    {
        public int MaximumHarvesters { get; set; }
        public int PlantersPerHarvester { get; set; }
        public float FuelPerSecond { get; set; }
        public float PlanterDistance { get; set; }
        public float EditorTimeout { get; set; }
    }

}

public class OutputContainerSkins
{
    public ulong WoodStorageBox { get; set; }
    public ulong LargeWoodBox { get; set; }
    public OutputContainerSkins();
    public OutputContainerSkins(ulong woodStorageBoxSkin, ulong largeWoodBoxSkin);
}

public class Harvester
{
    public Harvester();
    public Harvester(BasePlayer player, FuelGenerator generator);
    public ulong OwnerPlayerId { get; set; }
    public uint GeneratorId { get; set; }
    public uint OutputContainerId { get; set; }
    public List<Planter> Planters { get; set; }
    public bool AllowTeamToManage { get; set; }
    public bool AllowFriendsToManage { get; set; }
    public bool AllowClanToManage { get; set; }
    public FuelGeneratorSettings PreviousGeneratorSettings { get; set; }
    public ulong PreviousOutputContainerSkinId { get; set; }
    public void BackSettingsUp();
    public void LoadBackupSettings();
    private FuelGenerator _generator { get; set; }
    private StorageContainer _storageContainer { get; set; }
    private PlanterBox [] _planters { get; set; }
    private GrowableEntity [] _planterGrowables { get; set; }
    public FuelGenerator GetGenerator();
    public StorageContainer GetOutputContainer();
    public PlanterBox [] GetPlanters();
    public GrowableEntity [] GetPlanterGrowables();
    public bool HasOutputContainerAssigned();
    public IEnumerator RefreshEverything();
    public IEnumerator RefreshPlanterGrowables();
    public IEnumerator ApplyOutputContainerSkin();
    public IEnumerator RemoveOutputContainerSkin();
    public bool IsGeneratorRunning();
    public class FuelGeneratorSettings
    {
        public bool IsOn { get; set; }
        public int OutputEnergy { get; set; }
        public float FuelPerSecond { get; set; }
    }

}

public class FuelGeneratorSettings
{
    public bool IsOn { get; set; }
    public int OutputEnergy { get; set; }
    public float FuelPerSecond { get; set; }
}

public class Planter
{
    public uint PlanterId { get; set; }
    public ulong OwnerPlayerId { get; set; }
    public Planter();
    public Planter(uint planterId, ulong ownerPlayerId);
}

public class Setting
{
    public int MaximumHarvesters { get; set; }
    public int PlantersPerHarvester { get; set; }
    public float FuelPerSecond { get; set; }
    public float PlanterDistance { get; set; }
    public float EditorTimeout { get; set; }
}


```

---

## HBheal

```csharp
using System.Collections.Generic;
using System.IO;
using Newtonsoft.Json;
using Oxide.Core;

Oxide.Plugins
[Info("HBheal", "Frizen", "1.0.0")]
[Description("Хп бредли и верта")]
public class HBheal : RustPlugin
{
    public float GlobalDamageMultiplier;
    private Configuration config;
    public class Configuration
    {
        [JsonProperty("Хп танка")]
        public float bradleyhp;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnBradleyApcInitialize(BradleyAPC bradley);
    private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo);
}

public class Configuration
{
    [JsonProperty("Хп танка")]
    public float bradleyhp;
}


```

---

## HCraft

```csharp
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System;
using System.Reflection;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("HCraft", "Hougan", "1.0", ResourceId = 1855)]
public class HCraft : RustPlugin
{
     Dictionary<ulong, int> Craft;
     Dictionary<ulong, bool> Pay;
     void Loaded();
     void OnItemCraft(ItemCraftTask task, BasePlayer crafter);
     void OnPlayerDisconnected(BasePlayer player, string reason);
}


```

---

## HealthChange

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

Oxide.Plugins
[Info("HealthChange", "CA$HR(discord: CASHR#6906)", "1.0.0")]
internal class HealthChange : RustPlugin
{
    private static HealthChange _;
    private Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Список настроек хп по привилегиям", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, int> HPList;
        [JsonProperty(PropertyName = "Список настроек урона по привилегиям", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, float> DamageList;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private void OnServerInitialized();
    private object OnEntityTakeDamage(BaseEntity entity, HitInfo info);
    private void OnPlayerRespawned(BasePlayer player);
    private void OnPlayerConnected(BasePlayer player);
    private void UpdateHealth(BasePlayer player, float amount);
    private int GetMaxHP(BasePlayer player);
    private float GetDamage(BasePlayer player);
    private void Unload();
    private void DestroyAll();
}

private class Configuration
{
    [JsonProperty(PropertyName = "Список настроек хп по привилегиям", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, int> HPList;
    [JsonProperty(PropertyName = "Список настроек урона по привилегиям", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<string, float> DamageList;
}


```

---

## HeliCallCraft

```csharp


```

---

## HelicopterInstantTakeoff

```csharp
using Oxide.Core;
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("Helicopter Instant Takeoff", "bsdinis", "0.0.9")]
[Description("Allows helicopters to takeoff instantly when the engine starts.")]
 class HelicopterInstantTakeoff : RustPlugin
{
     void Init();
     ConfigData config;
     class ConfigData
    {
        public string AirPermission;
        public string GroundPermission;
    }

    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
     bool DriverHasPermission(PlayerHelicopter heli, string perm);
     object OnEngineStart(PlayerHelicopter heli);
}

 class ConfigData
{
    public string AirPermission;
    public string GroundPermission;
}


```

---

## HeliRide

```csharp
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

Oxide.Plugins
[Info("Heli Ride", "ColonBlow", "1.1.17")]
[Description("Allows players to fly the Patrol Helicopter")]
public class HeliRide : RustPlugin
{
    [PluginReference]
    private Plugin Chute;
    private Plugin Vanish;
    public bool CockpitOverlay { get; set; }
    public bool CrossHair { get; set; }
    private static Dictionary<ulong, HeliData> HeliFlying;
    private static Dictionary<ulong, HeliDamage> DamagedHeli;
    private static Dictionary<ulong, HasParachute> AddParachute;
    public class HeliData
    {
        public BasePlayer player;
    }

    public class HeliDamage
    {
        public BasePlayer player;
    }

    public class HasParachute
    {
        public BasePlayer player;
    }

    private void Loaded();
    private bool Changed;
    private static bool ShowCockpitOverlay;
    private static bool ShowCrosshair;
    private static bool UseParachutes;
    private static bool SpawnCrates;
    private static bool UseAutoVanish;
    private static double RocketDelay;
    private static float RocketMax;
    private static float NapalmMax;
    private static double RocketNapalmReloadTime;
    private static float BulletDamage;
    private static string RocketPrefab;
    private static string NapalmPrefab;
    private void LoadConfigVariables();
    protected override void LoadDefaultConfig();
    private void LoadVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
    private object GetConfig(string menu, string datavalue, object defaultValue);
    private new void LoadDefaultMessages();
    [ChatCommand("flyheli")]
    private void chatFlyHeli(BasePlayer player, string command, string[] args);
    [ConsoleCommand("flyheli")]
    private void cmdConsoleFlyHeli(ConsoleSystem.Arg arg);
    [ConsoleCommand("showcockpit")]
    private void cmdConsoleShowCockpit(ConsoleSystem.Arg arg);
    [ConsoleCommand("hidecockpit")]
    private void cmdConsoleHideCockpit(ConsoleSystem.Arg arg);
    private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo);
    private void OnPlayerTick(BasePlayer player);
    private void AddHeli(BasePlayer player);
    private void Unload();
    private static void DestroyAll();
    private void RemoveHeliComponents(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnPlayerRespawned(BasePlayer player);
    private bool isAllowed(BasePlayer player, string perm);
    private class FlyHelicopter : MonoBehaviour
    {
        public BasePlayer player;
        public BaseEntity helicopterBase;
        private BaseEntity rockets;
        public PatrolHelicopterAI heliAI;
        public PatrolHelicopter heli;
        public HelicopterTurret heliturret;
        public InputState input;
        private RaycastHit hitInfo;
        public Vector3 PlayerPOS;
        public Vector3 target;
        public Vector3 CurrentPOS;
        private Vector3 direction;
        private float bulletDamage;
        private float rocketMax;
        private bool hasRockets;
        private float napalmMax;
        private bool hasNapalm;
        private double rocketcycletimer;
        private double reloadtimer;
        private double rocketDelay;
        private bool rocketcycle;
        private bool leftTubeFiredLast;
        private bool isReloading;
        private double rocketNapalmReploadTime;
        private void Awake();
        public void CockpitOverlay(BasePlayer player);
        public void CrosshairOverlay(BasePlayer player);
        public void DamageOverlay(BasePlayer player);
        public void HealthIndicator(BasePlayer player, float health);
        private void FixedUpdate();
        private void FireGuns(Vector3 target);
        private void FireRocket(bool leftTubeFiredLast, Vector3 direction, Vector3 PlayerPOS, bool isrocket);
        private Vector3 FindTarget(Vector3 target);
        public void DestroyCui(BasePlayer player);
        private void addplayerchute();
        public void OnDestroy();
    }

}

public class HeliData
{
    public BasePlayer player;
}

public class HeliDamage
{
    public BasePlayer player;
}

public class HasParachute
{
    public BasePlayer player;
}

private class FlyHelicopter : MonoBehaviour
{
    public BasePlayer player;
    public BaseEntity helicopterBase;
    private BaseEntity rockets;
    public PatrolHelicopterAI heliAI;
    public PatrolHelicopter heli;
    public HelicopterTurret heliturret;
    public InputState input;
    private RaycastHit hitInfo;
    public Vector3 PlayerPOS;
    public Vector3 target;
    public Vector3 CurrentPOS;
    private Vector3 direction;
    private float bulletDamage;
    private float rocketMax;
    private bool hasRockets;
    private float napalmMax;
    private bool hasNapalm;
    private double rocketcycletimer;
    private double reloadtimer;
    private double rocketDelay;
    private bool rocketcycle;
    private bool leftTubeFiredLast;
    private bool isReloading;
    private double rocketNapalmReploadTime;
    private void Awake();
    public void CockpitOverlay(BasePlayer player);
    public void CrosshairOverlay(BasePlayer player);
    public void DamageOverlay(BasePlayer player);
    public void HealthIndicator(BasePlayer player, float health);
    private void FixedUpdate();
    private void FireGuns(Vector3 target);
    private void FireRocket(bool leftTubeFiredLast, Vector3 direction, Vector3 PlayerPOS, bool isrocket);
    private Vector3 FindTarget(Vector3 target);
    public void DestroyCui(BasePlayer player);
    private void addplayerchute();
    public void OnDestroy();
}


```

---

## HeliSupport

```csharp
using System.Collections.Generic;
using ConVar;
using UnityEngine;

Oxide.Plugins
[Info("Heli Support", "Unknown", "1.0.8")]
public class HeliSupport : RustPlugin
{
    private const string nocdperm;
    private const string heliprefab;
    private void OnServerInitialized();
    private bool CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player);
    private Dictionary<uint, ulong> helis;
    [ChatCommand("heli")]
    private void CmdCall(BasePlayer player);
    [ConsoleCommand("heli.ctm")]
    private void CmdCall2(ConsoleSystem.Arg arg);
    private void CallHeli(BasePlayer player);
    private void StartPos(PatrolHelicopterAI heli, Vector3 pos);
    private void UpdatePos(PatrolHelicopterAI heli, Vector3 pos);
}


```

---

## HeliVote

```csharp
using System.Collections.Generic;
using System;
using UnityEngine;

Oxide.Plugins
[Info("HeliVote", "k1lly0u", "0.1.31", ResourceId = 1665)]
 class HeliVote : RustPlugin
{
     bool Changed;
    private List<ulong> receivedYes;
    private List<ulong> receivedNo;
    private List<BaseEntity> currentHelis;
    private bool voteOpen;
    private bool helisActive;
    private bool timeBetween;
    private BasePlayer initiator;
     void Loaded();
     void OnServerInitialized();
     void LoadDefaultConfig();
     void Unload();
     void OnEntityDeath(BaseEntity entity, HitInfo hitinfo);
    private bool alreadyVoted(BasePlayer player);
    private bool TallyVotes();
    private void voteEnd(int amount);
    private void clearData();
    private void CallHeli(int amount);
    private void VoteTimer(int amount);
    private void msgAll(string left);
    private bool CheckIfStillExist();
    [ChatCommand("helivote")]
    private void cmdHeiVote(BasePlayer player, string command, string[] args);
    [ConsoleCommand("helivote")]
    private void ccmdVote(ConsoleSystem.Arg arg);
    private bool canVote(BasePlayer player);
     bool isAuth(BasePlayer player);
     bool isAuthCon(ConsoleSystem.Arg arg);
    static float requiredVotesPercentage;
    static bool useMajorityRules;
    static int voteOpenTimer;
    static bool displayProgress;
    static int auth;
    static int minBetween;
    static int maxAmount;
    static bool heliToInit;
    static bool usePerms;
    private void LoadVariables();
    private void LoadConfigVariables();
    private void CheckCfg(string Key, T var);
    private void CheckCfgFloat(string Key, float var);
     object GetConfig(string menu, string datavalue, object defaultValue);
     Dictionary<string, string> messages;
}


```

---

## Help

```csharp
using System;
using System.Linq;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

Oxide.Plugins
[Info("Help", "Chibubrik", "2.0.0")]
 class Help : RustPlugin
{
    private string Layer;
    public Dictionary<string, HelpList> help;
    public class HelpList
    {
        [JsonProperty("Название кнопки")]
        public string NameUI;
        [JsonProperty("Команда")]
        public string Command;
        [JsonProperty("Цвет кнопки")]
        public string ButtonColor;
        [JsonProperty("Размер текста")]
        public int Sizes;
        [JsonProperty("Список")]
        public List<Messages> MessagesList;
    }

    public class Messages
    {
        [JsonProperty("Текст")]
        public string Message;
    }

    [ChatCommand("help")]
     void cmdHelp(BasePlayer player, string command, string[] args);
    [ConsoleCommand("help")]
     void cmdConsoleHelp(ConsoleSystem.Arg args);
    [ConsoleCommand("next.page")]
     void cmdNewxt(ConsoleSystem.Arg args);
    private void HelpUI(BasePlayer player, bool section, string name, int numbr);
    private void OnServerInitialized();
    private bool EnabledLogin;
     void OnPlayerInit(BasePlayer player);
    private void Unload();
    private void CheckData();
    private void LoadData();
    private static string HexToCuiColor(string hex);
}

public class HelpList
{
    [JsonProperty("Название кнопки")]
    public string NameUI;
    [JsonProperty("Команда")]
    public string Command;
    [JsonProperty("Цвет кнопки")]
    public string ButtonColor;
    [JsonProperty("Размер текста")]
    public int Sizes;
    [JsonProperty("Список")]
    public List<Messages> MessagesList;
}

public class Messages
{
    [JsonProperty("Текст")]
    public string Message;
}


```

---

## HelpGUI

```csharp
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System;
using System.Reflection;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("Help GUI", "reyzi", "1.0")]
[Description("Плагин отображает экран помощи")]
 class HelpGUI : RustPlugin
{
    private bool Changed;
    private string text;
    private string backroundimageurl;
     void Loaded();
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
     class Data
    {
        public List<string> Players;
    }

     Data data;
     void Unloaded();
     void UseUI(BasePlayer player, string msg);
    [ChatCommand("help")]
     void cmdRule(BasePlayer player, string cmd, string[] args);
     void DisplayUI(BasePlayer player);
     void OnPlayerInit(BasePlayer player);
}

 class Data
{
    public List<string> Players;
}


```

---

## HelpText

```csharp
using System;
using System.Collections.Generic;
using System.Text;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

Oxide.Plugins
[Info("HelpText", "Domestos/Calytic", "2.0.1", ResourceId = 676)]
 class HelpText : CovalencePlugin
{
    private bool UseCustomHelpText;
    private bool AllowHelpTextFromOtherPlugins;
    private List<object> CustomHelpText;
    private void Loaded();
    protected override void LoadDefaultConfig();
    [Command("help")]
     void cmdHelp(IPlayer player, string command, string[] args);
    private T GetConfig(string name, T defaultValue);
    private T GetConfig(string name, string name2, T defaultValue);
}


```

---

## HideAndSeek

```csharp
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("HideAndSeek", "Wulf/lukespragg", 0.1, ResourceId = 0)]
[Description("The classic game(mode) of hide and seek, as props.")]
 class HideAndSeek : RustPlugin
{
     string NoPermission { get; set; }
     string PlayerHiding { get; set; }
     string PlayerNotHiding { get; set; }
    protected override void LoadDefaultConfig();
    readonly Dictionary<BaseEntity, BasePlayer> props;
     void Loaded();
     class OnlinePlayer
    {
        public BasePlayer Player;
        public bool IsHidden;
    }

    [OnlinePlayers]
     Hash<BasePlayer, OnlinePlayer> onlinePlayers;
     void OnPlayerInit(BasePlayer player);
     void SetPropFlags(BasePlayer player);
     void UnsetPropFlags(BasePlayer player);
     void HidePlayer(BasePlayer player);
     void UnhidePlayer(BasePlayer player);
    [ChatCommand("hide")]
     void HideChat(BasePlayer player, string command, string[] args);
    [ChatCommand("unhide")]
     void UnhideChat(BasePlayer player, string command, string[] args);
    [ChatCommand("taunt")]
     void TauntPlayer(BasePlayer player, string command, string[] args);
     object OnEntityTakeDamage(BaseEntity entity, HitInfo info);
     void OnEntityDeath(BaseEntity entity);
     void OnEntitySpawned(BaseNetworkable entity);
     object OnRunCommand(ConsoleSystem.Arg arg);
     object OnPlayerInput(BasePlayer player, InputState input);
    [ConsoleCommand("global.taunt")]
     void TauntConsole(ConsoleSystem.Arg arg);
     string tauntPanel;
     void TauntButton(BasePlayer player, string text);
     void Unload();
    static BaseEntity FindObject(Ray ray, float distance);
     bool HasPermission(BasePlayer player, string perm);
}

 class OnlinePlayer
{
    public BasePlayer Player;
    public bool IsHidden;
}


```

---

## HitAdvance

```csharp
using System;
using System.Collections;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using VLB;
using WebSocketSharp;

Oxide.Plugins
[Info("HitAdvance", "Hougan", "2.0.4")]
[Description("Уникальный маркер для вашего сервера. Куплено на server-rust.RU")]
public class HitAdvance : RustPlugin
{
    private class PlayerMarker : MonoBehaviour
    {
        public BasePlayer Player;
        public void Awake();
        public void ShowHit(BaseEntity target, HitInfo info);
        public const string Layer;
        public void DestroyHit();
        public IEnumerator DestroyHit(string ID, float delay);
        public PlayerSettings GetSettings();
    }

    private class PlayerSettings
    {
        public HitType CurrentType;
        public bool BuildingHit;
        public PlayerSettings();
        public static PlayerSettings Generate();
    }

    private class HitSetting
    {
        [JsonProperty("Название маркера")]
        public string DisplayName;
        [JsonProperty("Разрешение, с которым его можно выбрать")]
        public string Permission;
        [JsonProperty("Включён у игроков изначально")]
        public bool IsDefault;
    }

    private class Configuration
    {
        [JsonProperty("Настройки различных маркеров")]
        public Hash<HitType, HitSetting> HitSettings;
        [JsonProperty("Включить отображение урона по постройкам изначально")]
        public bool DefaultBuildingDamage;
        [JsonProperty("Показывать урон по НПС")]
        public bool ShowNPCDamage;
        [JsonProperty("Показывать урон по животным")]
        public bool ShowAnimalDamage;
        [JsonProperty("Время удаления маркера (если отсутвует другой урон)")]
        public float DestroyTime;
        [JsonProperty("Укажите название команды для изменения маркера")]
        public string CommandName;
        public static Configuration LoadDefault();
    }

    private static Configuration Settings;
    private static Hash<ulong, PlayerSettings> PlayerSettingses;
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
    private void Unload();
    private void SaveData();
    private void OnPlayerConnected(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    private void OnPlayerAttack(BasePlayer attacker, HitInfo info);
    private void ChatCommandMarker(BasePlayer player, string command, string[] args);
    [ConsoleCommand("UI_HitAdvance")]
    private void consoleCmdChange(ConsoleSystem.Arg args);
    private const string Layer;
    private void UI_DrawInterface(BasePlayer player);
    private static string HexToRustFormat(string hex);
    public static Vector2 GetRandomTextPosition();
    public static string GetGradientColor(int count, int max);
    private static string[] ColorsGradientDB;
}

private class PlayerMarker : MonoBehaviour
{
    public BasePlayer Player;
    public void Awake();
    public void ShowHit(BaseEntity target, HitInfo info);
    public const string Layer;
    public void DestroyHit();
    public IEnumerator DestroyHit(string ID, float delay);
    public PlayerSettings GetSettings();
}

private class PlayerSettings
{
    public HitType CurrentType;
    public bool BuildingHit;
    public PlayerSettings();
    public static PlayerSettings Generate();
}

private class HitSetting
{
    [JsonProperty("Название маркера")]
    public string DisplayName;
    [JsonProperty("Разрешение, с которым его можно выбрать")]
    public string Permission;
    [JsonProperty("Включён у игроков изначально")]
    public bool IsDefault;
}

private class Configuration
{
    [JsonProperty("Настройки различных маркеров")]
    public Hash<HitType, HitSetting> HitSettings;
    [JsonProperty("Включить отображение урона по постройкам изначально")]
    public bool DefaultBuildingDamage;
    [JsonProperty("Показывать урон по НПС")]
    public bool ShowNPCDamage;
    [JsonProperty("Показывать урон по животным")]
    public bool ShowAnimalDamage;
    [JsonProperty("Время удаления маркера (если отсутвует другой урон)")]
    public float DestroyTime;
    [JsonProperty("Укажите название команды для изменения маркера")]
    public string CommandName;
    public static Configuration LoadDefault();
}


```

---

## HitIcon

```csharp
using UnityEngine;
using System;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.IO;
using System.Linq;
using Rust;

Oxide.Plugins
[Info("HitIcon", "serezhadelaet", "0.6")]
[Description("Configurable precached icon when you hit player|friend|clanmate")]
 class HitIcon : RustPlugin
{
     int dmgtextsize;
     float timetodestroy;
     bool usefriends;
     bool useclans;
     bool usesound;
     bool Changed;
     bool friendapi;
     bool showdmg;
     bool showclandmg;
     bool showfrienddmg;
     string colorfriend;
     string colorhead;
     string colorbody;
     string colorclan;
     string dmgcolor;
     string endcolor;
     string matesound;
     Oxide.Plugins.Timer activateTimer;
     Dictionary<ulong, byte> active;
    [PluginReference]
    private Plugin Friends;
    private void InitializeFriendsAPI();
    private bool AreFriendsAPIFriend(string playerId, string friendId);
     void language();
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
    public class disabledplayers
    {
         string playerid;
        public disabledplayers();
        public disabledplayers(BasePlayer player);
        public ulong GetPlayer();
    }

    public class StoredData
    {
        public List<ulong> DisabledUsers;
        public StoredData();
    }

    static StoredData storedData;
    static List<ulong> DisabledUsers;
    static void SaveData();
    static void LoadData();
     ImageCache ImageAssets;
     GameObject HitObject;
    private void cacheImage();
    public class ImageCache : MonoBehaviour
    {
        public Dictionary<string, string> imageFiles;
        public List<Queue> queued;
        public class Queue
        {
            public string url { get; set; }
            public string name { get; set; }
        }

        private void OnDestroy();
        public void getImage(string name, string url);
         IEnumerator WaitForRequest(Queue queue);
        public void process();
    }

    public string fetchImage(string name);
     void download();
    private class GUIv4
    {
         string guiname { get; set; }
         CuiElementContainer container;
        public void add(string uiname, string image, string start, string end, string colour);
        public void dmg(string uiname, string uitext, string start, string end, string uicolor, int uisize);
        public void send(BasePlayer player);
    }

    private void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo);
    [ChatCommand("hit")]
     void toggle(BasePlayer player);
     void OnServerInitialized();
     void OnPlayerInit(BasePlayer player);
     void Loaded();
     void Unloaded();
}

public class disabledplayers
{
     string playerid;
    public disabledplayers();
    public disabledplayers(BasePlayer player);
    public ulong GetPlayer();
}

public class StoredData
{
    public List<ulong> DisabledUsers;
    public StoredData();
}

public class ImageCache : MonoBehaviour
{
    public Dictionary<string, string> imageFiles;
    public List<Queue> queued;
    public class Queue
    {
        public string url { get; set; }
        public string name { get; set; }
    }

    private void OnDestroy();
    public void getImage(string name, string url);
     IEnumerator WaitForRequest(Queue queue);
    public void process();
}

public class Queue
{
    public string url { get; set; }
    public string name { get; set; }
}

private class GUIv4
{
     string guiname { get; set; }
     CuiElementContainer container;
    public void add(string uiname, string image, string start, string end, string colour);
    public void dmg(string uiname, string uitext, string start, string end, string uicolor, int uisize);
    public void send(BasePlayer player);
}


```

---

## HitMarker

```csharp
using Facepunch;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using UnityEngine;
using Random = System.Random;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("HitMarker", "Rust-Plugin.ru", "1.0.2")]
 class HitMarker : RustPlugin
{
    private bool Changed;
    private bool enablesound;
    private string soundeffect;
    private string headshotsoundeffect;
    private float damageTimeout;
     object GetConfig(string menu, string datavalue, object defaultValue);
    protected override void LoadDefaultConfig();
    public static void GetVariable(DynamicConfigFile config, string name, T value, T defaultValue);
    [PluginReference]
    private Plugin Clans;
     Random rnd;
     List<BasePlayer> hitmarkeron;
     Dictionary<BasePlayer, List<KeyValuePair<float, HitNfo>>> damageHistory;
     class HitNfo
    {
        public int damage;
        public bool isHead;
        public bool isFriend;
        public double xs;
        public double ys;
        public double xe;
        public double ye;
        public int num;
    }

     Dictionary<BasePlayer, Oxide.Plugins.Timer> destTimers;
    [ChatCommand("hitmarker")]
     void cmdHitMarker(BasePlayer player, string cmd, string[] args);
     void Unload();
     void OnServerInitialized();
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo);
     string DamageGUI;
     string ActionGUI;
     string HandleArgs(string json, object[] args);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
     void OnPlayerWound(BasePlayer player);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void OnDamageTimer();
     void DamageNotifier(BasePlayer player, int damage, bool isHead, bool isFriend);
     string GetDamageText(string action);
     void DestroyLastCui(BasePlayer player);
     float GetRandomX();
     float GetRandomY();
     void DrawDamageNotifier(BasePlayer player);
}

 class HitNfo
{
    public int damage;
    public bool isHead;
    public bool isFriend;
    public double xs;
    public double ys;
    public double xe;
    public double ye;
    public int num;
}


```

---

## HitMarker2

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Random = System.Random;
using UnityEngine;
using Newtonsoft.Json;

Oxide.Plugins
[Info("HitMarker", "Nimant", "1.0.8")]
 class HitMarker : RustPlugin
{
    private const string FQESDScddeVSnMtmMZIDHysoQQeud;
    private const float jmwbJqIfnPFuCLc;
    private const float JjVBsPmxzClQcxfPLGYklXphElAEL;
    private const float MYUzWGsPPPAjW;
    private const float pLfOPAzItAZvENLYHJKa;
    private const float phNZPBUfWkxbAAjjLKoQn;
    private const float YDwaEHcSSTpdfVwEYDWeifdhvyUGUG;
    private const int pbEYgDuukAhQIvKAJEvuwJGRnX;
    [PluginReference]
    private Plugin Friends;
    private Plugin Clans;
    private static string pPolAKqdVykL;
    private static string YlxbtUWZOSDptMsAzQZcIwi;
    private static string ROTBuIYSvOAADCshJ;
    private static Random KcmKFTzCpT;
    private static bool yWVTHCfyjloropSb;
    private static HashSet<ulong> YSRTmIWdKsCFqqGACmjvrtldzeAql;
    private static Dictionary<ulong, List<KmSRLTezgXWZQtUCPP>> vENIlwkjClONhcjqdvoqcWdykGPsAR;
    private static Dictionary<ulong, Timer> HZNKZzHXexvWyCw;
    private static Dictionary<ulong, int> PVJZIIMBljwltlPwBUJLvnAtqboXly;
    private static Dictionary<ulong, HitTempData> oduSURcrTdLIAiUja;
    private class HitTempData
    {
        public HitInfo WTErBWOgNxznmhdeuupUlRgzX;
        public float timeSS;
    }

    private class KmSRLTezgXWZQtUCPP
    {
        public int ZemtfYLMNQppzPcMQ;
        public int pJiukTaQyZuARIIhxWeh;
        public int TjmUvSIAVMUfL;
        public bool uxRKkIhORRANsHqVAzy;
        public bool vMBmipZWyOWJlPfNSwOmGZAwEBjfoe;
        public bool GTAMETsGPzQqHq;
        public bool DbyQbqasvMURhff;
        public ulong EkkDQHJpAFpiEVRGplp;
        public string pWILvPlyaQPDxgEKcPTatabVqkzsOY;
        public double mypvetKcWiGeeaVzcGbmzMRoPSQaz;
        public double nxZkLTVXQQVCxGSBqZb;
        public double BnaDETkqaq;
        public double fCweONHNklRzOARIiwKDzQgC;
        public BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK;
    }

    private void Init();
    private void OnServerSave();
    private void Unload();
    [ChatCommand("hitmarker")]
    private void UKHLUcyxhSdnewiWxcHMYC(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, string BzYcrLrhhVYbBuBxKF, string[] LbgzPbECnAiYdGwZNVtSCMSwV);
    private void OnEntityDeath(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, HitInfo info);
    private void OnEntityTakeDamage(BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, HitInfo WTErBWOgNxznmhdeuupUlRgzX);
    private void OnPlayerHealthChange(BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, float oldvalue, float newvalue);
    private void RjABDyMmlcsl(BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, HitInfo WTErBWOgNxznmhdeuupUlRgzX, bool DbyQbqasvMURhff, float wpXwTxHuXKCLpK);
    private static string OMbnrvSKZGAsucYF(ulong userID);
    private static float olgPFSgEZabwjJtjYQKcgs(float[] GxFfYcAYiJzEhZGfN);
    private static bool bjiMhgGIkTtGMrwoLHZ(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, BasePlayer GSwFeUOlQSOKEpxo);
    private bool lXVelXRENKCggSmMohvLIgyxHtp(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, string GsuOOXCOuuJsfoY);
    private void eQgBWpgTQv(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, int wpXwTxHuXKCLpK, bool isHeadshot, bool RFWQCbyFRbrFrzySozq, bool DbyQbqasvMURhff);
    private void BHsuvsDvmylfxYItMdJo(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD);
    private void jxSnQeHRYbgSYvaEKBhf(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, KmSRLTezgXWZQtUCPP dbuNWhZTsapNvMQoE);
    private void LoadDefaultMessages();
    private string qYWsfeIjhPmUOhImNPubC(string nQZpQwjmcBoJpfMWfdn, string aZycMyihQopsy);
    private static yauPlNsmRLCQVA ZKXvyhGByQjwSbnuAmdUq;
    private class yauPlNsmRLCQVA
    {
        [JsonProperty(PropertyName = "Разрешать видеть урон только тем, у кого есть привилегия")]
        public bool KtBLDlYWPkMkDaG;
        [JsonProperty(PropertyName = "Отображать урон по учёным")]
        public bool mijMxoNNKsg;
        [JsonProperty(PropertyName = "Использовать встроенные в игру кланы для подсветки их как друзей")]
        public bool IttjgRZsHrAORkAUSX;
        [JsonProperty(PropertyName = "Отображать урон со знаком минус")]
        public bool yRbuQBYevRTRKjAJk;
        [JsonProperty(PropertyName = "Время отображения текста с величиной урона (в разах, где раз = 0.1 секунда)")]
        public int gttNQcNEBcWRDWR;
        [JsonProperty(PropertyName = "Время отображения текста о убийстве или падении (в разах, где раз = 0.1 секунда)")]
        public int AtmXIpQrwuCtiwDWDbUS;
        [JsonProperty(PropertyName = "Размер текста")]
        public int kDzlpKVVhCZOtLyiXSqilnLHgmPe;
        [JsonProperty(PropertyName = "Шрифт текста")]
        public string qFCJXIkCunttAsNTwzDJEoZvkuQ;
        [JsonProperty(PropertyName = "Цвет текста при попадании в тело")]
        public string qSZQyzeLcPQuQiewCIKjnQArZr;
        [JsonProperty(PropertyName = "Цвет текста при попадании в голову")]
        public string xEESiugkPZKsBMVdyFEGrEWuhJsqD;
        [JsonProperty(PropertyName = "Цвет текста при убийстве противника")]
        public string RcZHoMsURuSKwBPrV;
        [JsonProperty(PropertyName = "Цвет текста при падении противника")]
        public string SDbXfPLMIkyvZNMrTcoSufgpCjkQTf;
        [JsonProperty(PropertyName = "Цвет текста при попадании в друга")]
        public string cAbIFjAlJrrJHal;
        [JsonProperty(PropertyName = "Плавное пропадание текста")]
        public float? sMJZnclGAudTXZUpkliIU;
        [JsonProperty(PropertyName = "Отображение урона включено по умолчанию")]
        public bool? xqUCnXSUJxGICyh;
    }

    private void KczZmGUZKFxFOdESykMiI();
    protected override void LoadDefaultConfig();
    private void jwICZLLCOLOBtAZK(yauPlNsmRLCQVA tiTilaTtjtxAieYXrpsSA);
    private void XSOTfIcDwGMmwuPKrnKASItRXc();
    private static void wmnMznvSdBMsjifLOubXOSvXYub();
}

private class HitTempData
{
    public HitInfo WTErBWOgNxznmhdeuupUlRgzX;
    public float timeSS;
}

private class KmSRLTezgXWZQtUCPP
{
    public int ZemtfYLMNQppzPcMQ;
    public int pJiukTaQyZuARIIhxWeh;
    public int TjmUvSIAVMUfL;
    public bool uxRKkIhORRANsHqVAzy;
    public bool vMBmipZWyOWJlPfNSwOmGZAwEBjfoe;
    public bool GTAMETsGPzQqHq;
    public bool DbyQbqasvMURhff;
    public ulong EkkDQHJpAFpiEVRGplp;
    public string pWILvPlyaQPDxgEKcPTatabVqkzsOY;
    public double mypvetKcWiGeeaVzcGbmzMRoPSQaz;
    public double nxZkLTVXQQVCxGSBqZb;
    public double BnaDETkqaq;
    public double fCweONHNklRzOARIiwKDzQgC;
    public BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK;
}

private class yauPlNsmRLCQVA
{
    [JsonProperty(PropertyName = "Разрешать видеть урон только тем, у кого есть привилегия")]
    public bool KtBLDlYWPkMkDaG;
    [JsonProperty(PropertyName = "Отображать урон по учёным")]
    public bool mijMxoNNKsg;
    [JsonProperty(PropertyName = "Использовать встроенные в игру кланы для подсветки их как друзей")]
    public bool IttjgRZsHrAORkAUSX;
    [JsonProperty(PropertyName = "Отображать урон со знаком минус")]
    public bool yRbuQBYevRTRKjAJk;
    [JsonProperty(PropertyName = "Время отображения текста с величиной урона (в разах, где раз = 0.1 секунда)")]
    public int gttNQcNEBcWRDWR;
    [JsonProperty(PropertyName = "Время отображения текста о убийстве или падении (в разах, где раз = 0.1 секунда)")]
    public int AtmXIpQrwuCtiwDWDbUS;
    [JsonProperty(PropertyName = "Размер текста")]
    public int kDzlpKVVhCZOtLyiXSqilnLHgmPe;
    [JsonProperty(PropertyName = "Шрифт текста")]
    public string qFCJXIkCunttAsNTwzDJEoZvkuQ;
    [JsonProperty(PropertyName = "Цвет текста при попадании в тело")]
    public string qSZQyzeLcPQuQiewCIKjnQArZr;
    [JsonProperty(PropertyName = "Цвет текста при попадании в голову")]
    public string xEESiugkPZKsBMVdyFEGrEWuhJsqD;
    [JsonProperty(PropertyName = "Цвет текста при убийстве противника")]
    public string RcZHoMsURuSKwBPrV;
    [JsonProperty(PropertyName = "Цвет текста при падении противника")]
    public string SDbXfPLMIkyvZNMrTcoSufgpCjkQTf;
    [JsonProperty(PropertyName = "Цвет текста при попадании в друга")]
    public string cAbIFjAlJrrJHal;
    [JsonProperty(PropertyName = "Плавное пропадание текста")]
    public float? sMJZnclGAudTXZUpkliIU;
    [JsonProperty(PropertyName = "Отображение урона включено по умолчанию")]
    public bool? xqUCnXSUJxGICyh;
}


```

---

## HitmarkerGUI

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;

Oxide.Plugins
[Info("Hitmarker GUI", "PaiN", "1.3.2", ResourceId = 1241)]
[Description("This plugin informs the attacker/player if he hit someone..")]
 class HitmarkerGUI : RustPlugin
{
    private bool Changed;
    private bool enablesound;
    private string soundeffect;
    private string headshotsoundeffect;
    private string HeadshotImageURL;
    private bool useimage;
    private string ImageURL;
    private bool usetext;
    private string TextWord;
     List<BasePlayer> hitmarkeron;
     void Loaded();
     object GetConfig(string menu, string datavalue, object defaultValue);
     void LoadVariables();
    protected override void LoadDefaultConfig();
     string image;
     string text;
    [ChatCommand("hitmarker")]
     void cmdHitMarker(BasePlayer player, string cmd, string[] args);
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo);
}


```

---

## HitMarkersRu

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = UnityEngine.Random;

Oxide.Plugins
[Info("Hit Markers", "Oleshka", "1.2.0")]
public class HitMarkersRu : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private Plugin Notify;
    private const string Layer;
    private const string HitLayer;
    private const string HealthLineLayer;
    private static HitMarkersRu _instance;
    private static Configuration _config;
    private class Configuration
    {
        [JsonProperty(PropertyName = "Команды", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public string[] Commands;
        [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.use)")]
        public string Permission;
        [JsonProperty(PropertyName = "Включить работу с Notify?")]
        public bool UseNotify;
        [JsonProperty(PropertyName = "Шрифты", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<int, FontConf> Fonts;
        [JsonProperty(PropertyName = "Минимальный размер шрифта")]
        public int MinFontSize;
        [JsonProperty(PropertyName = "Максимальный размер шрифта")]
        public int MaxFontSize;
        [JsonProperty(PropertyName = "Кнопки", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<BtnConf> Buttons;
        [JsonProperty(PropertyName = "Иконка информации")]
        public string InfoIcon;
        [JsonProperty(PropertyName = "Показывать урон по НПЦ")]
        public bool ShowNpcDamage;
        [JsonProperty(PropertyName = "Показывать урон по животным")]
        public bool ShowAnimalDamage;
        [JsonProperty(PropertyName = "Время удаления маркера")]
        public float DestroyTime;
        [JsonProperty(PropertyName = "Значения по умолчанию")]
        public DefaultValues DefaultValues;
        [JsonProperty(PropertyName = "Настройка линии")]
        public LineSettings Line;
    }

    private class LineSettings
    {
        [JsonProperty(PropertyName = "Показывать линию?")]
        public bool Show;
        [JsonProperty(PropertyName = "Показывать текст?")]
        public bool Text;
    }

    private class DefaultValues
    {
        [JsonProperty(PropertyName = "ID шрифта")]
        public int FontId;
        [JsonProperty(PropertyName = "Размер шрифта")]
        public int FontSize;
        [JsonProperty(PropertyName = "Текст")]
        public bool Text;
        [JsonProperty(PropertyName = "Иконка")]
        public bool Icon;
        [JsonProperty(PropertyName = "Полоса ХП ")]
        public bool HealthLine;
        [JsonProperty(PropertyName = "Урон по строениям")]
        public bool Buildings;
    }

    private class BtnConf
    {
        [JsonProperty(PropertyName = "Включено")]
        public bool Enabled;
        [JsonProperty(PropertyName = "Название")]
        public string Title;
        [JsonProperty(PropertyName = "Тип")]
        [JsonConverter(typeof(StringEnumConverter))]
        public BtnType Type;
        [JsonProperty(PropertyName = "Описание")]
        public string Description;
        [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.text)")]
        public string Permission;
    }

    private class FontConf
    {
        [JsonProperty(PropertyName = "Шрифт")]
        public string Font;
        [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.font)")]
        public string Permission;
    }

    protected override void LoadConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private static PluginData _data;
    private void SaveData();
    private void LoadData();
    private class PluginData
    {
        [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<ulong, PlayerData> Players;
    }

    private class PlayerData
    {
        [JsonProperty(PropertyName = "Font ID")]
        public int FontId;
        [JsonProperty(PropertyName = "Font Size")]
        public int FontSize;
        [JsonProperty(PropertyName = "Text")]
        public bool Text;
        [JsonProperty(PropertyName = "Icon")]
        public bool Icon;
        [JsonProperty(PropertyName = "Health Line")]
        public bool HealthLine;
        [JsonProperty(PropertyName = "Buildings")]
        public bool Buildings;
        public static PlayerData GetOrAdd(BasePlayer player);
        public static PlayerData GetOrAdd(ulong userId);
        public bool GetValue(BtnType type);
        public void SetValue(BtnType type, bool newValue);
    }

    private void OnServerInitialized();
    private void Unload();
    private void OnEntityTakeDamage(BuildingBlock block, HitInfo info);
    private void OnPlayerAttack(BasePlayer attacker, HitInfo info);
    private void CmdOpenMarkers(IPlayer cov, string command, string[] args);
    [ConsoleCommand("UI_Markers")]
    private void CmdConsoleMarkers(ConsoleSystem.Arg arg);
    private void MainUi(BasePlayer player, bool first);
    private void SwitchUi(CuiElementContainer container, string parent, bool value, string command);
    private void InfoUi(BasePlayer player, string text);
    private void RegisterPermissions();
    private static string HexToCuiColor(string hex, float alpha);
    private static bool IsTeammates(ulong player, ulong friend);
    private static Vector2 GetRandomTextPosition();
    private static string GetGradientColor(int count, int max);
    private static readonly string[] ColorsGradientDB;
    private readonly Dictionary<BasePlayer, MarkerComponent> _markerByPlayer;
    private MarkerComponent GetMarker(BasePlayer player);
    private MarkerComponent GetOrAddMarker(BasePlayer player);
    private class MarkerComponent : FacepunchBehaviour
    {
        private BasePlayer _player;
        private PlayerData _playerData;
        private void Awake();
        public void ShowHit(BaseCombatEntity target, HitInfo info);
        private void ShowLine(BtnType type, BaseCombatEntity target, HitInfo info);
        public void DestroyHit();
        public void DestroyHealthLine();
        public IEnumerator DestroyHit(string id, float delay);
        private void OnDestroy();
        public void Kill();
    }

    private const string InfoTitle;
    private const string FontSizeFormat;
    private const string FontIncreaseTitle;
    private const string FontTitle;
    private const string TextTitle;
    private const string PreviewTitle;
    private const string LooksNow;
    private const string FormatFriendTitle;
    private const string FormatFellHeadshotTitle;
    private const string FormatFellTitle;
    private const string FormatHeadshotTitle;
    private const string NoPermission;
    private const string CloseButton;
    private const string TitleMenu;
    protected override void LoadDefaultMessages();
    private string Msg(string key, string userid, object[] obj);
    private string Msg(BasePlayer player, string key, object[] obj);
    private void Reply(BasePlayer player, string key, object[] obj);
    private void SendNotify(BasePlayer player, string key, int type, object[] obj);
}

private class Configuration
{
    [JsonProperty(PropertyName = "Команды", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public string[] Commands;
    [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.use)")]
    public string Permission;
    [JsonProperty(PropertyName = "Включить работу с Notify?")]
    public bool UseNotify;
    [JsonProperty(PropertyName = "Шрифты", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<int, FontConf> Fonts;
    [JsonProperty(PropertyName = "Минимальный размер шрифта")]
    public int MinFontSize;
    [JsonProperty(PropertyName = "Максимальный размер шрифта")]
    public int MaxFontSize;
    [JsonProperty(PropertyName = "Кнопки", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public List<BtnConf> Buttons;
    [JsonProperty(PropertyName = "Иконка информации")]
    public string InfoIcon;
    [JsonProperty(PropertyName = "Показывать урон по НПЦ")]
    public bool ShowNpcDamage;
    [JsonProperty(PropertyName = "Показывать урон по животным")]
    public bool ShowAnimalDamage;
    [JsonProperty(PropertyName = "Время удаления маркера")]
    public float DestroyTime;
    [JsonProperty(PropertyName = "Значения по умолчанию")]
    public DefaultValues DefaultValues;
    [JsonProperty(PropertyName = "Настройка линии")]
    public LineSettings Line;
}

private class LineSettings
{
    [JsonProperty(PropertyName = "Показывать линию?")]
    public bool Show;
    [JsonProperty(PropertyName = "Показывать текст?")]
    public bool Text;
}

private class DefaultValues
{
    [JsonProperty(PropertyName = "ID шрифта")]
    public int FontId;
    [JsonProperty(PropertyName = "Размер шрифта")]
    public int FontSize;
    [JsonProperty(PropertyName = "Текст")]
    public bool Text;
    [JsonProperty(PropertyName = "Иконка")]
    public bool Icon;
    [JsonProperty(PropertyName = "Полоса ХП ")]
    public bool HealthLine;
    [JsonProperty(PropertyName = "Урон по строениям")]
    public bool Buildings;
}

private class BtnConf
{
    [JsonProperty(PropertyName = "Включено")]
    public bool Enabled;
    [JsonProperty(PropertyName = "Название")]
    public string Title;
    [JsonProperty(PropertyName = "Тип")]
    [JsonConverter(typeof(StringEnumConverter))]
    public BtnType Type;
    [JsonProperty(PropertyName = "Описание")]
    public string Description;
    [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.text)")]
    public string Permission;
}

private class FontConf
{
    [JsonProperty(PropertyName = "Шрифт")]
    public string Font;
    [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.font)")]
    public string Permission;
}

private class PluginData
{
    [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
    public Dictionary<ulong, PlayerData> Players;
}

private class PlayerData
{
    [JsonProperty(PropertyName = "Font ID")]
    public int FontId;
    [JsonProperty(PropertyName = "Font Size")]
    public int FontSize;
    [JsonProperty(PropertyName = "Text")]
    public bool Text;
    [JsonProperty(PropertyName = "Icon")]
    public bool Icon;
    [JsonProperty(PropertyName = "Health Line")]
    public bool HealthLine;
    [JsonProperty(PropertyName = "Buildings")]
    public bool Buildings;
    public static PlayerData GetOrAdd(BasePlayer player);
    public static PlayerData GetOrAdd(ulong userId);
    public bool GetValue(BtnType type);
    public void SetValue(BtnType type, bool newValue);
}

private class MarkerComponent : FacepunchBehaviour
{
    private BasePlayer _player;
    private PlayerData _playerData;
    private void Awake();
    public void ShowHit(BaseCombatEntity target, HitInfo info);
    private void ShowLine(BtnType type, BaseCombatEntity target, HitInfo info);
    public void DestroyHit();
    public void DestroyHealthLine();
    public IEnumerator DestroyHit(string id, float delay);
    private void OnDestroy();
    public void Kill();
}


```

---

## HomeProtection

```csharp

Oxide.Plugins
[Info("HomeProtection", "Wulf/lukespragg", 0.1, ResourceId = 1391)]
[Description("Protects you and your home from intruders.")]
 class HomeProtection : RustPlugin
{
     object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
}


```

---

## HomeRecycler

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("HomeRecycler", "wazzzup", "1.3.2")]
[Description("Allows to have Recycler at home")]
 class HomeRecycler : RustPlugin
{
    [PluginReference]
     Plugin Friends;
     Dictionary<uint, ulong> startedRecyclers;
    public Dictionary<int, KeyValuePair<string, int>> itemsNeededToCraft;
    public static HomeRecycler Instance;
    private ItemBlueprint bp;
    private class RecyclerEntity : MonoBehaviour
    {
        private DestroyOnGroundMissing desGround;
        private GroundWatch groundWatch;
        public ulong OwnerID;
         void Awake();
    }

     PluginData pluginData;
     class PluginData
    {
        public Dictionary<ulong, double> userCooldowns;
        public Dictionary<ulong, int> userSpawned;
        public Dictionary<ulong, double> userCooldownsCraft;
        public Dictionary<ulong, int> userCrafted;
    }

     void SaveData();
     ConfigData configData;
     class ConfigData
    {
        public string chatCommand;
        public string craftCommand;
        public bool restrictUseByCupboard;
        public bool adminSpawnsPublicRecycler;
        public bool useSpawning;
        public bool useCrafting;
        public bool useSpawnCooldown;
        public bool useCraftCooldown;
        public bool useSpawnLimit;
        public bool useCraftLimit;
        public bool allowDeployOnGround;
        public bool allowPickupByHammerHit;
        public bool pickupOnlyOwnerFriends;
        public bool spawnInLoot;
        public Rates DefaultRates;
        public Dictionary<string, int> itemsNeededToCraft;
        public Dictionary<string, Rates> PermissionsRates;
        public List<Loot> Loot;
    }

    public class Loot
    {
        public string containerName;
        public int probability;
    }

     class Rates
    {
        public int Priority;
        public float spawnCooldown;
        public float craftCooldown;
        public int craftLimit;
        public int spawnLimit;
        public float Ratio;
        public float RatioScrap;
        public float Speed;
        public float percentOfMaxStackToTake;
    }

    protected override void LoadDefaultConfig();
    protected override void LoadDefaultMessages();
     void Init();
     void SaveConfig(ConfigData config);
     void OnNewSave();
     void OnServerInitialized();
     void OnLootSpawn(LootContainer container);
     void Unload();
     object CanStackItem(Item item, Item anotherItem);
     float GetCraftLimit(BasePlayer player);
     float GetSpawnLimit(BasePlayer player);
     float GetCraftCooldown(BasePlayer player);
     float GetSpawnCooldown(BasePlayer player);
     void cmdRec(BasePlayer player, string command, string[] args);
     void cmdCraft(BasePlayer player, string command, string[] args);
    private string msg(string key, BasePlayer player);
    private void SendMsg(BasePlayer player, string langkey, bool title, string[] args);
    [ConsoleCommand("giverecycler")]
     void cmdGiveRecycler(ConsoleSystem.Arg arg);
     bool GiveRecycler(ItemContainer container);
     bool GiveRecycler(BasePlayer player);
     bool Check(BaseEntity entity);
     void OnEntityBuilt(Planner plan, GameObject obj);
    private void OnHammerHit(BasePlayer player, HitInfo info);
     void OnRecyclerToggle(Recycler recycler, BasePlayer player);
     object OnRecycleItem(Recycler recycler, Item item);
}

private class RecyclerEntity : MonoBehaviour
{
    private DestroyOnGroundMissing desGround;
    private GroundWatch groundWatch;
    public ulong OwnerID;
     void Awake();
}

 class PluginData
{
    public Dictionary<ulong, double> userCooldowns;
    public Dictionary<ulong, int> userSpawned;
    public Dictionary<ulong, double> userCooldownsCraft;
    public Dictionary<ulong, int> userCrafted;
}

 class ConfigData
{
    public string chatCommand;
    public string craftCommand;
    public bool restrictUseByCupboard;
    public bool adminSpawnsPublicRecycler;
    public bool useSpawning;
    public bool useCrafting;
    public bool useSpawnCooldown;
    public bool useCraftCooldown;
    public bool useSpawnLimit;
    public bool useCraftLimit;
    public bool allowDeployOnGround;
    public bool allowPickupByHammerHit;
    public bool pickupOnlyOwnerFriends;
    public bool spawnInLoot;
    public Rates DefaultRates;
    public Dictionary<string, int> itemsNeededToCraft;
    public Dictionary<string, Rates> PermissionsRates;
    public List<Loot> Loot;
}

public class Loot
{
    public string containerName;
    public int probability;
}

 class Rates
{
    public int Priority;
    public float spawnCooldown;
    public float craftCooldown;
    public int craftLimit;
    public int spawnLimit;
    public float Ratio;
    public float RatioScrap;
    public float Speed;
    public float percentOfMaxStackToTake;
}


```

---

## HomesGUI

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("HomesGUI", "PsychoTea", "1.2.9")]
 class HomesGUI : RustPlugin
{
    private static HomesGUI Instance;
    private const string permUse;
    private const string permBack;
    private GameObject CMObject;
    private bool DebuggingMode;
    private Dictionary<BasePlayer, bool> GUIOpen;
    private Dictionary<BasePlayer, Vector3> HomeBack;
    [PluginReference]
    private Plugin Economics;
    private Plugin ServerRewards;
    private Plugin NoEscape;
    private Plugin ZoneManager;
     class GamePos
    {
        public float x;
        public float y;
        public float z;
        public GamePos(float x, float y, float z);
        public Vector3 ToVector();
    }

     class HomePoint
    {
        public string Name { get; set; }
        public GamePos Position { get; set; }
        public bool IsSleeping { get; set; }
        public uint BedID { get; set; }
        public HomePoint(string name, GamePos position, bool isSleeping, uint bedID);
        public void UpdateName(string newName);
    }

     class HomeTeleporter : MonoBehaviour
    {
         BasePlayer Player { get; set; }
         int TimeUntilTeleport;
        public Vector3 Pos;
        public string HomeName;
        public bool PlayerIsPaying;
        public void Go();
         void Awake();
         void TimerTick();
        public void CancelTeleport();
         void Teleport();
    }

     class CooldownManager : MonoBehaviour
    {
         void Awake();
         void TimerTick();
    }

     class StoredData
    {
        public Dictionary<ulong, List<HomePoint>> Homes;
        public Dictionary<ulong, int> Cooldowns;
        public Dictionary<ulong, int> Uses;
    }

     StoredData storedData;
     void Init();
     void OnServerInitialized();
     void Unload();
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
     void OnEntitySpawned(BaseEntity entity);
     void OnEntityDeath(BaseCombatEntity entity, HitInfo info);
     void OnEntityKill(BaseNetworkable entity);
     void CanRenameBed(BasePlayer player, SleepingBag bed, string bedName);
     ConfigData ConfigFile;
     class ConfigData
    {
        public class _SleepingBags
        {
            [JsonProperty("Create Home On Bag Placement")]
            public bool CreateHomeOnBagPlacement;
            [JsonProperty("Create Home On Bed Placement")]
            public bool CreateHomeOnBedPlacement;
            [JsonProperty("Remove Home On Bag/Bed Removal")]
            public bool RemoveHomeOnRemoval;
        }

        public bool PrefixEnabled;
        public string PrefixText;
        public int DefaultTimeUntilTeleport;
        public Dictionary<string, int> TimeUntilTeleport;
        public List<string> HomeCommandAliases;
        public int DefaultCooldown;
        public Dictionary<string, int> Cooldowns;
        public int DefaultMaxHomes;
        public Dictionary<string, int> MaxHomes;
        public int DefaultMaxUses;
        public Dictionary<string, int> MaxUses;
        public bool AllowTeleportWhilstBleeding;
        public bool AllowTeleportFromBuildBlock;
        public bool AllowTeleportToBuildBlock;
        public bool UseEconomicsPlugin;
        public double EconomicsPrice;
        public bool UseServerRewardsPlugin;
        public double ServerRewardsPrice;
        public bool PayAfterUsingDailyLimits;
        public bool BlockTPCrafting;
        public bool AdminInstaTP;
        public bool AllowSetHomeInBuildBlocked;
        public bool MustSetHomeOnBuilding;
        public bool CanSetHomeOnFloor;
        public bool CheckForBuildingOnHomeTP;
        public bool ShouldCancelOnDamage;
        public _SleepingBags SleepingBags;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    [ChatCommand("home")]
     void HomeCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("sethome")]
     void SetHomeCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("delhome")]
     void DelHomeCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("listhomes")]
     void ListHomesCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("homec")]
     void HomeCancelCommand(BasePlayer player, string command, string[] args);
    [ChatCommand("homeback")]
     void HomeBackCommand(BasePlayer player, string command, string[] args);
    [ConsoleCommand("homegui")]
     void HomeGUICommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("homesgui.resetdatafile")]
     void ResetAllCommand(ConsoleSystem.Arg arg);
     string CancelAllTeleports(BasePlayer player);
     void ShowHomesUI(BasePlayer player);
     void ShowUI(BasePlayer player);
     void HideUI(BasePlayer player);
     Dictionary<string, Vector3> GetPlayerHomes(string steamID);
     int GetPlayerCooldown(string steamID);
     int GetPlayerUses(string steamID);
     void TPBack(BasePlayer player);
     string TPCancel(BasePlayer player);
     void RecordHomeBack(BasePlayer player);
     bool CanSetHome(BasePlayer player);
     bool FindBuildBlock(Vector3 pos, string BlockName);
     bool CheckMaxHomes(BasePlayer player);
     bool CheckHighestUses(BasePlayer player, string uses);
     int GetDailyMaxUses(BasePlayer player);
     object AllowedToTeleport(BasePlayer player, Vector3 homePos, bool playerIsPaying);
     void AssignCooldown(BasePlayer player);
     void RecordUse(BasePlayer player);
     bool IsBuildingBlocked(BasePlayer player, Vector3 pos);
     bool EconomicsInstalled();
     bool ServerRewardsInstalled();
     bool PayEconomics(BasePlayer player);
     bool PayServerRewards(BasePlayer player);
     void RefundPlayerEconomics(BasePlayer player);
     void RefundServerRewards(BasePlayer player);
     void Teleport(BasePlayer player, Vector3 pos);
     void StartSleeping(BasePlayer player);
     bool HasLastHome(BasePlayer player);
     bool CheckFoundation(Vector3 homePos);
     bool CheckFloor(Vector3 homePos);
     bool HasPerm(BasePlayer player);
     bool HasPerm(BasePlayer player, string perm);
     bool IsCrafting(BasePlayer player);
     string GetMessage(string key);
     bool HasComponent(BasePlayer player);
     void SaveData();
     bool ReadData();
}

 class GamePos
{
    public float x;
    public float y;
    public float z;
    public GamePos(float x, float y, float z);
    public Vector3 ToVector();
}

 class HomePoint
{
    public string Name { get; set; }
    public GamePos Position { get; set; }
    public bool IsSleeping { get; set; }
    public uint BedID { get; set; }
    public HomePoint(string name, GamePos position, bool isSleeping, uint bedID);
    public void UpdateName(string newName);
}

 class HomeTeleporter : MonoBehaviour
{
     BasePlayer Player { get; set; }
     int TimeUntilTeleport;
    public Vector3 Pos;
    public string HomeName;
    public bool PlayerIsPaying;
    public void Go();
     void Awake();
     void TimerTick();
    public void CancelTeleport();
     void Teleport();
}

 class CooldownManager : MonoBehaviour
{
     void Awake();
     void TimerTick();
}

 class StoredData
{
    public Dictionary<ulong, List<HomePoint>> Homes;
    public Dictionary<ulong, int> Cooldowns;
    public Dictionary<ulong, int> Uses;
}

 class ConfigData
{
    public class _SleepingBags
    {
        [JsonProperty("Create Home On Bag Placement")]
        public bool CreateHomeOnBagPlacement;
        [JsonProperty("Create Home On Bed Placement")]
        public bool CreateHomeOnBedPlacement;
        [JsonProperty("Remove Home On Bag/Bed Removal")]
        public bool RemoveHomeOnRemoval;
    }

    public bool PrefixEnabled;
    public string PrefixText;
    public int DefaultTimeUntilTeleport;
    public Dictionary<string, int> TimeUntilTeleport;
    public List<string> HomeCommandAliases;
    public int DefaultCooldown;
    public Dictionary<string, int> Cooldowns;
    public int DefaultMaxHomes;
    public Dictionary<string, int> MaxHomes;
    public int DefaultMaxUses;
    public Dictionary<string, int> MaxUses;
    public bool AllowTeleportWhilstBleeding;
    public bool AllowTeleportFromBuildBlock;
    public bool AllowTeleportToBuildBlock;
    public bool UseEconomicsPlugin;
    public double EconomicsPrice;
    public bool UseServerRewardsPlugin;
    public double ServerRewardsPrice;
    public bool PayAfterUsingDailyLimits;
    public bool BlockTPCrafting;
    public bool AdminInstaTP;
    public bool AllowSetHomeInBuildBlocked;
    public bool MustSetHomeOnBuilding;
    public bool CanSetHomeOnFloor;
    public bool CheckForBuildingOnHomeTP;
    public bool ShouldCancelOnDamage;
    public _SleepingBags SleepingBags;
}

public class _SleepingBags
{
    [JsonProperty("Create Home On Bag Placement")]
    public bool CreateHomeOnBagPlacement;
    [JsonProperty("Create Home On Bed Placement")]
    public bool CreateHomeOnBedPlacement;
    [JsonProperty("Remove Home On Bag/Bed Removal")]
    public bool RemoveHomeOnRemoval;
}


```

---

## Hookie

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Oxide.Core.Plugins;
using Rust;
using System.Reflection;

Oxide.Plugins
[Info("Hookie", "Norn", 0.1, ResourceId = 1518)]
[Description("Useful hooks.")]
public class Hookie : RustPlugin
{
     void OnServerInitialized();
    protected override void LoadDefaultConfig();
    private bool IsPlayerInArea(BasePlayer player, float MinX, float MinY, float MaxX, float MaxY);
    private void Explode(BasePlayer player, float damage, int times);
    private static LayerMask GROUND_MASKS;
    static Vector3 GetGroundPosition(Vector3 sourcePos);
    private object FindPlayerByID(ulong steamid);
    private object FindPlayer(string tofind);
    private int MoveEveryPlayerToPlayer(BasePlayer user);
    [ChatCommand("explode")]
    private void cmdExplode(BasePlayer player, string command, string[] args);
    [ChatCommand("slap")]
    private void cmdSlap(BasePlayer player, string command, string[] args);
    [ChatCommand("tpall")]
    private void cmdTPAll(BasePlayer player, string command, string[] args);
    [ChatCommand("healall")]
    private void cmdHealAll(BasePlayer player, string command, string[] args);
    [ChatCommand("heal")]
    private void cmdHeal(BasePlayer player, string command, string[] args);
    private void HealAll();
    private bool IsPlayerInWater(BasePlayer player);
    private void RemovePlayerHealth(BasePlayer player, float hp);
    private void GivePlayerHealth(BasePlayer player, float hp);
    private void SetPlayerHealth(BasePlayer player, float hp);
    private bool Slap(BasePlayer player, float amount);
}


```

---

## HorseSpawns

```csharp
using Facepunch;
using Newtonsoft.Json;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("Horse Spawns", "OxideBro", "0.1.0")]
public class HorseSpawns : RustPlugin
{
    private PluginConfig config;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class PluginConfig
    {
        [JsonProperty("Популяция лошадей на один квадратный километр")]
        public int HorsePopulation;
        [JsonProperty("[MAP]: Включить отображение лошадей на стандартной карте")]
        public bool EnabledMapMarker;
        [JsonProperty("[MAP]: Радиус отметки на карте")]
        public float MarketRadius;
        [JsonProperty("[MAP]: Текст на отметке на карты лошадей")]
        public string MarkerDescription;
        public static PluginConfig DefaultConfig();
    }

    static HorseSpawns ins;
    private void OnServerInitialized();
     void Unload();
     void OnEntityKill(BaseNetworkable entity);
     void StartSpawnHorse();
     class HorseMarker : BaseEntity
    {
         RidableHorse horse;
         MapMarkerGenericRadius mapmarker;
         VendingMachineMapMarker MarkerName;
         SphereCollider sphereCollider;
         void Awake();
        public void SpawnMapMarkers();
        private void OnTriggerEnter(Collider col);
         void OnDestroy();
        public void Destroy();
    }

     SpawnFilter filter;
     List<Vector3> monuments;
    static float GetGroundPosition(Vector3 pos);
    public Vector3 RandomDropPosition();
     List<int> BlockedLayers;
    static int blockedMask;
    public Vector3 GetSafeDropPosition(Vector3 position);
    public Vector3 GetEventPosition();
}

private class PluginConfig
{
    [JsonProperty("Популяция лошадей на один квадратный километр")]
    public int HorsePopulation;
    [JsonProperty("[MAP]: Включить отображение лошадей на стандартной карте")]
    public bool EnabledMapMarker;
    [JsonProperty("[MAP]: Радиус отметки на карте")]
    public float MarketRadius;
    [JsonProperty("[MAP]: Текст на отметке на карты лошадей")]
    public string MarkerDescription;
    public static PluginConfig DefaultConfig();
}

 class HorseMarker : BaseEntity
{
     RidableHorse horse;
     MapMarkerGenericRadius mapmarker;
     VendingMachineMapMarker MarkerName;
     SphereCollider sphereCollider;
     void Awake();
    public void SpawnMapMarkers();
    private void OnTriggerEnter(Collider col);
     void OnDestroy();
    public void Destroy();
}


```

---

## Hotel

```csharp
using System;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using NLua;

Oxide.Plugins
[Info("Hotel", "Reneb", "1.1.4", ResourceId = 1298)]
 class Hotel : RustPlugin
{
    [PluginReference]
     Plugin ZoneManager;
    [PluginReference("Economics")]
     Plugin Economics;
     void OnServerInitialized();
    static int deployableColl;
    static int constructionColl;
     Oxide.Plugins.Timer hotelTimer;
     Hash<BasePlayer, Oxide.Plugins.Timer> playerguiTimers;
    public static Dictionary<string, HotelData> EditHotel;
    static DateTime epoch;
    public static Vector3 Vector3UP;
    public static Vector3 Vector3UP2;
    public FieldInfo fieldWhiteList;
    public FieldInfo serverinput;
    public static Quaternion defaultQuaternion;
    static int authlevel;
    static string MessageAlreadyEditing;
    static string MessageHotelNewHelp;
    static string MessageHotelEditHelp;
    static string MessageHotelEditEditing;
    static string MessageErrorAlreadyExist;
    static string MessageErrorNotAllowed;
    static string MessageErrorEditDoesntExist;
    static string MessageMaintenance;
    static string MessageErrorUnavaibleRoom;
    static string MessageHotelNewCreated;
    static string MessageErrorNotAllowedToEnter;
    static string MessageErrorAlreadyGotRoom;
    static string MessageErrorPermissionsNeeded;
    static string MessageRentUnlimited;
    static string MessageRentTimeLeft;
    static string MessagePaydRent;
    static string MessageErrorNotEnoughCoins;
    static string GUIBoardAdmin;
    static string GUIBoardPlayer;
    static string GUIBoardPlayerRoom;
    static string GUIBoardPlayerMaintenance;
    static string xmin;
    static string xmax;
    static string ymin;
    static string ymax;
    static string pxmin;
    static string pxmax;
    static string pymin;
    static string pymax;
    static int pTimeOut;
    static bool EnterZoneShowRoom;
    static bool EnterZoneShowPlayerGUI;
    static bool UseNPCShowRoom;
    static bool UseNPCShowPlayerGUI;
    static bool OpenDoorShowRoom;
    static bool OpenDoorPlayerGUI;
    public static string adminguijson;
    public static string playerguijson;
    protected override void LoadDefaultConfig();
    private void CheckCfg(string Key, T var);
     void Init();
    static StoredData storedData;
     class StoredData
    {
        public HashSet<HotelData> Hotels;
        public StoredData();
    }

     void OnServerSave();
     void SaveData();
     void LoadData();
    public class DeployableItem
    {
        public string x;
        public string y;
        public string z;
        public string rx;
        public string ry;
        public string rz;
        public string rw;
        public string prefabname;
         Vector3 pos;
         Quaternion rot;
        public DeployableItem();
        public DeployableItem(Deployable deployable);
        public Vector3 Pos();
        public Quaternion Rot();
    }

    public class Room
    {
        public string roomid;
        public string x;
        public string y;
        public string z;
        public List<DeployableItem> defaultDeployables;
        public string renter;
        public string checkingTime;
        public string checkoutTime;
         double intcheckoutTime;
         Vector3 pos;
        public Room();
        public Room(Vector3 position);
        public Vector3 Pos();
        public double CheckOutTime();
        public void Reset();
    }

    public class HotelData
    {
        public string hotelname;
        public string x;
        public string y;
        public string z;
        public string r;
        public string rr;
        public string rd;
        public string npc;
        public string p;
        public string e;
        public Dictionary<string, Room> rooms;
         Vector3 pos;
        public bool enabled;
        public int price;
        public HotelData();
        public HotelData(string hotelname);
        public Vector3 Pos();
        public void RefreshRooms();
        public int Price();
        public void Deactivate();
        public void Activate();
        public void AddRoom(Room newroom);
    }

    static double LogTime();
    static void CloseDoor(Door door);
    static void OpenDoor(Door door);
    static void LockLock(CodeLock codelock);
    static void UnlockLock(CodeLock codelock);
     void LoadPermissions();
     void Unload();
     void Loaded();
     object CanUseDoor(BasePlayer player, BaseLock baselock);
     void CheckTimeOutRooms();
    static List<Door> FindDoorsFromPosition(Vector3 position, float radius);
    static Dictionary<string, Room> FindAllRooms(Vector3 position, float radius, float roomradius);
    static Room FindRoomByDoorAndHotel(HotelData hotel, BaseEntity door);
     void EconomicsWithdraw(BasePlayer player, int amount);
     bool CanRentRoom(BasePlayer player, HotelData hotel);
     bool FindHotelAndRoomByPos(Vector3 position, HotelData hoteldata, Room roomdata);
     CodeLock FindCodeLockByRoomID(string roomid);
     CodeLock FindCodeLockByPos(Vector3 pos);
     void SpawnDeployable(string prefabname, Vector3 pos, Quaternion rot, BasePlayer player);
     void NewRoomOwner(CodeLock codelock, BasePlayer player, HotelData hotel, Room room);
     void EmptyDeployablesRoom(BaseEntity door, float radius);
     void ResetRoom(HotelData hotel, Room room);
     void ResetRoom(CodeLock codelock, HotelData hotel, Room room);
     void OnUseNPC(BasePlayer npc, BasePlayer player);
     void OnEnterZone(string zoneid, BasePlayer player);
     void RefreshAdminHotelGUI(BasePlayer player);
     void RefreshPlayerHotelGUI(BasePlayer player, HotelData hotel);
     string ConvertSecondsToBetter(string seconds);
     string ConvertSecondsToBetter(double seconds);
     string ConvertSecondsToDate(string seconds);
     string ConvertSecondsToDate(double seconds);
     string CreatePlayerGUIMsg(BasePlayer player, HotelData hotel, string GUIMsg);
     string CreateAdminGUIMsg(BasePlayer player);
     void RemoveAdminHotelGUI(BasePlayer player);
     void RemovePlayerHotelGUI(BasePlayer player);
     void ShowHotelGrid(BasePlayer player);
     void ShowPlayerRoom(BasePlayer player, HotelData hotel);
     bool hasAccess(BasePlayer player);
    [ChatCommand("hotel_save")]
     void cmdChatHotelSave(BasePlayer player, string command, string[] args);
    [ChatCommand("hotel_close")]
     void cmdChatHotelClose(BasePlayer player, string command, string[] args);
    [ChatCommand("hotel")]
     void cmdChatHotel(BasePlayer player, string command, string[] args);
    [ChatCommand("hotel_list")]
     void cmdChatHotelList(BasePlayer player, string command, string[] args);
    [ChatCommand("hotel_edit")]
     void cmdChatHotelEdit(BasePlayer player, string command, string[] args);
    [ChatCommand("hotel_remove")]
     void cmdChatHotelRemove(BasePlayer player, string command, string[] args);
    [ChatCommand("hotel_reset")]
     void cmdChatHotelReset(BasePlayer player, string command, string[] args);
     BuildingBlock FindBlockFromRay(Vector3 Pos, Vector3 Aim);
     Vector3 RayForDoor(BasePlayer player);
     bool FindRoomByID(string roomid, HotelData targethotel, Room targetroom);
    [ChatCommand("room")]
     void cmdChatRoom(BasePlayer player, string command, string[] args);
    [ChatCommand("hotel_new")]
     void cmdChatHotelNew(BasePlayer player, string command, string[] args);
}

 class StoredData
{
    public HashSet<HotelData> Hotels;
    public StoredData();
}

public class DeployableItem
{
    public string x;
    public string y;
    public string z;
    public string rx;
    public string ry;
    public string rz;
    public string rw;
    public string prefabname;
     Vector3 pos;
     Quaternion rot;
    public DeployableItem();
    public DeployableItem(Deployable deployable);
    public Vector3 Pos();
    public Quaternion Rot();
}

public class Room
{
    public string roomid;
    public string x;
    public string y;
    public string z;
    public List<DeployableItem> defaultDeployables;
    public string renter;
    public string checkingTime;
    public string checkoutTime;
     double intcheckoutTime;
     Vector3 pos;
    public Room();
    public Room(Vector3 position);
    public Vector3 Pos();
    public double CheckOutTime();
    public void Reset();
}

public class HotelData
{
    public string hotelname;
    public string x;
    public string y;
    public string z;
    public string r;
    public string rr;
    public string rd;
    public string npc;
    public string p;
    public string e;
    public Dictionary<string, Room> rooms;
     Vector3 pos;
    public bool enabled;
    public int price;
    public HotelData();
    public HotelData(string hotelname);
    public Vector3 Pos();
    public void RefreshRooms();
    public int Price();
    public void Deactivate();
    public void Activate();
    public void AddRoom(Room newroom);
}


```

---

## HotKeys

```csharp
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("HotKeys", "Calytic", "0.0.31", ResourceId = 2135)]
 class HotKeys : RustPlugin
{
    private Dictionary<string, object> keys;
    private bool ResetDefaultKeysOnJoin;
     Dictionary<string, string> defaultRustBinds;
     void Loaded();
     void OnPlayerInit(BasePlayer player);
    [ConsoleCommand("hotkey.bind")]
    private void ccHotKeyBind(ConsoleSystem.Arg arg);
    [ConsoleCommand("hotkey.unbind")]
    private void ccHotKeyUnbind(ConsoleSystem.Arg arg);
     void BindAll();
     void UnbindAll(string keyCombo);
     void BindDefaultKeys(BasePlayer player);
     void BindKeys(BasePlayer player);
     void UnbindKey(BasePlayer player, string keyCombo);
     void SaveBinds();
     void LoadDefaultConfig();
     void CheckConfig();
    protected void ReloadConfig();
     Dictionary<string, object> GetDefaultKeys();
    private T GetConfig(string name, T defaultValue);
    private T GetConfig(string name, string name2, T defaultValue);
}


```

---

## HumanitySystem

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Reflection;

Oxide.Plugins
[Info("Humanity System", "DylanSMR", "1.1.5", ResourceId = 1999)]
[Description("A humanity system based off of DayZ mod.")]
public class HumanitySystem : RustPlugin
{
    [PluginReference]
     Plugin BetterChat;
     void LoadDefaultConfig();
    static HumanityData humanityData;
    public List<ulong> inUI;
     class HumanityData
    {
        public Dictionary<ulong, players> playerH;
        public HumanityData();
    }

     class players
    {
        public ulong playerID;
        public int Humanity;
        public int Rank;
        public int Kills;
        public int Deaths;
        public players();
        internal static players Find(BasePlayer player);
    }

    public string GetMin();
    public string GetMax();
    public object GetRank(BasePlayer player);
    public object GetStat(BasePlayer player, string Stat);
    public object RankAlgorithm(BasePlayer player);
    public void CreateGroup(string groupName);
     void Unload();
     void Loaded();
     void SaveData();
     Dictionary<string, string> messages;
     void OnPlayerInit(BasePlayer player);
    [ChatCommand("HStatus")]
     void HumanStat(BasePlayer player);
    [ChatCommand("HInfo")]
     void HumanInfo(BasePlayer player);
     void OnEntityDeath(BaseCombatEntity victimEntity, HitInfo info);
     void CheckDis();
     void DrawChatMessage(BasePlayer player, BasePlayer nearby);
    [ChatCommand("hmt")]
    private void RenderUI(BasePlayer player);
    private void FillElements(CuiElementContainer elements, string mainPanel, int humanity, string rank, int kills, int deaths);
}

 class HumanityData
{
    public Dictionary<ulong, players> playerH;
    public HumanityData();
}

 class players
{
    public ulong playerID;
    public int Humanity;
    public int Rank;
    public int Kills;
    public int Deaths;
    public players();
    internal static players Find(BasePlayer player);
}


```

---

## HumanNPC

```csharp
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Rust;
using Facepunch;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using Convert = System.Convert;

Oxide.Plugins
[Info("HumanNPC", "Reneb/Nogrod/Calytic FIX BY HUZAKI", "0.3.48", ResourceId = 856)]
[Description("Adds interactive Human NPCs which can be modded by other plugins")]
public class HumanNPC : RustPlugin
{
    private static Collider[] colBuffer;
    private int playerLayer;
    private static int targetLayer;
    private static Vector3 Vector3Down;
    private static int groundLayer;
    private Hash<ulong, HumanNPCInfo> humannpcs;
    static int playerMask;
    static int obstructionMask;
    private bool save;
    private StoredData storedData;
    private DynamicConfigFile data;
    private Vector3 eyesPosition;
    private string chat;
    [PluginReference]
    private Plugin Kits;
    private Plugin Waypoints;
    private Plugin Vanish;
    private static PathFinding PathFinding;
    private class StoredData
    {
        public HashSet<HumanNPCInfo> HumanNPCs;
    }

    public class WaypointInfo
    {
        public float Speed;
        public Vector3 Position;
        public WaypointInfo(Vector3 position, float speed);
    }

    public static bool IsLayerBlocked(Vector3 position, float radius, int mask);
    public class SpawnInfo
    {
        public Vector3 position;
        public Quaternion rotation;
        public SpawnInfo(Vector3 position, Quaternion rotation);
        public string String();
        public string ShortString();
    }

    public class HumanTrigger : MonoBehaviour
    {
        private HumanPlayer npc;
        private readonly HashSet<BasePlayer> triggerPlayers;
        public float collisionRadius;
        private void Awake();
        private void OnDestroy();
        private void UpdateTriggerArea();
        private void OnEnterCollision(BasePlayer player);
        private void OnLeaveCollision(BasePlayer player);
    }

    public class HumanLocomotion : MonoBehaviour
    {
        private HumanPlayer npc;
        public Vector3 StartPos;
        public Vector3 EndPos;
        public Vector3 LastPos;
        private Vector3 nextPos;
        private float waypointDone;
        public float secondsTaken;
        private float secondsToTake;
        public List<WaypointInfo> cachedWaypoints;
        private int currentWaypoint;
        public float followDistance;
        private float lastHit;
        public int noPath;
        public bool shouldMove;
        private float startedReload;
        private bool reloading;
        public bool returning;
        public bool sitting;
        public BaseCombatEntity attackEntity;
        public BaseEntity followEntity;
        public Vector3 targetPosition;
        public List<Vector3> pathFinding;
        private HeldEntity firstWeapon;
        public void Awake();
        public void UpdateWaypoints();
        private void FixedUpdate();
        public void TryToMove();
        private void Execute_Move();
        public void Evade();
        public bool IsSwimming();
        private bool CanSit();
        public void Stand();
        private float GetSpeed(float speed);
        private void GetNextPath();
        public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s);
        private bool HitChance(float chance);
        private void Move(Vector3 position, float speed);
        private void ProcessAttack(BaseCombatEntity entity);
        public void ProcessFollow(Vector3 target);
        public void PathFinding();
        public void PathFinding(Vector3 targetPos);
        public void GetBackToLastPos();
        public void Enable();
        public void Disable();
        public float GetMoveY(Vector3 position);
        public float GetGroundY(Vector3 position);
        public void CreateProjectileEffect(BaseCombatEntity target, BaseProjectile baseProjectile, float dmg, bool miss);
        public void AttemptAttack(BaseCombatEntity entity);
        public void DoAttack(BaseCombatEntity target, bool miss);
    }

    public class HumanPlayer : MonoBehaviour
    {
        public HumanNPCInfo info;
        public HumanLocomotion locomotion;
        public HumanTrigger trigger;
        public ProtectionProperties protection;
        public BasePlayer player;
        public float lastMessage;
        private void Awake();
        public void SetInfo(HumanNPCInfo info, bool update);
        public void UpdateHealth(HumanNPCInfo info);
        public void Evade();
        public void AllowMove();
        public void DisableMove();
        public void TemporaryDisableMove(float thetime);
        public void EndAttackingEntity(bool trigger);
        public void EndFollowingEntity(bool trigger);
        public void EndGo(bool trigger);
        public void StartAttackingEntity(BaseCombatEntity entity);
        public void StartFollowingEntity(BaseEntity entity);
        public void StartGo(Vector3 position);
        public HeldEntity GetCurrentWeapon();
        public Item GetFirstWeaponItem();
        public HeldEntity GetFirstWeapon();
        public HeldEntity GetFirstTool();
        public HeldEntity GetFirstMisc();
        public List<Item> GetAmmo(Item item);
        public bool HasAmmo(Item item);
        public void UnequipAll();
        public HeldEntity EquipFirstWeapon();
        public HeldEntity EquipFirstTool();
        public HeldEntity EquipFirstMisc();
        public void SetActive(uint id);
        private void OnDestroy();
        public void LookTowards(Vector3 pos);
        public void ForceSignalGesture();
        public void ForceSignalAttack();
        public void SetViewAngle(Quaternion viewAngles);
    }

    public class HumanNPCInfo
    {
        public ulong userid;
        public string displayName;
        public bool invulnerability;
        public float health;
        public bool respawn;
        public float respawnSeconds;
        public SpawnInfo spawnInfo;
        public string waypoint;
        public float collisionRadius;
        public string spawnkit;
        public float damageAmount;
        public float damageDistance;
        public float damageInterval;
        public float attackDistance;
        public float maxDistance;
        public bool hostile;
        public float speed;
        public bool stopandtalk;
        public float stopandtalkSeconds;
        public bool enable;
        public bool lootable;
        public float hitchance;
        public float reloadDuration;
        public bool needsAmmo;
        public bool defend;
        public bool evade;
        public float evdist;
        public bool allowsit;
        public List<string> message_hello;
        public List<string> message_bye;
        public List<string> message_use;
        public List<string> message_hurt;
        public List<string> message_kill;
        public Dictionary<DamageType, float> protections;
        public HumanNPCInfo(ulong userid, Vector3 position, Quaternion rotation);
        public HumanNPCInfo Clone(ulong userid);
    }

    private class NPCEditor : MonoBehaviour
    {
        public BasePlayer player;
        public HumanPlayer targetNPC;
        private void Awake();
    }

    public static Dictionary<string, AmmoTypes> ammoTypes;
    private static Dictionary<string, BaseProjectile> weaponProjectile;
    protected override void LoadDefaultConfig();
    private void CheckCfg(string Key, T var);
    private void Init();
    private static bool GetBoolValue(string value);
    private void Loaded();
    private void Unload();
    private void SaveData();
    private void LoadData();
    private void OnServerInitialized();
    private void OnServerSave();
    private void OnServerShutdown();
    private void OnPlayerInput(BasePlayer player, InputState input);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo);
    private void OnEntityDeath(BaseEntity entity, HitInfo hitinfo);
    private object CanLootPlayer(BasePlayer target, BasePlayer looter);
    private void OnLootPlayer(BasePlayer looter, BasePlayer target);
    private void OnLootEntity(BasePlayer looter, BaseEntity entity);
    private Dictionary<ulong, HumanPlayer> cache;
    public HumanPlayer FindHumanPlayerByID(ulong userid);
    public HumanPlayer FindHumanPlayer(string nameOrId);
    private BasePlayer FindPlayerByID(ulong userid);
    private void RefreshAllNPC();
    private void SpawnOrRefresh(ulong userid);
    private void SpawnNPC(ulong userid, bool isediting);
    private void UpdateInventory(HumanPlayer humanPlayer);
    private void KillNpc(BasePlayer player);
    public void RefreshNPC(BasePlayer player, bool isediting);
    public void UpdateNPC(BasePlayer player, bool isediting);
    public HumanPlayer CreateNPC(Vector3 position, Quaternion currentRot, string name, ulong clone);
    public void RemoveNPC(ulong npcid);
    private bool hasAccess(BasePlayer player);
    private bool TryGetPlayerView(BasePlayer player, Quaternion viewAngle);
    private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, object closestEnt, Vector3 closestHitpoint);
    private static bool CanSee(HumanPlayer npc, BaseEntity target);
    private static string GetRandomMessage(List<string> messagelist);
    private static int GetRandom(int min, int max);
    private List<string> ListFromArgs(string[] args, int from);
    [ChatCommand("npc_add")]
    private void cmdChatNPCAdd(BasePlayer player, string command, string[] args);
    [ChatCommand("npc_way")]
    private void cmdChatNPCWay(BasePlayer player, string command, string[] args);
    [ChatCommand("npc_edit")]
    private void cmdChatNPCEdit(BasePlayer player, string command, string[] args);
    [ChatCommand("npc_list")]
    private void cmdChatNPCList(BasePlayer player, string command, string[] args);
    [ChatCommand("npc")]
    private void cmdChatNPC(BasePlayer player, string command, string[] args);
    [ChatCommand("npc_end")]
    private void cmdChatNPCEnd(BasePlayer player, string command, string[] args);
    [ChatCommand("npc_pathtest")]
    private void cmdChatNPCPathTest(BasePlayer player, string command, string[] args);
    [ChatCommand("npc_remove")]
    private void cmdChatNPCRemove(BasePlayer player, string command, string[] args);
    [ChatCommand("npc_reset")]
    private void cmdChatNPCReset(BasePlayer player, string command, string[] args);
    private void SendMessage(HumanPlayer npc, BasePlayer target, string message);
    private void OnEnterNPC(BasePlayer npc, BasePlayer player);
    private void OnLeaveNPC(BasePlayer npc, BasePlayer player);
    private class UnityQuaternionConverter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private class UnityVector3Converter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanConvert(Type objectType);
    }

    private class SpawnInfoConverter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
        public override bool CanWrite { get; set; }
        public override bool CanConvert(Type objectType);
    }

}

private class StoredData
{
    public HashSet<HumanNPCInfo> HumanNPCs;
}

public class WaypointInfo
{
    public float Speed;
    public Vector3 Position;
    public WaypointInfo(Vector3 position, float speed);
}

public class SpawnInfo
{
    public Vector3 position;
    public Quaternion rotation;
    public SpawnInfo(Vector3 position, Quaternion rotation);
    public string String();
    public string ShortString();
}

public class HumanTrigger : MonoBehaviour
{
    private HumanPlayer npc;
    private readonly HashSet<BasePlayer> triggerPlayers;
    public float collisionRadius;
    private void Awake();
    private void OnDestroy();
    private void UpdateTriggerArea();
    private void OnEnterCollision(BasePlayer player);
    private void OnLeaveCollision(BasePlayer player);
}

public class HumanLocomotion : MonoBehaviour
{
    private HumanPlayer npc;
    public Vector3 StartPos;
    public Vector3 EndPos;
    public Vector3 LastPos;
    private Vector3 nextPos;
    private float waypointDone;
    public float secondsTaken;
    private float secondsToTake;
    public List<WaypointInfo> cachedWaypoints;
    private int currentWaypoint;
    public float followDistance;
    private float lastHit;
    public int noPath;
    public bool shouldMove;
    private float startedReload;
    private bool reloading;
    public bool returning;
    public bool sitting;
    public BaseCombatEntity attackEntity;
    public BaseEntity followEntity;
    public Vector3 targetPosition;
    public List<Vector3> pathFinding;
    private HeldEntity firstWeapon;
    public void Awake();
    public void UpdateWaypoints();
    private void FixedUpdate();
    public void TryToMove();
    private void Execute_Move();
    public void Evade();
    public bool IsSwimming();
    private bool CanSit();
    public void Stand();
    private float GetSpeed(float speed);
    private void GetNextPath();
    public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s);
    private bool HitChance(float chance);
    private void Move(Vector3 position, float speed);
    private void ProcessAttack(BaseCombatEntity entity);
    public void ProcessFollow(Vector3 target);
    public void PathFinding();
    public void PathFinding(Vector3 targetPos);
    public void GetBackToLastPos();
    public void Enable();
    public void Disable();
    public float GetMoveY(Vector3 position);
    public float GetGroundY(Vector3 position);
    public void CreateProjectileEffect(BaseCombatEntity target, BaseProjectile baseProjectile, float dmg, bool miss);
    public void AttemptAttack(BaseCombatEntity entity);
    public void DoAttack(BaseCombatEntity target, bool miss);
}

public class HumanPlayer : MonoBehaviour
{
    public HumanNPCInfo info;
    public HumanLocomotion locomotion;
    public HumanTrigger trigger;
    public ProtectionProperties protection;
    public BasePlayer player;
    public float lastMessage;
    private void Awake();
    public void SetInfo(HumanNPCInfo info, bool update);
    public void UpdateHealth(HumanNPCInfo info);
    public void Evade();
    public void AllowMove();
    public void DisableMove();
    public void TemporaryDisableMove(float thetime);
    public void EndAttackingEntity(bool trigger);
    public void EndFollowingEntity(bool trigger);
    public void EndGo(bool trigger);
    public void StartAttackingEntity(BaseCombatEntity entity);
    public void StartFollowingEntity(BaseEntity entity);
    public void StartGo(Vector3 position);
    public HeldEntity GetCurrentWeapon();
    public Item GetFirstWeaponItem();
    public HeldEntity GetFirstWeapon();
    public HeldEntity GetFirstTool();
    public HeldEntity GetFirstMisc();
    public List<Item> GetAmmo(Item item);
    public bool HasAmmo(Item item);
    public void UnequipAll();
    public HeldEntity EquipFirstWeapon();
    public HeldEntity EquipFirstTool();
    public HeldEntity EquipFirstMisc();
    public void SetActive(uint id);
    private void OnDestroy();
    public void LookTowards(Vector3 pos);
    public void ForceSignalGesture();
    public void ForceSignalAttack();
    public void SetViewAngle(Quaternion viewAngles);
}

public class HumanNPCInfo
{
    public ulong userid;
    public string displayName;
    public bool invulnerability;
    public float health;
    public bool respawn;
    public float respawnSeconds;
    public SpawnInfo spawnInfo;
    public string waypoint;
    public float collisionRadius;
    public string spawnkit;
    public float damageAmount;
    public float damageDistance;
    public float damageInterval;
    public float attackDistance;
    public float maxDistance;
    public bool hostile;
    public float speed;
    public bool stopandtalk;
    public float stopandtalkSeconds;
    public bool enable;
    public bool lootable;
    public float hitchance;
    public float reloadDuration;
    public bool needsAmmo;
    public bool defend;
    public bool evade;
    public float evdist;
    public bool allowsit;
    public List<string> message_hello;
    public List<string> message_bye;
    public List<string> message_use;
    public List<string> message_hurt;
    public List<string> message_kill;
    public Dictionary<DamageType, float> protections;
    public HumanNPCInfo(ulong userid, Vector3 position, Quaternion rotation);
    public HumanNPCInfo Clone(ulong userid);
}

private class NPCEditor : MonoBehaviour
{
    public BasePlayer player;
    public HumanPlayer targetNPC;
    private void Awake();
}

private class UnityQuaternionConverter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

private class UnityVector3Converter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanConvert(Type objectType);
}

private class SpawnInfoConverter : JsonConverter
{
    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public override bool CanWrite { get; set; }
    public override bool CanConvert(Type objectType);
}


```

---

## HydraBot

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Random = Oxide.Core.Random;

Oxide.Plugins
[Info("HydraBot", "Deversive", "0.0.1", ResourceId = 1510)]
[Description("Авто-оправка оповещений в чат для сервера - Hydra Rust")]
internal class HydraBot : CovalencePlugin
{
    private Configuration _config;
    private int _previousAdvert;
    private ulong ImageID;
    private void Loaded();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private class Configuration
    {
        [JsonProperty("Сообщение")]
        public List<string> Messages { get; set; }
        [JsonProperty("Интервал сообщений( в минутах)")]
        public float AdvertInterval { get; set; }
        [JsonProperty("Оповещать в консоль? (true/false)")]
        public bool BroadcastToConsole { get; set; }
        [JsonProperty("Выбрать сообщение в случайном порядке (true/false)")]
        public bool ChooseMessageAtRandom { get; set; }
        public static Configuration CreateDefault();
    }

     void OnServerInitialized();
    private void BroadcastNextAdvert();
    private int GetNextAdvertIndex();
}

private class Configuration
{
    [JsonProperty("Сообщение")]
    public List<string> Messages { get; set; }
    [JsonProperty("Интервал сообщений( в минутах)")]
    public float AdvertInterval { get; set; }
    [JsonProperty("Оповещать в консоль? (true/false)")]
    public bool BroadcastToConsole { get; set; }
    [JsonProperty("Выбрать сообщение в случайном порядке (true/false)")]
    public bool ChooseMessageAtRandom { get; set; }
    public static Configuration CreateDefault();
}


```

---

## ID

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using Oxide;

Oxide.Plugins
[Info("ID Lookup", "Cheeze", "0.1")]
[Description("Lookup a connected player's steamid")]
 class ID : RustPlugin
{
    [ChatCommand("id")]
     void cmdID(BasePlayer player, string cmd, string[] args);
     BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix);
     string ListToString(List<string> list, int first, string seperator);
     void SendChatMessage(BasePlayer player, string prefix, string msg);
}


```

---

## IGather

```csharp
using Oxide.Core;
using System;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using ConVar;

Oxide.Plugins
[Info("IGather", "DylanSMR", "1.0.9", ResourceId = 1763)]
[Description("A GUI timer.")]
 class IGather : RustPlugin
{
     void LoadDefaultConfig();
     T GetConfig(string name, T defaultValue);
     float _defQuarryGatherRate;
     float _defResourceGatherRate;
     float _defPickupGatherRate;
     string _defPermission;
     string _defGroupName;
     string Permission;
    public string GroupName;
    public int newcount;
    public bool WipeConfirmV;
    public List<string> nameli;
    public List<ulong> newadd;
     class GroupData
    {
        public Dictionary<int, Groups> groupD;
        public List<string> perms;
        public GroupData();
    }

     class Groups
    {
        public string groupName;
        public int groupID;
        public string groupPerm;
        public string groupTimeCreated;
        public float groupQuarryRate;
        public float groupResourceRate;
        public float groupPickupRate;
        public string groupCreater;
        public List<ulong> groupPlayers;
        public Groups();
    }

     GroupData groupData;
     class PlayerData
    {
        public Dictionary<ulong, Players> playerD;
        public PlayerData();
    }

     class Players
    {
        public string playerName;
        public ulong playerID;
        public float playerPickup;
        public float playerQuarry;
        public float playerResource;
        public int playerGroupID;
        public string playerGroupName;
        public Players();
    }

     PlayerData playerData;
     void Loaded();
     void LoadPerms();
     void LoadDefaultGroups();
     void OnPlayerInit(BasePlayer player);
     void OnGroupPermissionGranted(string name, string perm);
     void grabPermG(string perma, string name);
    [ConsoleCommand("igGrabPermissions")]
     void PermissionGrab(ConsoleSystem.Arg arg);
     void GrantPermission(int newid, BasePlayer target);
     void grabPerm(string perma, string name);
     void OnUserPermissionGranted(string name, string str);
     void RevokePermission(int newid, BasePlayer target);
     void grabPerm2(string perma, string name);
     void OnUserPermissionRevoked(string name, string str);
     void SaveData();
     Dictionary<string, string> messages;
    [ConsoleCommand("igcreategroup")]
     void CreateGroupC(ConsoleSystem.Arg arg);
    [ConsoleCommand("igcollectstats")]
     void CollectStatsC(ConsoleSystem.Arg arg);
    [ConsoleCommand("igwipegroups")]
     void WipeGroupsC(ConsoleSystem.Arg arg);
    [ConsoleCommand("igconfirm")]
     void ConfirmC(ConsoleSystem.Arg arg);
    [ChatCommand("igath")]
     void cmdChat(BasePlayer player, string command, string[] args);
    private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item);
    private void OnQuarryGather(MiningQuarry quarry, Item item);
    private void OnCollectiblePickup(Item item, BasePlayer player);
     bool TryGroupSe();
     bool TryGroup();
     void AddPlayers();
    private BasePlayer FindPlayer(BasePlayer player, string arg);
    private BasePlayer FindPlayerC(ConsoleSystem.Arg targer, string arg);
    private BasePlayer FindPlayerU(string arg);
}

 class GroupData
{
    public Dictionary<int, Groups> groupD;
    public List<string> perms;
    public GroupData();
}

 class Groups
{
    public string groupName;
    public int groupID;
    public string groupPerm;
    public string groupTimeCreated;
    public float groupQuarryRate;
    public float groupResourceRate;
    public float groupPickupRate;
    public string groupCreater;
    public List<ulong> groupPlayers;
    public Groups();
}

 class PlayerData
{
    public Dictionary<ulong, Players> playerD;
    public PlayerData();
}

 class Players
{
    public string playerName;
    public ulong playerID;
    public float playerPickup;
    public float playerQuarry;
    public float playerResource;
    public int playerGroupID;
    public string playerGroupName;
    public Players();
}


```

---

## Ignore

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core;
using UnityEngine;

Oxide.Plugins
[Info("Ignore", "Nogrod", "2.0.1", ResourceId = 1054)]
 class Ignore : RustPlugin
{
    private ConfigData configData;
    private Dictionary<ulong, PlayerData> IgnoreData;
    private readonly Dictionary<ulong, HashSet<ulong>> ReverseData;
     class ConfigData
    {
        public int IgnoreLimit { get; set; }
    }

     class PlayerData
    {
        public string Name { get; set; }
        public HashSet<ulong> Ignores { get; set; }
    }

    protected override void LoadDefaultConfig();
    private void Init();
    private void SaveIgnores();
    private bool AddIgnoreS(string playerS, string ignoreS);
    private bool AddIgnore(ulong playerId, ulong ignoreId);
    private bool RemoveIgnoreS(string playerS, string ignoreS);
    private bool RemoveIgnore(ulong playerId, ulong ignoreId);
    private bool HasIgnoredS(string playerS, string ignoreS);
    private bool HasIgnored(ulong playerId, ulong ignoreId);
    private bool AreIgnoredS(string playerS, string ignoreS);
    private bool AreIgnored(ulong playerId, ulong ignoreId);
    private bool IsIgnoredS(string playerS, string ignoreS);
    private bool IsIgnored(ulong playerId, ulong ignoreId);
    private string[] GetIgnoreListS(string playerS);
    private string[] GetIgnoreList(ulong playerId);
    private string[] IsIgnoredByS(string playerS);
    private ulong[] IsIgnoredBy(ulong playerId);
    private PlayerData GetPlayerData(ulong playerId);
    [ChatCommand("ignore")]
    private void cmdIgnore(BasePlayer player, string command, string[] args);
    private void SendHelpText(BasePlayer player);
    private void AddIgnoreReverse(ulong playerId, ulong ignoreId);
    private void PrintMessage(BasePlayer player, string msgId, object[] args);
    private ulong FindIgnore(string ignore);
    private static BasePlayer FindPlayer(string nameOrIdOrIp);
    private static BasePlayer FindPlayer(ulong id);
}

 class ConfigData
{
    public int IgnoreLimit { get; set; }
}

 class PlayerData
{
    public string Name { get; set; }
    public HashSet<ulong> Ignores { get; set; }
}


```

---

## ImageLibrary

```csharp
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;
using System.IO;
using System.Collections;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("ImageLibrary", "Absolut", "1.2.1", ResourceId = 2193)]
 class ImageLibrary : RustPlugin
{
     ImageData imageData;
    private DynamicConfigFile ImageLibraryData;
    public class ImageData
    {
        public Dictionary<string, Dictionary<ulong, uint>> Images;
    }

    static GameObject webObject;
    static Images images;
     void Loaded();
     void Unload();
     void OnServerInitialized();
    [HookMethod("GetImage")]
    public string GetImage(string shortname, ulong skin);
    [HookMethod("HasImage")]
    public bool HasImage(string shortname, ulong skin);
    [HookMethod("AddImage")]
    public bool AddImage(string url, string name, ulong skin);
     class QueueImages
    {
        public string url;
        public string name;
        public ulong skin;
        public QueueImages(string ur, string nm, ulong sk);
    }

     class Images : MonoBehaviour
    {
         ImageLibrary filehandler;
        const ulong MaxActiveLoads;
        static readonly List<QueueImages> QueueList;
        static byte activeLoads;
        private MemoryStream stream;
        public void SetDataDir(ImageLibrary fc);
        public void Add(string url, string name, ulong skin);
         void Next();
        private void ClearStream();
         IEnumerator WaitForRequest(WWW www, QueueImages info);
    }

    [ConsoleCommand("RefreshAllImages")]
    private void cmdRefreshAllImages(ConsoleSystem.Arg arg);
    private void RefreshAllImages();
    private void CheckNewImages();
    private Dictionary<string, Dictionary<ulong, string>> ItemImages;
     void SaveData();
     void LoadData();
}

public class ImageData
{
    public Dictionary<string, Dictionary<ulong, uint>> Images;
}

 class QueueImages
{
    public string url;
    public string name;
    public ulong skin;
    public QueueImages(string ur, string nm, ulong sk);
}

 class Images : MonoBehaviour
{
     ImageLibrary filehandler;
    const ulong MaxActiveLoads;
    static readonly List<QueueImages> QueueList;
    static byte activeLoads;
    private MemoryStream stream;
    public void SetDataDir(ImageLibrary fc);
    public void Add(string url, string name, ulong skin);
     void Next();
    private void ClearStream();
     IEnumerator WaitForRequest(WWW www, QueueImages info);
}


```

---

## ImageLoader

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using UnityEngine.Networking;
using Database = Facepunch.Sqlite.Database;

Oxide.Plugins
[Info("ImageLoader", "Bombardir", "0.1.0")]
 class ImageLoader : RustPlugin
{
    public class QueueImageCache : IDisposable
    {
        private class DownloadingItem
        {
            public readonly string ImageUrl;
            public UnityWebRequest Www;
            public DownloadingItem(string imageUrl);
        }

        private const int MaxActiveDownloads;
        private readonly List<DownloadingItem> _activeDownloads;
        private readonly Queue<DownloadingItem> _itemsToDownload;
        private readonly Action _onQueueComplete;
        private readonly Action<string> _onError;
        private readonly Dictionary<string, string> _cachedImages;
        public QueueImageCache(Dictionary<string, string> cachedImages, Action onQueueComplete, Action<string> onError);
        public void Dispose();
        public bool TryGetCachedOrCache(string imageUrl, string cachedImageId);
        private void CacheNextImageIfNeeded();
        private IEnumerator CacheAndStartNextImage(DownloadingItem downloadingItem);
        private IEnumerator CacheImage(DownloadingItem downloadingItem);
    }

    private class ImageLoaderData
    {
        public uint entid;
        public Dictionary<string, string> cachedImages;
        public ImageLoaderData();
    }

    private const string DataFileName;
    private const string NoneImageUrl;
    private readonly Regex _avatarRegex;
    private readonly Dictionary<ulong, string> _avatarUrls;
    private readonly Queue<string> _imagesToCache;
    private QueueImageCache _imageCache;
    private ImageLoaderData _imageLoaderData;
     void Loaded();
     void OnServerInitialized();
     void Unload();
    private void OnPlayerInit(BasePlayer player);
    [HookMethod("BuildItemImageComponent")]
    public CuiRawImageComponent BuildItemImageComponent(string shortName);
    [HookMethod("BuildAvatarImageComponent")]
    public CuiRawImageComponent BuildAvatarImageComponent(ulong userId);
    [HookMethod("BuildImageComponent")]
    public CuiRawImageComponent BuildImageComponent(string url, string color, float FadeIn);
    public bool CheckCachedOrCache(string url);
    private void LogDownloadError(string error);
    private void SaveCachedImages();
    private ImageLoaderData LoadImageLoaderDataFromFile();
    private bool RepairImagesDatabaseIfNeeded(uint oldEntId);
    private static string BuildItemUrl(string shortName);
}

public class QueueImageCache : IDisposable
{
    private class DownloadingItem
    {
        public readonly string ImageUrl;
        public UnityWebRequest Www;
        public DownloadingItem(string imageUrl);
    }

    private const int MaxActiveDownloads;
    private readonly List<DownloadingItem> _activeDownloads;
    private readonly Queue<DownloadingItem> _itemsToDownload;
    private readonly Action _onQueueComplete;
    private readonly Action<string> _onError;
    private readonly Dictionary<string, string> _cachedImages;
    public QueueImageCache(Dictionary<string, string> cachedImages, Action onQueueComplete, Action<string> onError);
    public void Dispose();
    public bool TryGetCachedOrCache(string imageUrl, string cachedImageId);
    private void CacheNextImageIfNeeded();
    private IEnumerator CacheAndStartNextImage(DownloadingItem downloadingItem);
    private IEnumerator CacheImage(DownloadingItem downloadingItem);
}

private class DownloadingItem
{
    public readonly string ImageUrl;
    public UnityWebRequest Www;
    public DownloadingItem(string imageUrl);
}

private class ImageLoaderData
{
    public uint entid;
    public Dictionary<string, string> cachedImages;
    public ImageLoaderData();
}


```

---

## IndestructableBuildings

```csharp
using System;
using System.Collections.Generic;
using Rust;

Oxide.Plugins
[Info("Indestructable Buildings", "Mughisi", "1.0.1", ResourceId=966)]
 class IndestructableBuildings : RustPlugin
{
     bool configChanged;
     string defaultChatPrefix;
     string defaultChatPrefixColor;
     string chatPrefix;
     string chatPrefixColor;
     bool defaultProtectFoundations;
     bool defaultProtectAllBuildingBlocks;
     bool defaultInformPlayer;
     float defaultInformInterval;
     bool protectFoundations;
     bool protectAllBuildingBlocks;
     bool informPlayer;
     float informInterval;
     string defaultHelpText;
     string defaultInformMessage;
     string helpText;
     string informMessage;
     class OnlinePlayer
    {
        public BasePlayer Player;
        public float LastInformTime;
        public OnlinePlayer(BasePlayer player);
    }

    [OnlinePlayers]
     Hash<BasePlayer, OnlinePlayer> onlinePlayers;
     DateTime epoch;
    protected override void LoadDefaultConfig();
     void Loaded();
     void LoadVariables();
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
     void OnPlayerInit(BasePlayer player);
     void SendHelpText(BasePlayer player);
     void Log(string message);
     void SendChatMessage(BasePlayer player, string message, object[] arguments);
     object GetConfigValue(string category, string setting, object defaultValue);
    private long GetTimestamp();
}

 class OnlinePlayer
{
    public BasePlayer Player;
    public float LastInformTime;
    public OnlinePlayer(BasePlayer player);
}


```

---

## IndividualDC

```csharp
using System;
using System.Collections.Generic;

Oxide.Plugins
[Info("IndividualDC", "k1lly0u", "0.1.3", ResourceId = 1758)]
[Description("Damage controller for individual bones and weapons")]
 class IndividualDC : RustPlugin
{
    private ConfigData configData;
    public string[] Bodyparts;
     class ConfigData
    {
        public Dictionary<string, Dictionary<string, float>> Weapons { get; set; }
    }

     void OnServerInitialized();
    protected override void LoadDefaultConfig();
    private Dictionary<string, Dictionary<string, float>> SetConfigData();
    private void LoadVariables();
    private void LoadConfigVariables();
     void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
    private bool InList(string weapon, string bodypart);
    [ChatCommand("scale")]
    private void cmdScale(BasePlayer player, string command, string[] args);
    private bool isAuth(BasePlayer player);
     Dictionary<string, string> messages;
}

 class ConfigData
{
    public Dictionary<string, Dictionary<string, float>> Weapons { get; set; }
}


```

---

## InfoPanel

```csharp
using System;
using System.Globalization;
using System.Runtime.Remoting.Messaging;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("InfoPanel", "Sparkless", "0.0.2")]
public class InfoPanel : RustPlugin
{
    [PluginReference]
    private Plugin ImageLibrary;
    private Configuration _config;
    private string CmdText;
    private string CmdCommand;
     class Configuration
    {
        [JsonProperty("Название сервера")]
        public string NameServer;
        [JsonProperty("Иконка (где коробка)")]
        public string StoreIcons;
        [JsonProperty("Команда при нажатии на коробку")]
        public string CommandStore;
        [JsonProperty("Иконка(Онлайн)")]
        public string OnlineIcons;
        [JsonProperty("Иконка(Спящих)")]
        public string SleepIcons;
        [JsonProperty("Иконка 1 кнопки")]
        public string Knopka1;
        [JsonProperty("Иконка 2 кнопки")]
        public string Knopka2;
        [JsonProperty("Иконка 3 кнопки")]
        public string Knopka3;
        [JsonProperty("Иконка 4 кнопки")]
        public string Knopka4;
        [JsonProperty("Иконка 5 кнопки")]
        public string Knopka5;
        [JsonProperty("Текст на 1 кнопки")]
        public string KnopkaText1;
        [JsonProperty("Текст на 2 кнопки")]
        public string KnopkaText2;
        [JsonProperty("Текст на 3 кнопки")]
        public string KnopkaText3;
        [JsonProperty("Текст на 4 кнопки")]
        public string KnopkaText4;
        [JsonProperty("Текст на 5 кнопки")]
        public string KnopkaText5;
        [JsonProperty("Команда при нажатии на 1 кнопку")]
        public string CommandKnopka1;
        [JsonProperty("Команда при нажатии на 2 кнопку")]
        public string CommandKnopka2;
        [JsonProperty("Команда при нажатии на 3 кнопку")]
        public string CommandKnopka3;
        [JsonProperty("Команда при нажатии на 4 кнопку")]
        public string CommandKnopka4;
        [JsonProperty("Команда при нажатии на 5 кнопку")]
        public string CommandKnopka5;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
     void OnServerInitialized();
     void Unload();
    private void OnPlayerInit(BasePlayer player);
    private void OnPlayerDisconnected(BasePlayer player, string reason);
    private string Layer;
    private void DrawMenu(BasePlayer player);
    private string Open;
    [ChatCommand("menu")]
    private void OpenMenu(BasePlayer player);
    private static string HexToCuiColor(string hex);
}

 class Configuration
{
    [JsonProperty("Название сервера")]
    public string NameServer;
    [JsonProperty("Иконка (где коробка)")]
    public string StoreIcons;
    [JsonProperty("Команда при нажатии на коробку")]
    public string CommandStore;
    [JsonProperty("Иконка(Онлайн)")]
    public string OnlineIcons;
    [JsonProperty("Иконка(Спящих)")]
    public string SleepIcons;
    [JsonProperty("Иконка 1 кнопки")]
    public string Knopka1;
    [JsonProperty("Иконка 2 кнопки")]
    public string Knopka2;
    [JsonProperty("Иконка 3 кнопки")]
    public string Knopka3;
    [JsonProperty("Иконка 4 кнопки")]
    public string Knopka4;
    [JsonProperty("Иконка 5 кнопки")]
    public string Knopka5;
    [JsonProperty("Текст на 1 кнопки")]
    public string KnopkaText1;
    [JsonProperty("Текст на 2 кнопки")]
    public string KnopkaText2;
    [JsonProperty("Текст на 3 кнопки")]
    public string KnopkaText3;
    [JsonProperty("Текст на 4 кнопки")]
    public string KnopkaText4;
    [JsonProperty("Текст на 5 кнопки")]
    public string KnopkaText5;
    [JsonProperty("Команда при нажатии на 1 кнопку")]
    public string CommandKnopka1;
    [JsonProperty("Команда при нажатии на 2 кнопку")]
    public string CommandKnopka2;
    [JsonProperty("Команда при нажатии на 3 кнопку")]
    public string CommandKnopka3;
    [JsonProperty("Команда при нажатии на 4 кнопку")]
    public string CommandKnopka4;
    [JsonProperty("Команда при нажатии на 5 кнопку")]
    public string CommandKnopka5;
}


```

---

## InfoTabs

```csharp
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

Oxide.Plugins
[Info("InfoTabs", "VooDoo", "1.0.0")]
[Description("Rules and Commands for XMenu")]
public class InfoTabs : RustPlugin
{
    [PluginReference]
     Plugin XMenu;
    private PluginConfig config;
    private class PluginConfig
    {
        public ColorConfig colorConfig;
        public class ColorConfig
        {
            public string menuContentHighlighting;
            public string menuContentHighlightingalternative;
            public string menuContentText;
            public string menuContentTextAlternative;
            public string gradientColor;
        }

        public Dictionary<string, string> commandsTab;
        public Dictionary<string, string> bindsTab;
        public List<string> rulesTab;
    }

    private void Init();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    public const string MenuLayer;
    public const string MenuItemsLayer;
    public const string MenuSubItemsLayer;
    public const string MenuContent;
     Timer TimerInitialize;
    private void OnServerInitialized();
    private void RenderCommands(ulong userID, object[] objects);
    private void RenderBinds(ulong userID, object[] objects);
    private void RenderRules(ulong userID, object[] objects);
    public static DateTime UnixTimeStampToDateTime(double unixTimeStamp);
    private static string HexToRustFormat(string hex);
}

private class PluginConfig
{
    public ColorConfig colorConfig;
    public class ColorConfig
    {
        public string menuContentHighlighting;
        public string menuContentHighlightingalternative;
        public string menuContentText;
        public string menuContentTextAlternative;
        public string gradientColor;
    }

    public Dictionary<string, string> commandsTab;
    public Dictionary<string, string> bindsTab;
    public List<string> rulesTab;
}

public class ColorConfig
{
    public string menuContentHighlighting;
    public string menuContentHighlightingalternative;
    public string menuContentText;
    public string menuContentTextAlternative;
    public string gradientColor;
}


```

---

## IngameClockGUI

```csharp
using System;
using System.Collections.Generic;
using Oxide.Core;

Oxide.Plugins
[Info("Ingame Clock GUI", "deer_SWAG", "0.0.5", ResourceId = 1245)]
[Description("Displays ingame and server time")]
public class IngameClockGUI : RustPlugin
{
    const string databaseName;
    const int isClockEnabled;
    const int isServerTime;
    const string defaultInfoSize;
     class Data
    {
        public HashSet<Player> Players;
        public Data();
    }

     class Player
    {
        public ulong userID;
        public short options;
        public Player();
        public Player(ulong id, short o);
    }

    private class TimedInfo
    {
        public DateTime startTime;
        public DateTime endTime;
        public string text;
        public bool serverTime;
        public string size;
        public TimedInfo(DateTime st, DateTime et, string txt, bool server, string s);
    }

    private string clockJson;
    private string infoJson;
     Data data;
     Timer updateTimer;
     TOD_Sky sky;
     DateTime dt;
     bool isLoaded;
     bool isInit;
     string time;
     DateTime gameTime;
     DateTime serverTime;
    private TimedInfo currentTI;
    private List<TimedInfo> tiList;
    protected override void LoadDefaultConfig();
     void OnPluginLoaded();
     void OnServerInitialized();
     void Load();
     void Unload();
    [ChatCommand("clock")]
     void cmdChat(BasePlayer player, string command, string[] args);
     void AddGUI();
    private void UpdateTime();
    private void DestroyGUI();
    private void ShowTime();
     void ShowInfo(string text, string iSize);
     void UpdateInfo();
     void DestroyInfo();
     void SaveData();
     bool GetOption(int options, int option);
     void SendHelpText(BasePlayer player);
    private TimedInfo GetTimedInfo(string source);
     void CheckCreateConfig();
}

 class Data
{
    public HashSet<Player> Players;
    public Data();
}

 class Player
{
    public ulong userID;
    public short options;
    public Player();
    public Player(ulong id, short o);
}

private class TimedInfo
{
    public DateTime startTime;
    public DateTime endTime;
    public string text;
    public bool serverTime;
    public string size;
    public TimedInfo(DateTime st, DateTime et, string txt, bool server, string s);
}


```

---

## InjectionSyringe

```csharp
using UnityEngine;
using Random = UnityEngine.Random;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

Oxide.Plugins
[Info("InjectionSyringe", "Empty", "2.0.0")]
public class InjectionSyringe : RustPlugin
{
     string pic1;
     string pic2;
     string pic3;
     string pic4;
     string pic5;
     string pic6;
     ulong skinid1;
     ulong skinid2;
     ulong skinid3;
     ulong skinid4;
    [PluginReference]
    private Plugin ImageLibrary;
     void OnServerInitialized();
     object OnHealingItemUse(MedicalTool tool, BasePlayer player);
     void GiveMedical(BasePlayer player);
    [ConsoleCommand("syringe.add")]
    private void CmdHandler(ConsoleSystem.Arg args);
    [ChatCommand("medical")]
     void DrawUI(BasePlayer player);
    [ChatCommand("medicaladmin")]
     void AdminGive(BasePlayer player);
}


```

---

## InstantBarrel

```csharp
using System;
using CompanionServer.Handlers;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using UnityEngine;

Oxide.Plugins
[Info("Instant Barrel", "rustmods.ru", "1.1.5")]
[Description("Makes barrels and road signs 1 hp and instantly spawns loot in player inventory")]
public class InstantBarrel : RustPlugin
{
    private const string onPermission;
    private readonly string[] lootBarrelsNames;
    private void OnServerInitialized();
    private object OnEntityTakeDamage(LootContainer lootContainer, HitInfo hitInfo);
    static Configuration config;
    public class Configuration
    {
        [JsonProperty("Enable farming with weapons")]
        public bool eWeapon;
        [JsonProperty("Max farming distance")]
        public float maxDistance;
        [JsonProperty("Make barrels 1 hit to kill")]
        public bool oneShot;
        [JsonProperty("Enable barrel gibs")]
        public bool gibs;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

public class Configuration
{
    [JsonProperty("Enable farming with weapons")]
    public bool eWeapon;
    [JsonProperty("Max farming distance")]
    public float maxDistance;
    [JsonProperty("Make barrels 1 hit to kill")]
    public bool oneShot;
    [JsonProperty("Enable barrel gibs")]
    public bool gibs;
}


```

---

## InstantBuy

```csharp

Oxide.Plugins
[Info("Instant Buy", "Apple", "1.0.3")]
[Description("Vending Machine has no delay")]
public class InstantBuy : CovalencePlugin
{
    private object OnBuyVendingItem(VendingMachine machine, BasePlayer player, int sellOrderID, int amount);
}


```

---

## InstantCraft

```csharp
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;

Oxide.Plugins
[Info("Instant Craft", "Orange", "2.1.5")]
[Description("Allows players to instantly craft items with features")]
public class InstantCraft : RustPlugin
{
    private const string permUse;
    private void Init();
    private object OnItemCraft(ItemCraftTask item);
    private object OnCraft(ItemCraftTask task);
    private void GiveItem(BasePlayer player, ItemCraftTask task, ItemDefinition def, List<int> stacks, int taskSkinID);
    private int FreeSlots(BasePlayer player);
    private void GiveRefund(BasePlayer player, List<Item> items);
    private List<int> GetStacks(ItemDefinition item, int amount);
    private bool IsNormalItem(string name);
    private bool IsBlocked(string name);
    private bool HasPlace(int slots, List<int> stacks);
    protected override void LoadDefaultMessages();
    private void Message(BasePlayer player, string messageKey, object[] args);
    private string GetMessage(string messageKey, string playerID, object[] args);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Check for free place")]
        public bool checkPlace;
        [JsonProperty(PropertyName = "Split crafted stacks")]
        public bool split;
        [JsonProperty(PropertyName = "Normal Speed")]
        public string[] normal;
        [JsonProperty(PropertyName = "Blacklist")]
        public string[] blocked;
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Check for free place")]
    public bool checkPlace;
    [JsonProperty(PropertyName = "Split crafted stacks")]
    public bool split;
    [JsonProperty(PropertyName = "Normal Speed")]
    public string[] normal;
    [JsonProperty(PropertyName = "Blacklist")]
    public string[] blocked;
}


```

---

## InstantResearch

```csharp

Oxide.Plugins
[Info("Instant Research", "Artasan", 1.0)]
[Description("Allows instant research.")]
public class InstantResearch : RustPlugin
{
     void OnServerInitialized();
     void OnItemDeployed(Deployer deployer, BaseEntity deployedEntity);
     void OnItemResearchStart(ResearchTable table);
    public void updateResearchTables();
}


```

---

## InstantSmelt

```csharp
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;

Oxide.Plugins
[Info("Instant Smelt", "Orange", "2.0.5")]
[Description("Smelt resources as soon as they are mined")]
public class InstantSmelt : RustPlugin
{
    private const string permUse;
    private const string charcoalItemName;
    private const string woodItemName;
    private void Init();
    private void Unload();
    private object OnCollectiblePickup(Item item, BasePlayer player);
    private object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item);
    private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
    private void cmdToggleChat(BasePlayer player);
    private object OnGather(BasePlayer player, Item item, bool bonus, bool pickup);
    private bool HasPermission(BasePlayer player);
    private static ConfigData config;
    private class ConfigData
    {
        [JsonProperty(PropertyName = "Command")]
        public string command;
        [JsonProperty(PropertyName = "A. Blacklist")]
        public List<string> blackList;
    }

    private ConfigData GetDefaultConfig();
    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private const string filename;
    private List<ulong> data;
    private void LoadData();
    private void SaveData();
    protected override void LoadDefaultMessages();
    private void Message(BasePlayer player, string messageKey, object[] args);
    private string GetMessage(string messageKey, string playerID, object[] args);
}

private class ConfigData
{
    [JsonProperty(PropertyName = "Command")]
    public string command;
    [JsonProperty(PropertyName = "A. Blacklist")]
    public List<string> blackList;
}


```

---

## InstantXP

```csharp
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;

Oxide.Plugins
[Info("InstantXP", "k1lly0u", "0.1.2", ResourceId = 2017)]
 class InstantXP : RustPlugin
{
     IXPData ixpData;
    private DynamicConfigFile data;
     int[] Levels;
     void Loaded();
     void OnServerInitialized();
     void OnPlayerInit(BasePlayer player);
     void OnUserPermissionGranted(string name, string perm);
    private int GetLevel(ulong playerid);
    [ChatCommand("ixp")]
    private void cmdRod(BasePlayer player, string command, string[] args);
    private void SendMSG(BasePlayer player, string message);
    private ConfigData configData;
     class ConfigData
    {
        public int DefaultLevel { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
     void SaveData();
     void LoadData();
     class IXPData
    {
        public Dictionary<string, int> Permissions;
    }

     Dictionary<string, string> Messages;
    private string LA(string key, string userid);
}

 class ConfigData
{
    public int DefaultLevel { get; set; }
}

 class IXPData
{
    public Dictionary<string, int> Permissions;
}


```

---

## InsultGenerator

```csharp
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("InsultGenerator", "Spicy", 1.0)]
[Description("Grabs an insult from the web and pastes it to a player on command.")]
 class InsultGenerator : RustPlugin
{
     void Init();
     void LoadLang();
     string GetLangMessage(string key);
     void RegisterPermission(string permission_name);
     bool HasPermission(string steamid, string permission_name);
     void SendMessage(BasePlayer player, string message);
     BasePlayer FindPlayer(string args);
    [ChatCommand("insult")]
     void cmdInsult(BasePlayer player, string command, string[] args);
     void Request(string page, BasePlayer playertoinsult, BasePlayer player);
     void GetCallback(int code, string response, string page, BasePlayer playertoinsult, BasePlayer player);
     string Insult(string response);
}


```

---

## InvalidDistanceDetector

```csharp
using Newtonsoft.Json;

Oxide.Plugins
[Info("Invalid Distance Detector", "HiTTA", "1.3.0")]
[Description("Bans suspicious players based on weapon distances")]
 class InvalidDistanceDetector : CovalencePlugin
{
    private Configuration _config;
    protected override void LoadDefaultConfig();
    protected override void LoadConfig();
    protected override void SaveConfig();
    private class Configuration
    {
        [JsonProperty("Compound Bow Distance")]
        public float CompoundBow;
        [JsonProperty("Bow Distance")]
        public float Bow;
        [JsonProperty("Crossbow Distance")]
        public float Crossbow;
        [JsonProperty("M249 Distance")]
        public float M249;
        [JsonProperty("Eoka Pistol Distance")]
        public float EokaPistol;
        [JsonProperty("M92 Pistol Distance")]
        public float M92Pistol;
        [JsonProperty("Nailgun Distance")]
        public float Nailgun;
        [JsonProperty("Python Revolver Distance")]
        public float PythonRevolver;
        [JsonProperty("Revolver Distance")]
        public float Revolver;
        [JsonProperty("Semi-Automatic Pistol Distance")]
        public float SemiAutoPistol;
        [JsonProperty("Assault Rifle Distance")]
        public float AssaultRifle;
        [JsonProperty("Bolt Action Rifle Distance")]
        public float BoltActionRifle;
        [JsonProperty("L96 Distance")]
        public float L96Rifle;
        [JsonProperty("LR-300 Assault Rifle distance")]
        public float LR300AssaultRifle;
        [JsonProperty("M39 Rifle distance")]
        public float M39Rifle;
        [JsonProperty("Semi-Automatic Rifle distance")]
        public float SemiAutomaticRifle;
        [JsonProperty("MP5A4 distance")]
        public float MP5A4;
        [JsonProperty("Thompson distance")]
        public float Thompson;
    }

    private void OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo);
}

private class Configuration
{
    [JsonProperty("Compound Bow Distance")]
    public float CompoundBow;
    [JsonProperty("Bow Distance")]
    public float Bow;
    [JsonProperty("Crossbow Distance")]
    public float Crossbow;
    [JsonProperty("M249 Distance")]
    public float M249;
    [JsonProperty("Eoka Pistol Distance")]
    public float EokaPistol;
    [JsonProperty("M92 Pistol Distance")]
    public float M92Pistol;
    [JsonProperty("Nailgun Distance")]
    public float Nailgun;
    [JsonProperty("Python Revolver Distance")]
    public float PythonRevolver;
    [JsonProperty("Revolver Distance")]
    public float Revolver;
    [JsonProperty("Semi-Automatic Pistol Distance")]
    public float SemiAutoPistol;
    [JsonProperty("Assault Rifle Distance")]
    public float AssaultRifle;
    [JsonProperty("Bolt Action Rifle Distance")]
    public float BoltActionRifle;
    [JsonProperty("L96 Distance")]
    public float L96Rifle;
    [JsonProperty("LR-300 Assault Rifle distance")]
    public float LR300AssaultRifle;
    [JsonProperty("M39 Rifle distance")]
    public float M39Rifle;
    [JsonProperty("Semi-Automatic Rifle distance")]
    public float SemiAutomaticRifle;
    [JsonProperty("MP5A4 distance")]
    public float MP5A4;
    [JsonProperty("Thompson distance")]
    public float Thompson;
}


```

---

## InventoryCleaner

```csharp
using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

Oxide.Plugins
[Info("Inventory Cleaner", "PaiN", "1.1.3", ResourceId = 0)]
[Description("This plugin allows players with permission to clean all/their/target's inventory.")]
 class InventoryCleaner : RustPlugin
{
     void Loaded();
    [ChatCommand("invcleanall")]
     void cmdInvCleanAll(BasePlayer player, string cmd, string[] args);
    [ChatCommand("invclean")]
     void cmdInvClean(BasePlayer player, string cmd, string[] args);
    [ChatCommand("invcleanme")]
     void cmdInvCleanMe(BasePlayer player, string cmd, string[] args);
}


```

---

## InventoryGuardian

```csharp
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;

Oxide.Plugins
[Info("InventoryGuardian", "k1lly0u", "0.2.3", ResourceId = 773)]
 class InventoryGuardian : RustPlugin
{
     IGData igData;
    private DynamicConfigFile Inventory_Data;
    private Dictionary<ulong, PlayerInfo> cachedInventories;
    private bool isNewSave;
     void Loaded();
     void OnServerInitialized();
     void OnNewSave(string filename);
     void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player);
     void Unload();
    private void CheckProtocol();
    private void RestoreAll();
    private void SaveAll();
    private void RemoveAll();
    private BasePlayer FindPlayer(BasePlayer player, string arg);
    private void MSG(BasePlayer player, string message, string key, bool title);
    private bool SaveInventory(BasePlayer player);
    private List<SavedItem> GetPlayerItems(BasePlayer player);
    private SavedItem ProcessItem(Item item, string container);
    private bool RemoveInventory(BasePlayer player);
    private bool RestoreInventory(BasePlayer player);
    private void GiveItem(BasePlayer player, Item item, string container);
    private Item BuildItem(SavedItem sItem);
    private Item BuildWeapon(SavedItem sItem);
    private void RegisterPermisions();
    private bool IsAdmin(BasePlayer player);
    private bool IsUser(BasePlayer player);
    [ChatCommand("ig")]
    private void cmdInvGuard(BasePlayer player, string command, string[] args);
    [ConsoleCommand("ig")]
    private void ccmdInvGuard(ConsoleSystem.Arg arg);
     class IGData
    {
        public bool IsActivated;
        public bool AutoRestore;
        public bool KeepCondition;
        public int AuthLevel;
        public Dictionary<ulong, PlayerInfo> Inventories;
    }

     class PlayerInfo
    {
        public bool RestoreOnce;
        public List<SavedItem> Items;
    }

     class SavedItem
    {
        public string shortname;
        public int itemid;
        public string container;
        public float condition;
        public int amount;
        public int ammoamount;
        public string ammotype;
        public ulong skinid;
        public bool weapon;
        public List<SavedItem> mods;
    }

     void SaveData();
     void SaveLoop();
     void LoadData();
    private ConfigData configData;
     class ConfigData
    {
        public string Messages_MainColor { get; set; }
        public string Messages_MsgColor { get; set; }
    }

    private void LoadVariables();
    protected override void LoadDefaultConfig();
    private void LoadConfigVariables();
     void SaveConfig(ConfigData config);
}

 class IGData
{
    public bool IsActivated;
    public bool AutoRestore;
    public bool KeepCondition;
    public int AuthLevel;
    public Dictionary<ulong, PlayerInfo> Inventories;
}

 class PlayerInfo
{
    public bool RestoreOnce;
    public List<SavedItem> Items;
}

 class SavedItem
{
    public string shortname;
    public int itemid;
    public string container;
    public float condition;
    public int amount;
    public int ammoamount;
    public string ammotype;
    public ulong skinid;
    public bool weapon;
    public List<SavedItem> mods;
}

 class ConfigData
{
    public string Messages_MainColor { get; set; }
    public string Messages_MsgColor { get; set; }
}


```

---

## InventoryViewer

```csharp
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

Oxide.Plugins
[Info("Inventory Viewer", "Mughisi", "2.0.2", ResourceId = 871)]
public class InventoryViewer : RustPlugin
{
    private string prefix;
    private string prefixColor;
    private const string Permission;
    private static InventoryViewer instance;
    private readonly Dictionary<BasePlayer, List<BasePlayer>> activeMatches;
    public class Inspector : MonoBehaviour
    {
        private BasePlayer player;
        private BasePlayer target;
        private LootableCorpse view;
        private int ticks;
        private readonly MethodInfo markDirty;
        private readonly FieldInfo positionChecks;
        public void StartInspecting(BasePlayer p, BasePlayer t);
        private void Inspect();
        public void StopInspecting();
        private void BeginLooting();
        private void StopLooting();
        public void Remove();
    }

    private void Loaded();
    protected override void LoadDefaultConfig();
    private void LoadConfigValues();
    private void LoadDefaultMessages();
    private void Unload();
    private void OnPlayerLootEnd(PlayerLoot looter);
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info);
    [ChatCommand("viewinv")]
    private void ViewInventoryCommand(BasePlayer player, string command, string[] args);
    private void ViewInventory(BasePlayer player, BasePlayer target);
    private List<BasePlayer> FindPlayersByNameOrId(string nameOrId);
    private void ShowMatches(BasePlayer player);
    private void ShowMatch(BasePlayer player, int num);
    private T GetConfig(string name, T defaultValue);
    private string GetTranslation(string key, string id);
    private bool IsAllowed(string id);
    private void SendChatMessage(BasePlayer player, string message, string arguments);
}

public class Inspector : MonoBehaviour
{
    private BasePlayer player;
    private BasePlayer target;
    private LootableCorpse view;
    private int ticks;
    private readonly MethodInfo markDirty;
    private readonly FieldInfo positionChecks;
    public void StartInspecting(BasePlayer p, BasePlayer t);
    private void Inspect();
    public void StopInspecting();
    private void BeginLooting();
    private void StopLooting();
    public void Remove();
}


```

---

## InvFoundation

```csharp
using System;
using Rust;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

Oxide.Plugins
[Info("InvFoundation", "sami37", "1.1.0", ResourceId = 2096)]
[Description("Invulnerable foundation")]
public class InvFoundation : RustPlugin
{
    [PluginReference("BuildingOwners")]
     Plugin BuildingOwners;
    [PluginReference("EntityOwner")]
     Plugin EntityOwner;
    private Dictionary<string, object> damageList { get; set; }
    private bool UseEntityOwner { get; set; }
    private bool UseBuildOwners { get; set; }
    private bool UseDamageScaling { get; set; }
    static int colisionentity;
    private readonly int cupboardMask;
     T GetConfig(string name, T defaultValue);
    static Dictionary<string,object> defaultDamageScale();
     void Loaded();
    protected override void LoadDefaultConfig();
    private void OnServerInitialized();
    private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
     bool IsOwner(BasePlayer player, BaseEntity targetEntity);
    private bool CupboardPrivlidge(BasePlayer player, Vector3 position);
}


```

---

## IQBackpack

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("IQBackpack", "SkuliDropek", "1.0.7")]
[Description("Просто твой любимый рюкзачок :)")]
 class IQBackpack : RustPlugin
{
    [PluginReference]
     Plugin ImageLibrary;
     Plugin IQChat;
     Plugin Battles;
     Plugin Duel;
    public Boolean IsDuel(UInt64 userID);
    public void SendChat(String Message, BasePlayer player, Chat.ChatChannel channel);
    private String GetImage(String fileName, UInt64 skin);
    private String GetImage(Configuration.Backpack.BackpackCraft.ItemCraft CItem);
    public Boolean AddImage(String url, String shortname, UInt64 skin);
    public Boolean HasImage(String imageName);
    private IEnumerator DownloadImages();
    public static IQBackpack _;
    private Dictionary<BasePlayer, BackpackBehaviour> PlayerBackpack;
    private Dictionary<BasePlayer, ShopFrontBehavior> PlayerUpgrades;
    private List<BasePlayer> PlayerUseBackpacks;
    private Dictionary<BasePlayer, BackpackSpine> SpinesBackpacks;
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty("Настройка рюкзака")]
        public Backpack BackpackItem;
        [JsonProperty("Настройка поддерживающих плагинов")]
        public Reference References;
        [JsonProperty("Дополнительная настройка")]
        public Turneds TurnedsSetting;
        internal class Turneds
        {
            [JsonProperty("Тип работы рюкзака : 0 - требуется надеть его, чтобы пользоватья, 1 - требуются лишь права(из вариаций рюкзаков)")]
            public TypeBackpack Types;
            [JsonProperty("Отображать рюкзак за спиной игрока(модельку рюкзака, работает на всех поворотах и изгибах игрока) [ВНИМАНИЕ, ИСПОЛЬЗУЙТЕ ЭТО НА PVE СЕРВЕРЕ, ИЗ-ЗА ОСОБЕННОСТЕЙ ИГРЫ В ТАКОЙ РЮКЗАК НА СПИНЕ НЕ БУДЕТ ПРОХОДИТЬ УРОН]")]
            public Boolean UseSpineBackpack;
            [JsonProperty("Использовать возможность скрафтить рюкзак (true - да/false - нет)")]
            public Boolean UseCrafting;
            [JsonProperty("Использовать возможность улучшать рюкзаки и увеличивать в нем слоты (true - да/false - нет) [Дополнительно настраивается в каждом рюкзаке, учтите - это общий параметр, детальная настройка в вариациях рюкзаков]")]
            public Boolean UseUpgradeBackpack;
            [JsonProperty("Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
            public Boolean ClosePressedAgain;
            [JsonProperty("Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
            public TypeDropBackpack TypeDropBackpack;
            [JsonProperty("Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
            public Single RemoveBackpack;
            [JsonProperty("Настройка интерфейса")]
            public VisualBackpackSlot VisualBackpackSlots;
            internal class VisualBackpackSlot
            {
                [JsonProperty("Использовать отображение UI рюкзака возле слотов (true - да/false - нет)")]
                public Boolean UseVisual;
                [JsonProperty("Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
                public Boolean UseSlots;
                [JsonProperty("Отображать полосу заполненности рюкзака на UI (true - да/false - нет)")]
                public Boolean UseIsFulled;
                [JsonProperty("Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
                public Boolean UseButton;
                [JsonProperty("Настройка цветов полосы заполненности")]
                public ColorProgress ColorProgressBar;
                [JsonProperty("Настройка позиции UI слота с рюкзаком")]
                public Position PositionSlotVisual;
                [JsonProperty("Настройка позиции UI для улучшения рюкзака")]
                public Position PositionUpgrade;
                internal class ColorProgress
                {
                    [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
                    public String ColorMinimal;
                    [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
                    public String ColorAverage;
                    [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
                    public String ColorMaximum;
                }

                internal class Position
                {
                    public String AnchorMin;
                    public String AnchorMax;
                    public String OffsetMin;
                    public String OffsetMax;
                }

            }

        }

        internal class Reference
        {
            [JsonProperty("Настройка IQChat")]
            public IQChat IQChatSetting;
            internal class IQChat
            {
                [JsonProperty("IQChat : Кастомный префикс в чате")]
                public String CustomPrefix;
                [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                public String CustomAvatar;
                [JsonProperty("IQChat : Использовать UI уведомления")]
                public Boolean UIAlertUse;
            }

        }

        internal class Backpack
        {
            [JsonProperty("Shortname для рюкзака (нужен предмет, который является одеждой)")]
            public String Shortname;
            [JsonProperty("SkinID рюкзака")]
            public UInt64 SkinID;
            [JsonProperty("Ссылка на картинку для отображения рюкзака")]
            public String UrlBackpack;
            [JsonProperty("Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
            public List<BackpackCraft> BackpacOption;
            internal class BackpackCraft
            {
                [JsonProperty("Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
                public String Permissions;
                [JsonProperty("Количество слотов у данного рюкзака")]
                public Int32 AmountSlot;
                [JsonProperty("Черный список предметов для данного рюкзака")]
                public List<String> BlackListItems;
                [JsonProperty("Предметы для крафта рюкзака")]
                public List<ItemCraft> CraftItems;
                [JsonProperty("Настройка улучшений рюкзака (Улучшение будет постепенное в зависимости от листа, сверху -> вниз (максимальное количество слотов - 42))")]
                public List<UpgradeBackpack> UpgradeList;
                internal class UpgradeBackpack
                {
                    [JsonProperty("Предметы для улучшения на этот уровень")]
                    public List<ItemCraft> CraftItems;
                    [JsonProperty("Сколько слотов добавлять за это улучшение")]
                    public Int32 SlotUpgrade;
                }

                internal class ItemCraft
                {
                    public String Shortname;
                    public UInt64 SkinID;
                    [JsonProperty("Количество")]
                    public Int32 Amount;
                }

            }

        }

        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    public Dictionary<UInt64, BackpackInfo> Backpacks;
    internal class BackpackInfo
    {
        public Int32 AmountSlot;
        public Int32 IndexUpgrade;
        public List<SavedItem> Items;
        internal class SavedItem
        {
            public Int32 TargetSlot;
            public String Shortname;
            public Int32 Itemid;
            public Single Condition;
            public Single Maxcondition;
            public Int32 Amount;
            public Int32 Ammoamount;
            public String Ammotype;
            public Int32 Flamefuel;
            public UInt64 Skinid;
            public String Name;
            public Boolean Weapon;
            public Int32 Blueprint;
            public Single BusyTime;
            public Boolean OnFire;
            public List<SavedItem> Mods;
        }

    }

     void ReadData();
     void WriteData();
     void Init();
     void OnServerInitialized();
     void OnPlayerDeath(BasePlayer player, HitInfo info);
     void OnPlayerConnected(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
    private void OnServerShutdown();
     void Unload();
    public Dictionary<UInt64, List<Connection>> ContainerGetPlayer;
     void NetworkIDGetSet(UInt64 NetID, Boolean SetOrRemove, BasePlayer player);
     object OnLootNetworkUpdate(PlayerLoot loot);
     void CanLootEntity(BasePlayer player, StorageContainer container);
     void OnPlayerSleepEnded(BasePlayer player);
     void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
     object CanWearItem(PlayerInventory inventory, Item item, int targetSlot);
     void OnItemAddedToContainer(ItemContainer container, Item item);
     void OnItemDropped(Item item, BaseEntity entity);
     void OnItemStacked(Item destinationItem, Item sourceItem, ItemContainer destinationContainer);
    private Item OnItemSplit(Item item, int amount);
     object CanStackItem(Item item, Item targetItem);
     object CanAcceptItem(ItemContainer container, Item item);
     void OnUserPermissionGranted(string id, string permName);
     void OnUserPermissionRevoked(string id, string permName);
     void OnUserGroupAdded(string id, string groupName);
     void OnUserGroupRemoved(string id, string groupName);
     void OnGroupPermissionGranted(string name, string perm);
     void OnGroupPermissionRevoked(string name, string perm);
    private void UpdatePermissions(String ID, String Permissions, Boolean IsGranted);
    private void OpenBP(BasePlayer player);
    private void BackpackSpawnSpine(BasePlayer player);
    private void BackpackRemoveSpine(BasePlayer player);
    public static StorageContainer CreateContainer(BasePlayer player);
    private static void PlayerLootContainer(BasePlayer player, StorageContainer container);
    public static ShopFront CreateShopFront(BasePlayer player);
    private static void PlayerLootContainer(BasePlayer player, ShopFront shopFront, List<Configuration.Backpack.BackpackCraft.ItemCraft> ItemList);
    private void OpenUpgradeMenu(BasePlayer player);
    private void UpgradeBackpack(BasePlayer player);
    private List<BackpackInfo.SavedItem> GetSavedList(UInt64 ID);
    static List<BackpackInfo.SavedItem> SaveItems(List<Item> items);
    static BackpackInfo.SavedItem SaveItem(Item item);
    static Item BuildItem(BackpackInfo.SavedItem sItem);
    static Item BuildWeapon(BackpackInfo.SavedItem sItem);
    static List<Item> RestoreItems(List<BackpackInfo.SavedItem> sItems);
    private void DropBackpack(BasePlayer player, TypeDropBackpack typeDropBackpack);
    private class NoRagdollCollision : FacepunchBehaviour
    {
        private Collider _collider;
        private void Awake();
        private void OnCollisionEnter(Collision collision);
    }

    private void CraftingBackpack(BasePlayer player);
    private UInt64 GetBackpackID(BasePlayer player);
    private Item GetBackpack(BasePlayer player);
    private Configuration.Backpack.BackpackCraft GetBackpackOption(BasePlayer player);
    private List<Item> GetItemBlacklist(BasePlayer player);
    private Int32 GetAvailableSlots(BasePlayer player);
    private Int32 GetMaximumUpgradeSlots(BasePlayer player);
    private Int32 GetSlotsBackpack(BasePlayer player);
    private Int32 GetBusySlotsBackpack(BasePlayer player);
    private void RegisteredPermissions();
    private Boolean HaveAllItem(BasePlayer player, List<Configuration.Backpack.BackpackCraft.ItemCraft> BPCraft, ItemContainer contaner);
    private Boolean HaveItem(BasePlayer player, String Shortname, Int32 Amount, UInt64 SkinID, ItemContainer contaner);
    private void TakeItems(BasePlayer player, List<Configuration.Backpack.BackpackCraft.ItemCraft> BPCraft, ItemContainer contaner);
    [ConsoleCommand("bp")]
     void OpenBackpackConsole(ConsoleSystem.Arg arg);
    [ChatCommand("bp")]
     void OpenBackpackChat(BasePlayer player);
    [ConsoleCommand("backpack.upgrade")]
     void BackpackUpgradeCommand(ConsoleSystem.Arg arg);
    [ConsoleCommand("backpack.upgrade.menu")]
     void BackpackUpgrade(ConsoleSystem.Arg arg);
    [ChatCommand("upgradebp")]
     void UpgradeBPCommand(BasePlayer player);
    [ConsoleCommand("backpack.crafting")]
     void BackpackCrafting(ConsoleSystem.Arg arg);
    [ChatCommand("backpack")]
     void BackpackCraftMenu(BasePlayer player);
    private void DrawUI_Backpack_Main(BasePlayer player);
    private void DrawUI_Backpack_Slots(BasePlayer player);
    private void DrawUI_Backpack_Slots_Locked(BasePlayer player);
    private void DrawUI_Backpack_ItemCrafts(BasePlayer player);
    private Int32 GetSlotsPercent(Single Percent, Single Slots);
    private void DrawUI_Backpack_Visual(BasePlayer player);
    private void DrawUI_Backpack_Upgrade_Info(BasePlayer player);
    private void DrawUI_Backpack_Upgrade_Info_Controller(BasePlayer player);
    private void DrawUI_Backpack_Upgrade_Workbench(BasePlayer player);
    private static InterfaceBuilder _interface;
    private class InterfaceBuilder
    {
        public static InterfaceBuilder Instance;
        public const String UI_Backpack;
        public const String UI_Backpack_Visual;
        public const String UI_Backpack_Upgrade_Info;
        public const String UI_Backpack_Upgrade_Workbench;
        public Dictionary<String, String> Interfaces;
        public InterfaceBuilder();
        public static void AddInterface(String name, String json);
        public static string GetInterface(String name);
        public static void DestroyAll();
        private void BuildingBackpack_Main();
        private void BuildingBackpack_Slots();
        private void BuildingBackpack_Slots_Lock();
        private void BuildingBackpack_Craft();
        private void BuildingBackpack_Visual_Backpack_Slot();
        private void BuildingBackpack_UpgradeBackpack_Info();
        private void BuildingBackpack_UpgradeBackpack_Info_Controller();
        private void BuildingBackpack_UpgradeBackpack_Workbench();
    }

    public static StringBuilder sb;
    public string GetLang(string LangKey, string userID, object[] args);
    private new void LoadDefaultMessages();
    private class BackpackBehaviour : FacepunchBehaviour
    {
        public Item Backpack;
        private BasePlayer Player;
        public StorageContainer Container;
        public UInt64 BackpackID;
        private Dictionary<Item, Item.Flag> SaveFlags;
        private void Awake();
        private void BlackListAction(Boolean State);
        public void Open();
        public void LockSlot(bool state);
        public void Close();
        private void PushItems();
        public void Destroy(bool isClose);
    }

    private class ShopFrontBehavior : FacepunchBehaviour
    {
        private BasePlayer Player;
        public ShopFront Container;
        public Int32 UpgradeSlotsUp;
        public UInt64 BackpackID;
        public List<Configuration.Backpack.BackpackCraft.ItemCraft> ItemList;
        private Dictionary<Item, Item.Flag> SaveFlags;
        private void Awake();
        public void Open();
        private List<Configuration.Backpack.BackpackCraft.ItemCraft> GetListUpgrade();
        private List<Item> GetWhiteList();
        private void WhiteListAction(Boolean State);
        public void VendorLock(Boolean State);
        public void Close();
        public void Destroy(bool isClose);
    }

     class BackpackSpine : FacepunchBehaviour
    {
         Rigidbody rigidbodyBP;
         DroppedItemContainer backpack;
         BasePlayer player;
        public BackpackSpine();
        public void OnDestroy();
        public void KillParent();
    }

}

private class Configuration
{
    [JsonProperty("Настройка рюкзака")]
    public Backpack BackpackItem;
    [JsonProperty("Настройка поддерживающих плагинов")]
    public Reference References;
    [JsonProperty("Дополнительная настройка")]
    public Turneds TurnedsSetting;
    internal class Turneds
    {
        [JsonProperty("Тип работы рюкзака : 0 - требуется надеть его, чтобы пользоватья, 1 - требуются лишь права(из вариаций рюкзаков)")]
        public TypeBackpack Types;
        [JsonProperty("Отображать рюкзак за спиной игрока(модельку рюкзака, работает на всех поворотах и изгибах игрока) [ВНИМАНИЕ, ИСПОЛЬЗУЙТЕ ЭТО НА PVE СЕРВЕРЕ, ИЗ-ЗА ОСОБЕННОСТЕЙ ИГРЫ В ТАКОЙ РЮКЗАК НА СПИНЕ НЕ БУДЕТ ПРОХОДИТЬ УРОН]")]
        public Boolean UseSpineBackpack;
        [JsonProperty("Использовать возможность скрафтить рюкзак (true - да/false - нет)")]
        public Boolean UseCrafting;
        [JsonProperty("Использовать возможность улучшать рюкзаки и увеличивать в нем слоты (true - да/false - нет) [Дополнительно настраивается в каждом рюкзаке, учтите - это общий параметр, детальная настройка в вариациях рюкзаков]")]
        public Boolean UseUpgradeBackpack;
        [JsonProperty("Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
        public Boolean ClosePressedAgain;
        [JsonProperty("Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
        public TypeDropBackpack TypeDropBackpack;
        [JsonProperty("Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
        public Single RemoveBackpack;
        [JsonProperty("Настройка интерфейса")]
        public VisualBackpackSlot VisualBackpackSlots;
        internal class VisualBackpackSlot
        {
            [JsonProperty("Использовать отображение UI рюкзака возле слотов (true - да/false - нет)")]
            public Boolean UseVisual;
            [JsonProperty("Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
            public Boolean UseSlots;
            [JsonProperty("Отображать полосу заполненности рюкзака на UI (true - да/false - нет)")]
            public Boolean UseIsFulled;
            [JsonProperty("Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
            public Boolean UseButton;
            [JsonProperty("Настройка цветов полосы заполненности")]
            public ColorProgress ColorProgressBar;
            [JsonProperty("Настройка позиции UI слота с рюкзаком")]
            public Position PositionSlotVisual;
            [JsonProperty("Настройка позиции UI для улучшения рюкзака")]
            public Position PositionUpgrade;
            internal class ColorProgress
            {
                [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
                public String ColorMinimal;
                [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
                public String ColorAverage;
                [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
                public String ColorMaximum;
            }

            internal class Position
            {
                public String AnchorMin;
                public String AnchorMax;
                public String OffsetMin;
                public String OffsetMax;
            }

        }

    }

    internal class Reference
    {
        [JsonProperty("Настройка IQChat")]
        public IQChat IQChatSetting;
        internal class IQChat
        {
            [JsonProperty("IQChat : Кастомный префикс в чате")]
            public String CustomPrefix;
            [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
            public String CustomAvatar;
            [JsonProperty("IQChat : Использовать UI уведомления")]
            public Boolean UIAlertUse;
        }

    }

    internal class Backpack
    {
        [JsonProperty("Shortname для рюкзака (нужен предмет, который является одеждой)")]
        public String Shortname;
        [JsonProperty("SkinID рюкзака")]
        public UInt64 SkinID;
        [JsonProperty("Ссылка на картинку для отображения рюкзака")]
        public String UrlBackpack;
        [JsonProperty("Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
        public List<BackpackCraft> BackpacOption;
        internal class BackpackCraft
        {
            [JsonProperty("Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
            public String Permissions;
            [JsonProperty("Количество слотов у данного рюкзака")]
            public Int32 AmountSlot;
            [JsonProperty("Черный список предметов для данного рюкзака")]
            public List<String> BlackListItems;
            [JsonProperty("Предметы для крафта рюкзака")]
            public List<ItemCraft> CraftItems;
            [JsonProperty("Настройка улучшений рюкзака (Улучшение будет постепенное в зависимости от листа, сверху -> вниз (максимальное количество слотов - 42))")]
            public List<UpgradeBackpack> UpgradeList;
            internal class UpgradeBackpack
            {
                [JsonProperty("Предметы для улучшения на этот уровень")]
                public List<ItemCraft> CraftItems;
                [JsonProperty("Сколько слотов добавлять за это улучшение")]
                public Int32 SlotUpgrade;
            }

            internal class ItemCraft
            {
                public String Shortname;
                public UInt64 SkinID;
                [JsonProperty("Количество")]
                public Int32 Amount;
            }

        }

    }

    public static Configuration GetNewConfiguration();
}

internal class Turneds
{
    [JsonProperty("Тип работы рюкзака : 0 - требуется надеть его, чтобы пользоватья, 1 - требуются лишь права(из вариаций рюкзаков)")]
    public TypeBackpack Types;
    [JsonProperty("Отображать рюкзак за спиной игрока(модельку рюкзака, работает на всех поворотах и изгибах игрока) [ВНИМАНИЕ, ИСПОЛЬЗУЙТЕ ЭТО НА PVE СЕРВЕРЕ, ИЗ-ЗА ОСОБЕННОСТЕЙ ИГРЫ В ТАКОЙ РЮКЗАК НА СПИНЕ НЕ БУДЕТ ПРОХОДИТЬ УРОН]")]
    public Boolean UseSpineBackpack;
    [JsonProperty("Использовать возможность скрафтить рюкзак (true - да/false - нет)")]
    public Boolean UseCrafting;
    [JsonProperty("Использовать возможность улучшать рюкзаки и увеличивать в нем слоты (true - да/false - нет) [Дополнительно настраивается в каждом рюкзаке, учтите - это общий параметр, детальная настройка в вариациях рюкзаков]")]
    public Boolean UseUpgradeBackpack;
    [JsonProperty("Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
    public Boolean ClosePressedAgain;
    [JsonProperty("Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
    public TypeDropBackpack TypeDropBackpack;
    [JsonProperty("Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
    public Single RemoveBackpack;
    [JsonProperty("Настройка интерфейса")]
    public VisualBackpackSlot VisualBackpackSlots;
    internal class VisualBackpackSlot
    {
        [JsonProperty("Использовать отображение UI рюкзака возле слотов (true - да/false - нет)")]
        public Boolean UseVisual;
        [JsonProperty("Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
        public Boolean UseSlots;
        [JsonProperty("Отображать полосу заполненности рюкзака на UI (true - да/false - нет)")]
        public Boolean UseIsFulled;
        [JsonProperty("Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
        public Boolean UseButton;
        [JsonProperty("Настройка цветов полосы заполненности")]
        public ColorProgress ColorProgressBar;
        [JsonProperty("Настройка позиции UI слота с рюкзаком")]
        public Position PositionSlotVisual;
        [JsonProperty("Настройка позиции UI для улучшения рюкзака")]
        public Position PositionUpgrade;
        internal class ColorProgress
        {
            [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
            public String ColorMinimal;
            [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
            public String ColorAverage;
            [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
            public String ColorMaximum;
        }

        internal class Position
        {
            public String AnchorMin;
            public String AnchorMax;
            public String OffsetMin;
            public String OffsetMax;
        }

    }

}

internal class VisualBackpackSlot
{
    [JsonProperty("Использовать отображение UI рюкзака возле слотов (true - да/false - нет)")]
    public Boolean UseVisual;
    [JsonProperty("Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
    public Boolean UseSlots;
    [JsonProperty("Отображать полосу заполненности рюкзака на UI (true - да/false - нет)")]
    public Boolean UseIsFulled;
    [JsonProperty("Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
    public Boolean UseButton;
    [JsonProperty("Настройка цветов полосы заполненности")]
    public ColorProgress ColorProgressBar;
    [JsonProperty("Настройка позиции UI слота с рюкзаком")]
    public Position PositionSlotVisual;
    [JsonProperty("Настройка позиции UI для улучшения рюкзака")]
    public Position PositionUpgrade;
    internal class ColorProgress
    {
        [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
        public String ColorMinimal;
        [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
        public String ColorAverage;
        [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
        public String ColorMaximum;
    }

    internal class Position
    {
        public String AnchorMin;
        public String AnchorMax;
        public String OffsetMin;
        public String OffsetMax;
    }

}

internal class ColorProgress
{
    [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
    public String ColorMinimal;
    [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
    public String ColorAverage;
    [JsonProperty("Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
    public String ColorMaximum;
}

internal class Position
{
    public String AnchorMin;
    public String AnchorMax;
    public String OffsetMin;
    public String OffsetMax;
}

internal class Reference
{
    [JsonProperty("Настройка IQChat")]
    public IQChat IQChatSetting;
    internal class IQChat
    {
        [JsonProperty("IQChat : Кастомный префикс в чате")]
        public String CustomPrefix;
        [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
        public String CustomAvatar;
        [JsonProperty("IQChat : Использовать UI уведомления")]
        public Boolean UIAlertUse;
    }

}

internal class IQChat
{
    [JsonProperty("IQChat : Кастомный префикс в чате")]
    public String CustomPrefix;
    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
    public String CustomAvatar;
    [JsonProperty("IQChat : Использовать UI уведомления")]
    public Boolean UIAlertUse;
}

internal class Backpack
{
    [JsonProperty("Shortname для рюкзака (нужен предмет, который является одеждой)")]
    public String Shortname;
    [JsonProperty("SkinID рюкзака")]
    public UInt64 SkinID;
    [JsonProperty("Ссылка на картинку для отображения рюкзака")]
    public String UrlBackpack;
    [JsonProperty("Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
    public List<BackpackCraft> BackpacOption;
    internal class BackpackCraft
    {
        [JsonProperty("Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
        public String Permissions;
        [JsonProperty("Количество слотов у данного рюкзака")]
        public Int32 AmountSlot;
        [JsonProperty("Черный список предметов для данного рюкзака")]
        public List<String> BlackListItems;
        [JsonProperty("Предметы для крафта рюкзака")]
        public List<ItemCraft> CraftItems;
        [JsonProperty("Настройка улучшений рюкзака (Улучшение будет постепенное в зависимости от листа, сверху -> вниз (максимальное количество слотов - 42))")]
        public List<UpgradeBackpack> UpgradeList;
        internal class UpgradeBackpack
        {
            [JsonProperty("Предметы для улучшения на этот уровень")]
            public List<ItemCraft> CraftItems;
            [JsonProperty("Сколько слотов добавлять за это улучшение")]
            public Int32 SlotUpgrade;
        }

        internal class ItemCraft
        {
            public String Shortname;
            public UInt64 SkinID;
            [JsonProperty("Количество")]
            public Int32 Amount;
        }

    }

}

internal class BackpackCraft
{
    [JsonProperty("Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
    public String Permissions;
    [JsonProperty("Количество слотов у данного рюкзака")]
    public Int32 AmountSlot;
    [JsonProperty("Черный список предметов для данного рюкзака")]
    public List<String> BlackListItems;
    [JsonProperty("Предметы для крафта рюкзака")]
    public List<ItemCraft> CraftItems;
    [JsonProperty("Настройка улучшений рюкзака (Улучшение будет постепенное в зависимости от листа, сверху -> вниз (максимальное количество слотов - 42))")]
    public List<UpgradeBackpack> UpgradeList;
    internal class UpgradeBackpack
    {
        [JsonProperty("Предметы для улучшения на этот уровень")]
        public List<ItemCraft> CraftItems;
        [JsonProperty("Сколько слотов добавлять за это улучшение")]
        public Int32 SlotUpgrade;
    }

    internal class ItemCraft
    {
        public String Shortname;
        public UInt64 SkinID;
        [JsonProperty("Количество")]
        public Int32 Amount;
    }

}

internal class UpgradeBackpack
{
    [JsonProperty("Предметы для улучшения на этот уровень")]
    public List<ItemCraft> CraftItems;
    [JsonProperty("Сколько слотов добавлять за это улучшение")]
    public Int32 SlotUpgrade;
}

internal class ItemCraft
{
    public String Shortname;
    public UInt64 SkinID;
    [JsonProperty("Количество")]
    public Int32 Amount;
}

internal class BackpackInfo
{
    public Int32 AmountSlot;
    public Int32 IndexUpgrade;
    public List<SavedItem> Items;
    internal class SavedItem
    {
        public Int32 TargetSlot;
        public String Shortname;
        public Int32 Itemid;
        public Single Condition;
        public Single Maxcondition;
        public Int32 Amount;
        public Int32 Ammoamount;
        public String Ammotype;
        public Int32 Flamefuel;
        public UInt64 Skinid;
        public String Name;
        public Boolean Weapon;
        public Int32 Blueprint;
        public Single BusyTime;
        public Boolean OnFire;
        public List<SavedItem> Mods;
    }

}

internal class SavedItem
{
    public Int32 TargetSlot;
    public String Shortname;
    public Int32 Itemid;
    public Single Condition;
    public Single Maxcondition;
    public Int32 Amount;
    public Int32 Ammoamount;
    public String Ammotype;
    public Int32 Flamefuel;
    public UInt64 Skinid;
    public String Name;
    public Boolean Weapon;
    public Int32 Blueprint;
    public Single BusyTime;
    public Boolean OnFire;
    public List<SavedItem> Mods;
}

private class NoRagdollCollision : FacepunchBehaviour
{
    private Collider _collider;
    private void Awake();
    private void OnCollisionEnter(Collision collision);
}

private class InterfaceBuilder
{
    public static InterfaceBuilder Instance;
    public const String UI_Backpack;
    public const String UI_Backpack_Visual;
    public const String UI_Backpack_Upgrade_Info;
    public const String UI_Backpack_Upgrade_Workbench;
    public Dictionary<String, String> Interfaces;
    public InterfaceBuilder();
    public static void AddInterface(String name, String json);
    public static string GetInterface(String name);
    public static void DestroyAll();
    private void BuildingBackpack_Main();
    private void BuildingBackpack_Slots();
    private void BuildingBackpack_Slots_Lock();
    private void BuildingBackpack_Craft();
    private void BuildingBackpack_Visual_Backpack_Slot();
    private void BuildingBackpack_UpgradeBackpack_Info();
    private void BuildingBackpack_UpgradeBackpack_Info_Controller();
    private void BuildingBackpack_UpgradeBackpack_Workbench();
}

private class BackpackBehaviour : FacepunchBehaviour
{
    public Item Backpack;
    private BasePlayer Player;
    public StorageContainer Container;
    public UInt64 BackpackID;
    private Dictionary<Item, Item.Flag> SaveFlags;
    private void Awake();
    private void BlackListAction(Boolean State);
    public void Open();
    public void LockSlot(bool state);
    public void Close();
    private void PushItems();
    public void Destroy(bool isClose);
}

private class ShopFrontBehavior : FacepunchBehaviour
{
    private BasePlayer Player;
    public ShopFront Container;
    public Int32 UpgradeSlotsUp;
    public UInt64 BackpackID;
    public List<Configuration.Backpack.BackpackCraft.ItemCraft> ItemList;
    private Dictionary<Item, Item.Flag> SaveFlags;
    private void Awake();
    public void Open();
    private List<Configuration.Backpack.BackpackCraft.ItemCraft> GetListUpgrade();
    private List<Item> GetWhiteList();
    private void WhiteListAction(Boolean State);
    public void VendorLock(Boolean State);
    public void Close();
    public void Destroy(bool isClose);
}

 class BackpackSpine : FacepunchBehaviour
{
     Rigidbody rigidbodyBP;
     DroppedItemContainer backpack;
     BasePlayer player;
    public BackpackSpine();
    public void OnDestroy();
    public void KillParent();
}


```

---

## IQBackpackLite

```csharp
using System;
using UnityEngine;
using Object = System.Object;
using System.Linq;
using Newtonsoft.Json;
using System.Collections;
using ConVar;
using System.Text;
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Oxide.Core.Plugins;

Oxide.Plugins
[Info("IQBackpack Lite", "Mercury", "1.15.31")]
[Description("t.me/slivplugin")]
 class IQBackpackLite : RustPlugin
{
    private List<Item> GetItemBlacklist(BasePlayer player);
    public Boolean HasImage(String imageName);
    private const Boolean LanguageEn;
     void OnPlayerDeath(BasePlayer player, HitInfo info);
     void OnUserGroupRemoved(string id, string groupName);
    protected override void SaveConfig();
    private void OnNewSave(String filename);
    private const String PermissionNoDropBP;
    private Item OnItemSplit(Item item, int amount);
    private class InterfaceBuilder
    {
        public static InterfaceBuilder Instance;
        public const String UI_Backpack_Visual;
        public Dictionary<String, String> Interfaces;
        public InterfaceBuilder();
        public static void AddInterface(String name, String json);
        public static string GetInterface(String name);
        public static void DestroyAll();
        private void BuildingBackpack_Visual_Backpack_Slot();
    }

     void OnUserGroupAdded(string id, string groupName);
     void Unload();
    private class BackpackBehaviour : FacepunchBehaviour
    {
        private BasePlayer Player;
        public StorageContainer Container;
        public UInt64 BackpackID;
        private Dictionary<Item, Item.Flag> SaveFlags;
        private void Awake();
        private void BlackListAction(Boolean State);
        public void Open();
        public void Close();
        private void PushItems();
        public void Destroy(bool isClose);
    }

     void OnPlayerConnected(BasePlayer player);
    protected override void LoadDefaultConfig();
     void OnPlayerSleepEnded(BasePlayer player);
    private void OnServerShutdown();
    public void SendChat(String Message, BasePlayer player, Chat.ChatChannel channel);
    private void ClearData();
    static Item BuildItem(BackpackInfo.SavedItem sItem);
     void OnEntityDismounted(BaseMountable entity, BasePlayer player);
    private class NoRagdollCollision : FacepunchBehaviour
    {
        private Collider _collider;
        private void Awake();
        private void OnCollisionEnter(Collision collision);
    }

    private void UpdatePermissions(String ID, String Permissions, Boolean IsGranted, Boolean ReCheack);
    private Int32 GetSlotsBackpack(BasePlayer player);
    private Configuration.Backpack.BackpackCraft GetBackpackOption(BasePlayer player);
    private class Configuration
    {
        internal class Backpack
        {
            [JsonProperty(LanguageEn ? "Link to the picture to display the backpack" : "Ссылка на картинку для отображения рюкзака")]
            public String UrlBackpack;
            [JsonProperty(LanguageEn ? "Variations of backpacks by privileges (An available set is given to the player who is higher than others)" : "Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
            public List<BackpackCraft> BackpacOption;
            internal class BackpackCraft
            {
                [JsonProperty(LanguageEn ? "Permission to be able to craft and carry this backpack (do not leave this field empty, otherwise it will not be taken into account)" : "Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
                public String Permissions;
                [JsonProperty(LanguageEn ? "The amount slots in this backpack" : "Количество слотов у данного рюкзака")]
                public Int32 AmountSlot;
                [JsonProperty(LanguageEn ? "Blacklist of items for this backpack" : "Черный список предметов для данного рюкзака")]
                public List<String> BlackListItems;
            }

        }

        internal class Reference
        {
            [JsonProperty(LanguageEn ? "Setting up IQChat" : "Настройка IQChat")]
            public IQChat IQChatSetting;
            internal class IQChat
            {
                [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
                public String CustomPrefix;
                [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
                public String CustomAvatar;
                [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
                public Boolean UIAlertUse;
            }

        }

        [JsonProperty(LanguageEn ? "Additional configuration" : "Дополнительная настройка")]
        public Turneds TurnedsSetting;
        [JsonProperty(LanguageEn ? "Setting up a backpack" : "Настройка рюкзака")]
        public Backpack BackpackItem;
        [JsonProperty(LanguageEn ? "Configuring supporting plugins" : "Настройка поддерживающих плагинов")]
        public Reference References;
        public static Configuration GetNewConfiguration();
        internal class Turneds
        {
            [JsonProperty(LanguageEn ? "Time to remove the backpack when falling out (Works with : 2 - Throws the backpack with objects)" : "Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
            public Single RemoveBackpack;
            [JsonProperty(LanguageEn ? "Automatically clear the inventory of players' backpacks after the vape (true - yes/false - no)" : "Автоматически очищать инвентарь рюкзаков игроков после вайпа (true - да/false - нет)")]
            public Boolean WipeCleaning;
            [JsonProperty(LanguageEn ? "Close the backpack when clicking on the UI again/using the bind if it is open" : "Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
            public Boolean ClosePressedAgain;
            [JsonProperty(LanguageEn ? "Interface Setup" : "Настройка интерфейса")]
            public VisualBackpackSlot VisualBackpackSlots;
            internal class VisualBackpackSlot
            {
                [JsonProperty(LanguageEn ? "Setting up the position of the UI slot with a backpack" : "Настройка позиции UI слота с рюкзаком")]
                public Position PositionSlotVisual;
                internal class ColorProgress
                {
                    [JsonProperty(LanguageEn ? "The color of the fullness strip when the backpack is >30% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
                    public String ColorMinimal;
                    [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >80% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
                    public String ColorMaximum;
                    [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >60% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
                    public String ColorAverage;
                }

                [JsonProperty(LanguageEn ? "Allow to open the backpack by clicking on the UI interface (true - yes/false - no)" : "Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
                public Boolean UseButton;
                internal class Position
                {
                    public String AnchorMin;
                    public String AnchorMax;
                    public String OffsetMin;
                    public String OffsetMax;
                }

                [JsonProperty(LanguageEn ? "Display the number of slots in the backpack on the UI (true - yes/false - no)" : "Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
                public Boolean UseSlots;
                [JsonProperty(LanguageEn ? "Adjusting the colors of the fullness bar" : "Настройка цветов полосы заполненности")]
                public ColorProgress ColorProgressBar;
            }

            [JsonProperty(LanguageEn ? "The type of work of the backpack: 0 - you need to put it on to use, 1 - only permissions are required (from the variations of backpacks)" : "Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
            public TypeDropBackpack TypeDropBackpack;
        }

    }

    static List<BackpackInfo.SavedItem> SaveItems(List<Item> items);
    public Boolean IsDuel(UInt64 userID);
     void OnGroupPermissionRevoked(string name, string perm);
    public static Object CanOpenBackpack(BasePlayer player, UInt64 ownerId);
    private static void PlayerLootContainer(BasePlayer player, StorageContainer container);
    private void DropBackpack(BasePlayer player, TypeDropBackpack typeDropBackpack);
     void OnUserPermissionRevoked(string id, string permName);
    private void OpenBP(BasePlayer player);
     void WriteData();
    private String GetImage(String fileName, UInt64 skin);
    internal class BackpackInfo
    {
        public Int32 AmountSlot;
        public List<SavedItem> Items;
        internal class SavedItem
        {
            public Int32 TargetSlot;
            public String Shortname;
            public Int32 Itemid;
            public Single Condition;
            public Single Maxcondition;
            public Int32 Amount;
            public Int32 Ammoamount;
            public String Ammotype;
            public Int32 Flamefuel;
            public UInt64 Skinid;
            public String Name;
            public Boolean Weapon;
            public Int32 Blueprint;
            public Single BusyTime;
            public Boolean OnFire;
            public UInt32 FileContents;
            public UInt64 IdPhoto;
            public String Text;
            public Int32 GrowableGenes;
            public List<SavedItem> Mods;
        }

    }

    public static IQBackpackLite _;
    public Dictionary<UInt64, BackpackInfo> _old_Backpacks;
    public static StorageContainer CreateContainer(BasePlayer player);
     void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity);
     void OnServerInitialized();
    private Int32 GetAvailableSlots(BasePlayer player);
     ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos);
    private List<BasePlayer> PlayerUseBackpacks;
    public string GetLang(string LangKey, string userID, object[] args);
    [PluginReference]
     Plugin ImageLibrary;
     Plugin IQChat;
     Plugin Battles;
     Plugin Duel;
     Plugin OneVSOne;
     Plugin ArenaTournament;
     Plugin EventHelper;
     Plugin IQPermissions;
    public Boolean AddImage(String url, String shortname, UInt64 skin);
    private void RegisteredPermissions();
    [ChatCommand("bp")]
     void OpenBackpackChat(BasePlayer player);
    public Dictionary<UInt64, BackpackInfo> Backpacks;
    static List<Item> RestoreItems(List<BackpackInfo.SavedItem> sItems);
    private Int32 GetSlotsPercent(Single Percent, Single Slots);
    static Item BuildWeapon(BackpackInfo.SavedItem sItem);
    static BackpackInfo.SavedItem SaveItem(Item item);
    public static Object CanDropBackpack(UInt64 ownerId, Vector3 position);
     void OnUserPermissionGranted(string id, string permName);
    private Dictionary<BasePlayer, BackpackBehaviour> PlayerBackpack;
    private static InterfaceBuilder _interface;
    public static StringBuilder sb;
    private void CheckConnectionPermission(BasePlayer player);
    private Int32 GetBusySlotsBackpack(BasePlayer player);
    private List<BackpackInfo.SavedItem> GetSavedList(UInt64 ID);
    [ConsoleCommand("bp")]
     void OpenBackpackConsole(ConsoleSystem.Arg arg);
     void Init();
     void ReadData();
    private IEnumerator DownloadImages();
    private static Configuration config;
     void OnGroupPermissionGranted(string name, string perm);
    protected override void LoadConfig();
     void OnEntityMounted(BaseMountable entity, BasePlayer player);
    private void DrawUI_Backpack_Visual(BasePlayer player);
    private new void LoadDefaultMessages();
}

private class InterfaceBuilder
{
    public static InterfaceBuilder Instance;
    public const String UI_Backpack_Visual;
    public Dictionary<String, String> Interfaces;
    public InterfaceBuilder();
    public static void AddInterface(String name, String json);
    public static string GetInterface(String name);
    public static void DestroyAll();
    private void BuildingBackpack_Visual_Backpack_Slot();
}

private class BackpackBehaviour : FacepunchBehaviour
{
    private BasePlayer Player;
    public StorageContainer Container;
    public UInt64 BackpackID;
    private Dictionary<Item, Item.Flag> SaveFlags;
    private void Awake();
    private void BlackListAction(Boolean State);
    public void Open();
    public void Close();
    private void PushItems();
    public void Destroy(bool isClose);
}

private class NoRagdollCollision : FacepunchBehaviour
{
    private Collider _collider;
    private void Awake();
    private void OnCollisionEnter(Collision collision);
}

private class Configuration
{
    internal class Backpack
    {
        [JsonProperty(LanguageEn ? "Link to the picture to display the backpack" : "Ссылка на картинку для отображения рюкзака")]
        public String UrlBackpack;
        [JsonProperty(LanguageEn ? "Variations of backpacks by privileges (An available set is given to the player who is higher than others)" : "Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
        public List<BackpackCraft> BackpacOption;
        internal class BackpackCraft
        {
            [JsonProperty(LanguageEn ? "Permission to be able to craft and carry this backpack (do not leave this field empty, otherwise it will not be taken into account)" : "Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
            public String Permissions;
            [JsonProperty(LanguageEn ? "The amount slots in this backpack" : "Количество слотов у данного рюкзака")]
            public Int32 AmountSlot;
            [JsonProperty(LanguageEn ? "Blacklist of items for this backpack" : "Черный список предметов для данного рюкзака")]
            public List<String> BlackListItems;
        }

    }

    internal class Reference
    {
        [JsonProperty(LanguageEn ? "Setting up IQChat" : "Настройка IQChat")]
        public IQChat IQChatSetting;
        internal class IQChat
        {
            [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
            public String CustomPrefix;
            [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
            public String CustomAvatar;
            [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
            public Boolean UIAlertUse;
        }

    }

    [JsonProperty(LanguageEn ? "Additional configuration" : "Дополнительная настройка")]
    public Turneds TurnedsSetting;
    [JsonProperty(LanguageEn ? "Setting up a backpack" : "Настройка рюкзака")]
    public Backpack BackpackItem;
    [JsonProperty(LanguageEn ? "Configuring supporting plugins" : "Настройка поддерживающих плагинов")]
    public Reference References;
    public static Configuration GetNewConfiguration();
    internal class Turneds
    {
        [JsonProperty(LanguageEn ? "Time to remove the backpack when falling out (Works with : 2 - Throws the backpack with objects)" : "Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
        public Single RemoveBackpack;
        [JsonProperty(LanguageEn ? "Automatically clear the inventory of players' backpacks after the vape (true - yes/false - no)" : "Автоматически очищать инвентарь рюкзаков игроков после вайпа (true - да/false - нет)")]
        public Boolean WipeCleaning;
        [JsonProperty(LanguageEn ? "Close the backpack when clicking on the UI again/using the bind if it is open" : "Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
        public Boolean ClosePressedAgain;
        [JsonProperty(LanguageEn ? "Interface Setup" : "Настройка интерфейса")]
        public VisualBackpackSlot VisualBackpackSlots;
        internal class VisualBackpackSlot
        {
            [JsonProperty(LanguageEn ? "Setting up the position of the UI slot with a backpack" : "Настройка позиции UI слота с рюкзаком")]
            public Position PositionSlotVisual;
            internal class ColorProgress
            {
                [JsonProperty(LanguageEn ? "The color of the fullness strip when the backpack is >30% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
                public String ColorMinimal;
                [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >80% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
                public String ColorMaximum;
                [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >60% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
                public String ColorAverage;
            }

            [JsonProperty(LanguageEn ? "Allow to open the backpack by clicking on the UI interface (true - yes/false - no)" : "Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
            public Boolean UseButton;
            internal class Position
            {
                public String AnchorMin;
                public String AnchorMax;
                public String OffsetMin;
                public String OffsetMax;
            }

            [JsonProperty(LanguageEn ? "Display the number of slots in the backpack on the UI (true - yes/false - no)" : "Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
            public Boolean UseSlots;
            [JsonProperty(LanguageEn ? "Adjusting the colors of the fullness bar" : "Настройка цветов полосы заполненности")]
            public ColorProgress ColorProgressBar;
        }

        [JsonProperty(LanguageEn ? "The type of work of the backpack: 0 - you need to put it on to use, 1 - only permissions are required (from the variations of backpacks)" : "Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
        public TypeDropBackpack TypeDropBackpack;
    }

}

internal class Backpack
{
    [JsonProperty(LanguageEn ? "Link to the picture to display the backpack" : "Ссылка на картинку для отображения рюкзака")]
    public String UrlBackpack;
    [JsonProperty(LanguageEn ? "Variations of backpacks by privileges (An available set is given to the player who is higher than others)" : "Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
    public List<BackpackCraft> BackpacOption;
    internal class BackpackCraft
    {
        [JsonProperty(LanguageEn ? "Permission to be able to craft and carry this backpack (do not leave this field empty, otherwise it will not be taken into account)" : "Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
        public String Permissions;
        [JsonProperty(LanguageEn ? "The amount slots in this backpack" : "Количество слотов у данного рюкзака")]
        public Int32 AmountSlot;
        [JsonProperty(LanguageEn ? "Blacklist of items for this backpack" : "Черный список предметов для данного рюкзака")]
        public List<String> BlackListItems;
    }

}

internal class BackpackCraft
{
    [JsonProperty(LanguageEn ? "Permission to be able to craft and carry this backpack (do not leave this field empty, otherwise it will not be taken into account)" : "Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
    public String Permissions;
    [JsonProperty(LanguageEn ? "The amount slots in this backpack" : "Количество слотов у данного рюкзака")]
    public Int32 AmountSlot;
    [JsonProperty(LanguageEn ? "Blacklist of items for this backpack" : "Черный список предметов для данного рюкзака")]
    public List<String> BlackListItems;
}

internal class Reference
{
    [JsonProperty(LanguageEn ? "Setting up IQChat" : "Настройка IQChat")]
    public IQChat IQChatSetting;
    internal class IQChat
    {
        [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
        public String CustomPrefix;
        [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
        public String CustomAvatar;
        [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
        public Boolean UIAlertUse;
    }

}

internal class IQChat
{
    [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
    public String CustomPrefix;
    [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
    public String CustomAvatar;
    [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
    public Boolean UIAlertUse;
}

internal class Turneds
{
    [JsonProperty(LanguageEn ? "Time to remove the backpack when falling out (Works with : 2 - Throws the backpack with objects)" : "Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
    public Single RemoveBackpack;
    [JsonProperty(LanguageEn ? "Automatically clear the inventory of players' backpacks after the vape (true - yes/false - no)" : "Автоматически очищать инвентарь рюкзаков игроков после вайпа (true - да/false - нет)")]
    public Boolean WipeCleaning;
    [JsonProperty(LanguageEn ? "Close the backpack when clicking on the UI again/using the bind if it is open" : "Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
    public Boolean ClosePressedAgain;
    [JsonProperty(LanguageEn ? "Interface Setup" : "Настройка интерфейса")]
    public VisualBackpackSlot VisualBackpackSlots;
    internal class VisualBackpackSlot
    {
        [JsonProperty(LanguageEn ? "Setting up the position of the UI slot with a backpack" : "Настройка позиции UI слота с рюкзаком")]
        public Position PositionSlotVisual;
        internal class ColorProgress
        {
            [JsonProperty(LanguageEn ? "The color of the fullness strip when the backpack is >30% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
            public String ColorMinimal;
            [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >80% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
            public String ColorMaximum;
            [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >60% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
            public String ColorAverage;
        }

        [JsonProperty(LanguageEn ? "Allow to open the backpack by clicking on the UI interface (true - yes/false - no)" : "Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
        public Boolean UseButton;
        internal class Position
        {
            public String AnchorMin;
            public String AnchorMax;
            public String OffsetMin;
            public String OffsetMax;
        }

        [JsonProperty(LanguageEn ? "Display the number of slots in the backpack on the UI (true - yes/false - no)" : "Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
        public Boolean UseSlots;
        [JsonProperty(LanguageEn ? "Adjusting the colors of the fullness bar" : "Настройка цветов полосы заполненности")]
        public ColorProgress ColorProgressBar;
    }

    [JsonProperty(LanguageEn ? "The type of work of the backpack: 0 - you need to put it on to use, 1 - only permissions are required (from the variations of backpacks)" : "Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
    public TypeDropBackpack TypeDropBackpack;
}

internal class VisualBackpackSlot
{
    [JsonProperty(LanguageEn ? "Setting up the position of the UI slot with a backpack" : "Настройка позиции UI слота с рюкзаком")]
    public Position PositionSlotVisual;
    internal class ColorProgress
    {
        [JsonProperty(LanguageEn ? "The color of the fullness strip when the backpack is >30% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
        public String ColorMinimal;
        [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >80% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
        public String ColorMaximum;
        [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >60% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
        public String ColorAverage;
    }

    [JsonProperty(LanguageEn ? "Allow to open the backpack by clicking on the UI interface (true - yes/false - no)" : "Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
    public Boolean UseButton;
    internal class Position
    {
        public String AnchorMin;
        public String AnchorMax;
        public String OffsetMin;
        public String OffsetMax;
    }

    [JsonProperty(LanguageEn ? "Display the number of slots in the backpack on the UI (true - yes/false - no)" : "Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
    public Boolean UseSlots;
    [JsonProperty(LanguageEn ? "Adjusting the colors of the fullness bar" : "Настройка цветов полосы заполненности")]
    public ColorProgress ColorProgressBar;
}

internal class ColorProgress
{
    [JsonProperty(LanguageEn ? "The color of the fullness strip when the backpack is >30% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
    public String ColorMinimal;
    [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >80% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
    public String ColorMaximum;
    [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >60% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
    public String ColorAverage;
}

internal class Position
{
    public String AnchorMin;
    public String AnchorMax;
    public String OffsetMin;
    public String OffsetMax;
}

internal class BackpackInfo
{
    public Int32 AmountSlot;
    public List<SavedItem> Items;
    internal class SavedItem
    {
        public Int32 TargetSlot;
        public String Shortname;
        public Int32 Itemid;
        public Single Condition;
        public Single Maxcondition;
        public Int32 Amount;
        public Int32 Ammoamount;
        public String Ammotype;
        public Int32 Flamefuel;
        public UInt64 Skinid;
        public String Name;
        public Boolean Weapon;
        public Int32 Blueprint;
        public Single BusyTime;
        public Boolean OnFire;
        public UInt32 FileContents;
        public UInt64 IdPhoto;
        public String Text;
        public Int32 GrowableGenes;
        public List<SavedItem> Mods;
    }

}

internal class SavedItem
{
    public Int32 TargetSlot;
    public String Shortname;
    public Int32 Itemid;
    public Single Condition;
    public Single Maxcondition;
    public Int32 Amount;
    public Int32 Ammoamount;
    public String Ammotype;
    public Int32 Flamefuel;
    public UInt64 Skinid;
    public String Name;
    public Boolean Weapon;
    public Int32 Blueprint;
    public Single BusyTime;
    public Boolean OnFire;
    public UInt32 FileContents;
    public UInt64 IdPhoto;
    public String Text;
    public Int32 GrowableGenes;
    public List<SavedItem> Mods;
}


```

---

## IQBanSystem

```csharp
using Rust;
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;
using System.Text.RegularExpressions;
using ConVar;
using Oxide.Core.Libraries.Covalence;
using System;
using Object = System.Object;
using Oxide.Core.Libraries;
using System.Text;
using Oxide.Core.Plugins;
using Oxide.Core.Database;
using Newtonsoft.Json.Linq;
using System.Linq;
using Newtonsoft.Json;

Oxide.Plugins
[Info("IQBanSystem", "rustmods.ru", "1.12.19")]
[Description("IQBanSystem")]
public class IQBanSystem : RustPlugin
{
    private String SQL_Query_CreatedDatabase();
     object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, UInt64 target);
    [ChatCommand("ban")]
    private void ChatBanCommand(BasePlayer ownerCommand, String cmd, String[] arg);
    private static IQBanSystem _;
    private class TeamLocalMemory
    {
        public Double firstJoin;
        public Double lastRemoved;
    }

     void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team);
    public class Footer
    {
        public String text { get; set; }
        public String icon_url { get; set; }
        public String proxy_icon_url { get; set; }
        public Footer(String text, String icon_url, String proxy_icon_url);
    }

    protected override void SaveConfig();
    private class ProcessCheckVPN
    {
        public Int32 detectedVpn;
        public Boolean isCompleteProxyCheck;
        public Boolean isCompleteVpnApi;
        public Boolean isCompleteIPHub;
    }

    private List<String> ipListGods;
    private Timer timerCheckVpn;
    private Dictionary<Vector3, String> GetAuthCupboardPlayer(UInt64 playerID);
    private void OnServerInitialized();
    private const String VendingPrefab;
    private Boolean TryParseTimeSpan(String source, Double timeSpan);
    private const String permissionsUnBan;
    private Dictionary<UInt64, Dictionary<UInt64, TeamLocalMemory>> teamLocalMemory;
    private void PullOutTeamsInfo(BasePlayer player);
    private Boolean IsIpAdress(String mbIP);
    private void KickCommand(BasePlayer ownerCommand, String[] arg);
    private Connection sqlConnection;
    private Double GetUnbanTime(String idOrIP);
    private void BanUserOrIp(String idPlayer, String displayName, String ipAdress, String reason, Double banTime, TypeAction type, BasePlayer ownerAction, Boolean skipTeam);
    private const String permissionsBan;
     void WriteData();
    private static Double CurrentTime { get; set; }
    private IPlayer GetIPlayer(String userParams);
    private class PlayerInfo : SplitDatafile<PlayerInfo>
    {
        private const String BaseFolder;
        private const String UserFolder;
        private const String IpFolder;
        private static String GetFolder(TypeAction typeBanned);
        public static PlayerInfo Save(String idOrIp, TypeAction type);
        public static void Import(String idOrIp, PlayerInfo data, TypeAction type);
        public static void Remove(String idOrIp, TypeAction type);
        public static PlayerInfo Get(String idOrIp, TypeAction type);
        public static PlayerInfo Load(String idOrIp, TypeAction type);
        public static PlayerInfo Clear(String idOrIp, TypeAction type);
        public static PlayerInfo GetOrLoad(String idOrIp, TypeAction type);
        public static PlayerInfo GetOrCreate(String idOrIp, TypeAction type);
        public static String[] GetFiles(TypeAction type);
        public Boolean permanent;
        public Double timeUnbanned;
        public String reason;
        public String serverName;
        public String serverAdress;
        public String owner;
        public List<History> nameHistory;
        public List<History> ipHistory;
        public List<History> steamIdHistory;
        internal class History
        {
            public String value;
            public String time;
        }

        [JsonIgnore]
        public Double GetUnbanTime { get; set; }
        public Boolean IsBanned();
        public void UpdateHistory(TypeHistoryInfo typeInfo, String value);
        private List<History> GetHistoryList(TypeHistoryInfo typeInfo);
        private Boolean IsExistsValueHistory(List<History> histories, String value);
    }

    protected override void LoadConfig();
    private abstract class SplitDatafile
    {
        public static Dictionary<String, T> _players;
        public static Dictionary<String, T> _ipAdresses;
        public static Dictionary<String, T> _savedItems;
        private static Dictionary<String, T> GetRepository(TypeAction type);
        protected static void Import(TypeAction type, String baseFolder, String userId, T data);
        protected static String[] GetFiles(String baseFolder);
        protected static T Save(TypeAction type, string baseFolder, String userId);
        protected static void Remove(TypeAction type, string baseFolder, String userId);
        protected static T Get(TypeAction type, string baseFolder, String userId);
        protected static T Load(TypeAction type, String baseFolder, String userId);
        protected static T GetOrLoad(TypeAction type, String baseFolder, String userId);
        protected static T GetOrCreate(TypeAction type, String baseFolder, String userId);
        protected static T ClearAndSave(TypeAction type, String baseFolder, String userId);
    }

    private void BanIp(String IpAdress, IPlayer iPlayer, String reason, Double banTime, BasePlayer ownerCommand, Boolean skipTeam);
     object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player);
    private static Configuration config;
    private const String patternIP;
    private void BanCommand(BasePlayer ownerCommand, String[] arg);
    private void HandlerSteam(IPlayer player, Int32 code, String response);
    private void MarkerUpdate();
    public String FormatTime(Double Second, String UserID);
     void HandlerProxyCheckIo(Int32 code, String response, String adress);
    private Boolean IsBanned(String idOrIP);
    private String SQL_Query_SelectedDatabase();
    public class Fields
    {
        public String name { get; set; }
        public String value { get; set; }
        public bool inline { get; set; }
        public Fields(String name, String value, bool inline);
    }

    private void SaveDataFiles(TypeAction type);
    private new void LoadDefaultMessages();
    private String Format(Int32 units, String form1, String form2, String form3);
    private String SQL_Query_UpdateUser(TypeAction typeBanned);
    private void Unload();
    private void IsAvailabilityConnection(IPlayer player);
    private void GetUserData(IPlayer player, String ipAddress);
    [ConsoleCommand("kick")]
    private void ConsoleKickCommand(ConsoleSystem.Arg arg);
    private String GetFormatTimeDiscord(String input);
    private String BuildConnectionString(String host, Int32 port, String database, String user, String password);
    private void Init();
    private void Request(String url, String payload, Action<Int32> callback);
    private List<Int32> appIds;
    private String SQL_Query_DeletedDatabase(TypeAction typeUnBanned);
    public String GetLang(String LangKey, String userID, Object[] args);
     void OnPlayerConnected(BasePlayer player);
    private void SetTirifyBan(String steamIdString, String reason);
    private String SQL_Query_GetUserData();
    [ConsoleCommand("ban")]
    private void ConsoleBanCommand(ConsoleSystem.Arg arg);
     void OnUserConnected(IPlayer player);
    private static StringBuilder sb;
    private void SendInfo(BasePlayer player, String message);
    private void ProcessStorageContainer(BaseEntity entityPlayer, Action<StorageContainer> action);
     void HandlerVpnApiIo(Int32 code, String response, String adress);
    private void CheckSteamController(IPlayer player);
    private void TeamAdded(RelationshipManager.PlayerTeam team);
    private void SendChat(String message, BasePlayer player, Chat.ChatChannel channel);
    [ChatCommand("unban")]
    private void ChatUnBanCommand(BasePlayer ownerCommand, String cmd, String[] arg);
     object OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player);
    private Boolean IsOpenMySQL();
    [ConsoleCommand("unban")]
    private void ConsoleUnBanCommand(ConsoleSystem.Arg arg);
    [ChatCommand("kick")]
    private void ChatKickCommand(BasePlayer ownerCommand, String cmd, String[] arg);
    private void SQL_GetData();
    private class Configuration
    {
        [JsonProperty(LanguageEn ? "Server data configuration" : "Настройка данных сервера")]
        public GeneralSetting generalSetting;
        [JsonProperty(LanguageEn ? "Setting up MySQL connection" : "Настройка подключения MySQL")]
        public MySQLSetting mysqlConnected;
        [JsonProperty(LanguageEn ? "Setting up interaction with Steam" : "Настройка взаимодействия со Steam")]
        public SteamSetting steamSetting;
        [JsonProperty(LanguageEn ? "Setting up VPN protection" : "Настройка защиты от VPN")]
        public VPNSetting vpnSetting;
        [JsonProperty(LanguageEn ? "Setting up the blocking system" : "Настройка системы блокировки")]
        public BannedSetting bannedSetting;
        internal class GeneralSetting
        {
            [JsonProperty(LanguageEn ? "Server name" : "Название сервера")]
            public String serverName;
            [JsonProperty(LanguageEn ? "IP:PORT server" : "IP:Port сервера")]
            public String serverAdress;
            [JsonProperty(LanguageEn ? "Additional configuration" : "Дополнительная настройка")]
            public AdditionalSetting additionalSetting;
            [JsonProperty(LanguageEn ? "Setting IQChat" : "Настройка IQChat")]
            public IQChatSetting iqchatSetting;
            [JsonProperty(LanguageEn ? "Setting Discord" : "Настройка Discord")]
            public DiscordSetting discordSetting;
            internal class AdditionalSetting
            {
                [JsonProperty(LanguageEn ? "Sound effect for all players to notify when a player is blocked ('Notify all players' should be enabled) (leave it blank - if you don't need it)" : "Звуковой эффект для всех игроков для уведомления о блокировке игрока (должно быть включено 'Уведомлять всех игроков') (оставьте пустым - если вам не нужно это)")]
                public String effectAlertAllPlayers;
                [JsonProperty(LanguageEn ? "Notify all players when a player is blocked" : "Уведомлять всех игроков о блокировке игрока")]
                public Boolean useAlertAllPlayers;
                [JsonProperty(LanguageEn ? "Notify all players about player's kick" : "Уведомлять всех игроков о кике игрока")]
                public Boolean useAlertKickPlayer;
                [JsonProperty(LanguageEn ? "Add information about blocked teammates to the blocking notification" : "Добавлять в уведомление о блокировке - информацию о заблокированных тиммейтах")]
                public Boolean useAlertBlockTeam;
            }

            internal class IQChatSetting
            {
                [JsonProperty(LanguageEn ? "IQChat: Chat Prefix" : "IQChat : Префикс в чате")]
                public String customPrefix;
                [JsonProperty(LanguageEn ? "IQChat: Chat Avatar (Use Steam64ID)" : "IQChat : Аватарка в чате (Используйте Steam64ID)")]
                public String customAvatar;
            }

            internal class DiscordSetting
            {
                [JsonProperty(LanguageEn ? "Discord notification setting for player ban" : "Настройка уведомления в Discord о блокировке игрока")]
                public AlertBanned alertBanned;
                internal class AlertBanned
                {
                    [JsonProperty(LanguageEn ? "Webhooks: For banned notifications" : "Webhooks : Для уведомлений о блокировке")]
                    public String webHookBanned;
                    [JsonProperty(LanguageEn ? "Include home information of the banned player in the notification" : "Добавлять в уведомление дома где прописан заблокированный игрок")]
                    public Boolean cupboardAuthInfo;
                    [JsonProperty(LanguageEn ? "Additional notification setting for players who played with the banned player" : "Настройка дополнительного уведомления о тех с кем играл заблокированный")]
                    public TeamsAlert teamsAlert;
                    internal class TeamsAlert
                    {
                        [JsonProperty(LanguageEn ? "Include players who played with the banned player in the notification" : "Добавлять в уведомление игроков с которыми играл забаненный")]
                        public Boolean saveInfoTeams;
                        [JsonProperty(LanguageEn ? "Time spent together with the banned player to be included in the notification (Format: 1s/1m/1h/1d)" : "Сколько времени должны провести вместе забаненный с игроком для его отображения в уведомлении (В формате 1s/1m/1h/1d)")]
                        public String formatTimePlaying;
                    }

                }

                [JsonProperty(LanguageEn ? "Webhooks : For unbanned notifications" : "Webhooks : Для уведомлений о разблокировке")]
                public String webHookUnBanned;
                [JsonProperty(LanguageEn ? "Webhooks : For kicked notifications" : "Webhooks : Для уведомлений о киках")]
                public String webHookKicked;
                [JsonProperty(LanguageEn ? "Webhooks : For notifications about a blocked player's login attempt" : "Webhooks : Для уведомлений о попытке входа заблокированного игрока")]
                public String webHookConnectedBanned;
                [JsonProperty(LanguageEn ? "Link to the image in Discord" : "Ссылка на изображение в Discord")]
                public String imageLink;
            }

        }

        internal class SteamSetting
        {
            [JsonProperty(LanguageEn ? "Please provide the Steam API Key for the operation of these functions (Obtain it here - https://steamcommunity.com/dev/apikey)" : "Укажите SteamApiKey для работы данных функций (Взять тут - https://steamcommunity.com/dev/apikey)")]
            public String steamApiKey;
            [JsonProperty(LanguageEn ? "The minimum amount of time since Steam account registration for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество времени с регистрации аккаунта Steam для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
            public String minSteamRegisterTime;
            [JsonProperty(LanguageEn ? "The minimum amount of playtime in RUST required for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество отыгранного времени в RUST для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
            public String minPlayGameTime;
        }

        internal class MySQLSetting
        {
            [JsonProperty(LanguageEn ? "Use MySQL database (true - yes/false - no)" : "Использовать базу-данных MySQL (true - да/false - нет)")]
            public Boolean useMySQL;
            [JsonProperty(LanguageEn ? "Host (IP-Address)" : "Хост (IP-Address)")]
            public String dbIP;
            [JsonProperty(LanguageEn ? "Port (default 3306)" : "Порт (стандартно 3306)")]
            public String dbPort;
            [JsonProperty(LanguageEn ? "Database name" : "Имя базы данных")]
            public String dbName;
            [JsonProperty(LanguageEn ? "Username" : "Имя пользователя")]
            public String dbUser;
            [JsonProperty(LanguageEn ? "Password" : "Пароль")]
            public String dbPassword;
            [JsonProperty(LanguageEn ? "Table name" : "Название таблицы")]
            public String dbTableName;
        }

        internal class VPNSetting
        {
            [JsonProperty(LanguageEn ? "Saving 'Good IPs' to avoid reusing requests on the player" : "Сохранять `Хорошие IP`, чтобы не тратить запросы повторно на игрока")]
            public Boolean useSaveGodIps;
            [JsonProperty(LanguageEn ? "The number of detects for kicking a player for VPN (if you use more than 1 service for VPN checking)" : "Количество детектов для кика игрока за VPN (Если вы испольузете более 1 сервиса на проверку VPN)")]
            public Int32 countDetectedToKickInVPN;
            [JsonProperty(LanguageEn ? "Token https://iphub.info/" : "Токен от https://iphub.info/")]
            public String iPHubToken;
            [JsonProperty(LanguageEn ? "Token https://proxycheck.io/" : "Токен от https://proxycheck.io/")]
            public String proxyCheckIo;
            [JsonProperty(LanguageEn ? "Token https://vpnapi.io/" : "Токен от https://vpnapi.io/")]
            public String vpnApiIoToken;
            [JsonProperty(LanguageEn ? "IP Whitelist for ignoring VPN" : "Белый список IP для игнорирования VPN")]
            public List<String> vpnWhiteList;
        }

        internal class BannedSetting
        {
            [JsonProperty(LanguageEn ? "TirifyGamePluginRust : Block the player by hardware using Tirify if the lock is issued forever (true - yes/false - no)" : "TirifyGamePluginRust : Блокировать игрока по железу с помощью Tirify если блокировка выдана навсегда (true - да/false - нет)")]
            public Boolean tirifyBannedReplace;
            [JsonProperty(LanguageEn ? "Kill player after being banned on the server" : "Убивать игрока после блокировки на сервере")]
            public Boolean useKilledPlayer;
            [JsonProperty(LanguageEn ? "Setting for banning teammates for playing with the offender" : "Настройка блокировки тиммейтов за игру с нарушителем")]
            public TeamBannedSetting teamBannedSetting;
            [JsonProperty(LanguageEn ? "Setting for destroying player's objects after being banned" : "Настройка уничтожения объектов игрока после блокировки")]
            public DestroyedAfterBannedSetting destroyedAfterBannedSetting;
            internal class TeamBannedSetting
            {
                [JsonProperty(LanguageEn ? "Specify the time played with the offender for issuing a ban. Format 1s/1m/1h/1d" : "Укажите время игры с нарушителем для выдачи блокировки. Формат 1s/1m/1h/1d")]
                public String timeDeteckGamingTeamMemory;
                [JsonProperty(LanguageEn ? "Ban teammates of the banned player" : "Блокировать тиммейтов заблокированного игрока")]
                public Boolean useBlockTeam;
                [JsonProperty(LanguageEn ? "Specify the ban time for teammates for playing with the offender. Format 1s/1m/1h/1d (Leave empty for issuing a permanent ban)" : "Укажите время блокировки тиммейтов за игру с нарушителем. Формат 1s/1m/1h/1d (Оставьте пустым - для выдачи блокировки навсегда)")]
                public String timeBlockTeam;
            }

            internal class DestroyedAfterBannedSetting
            {
                [JsonProperty(LanguageEn ? "Use the function to delete player's objects after being banned" : "Использовать функцию удаления объектов игрока после блокировки")]
                public Boolean useDestroyObjects;
                [JsonProperty(LanguageEn ? "Type of object destruction: 0 - All objects, 1 - All objects and dropping items from containers on the ground, 2 - Only locks, 3 - Only boxes, 4 - Only boxes with dropping items from them" : "Тип уничтожения объектов : 0 - Все объекты, 1 - Все объекты и выбрасывание предметов из контейнеров на пол, 2 - Только замки, 3 - Только ящики, 4 - Только ящики с выбрасыванием предметов из них")]
                public TypeDestroy typeDestroyed;
                [JsonProperty(LanguageEn ? "Notify in chat about squares of destroyed player's objects" : "Уведомлять в чате о квадратах разрушенных объектах игрока")]
                public Boolean useAlertGridHomes;
                [JsonProperty(LanguageEn ? "Setting for displaying markers on the G-Map" : "Настройка отображения маркеров на G-Map")]
                public MapMarkerDestroyedObject mapMarkerDestroyedObjectSetting;
                internal class MapMarkerDestroyedObject
                {
                    [JsonProperty(LanguageEn ? "Display points with destroyed objects on the map" : "Отображать на карте точки с разрушенными объектами")]
                    public Boolean useMapMarkerDestroyedObjectPlayer;
                    [JsonProperty(LanguageEn ? "Main marker color" : "Основной цвет маркера")]
                    public String mainColorMarker;
                    [JsonProperty(LanguageEn ? "Outline marker color" : "Цвет обводки маркера")]
                    public String additionalColorMarker;
                    [JsonProperty(LanguageEn ? "Marker radius on the map" : "Радиус маркера на карте")]
                    public Single radiusMarker;
                    [JsonProperty(LanguageEn ? "How long the marker will be displayed. Format 1s/1m/1h/1d" : "Сколько будет отображаться маркер. Формат 1s/1m/1h/1d")]
                    public String markerLifeTime;
                }

            }

        }

        public static Configuration GetNewConfiguration();
    }

    private Boolean useIpHub;
    private List<String> DestroyObjectBanned(IPlayer bannedPlayer, String bannedDisplayName);
    [PluginReference]
    private Plugin IQChat;
    private Plugin RustApp;
    private Plugin IQTeleportation;
    private Plugin TirifyGamePluginRust;
    private void KickUser(IPlayer iTarget, String reason, BasePlayer ownerCommand);
    private const String GenericPrefab;
    public class FancyMessage
    {
        public String content { get; set; }
        public Boolean tts { get; set; }
        public Embeds[] embeds { get; set; }
        public class Embeds
        {
            public String title { get; set; }
            public Int32 color { get; set; }
            public List<Fields> fields { get; set; }
            public Footer footer { get; set; }
            public Authors author { get; set; }
            public Embeds(String title, Int32 color, List<Fields> fields, Authors author, Footer footer);
        }

        public FancyMessage(String content, bool tts, Embeds[] embeds);
        public String toJSON();
    }

    private void CreateMapMarker(Vector3 position, String namePlayer);
    private void RunEffect(BasePlayer player, String effectPath);
    private String SQL_Query_InsertUser();
    private void UnBanCommand(BasePlayer ownerCommand, String[] arg);
    private List<IPlayer> BannedTeams(UInt64 playerID, BasePlayer ownerCommand);
     void ReadData();
    private void SQL_OpenConnection();
     void HandlerIPHub(Int32 code, String response, String adress);
    private void RustApp_OnPaidAnnounceBan(String steamID, List<String> targets, String reason);
    private List<MarkerRepository> mapMarkers;
    private void ProcessBanData(IPlayer player, PlayerInfo playerData, TypeAction typeAction, String userID, String ipAddress);
    private void SetTirifyUnBan(String steamIdString, String reason);
    private void OnServerShutdown();
    private Dictionary<UInt64, Double> GetTeamsBannedPlayer(UInt64 bannedPlayer);
    protected override void LoadDefaultConfig();
    private Boolean useVpnApi;
    private void ResponseError(String nameService, String message);
    public class MarkerRepository
    {
        public VendingMachineMapMarker vending;
        public MapMarkerGenericRadius marker;
        public DateTime timeSetMarker;
    }

    private const String permissionsKick;
    private void HandleGameTimes(IPlayer player, Int64? accountCreationDate, Int32 code, String response);
    private void CheckPlayerUsedVPN(IPlayer player);
    private void UnBanUserOrIp(String valueInfo, PlayerInfo infoUser, TypeAction type, Double unBanTime, BasePlayer ownerPlayer);
    private void LeaveTeamPlayer(UInt64 targetPlayer);
    private readonly Core.MySql.Libraries.MySql sqlLibrary;
    private void SendDiscord(List<Fields> fields, TypeAlertDiscord typeAlertDiscord, String webHooks);
    private String GetKickReason(PlayerInfo playerData, string userID);
    private const String permissionsIgnoreVPN;
    private void DeleteDatabase(String idOrIP, TypeAction typeUnBanned);
    private Int32 maxDetectedVpn;
    private void LoadDataFiles(TypeAction type);
    private void BanUser(UInt64 userID, IPlayer iPlayer, String reason, Double banTime, BasePlayer ownerCommand, Boolean skipTeam);
    private const Boolean LanguageEn;
    private readonly Dictionary<String, ProcessCheckVPN> ipListChecked;
    private const String permissionIgnoreBan;
    private Boolean useProxyCheck;
     void OnTeamDisbanded(RelationshipManager.PlayerTeam team);
    private Timer timerUpdateMarkers;
    public class Authors
    {
        public String name { get; set; }
        public String url { get; set; }
        public String icon_url { get; set; }
        public String proxy_icon_url { get; set; }
        public Authors(String name, String url, String icon_url, String proxy_icon_url);
    }

    private static readonly DateTime epoch;
    private void InserOrUpdateDatabase(String idOrIP, TypeAction typeBanned, IPlayer mbPlayer);
}

private class TeamLocalMemory
{
    public Double firstJoin;
    public Double lastRemoved;
}

public class Footer
{
    public String text { get; set; }
    public String icon_url { get; set; }
    public String proxy_icon_url { get; set; }
    public Footer(String text, String icon_url, String proxy_icon_url);
}

private class ProcessCheckVPN
{
    public Int32 detectedVpn;
    public Boolean isCompleteProxyCheck;
    public Boolean isCompleteVpnApi;
    public Boolean isCompleteIPHub;
}

private class PlayerInfo : SplitDatafile<PlayerInfo>
{
    private const String BaseFolder;
    private const String UserFolder;
    private const String IpFolder;
    private static String GetFolder(TypeAction typeBanned);
    public static PlayerInfo Save(String idOrIp, TypeAction type);
    public static void Import(String idOrIp, PlayerInfo data, TypeAction type);
    public static void Remove(String idOrIp, TypeAction type);
    public static PlayerInfo Get(String idOrIp, TypeAction type);
    public static PlayerInfo Load(String idOrIp, TypeAction type);
    public static PlayerInfo Clear(String idOrIp, TypeAction type);
    public static PlayerInfo GetOrLoad(String idOrIp, TypeAction type);
    public static PlayerInfo GetOrCreate(String idOrIp, TypeAction type);
    public static String[] GetFiles(TypeAction type);
    public Boolean permanent;
    public Double timeUnbanned;
    public String reason;
    public String serverName;
    public String serverAdress;
    public String owner;
    public List<History> nameHistory;
    public List<History> ipHistory;
    public List<History> steamIdHistory;
    internal class History
    {
        public String value;
        public String time;
    }

    [JsonIgnore]
    public Double GetUnbanTime { get; set; }
    public Boolean IsBanned();
    public void UpdateHistory(TypeHistoryInfo typeInfo, String value);
    private List<History> GetHistoryList(TypeHistoryInfo typeInfo);
    private Boolean IsExistsValueHistory(List<History> histories, String value);
}

internal class History
{
    public String value;
    public String time;
}

private abstract class SplitDatafile
{
    public static Dictionary<String, T> _players;
    public static Dictionary<String, T> _ipAdresses;
    public static Dictionary<String, T> _savedItems;
    private static Dictionary<String, T> GetRepository(TypeAction type);
    protected static void Import(TypeAction type, String baseFolder, String userId, T data);
    protected static String[] GetFiles(String baseFolder);
    protected static T Save(TypeAction type, string baseFolder, String userId);
    protected static void Remove(TypeAction type, string baseFolder, String userId);
    protected static T Get(TypeAction type, string baseFolder, String userId);
    protected static T Load(TypeAction type, String baseFolder, String userId);
    protected static T GetOrLoad(TypeAction type, String baseFolder, String userId);
    protected static T GetOrCreate(TypeAction type, String baseFolder, String userId);
    protected static T ClearAndSave(TypeAction type, String baseFolder, String userId);
}

public class Fields
{
    public String name { get; set; }
    public String value { get; set; }
    public bool inline { get; set; }
    public Fields(String name, String value, bool inline);
}

private class Configuration
{
    [JsonProperty(LanguageEn ? "Server data configuration" : "Настройка данных сервера")]
    public GeneralSetting generalSetting;
    [JsonProperty(LanguageEn ? "Setting up MySQL connection" : "Настройка подключения MySQL")]
    public MySQLSetting mysqlConnected;
    [JsonProperty(LanguageEn ? "Setting up interaction with Steam" : "Настройка взаимодействия со Steam")]
    public SteamSetting steamSetting;
    [JsonProperty(LanguageEn ? "Setting up VPN protection" : "Настройка защиты от VPN")]
    public VPNSetting vpnSetting;
    [JsonProperty(LanguageEn ? "Setting up the blocking system" : "Настройка системы блокировки")]
    public BannedSetting bannedSetting;
    internal class GeneralSetting
    {
        [JsonProperty(LanguageEn ? "Server name" : "Название сервера")]
        public String serverName;
        [JsonProperty(LanguageEn ? "IP:PORT server" : "IP:Port сервера")]
        public String serverAdress;
        [JsonProperty(LanguageEn ? "Additional configuration" : "Дополнительная настройка")]
        public AdditionalSetting additionalSetting;
        [JsonProperty(LanguageEn ? "Setting IQChat" : "Настройка IQChat")]
        public IQChatSetting iqchatSetting;
        [JsonProperty(LanguageEn ? "Setting Discord" : "Настройка Discord")]
        public DiscordSetting discordSetting;
        internal class AdditionalSetting
        {
            [JsonProperty(LanguageEn ? "Sound effect for all players to notify when a player is blocked ('Notify all players' should be enabled) (leave it blank - if you don't need it)" : "Звуковой эффект для всех игроков для уведомления о блокировке игрока (должно быть включено 'Уведомлять всех игроков') (оставьте пустым - если вам не нужно это)")]
            public String effectAlertAllPlayers;
            [JsonProperty(LanguageEn ? "Notify all players when a player is blocked" : "Уведомлять всех игроков о блокировке игрока")]
            public Boolean useAlertAllPlayers;
            [JsonProperty(LanguageEn ? "Notify all players about player's kick" : "Уведомлять всех игроков о кике игрока")]
            public Boolean useAlertKickPlayer;
            [JsonProperty(LanguageEn ? "Add information about blocked teammates to the blocking notification" : "Добавлять в уведомление о блокировке - информацию о заблокированных тиммейтах")]
            public Boolean useAlertBlockTeam;
        }

        internal class IQChatSetting
        {
            [JsonProperty(LanguageEn ? "IQChat: Chat Prefix" : "IQChat : Префикс в чате")]
            public String customPrefix;
            [JsonProperty(LanguageEn ? "IQChat: Chat Avatar (Use Steam64ID)" : "IQChat : Аватарка в чате (Используйте Steam64ID)")]
            public String customAvatar;
        }

        internal class DiscordSetting
        {
            [JsonProperty(LanguageEn ? "Discord notification setting for player ban" : "Настройка уведомления в Discord о блокировке игрока")]
            public AlertBanned alertBanned;
            internal class AlertBanned
            {
                [JsonProperty(LanguageEn ? "Webhooks: For banned notifications" : "Webhooks : Для уведомлений о блокировке")]
                public String webHookBanned;
                [JsonProperty(LanguageEn ? "Include home information of the banned player in the notification" : "Добавлять в уведомление дома где прописан заблокированный игрок")]
                public Boolean cupboardAuthInfo;
                [JsonProperty(LanguageEn ? "Additional notification setting for players who played with the banned player" : "Настройка дополнительного уведомления о тех с кем играл заблокированный")]
                public TeamsAlert teamsAlert;
                internal class TeamsAlert
                {
                    [JsonProperty(LanguageEn ? "Include players who played with the banned player in the notification" : "Добавлять в уведомление игроков с которыми играл забаненный")]
                    public Boolean saveInfoTeams;
                    [JsonProperty(LanguageEn ? "Time spent together with the banned player to be included in the notification (Format: 1s/1m/1h/1d)" : "Сколько времени должны провести вместе забаненный с игроком для его отображения в уведомлении (В формате 1s/1m/1h/1d)")]
                    public String formatTimePlaying;
                }

            }

            [JsonProperty(LanguageEn ? "Webhooks : For unbanned notifications" : "Webhooks : Для уведомлений о разблокировке")]
            public String webHookUnBanned;
            [JsonProperty(LanguageEn ? "Webhooks : For kicked notifications" : "Webhooks : Для уведомлений о киках")]
            public String webHookKicked;
            [JsonProperty(LanguageEn ? "Webhooks : For notifications about a blocked player's login attempt" : "Webhooks : Для уведомлений о попытке входа заблокированного игрока")]
            public String webHookConnectedBanned;
            [JsonProperty(LanguageEn ? "Link to the image in Discord" : "Ссылка на изображение в Discord")]
            public String imageLink;
        }

    }

    internal class SteamSetting
    {
        [JsonProperty(LanguageEn ? "Please provide the Steam API Key for the operation of these functions (Obtain it here - https://steamcommunity.com/dev/apikey)" : "Укажите SteamApiKey для работы данных функций (Взять тут - https://steamcommunity.com/dev/apikey)")]
        public String steamApiKey;
        [JsonProperty(LanguageEn ? "The minimum amount of time since Steam account registration for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество времени с регистрации аккаунта Steam для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
        public String minSteamRegisterTime;
        [JsonProperty(LanguageEn ? "The minimum amount of playtime in RUST required for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество отыгранного времени в RUST для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
        public String minPlayGameTime;
    }

    internal class MySQLSetting
    {
        [JsonProperty(LanguageEn ? "Use MySQL database (true - yes/false - no)" : "Использовать базу-данных MySQL (true - да/false - нет)")]
        public Boolean useMySQL;
        [JsonProperty(LanguageEn ? "Host (IP-Address)" : "Хост (IP-Address)")]
        public String dbIP;
        [JsonProperty(LanguageEn ? "Port (default 3306)" : "Порт (стандартно 3306)")]
        public String dbPort;
        [JsonProperty(LanguageEn ? "Database name" : "Имя базы данных")]
        public String dbName;
        [JsonProperty(LanguageEn ? "Username" : "Имя пользователя")]
        public String dbUser;
        [JsonProperty(LanguageEn ? "Password" : "Пароль")]
        public String dbPassword;
        [JsonProperty(LanguageEn ? "Table name" : "Название таблицы")]
        public String dbTableName;
    }

    internal class VPNSetting
    {
        [JsonProperty(LanguageEn ? "Saving 'Good IPs' to avoid reusing requests on the player" : "Сохранять `Хорошие IP`, чтобы не тратить запросы повторно на игрока")]
        public Boolean useSaveGodIps;
        [JsonProperty(LanguageEn ? "The number of detects for kicking a player for VPN (if you use more than 1 service for VPN checking)" : "Количество детектов для кика игрока за VPN (Если вы испольузете более 1 сервиса на проверку VPN)")]
        public Int32 countDetectedToKickInVPN;
        [JsonProperty(LanguageEn ? "Token https://iphub.info/" : "Токен от https://iphub.info/")]
        public String iPHubToken;
        [JsonProperty(LanguageEn ? "Token https://proxycheck.io/" : "Токен от https://proxycheck.io/")]
        public String proxyCheckIo;
        [JsonProperty(LanguageEn ? "Token https://vpnapi.io/" : "Токен от https://vpnapi.io/")]
        public String vpnApiIoToken;
        [JsonProperty(LanguageEn ? "IP Whitelist for ignoring VPN" : "Белый список IP для игнорирования VPN")]
        public List<String> vpnWhiteList;
    }

    internal class BannedSetting
    {
        [JsonProperty(LanguageEn ? "TirifyGamePluginRust : Block the player by hardware using Tirify if the lock is issued forever (true - yes/false - no)" : "TirifyGamePluginRust : Блокировать игрока по железу с помощью Tirify если блокировка выдана навсегда (true - да/false - нет)")]
        public Boolean tirifyBannedReplace;
        [JsonProperty(LanguageEn ? "Kill player after being banned on the server" : "Убивать игрока после блокировки на сервере")]
        public Boolean useKilledPlayer;
        [JsonProperty(LanguageEn ? "Setting for banning teammates for playing with the offender" : "Настройка блокировки тиммейтов за игру с нарушителем")]
        public TeamBannedSetting teamBannedSetting;
        [JsonProperty(LanguageEn ? "Setting for destroying player's objects after being banned" : "Настройка уничтожения объектов игрока после блокировки")]
        public DestroyedAfterBannedSetting destroyedAfterBannedSetting;
        internal class TeamBannedSetting
        {
            [JsonProperty(LanguageEn ? "Specify the time played with the offender for issuing a ban. Format 1s/1m/1h/1d" : "Укажите время игры с нарушителем для выдачи блокировки. Формат 1s/1m/1h/1d")]
            public String timeDeteckGamingTeamMemory;
            [JsonProperty(LanguageEn ? "Ban teammates of the banned player" : "Блокировать тиммейтов заблокированного игрока")]
            public Boolean useBlockTeam;
            [JsonProperty(LanguageEn ? "Specify the ban time for teammates for playing with the offender. Format 1s/1m/1h/1d (Leave empty for issuing a permanent ban)" : "Укажите время блокировки тиммейтов за игру с нарушителем. Формат 1s/1m/1h/1d (Оставьте пустым - для выдачи блокировки навсегда)")]
            public String timeBlockTeam;
        }

        internal class DestroyedAfterBannedSetting
        {
            [JsonProperty(LanguageEn ? "Use the function to delete player's objects after being banned" : "Использовать функцию удаления объектов игрока после блокировки")]
            public Boolean useDestroyObjects;
            [JsonProperty(LanguageEn ? "Type of object destruction: 0 - All objects, 1 - All objects and dropping items from containers on the ground, 2 - Only locks, 3 - Only boxes, 4 - Only boxes with dropping items from them" : "Тип уничтожения объектов : 0 - Все объекты, 1 - Все объекты и выбрасывание предметов из контейнеров на пол, 2 - Только замки, 3 - Только ящики, 4 - Только ящики с выбрасыванием предметов из них")]
            public TypeDestroy typeDestroyed;
            [JsonProperty(LanguageEn ? "Notify in chat about squares of destroyed player's objects" : "Уведомлять в чате о квадратах разрушенных объектах игрока")]
            public Boolean useAlertGridHomes;
            [JsonProperty(LanguageEn ? "Setting for displaying markers on the G-Map" : "Настройка отображения маркеров на G-Map")]
            public MapMarkerDestroyedObject mapMarkerDestroyedObjectSetting;
            internal class MapMarkerDestroyedObject
            {
                [JsonProperty(LanguageEn ? "Display points with destroyed objects on the map" : "Отображать на карте точки с разрушенными объектами")]
                public Boolean useMapMarkerDestroyedObjectPlayer;
                [JsonProperty(LanguageEn ? "Main marker color" : "Основной цвет маркера")]
                public String mainColorMarker;
                [JsonProperty(LanguageEn ? "Outline marker color" : "Цвет обводки маркера")]
                public String additionalColorMarker;
                [JsonProperty(LanguageEn ? "Marker radius on the map" : "Радиус маркера на карте")]
                public Single radiusMarker;
                [JsonProperty(LanguageEn ? "How long the marker will be displayed. Format 1s/1m/1h/1d" : "Сколько будет отображаться маркер. Формат 1s/1m/1h/1d")]
                public String markerLifeTime;
            }

        }

    }

    public static Configuration GetNewConfiguration();
}

internal class GeneralSetting
{
    [JsonProperty(LanguageEn ? "Server name" : "Название сервера")]
    public String serverName;
    [JsonProperty(LanguageEn ? "IP:PORT server" : "IP:Port сервера")]
    public String serverAdress;
    [JsonProperty(LanguageEn ? "Additional configuration" : "Дополнительная настройка")]
    public AdditionalSetting additionalSetting;
    [JsonProperty(LanguageEn ? "Setting IQChat" : "Настройка IQChat")]
    public IQChatSetting iqchatSetting;
    [JsonProperty(LanguageEn ? "Setting Discord" : "Настройка Discord")]
    public DiscordSetting discordSetting;
    internal class AdditionalSetting
    {
        [JsonProperty(LanguageEn ? "Sound effect for all players to notify when a player is blocked ('Notify all players' should be enabled) (leave it blank - if you don't need it)" : "Звуковой эффект для всех игроков для уведомления о блокировке игрока (должно быть включено 'Уведомлять всех игроков') (оставьте пустым - если вам не нужно это)")]
        public String effectAlertAllPlayers;
        [JsonProperty(LanguageEn ? "Notify all players when a player is blocked" : "Уведомлять всех игроков о блокировке игрока")]
        public Boolean useAlertAllPlayers;
        [JsonProperty(LanguageEn ? "Notify all players about player's kick" : "Уведомлять всех игроков о кике игрока")]
        public Boolean useAlertKickPlayer;
        [JsonProperty(LanguageEn ? "Add information about blocked teammates to the blocking notification" : "Добавлять в уведомление о блокировке - информацию о заблокированных тиммейтах")]
        public Boolean useAlertBlockTeam;
    }

    internal class IQChatSetting
    {
        [JsonProperty(LanguageEn ? "IQChat: Chat Prefix" : "IQChat : Префикс в чате")]
        public String customPrefix;
        [JsonProperty(LanguageEn ? "IQChat: Chat Avatar (Use Steam64ID)" : "IQChat : Аватарка в чате (Используйте Steam64ID)")]
        public String customAvatar;
    }

    internal class DiscordSetting
    {
        [JsonProperty(LanguageEn ? "Discord notification setting for player ban" : "Настройка уведомления в Discord о блокировке игрока")]
        public AlertBanned alertBanned;
        internal class AlertBanned
        {
            [JsonProperty(LanguageEn ? "Webhooks: For banned notifications" : "Webhooks : Для уведомлений о блокировке")]
            public String webHookBanned;
            [JsonProperty(LanguageEn ? "Include home information of the banned player in the notification" : "Добавлять в уведомление дома где прописан заблокированный игрок")]
            public Boolean cupboardAuthInfo;
            [JsonProperty(LanguageEn ? "Additional notification setting for players who played with the banned player" : "Настройка дополнительного уведомления о тех с кем играл заблокированный")]
            public TeamsAlert teamsAlert;
            internal class TeamsAlert
            {
                [JsonProperty(LanguageEn ? "Include players who played with the banned player in the notification" : "Добавлять в уведомление игроков с которыми играл забаненный")]
                public Boolean saveInfoTeams;
                [JsonProperty(LanguageEn ? "Time spent together with the banned player to be included in the notification (Format: 1s/1m/1h/1d)" : "Сколько времени должны провести вместе забаненный с игроком для его отображения в уведомлении (В формате 1s/1m/1h/1d)")]
                public String formatTimePlaying;
            }

        }

        [JsonProperty(LanguageEn ? "Webhooks : For unbanned notifications" : "Webhooks : Для уведомлений о разблокировке")]
        public String webHookUnBanned;
        [JsonProperty(LanguageEn ? "Webhooks : For kicked notifications" : "Webhooks : Для уведомлений о киках")]
        public String webHookKicked;
        [JsonProperty(LanguageEn ? "Webhooks : For notifications about a blocked player's login attempt" : "Webhooks : Для уведомлений о попытке входа заблокированного игрока")]
        public String webHookConnectedBanned;
        [JsonProperty(LanguageEn ? "Link to the image in Discord" : "Ссылка на изображение в Discord")]
        public String imageLink;
    }

}

internal class AdditionalSetting
{
    [JsonProperty(LanguageEn ? "Sound effect for all players to notify when a player is blocked ('Notify all players' should be enabled) (leave it blank - if you don't need it)" : "Звуковой эффект для всех игроков для уведомления о блокировке игрока (должно быть включено 'Уведомлять всех игроков') (оставьте пустым - если вам не нужно это)")]
    public String effectAlertAllPlayers;
    [JsonProperty(LanguageEn ? "Notify all players when a player is blocked" : "Уведомлять всех игроков о блокировке игрока")]
    public Boolean useAlertAllPlayers;
    [JsonProperty(LanguageEn ? "Notify all players about player's kick" : "Уведомлять всех игроков о кике игрока")]
    public Boolean useAlertKickPlayer;
    [JsonProperty(LanguageEn ? "Add information about blocked teammates to the blocking notification" : "Добавлять в уведомление о блокировке - информацию о заблокированных тиммейтах")]
    public Boolean useAlertBlockTeam;
}

internal class IQChatSetting
{
    [JsonProperty(LanguageEn ? "IQChat: Chat Prefix" : "IQChat : Префикс в чате")]
    public String customPrefix;
    [JsonProperty(LanguageEn ? "IQChat: Chat Avatar (Use Steam64ID)" : "IQChat : Аватарка в чате (Используйте Steam64ID)")]
    public String customAvatar;
}

internal class DiscordSetting
{
    [JsonProperty(LanguageEn ? "Discord notification setting for player ban" : "Настройка уведомления в Discord о блокировке игрока")]
    public AlertBanned alertBanned;
    internal class AlertBanned
    {
        [JsonProperty(LanguageEn ? "Webhooks: For banned notifications" : "Webhooks : Для уведомлений о блокировке")]
        public String webHookBanned;
        [JsonProperty(LanguageEn ? "Include home information of the banned player in the notification" : "Добавлять в уведомление дома где прописан заблокированный игрок")]
        public Boolean cupboardAuthInfo;
        [JsonProperty(LanguageEn ? "Additional notification setting for players who played with the banned player" : "Настройка дополнительного уведомления о тех с кем играл заблокированный")]
        public TeamsAlert teamsAlert;
        internal class TeamsAlert
        {
            [JsonProperty(LanguageEn ? "Include players who played with the banned player in the notification" : "Добавлять в уведомление игроков с которыми играл забаненный")]
            public Boolean saveInfoTeams;
            [JsonProperty(LanguageEn ? "Time spent together with the banned player to be included in the notification (Format: 1s/1m/1h/1d)" : "Сколько времени должны провести вместе забаненный с игроком для его отображения в уведомлении (В формате 1s/1m/1h/1d)")]
            public String formatTimePlaying;
        }

    }

    [JsonProperty(LanguageEn ? "Webhooks : For unbanned notifications" : "Webhooks : Для уведомлений о разблокировке")]
    public String webHookUnBanned;
    [JsonProperty(LanguageEn ? "Webhooks : For kicked notifications" : "Webhooks : Для уведомлений о киках")]
    public String webHookKicked;
    [JsonProperty(LanguageEn ? "Webhooks : For notifications about a blocked player's login attempt" : "Webhooks : Для уведомлений о попытке входа заблокированного игрока")]
    public String webHookConnectedBanned;
    [JsonProperty(LanguageEn ? "Link to the image in Discord" : "Ссылка на изображение в Discord")]
    public String imageLink;
}

internal class AlertBanned
{
    [JsonProperty(LanguageEn ? "Webhooks: For banned notifications" : "Webhooks : Для уведомлений о блокировке")]
    public String webHookBanned;
    [JsonProperty(LanguageEn ? "Include home information of the banned player in the notification" : "Добавлять в уведомление дома где прописан заблокированный игрок")]
    public Boolean cupboardAuthInfo;
    [JsonProperty(LanguageEn ? "Additional notification setting for players who played with the banned player" : "Настройка дополнительного уведомления о тех с кем играл заблокированный")]
    public TeamsAlert teamsAlert;
    internal class TeamsAlert
    {
        [JsonProperty(LanguageEn ? "Include players who played with the banned player in the notification" : "Добавлять в уведомление игроков с которыми играл забаненный")]
        public Boolean saveInfoTeams;
        [JsonProperty(LanguageEn ? "Time spent together with the banned player to be included in the notification (Format: 1s/1m/1h/1d)" : "Сколько времени должны провести вместе забаненный с игроком для его отображения в уведомлении (В формате 1s/1m/1h/1d)")]
        public String formatTimePlaying;
    }

}

internal class TeamsAlert
{
    [JsonProperty(LanguageEn ? "Include players who played with the banned player in the notification" : "Добавлять в уведомление игроков с которыми играл забаненный")]
    public Boolean saveInfoTeams;
    [JsonProperty(LanguageEn ? "Time spent together with the banned player to be included in the notification (Format: 1s/1m/1h/1d)" : "Сколько времени должны провести вместе забаненный с игроком для его отображения в уведомлении (В формате 1s/1m/1h/1d)")]
    public String formatTimePlaying;
}

internal class SteamSetting
{
    [JsonProperty(LanguageEn ? "Please provide the Steam API Key for the operation of these functions (Obtain it here - https://steamcommunity.com/dev/apikey)" : "Укажите SteamApiKey для работы данных функций (Взять тут - https://steamcommunity.com/dev/apikey)")]
    public String steamApiKey;
    [JsonProperty(LanguageEn ? "The minimum amount of time since Steam account registration for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество времени с регистрации аккаунта Steam для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
    public String minSteamRegisterTime;
    [JsonProperty(LanguageEn ? "The minimum amount of playtime in RUST required for logging into the server. Format: 1m/1h/1d (leave empty if you don't need this function)" : "Минимальное количество отыгранного времени в RUST для входа на сервер. Формат 1m/1h/1d (оставьте пустым - если вам не нужна эта функция)")]
    public String minPlayGameTime;
}

internal class MySQLSetting
{
    [JsonProperty(LanguageEn ? "Use MySQL database (true - yes/false - no)" : "Использовать базу-данных MySQL (true - да/false - нет)")]
    public Boolean useMySQL;
    [JsonProperty(LanguageEn ? "Host (IP-Address)" : "Хост (IP-Address)")]
    public String dbIP;
    [JsonProperty(LanguageEn ? "Port (default 3306)" : "Порт (стандартно 3306)")]
    public String dbPort;
    [JsonProperty(LanguageEn ? "Database name" : "Имя базы данных")]
    public String dbName;
    [JsonProperty(LanguageEn ? "Username" : "Имя пользователя")]
    public String dbUser;
    [JsonProperty(LanguageEn ? "Password" : "Пароль")]
    public String dbPassword;
    [JsonProperty(LanguageEn ? "Table name" : "Название таблицы")]
    public String dbTableName;
}

internal class VPNSetting
{
    [JsonProperty(LanguageEn ? "Saving 'Good IPs' to avoid reusing requests on the player" : "Сохранять `Хорошие IP`, чтобы не тратить запросы повторно на игрока")]
    public Boolean useSaveGodIps;
    [JsonProperty(LanguageEn ? "The number of detects for kicking a player for VPN (if you use more than 1 service for VPN checking)" : "Количество детектов для кика игрока за VPN (Если вы испольузете более 1 сервиса на проверку VPN)")]
    public Int32 countDetectedToKickInVPN;
    [JsonProperty(LanguageEn ? "Token https://iphub.info/" : "Токен от https://iphub.info/")]
    public String iPHubToken;
    [JsonProperty(LanguageEn ? "Token https://proxycheck.io/" : "Токен от https://proxycheck.io/")]
    public String proxyCheckIo;
    [JsonProperty(LanguageEn ? "Token https://vpnapi.io/" : "Токен от https://vpnapi.io/")]
    public String vpnApiIoToken;
    [JsonProperty(LanguageEn ? "IP Whitelist for ignoring VPN" : "Белый список IP для игнорирования VPN")]
    public List<String> vpnWhiteList;
}

internal class BannedSetting
{
    [JsonProperty(LanguageEn ? "TirifyGamePluginRust : Block the player by hardware using Tirify if the lock is issued forever (true - yes/false - no)" : "TirifyGamePluginRust : Блокировать игрока по железу с помощью Tirify если блокировка выдана навсегда (true - да/false - нет)")]
    public Boolean tirifyBannedReplace;
    [JsonProperty(LanguageEn ? "Kill player after being banned on the server" : "Убивать игрока после блокировки на сервере")]
    public Boolean useKilledPlayer;
    [JsonProperty(LanguageEn ? "Setting for banning teammates for playing with the offender" : "Настройка блокировки тиммейтов за игру с нарушителем")]
    public TeamBannedSetting teamBannedSetting;
    [JsonProperty(LanguageEn ? "Setting for destroying player's objects after being banned" : "Настройка уничтожения объектов игрока после блокировки")]
    public DestroyedAfterBannedSetting destroyedAfterBannedSetting;
    internal class TeamBannedSetting
    {
        [JsonProperty(LanguageEn ? "Specify the time played with the offender for issuing a ban. Format 1s/1m/1h/1d" : "Укажите время игры с нарушителем для выдачи блокировки. Формат 1s/1m/1h/1d")]
        public String timeDeteckGamingTeamMemory;
        [JsonProperty(LanguageEn ? "Ban teammates of the banned player" : "Блокировать тиммейтов заблокированного игрока")]
        public Boolean useBlockTeam;
        [JsonProperty(LanguageEn ? "Specify the ban time for teammates for playing with the offender. Format 1s/1m/1h/1d (Leave empty for issuing a permanent ban)" : "Укажите время блокировки тиммейтов за игру с нарушителем. Формат 1s/1m/1h/1d (Оставьте пустым - для выдачи блокировки навсегда)")]
        public String timeBlockTeam;
    }

    internal class DestroyedAfterBannedSetting
    {
        [JsonProperty(LanguageEn ? "Use the function to delete player's objects after being banned" : "Использовать функцию удаления объектов игрока после блокировки")]
        public Boolean useDestroyObjects;
        [JsonProperty(LanguageEn ? "Type of object destruction: 0 - All objects, 1 - All objects and dropping items from containers on the ground, 2 - Only locks, 3 - Only boxes, 4 - Only boxes with dropping items from them" : "Тип уничтожения объектов : 0 - Все объекты, 1 - Все объекты и выбрасывание предметов из контейнеров на пол, 2 - Только замки, 3 - Только ящики, 4 - Только ящики с выбрасыванием предметов из них")]
        public TypeDestroy typeDestroyed;
        [JsonProperty(LanguageEn ? "Notify in chat about squares of destroyed player's objects" : "Уведомлять в чате о квадратах разрушенных объектах игрока")]
        public Boolean useAlertGridHomes;
        [JsonProperty(LanguageEn ? "Setting for displaying markers on the G-Map" : "Настройка отображения маркеров на G-Map")]
        public MapMarkerDestroyedObject mapMarkerDestroyedObjectSetting;
        internal class MapMarkerDestroyedObject
        {
            [JsonProperty(LanguageEn ? "Display points with destroyed objects on the map" : "Отображать на карте точки с разрушенными объектами")]
            public Boolean useMapMarkerDestroyedObjectPlayer;
            [JsonProperty(LanguageEn ? "Main marker color" : "Основной цвет маркера")]
            public String mainColorMarker;
            [JsonProperty(LanguageEn ? "Outline marker color" : "Цвет обводки маркера")]
            public String additionalColorMarker;
            [JsonProperty(LanguageEn ? "Marker radius on the map" : "Радиус маркера на карте")]
            public Single radiusMarker;
            [JsonProperty(LanguageEn ? "How long the marker will be displayed. Format 1s/1m/1h/1d" : "Сколько будет отображаться маркер. Формат 1s/1m/1h/1d")]
            public String markerLifeTime;
        }

    }

}

internal class TeamBannedSetting
{
    [JsonProperty(LanguageEn ? "Specify the time played with the offender for issuing a ban. Format 1s/1m/1h/1d" : "Укажите время игры с нарушителем для выдачи блокировки. Формат 1s/1m/1h/1d")]
    public String timeDeteckGamingTeamMemory;
    [JsonProperty(LanguageEn ? "Ban teammates of the banned player" : "Блокировать тиммейтов заблокированного игрока")]
    public Boolean useBlockTeam;
    [JsonProperty(LanguageEn ? "Specify the ban time for teammates for playing with the offender. Format 1s/1m/1h/1d (Leave empty for issuing a permanent ban)" : "Укажите время блокировки тиммейтов за игру с нарушителем. Формат 1s/1m/1h/1d (Оставьте пустым - для выдачи блокировки навсегда)")]
    public String timeBlockTeam;
}

internal class DestroyedAfterBannedSetting
{
    [JsonProperty(LanguageEn ? "Use the function to delete player's objects after being banned" : "Использовать функцию удаления объектов игрока после блокировки")]
    public Boolean useDestroyObjects;
    [JsonProperty(LanguageEn ? "Type of object destruction: 0 - All objects, 1 - All objects and dropping items from containers on the ground, 2 - Only locks, 3 - Only boxes, 4 - Only boxes with dropping items from them" : "Тип уничтожения объектов : 0 - Все объекты, 1 - Все объекты и выбрасывание предметов из контейнеров на пол, 2 - Только замки, 3 - Только ящики, 4 - Только ящики с выбрасыванием предметов из них")]
    public TypeDestroy typeDestroyed;
    [JsonProperty(LanguageEn ? "Notify in chat about squares of destroyed player's objects" : "Уведомлять в чате о квадратах разрушенных объектах игрока")]
    public Boolean useAlertGridHomes;
    [JsonProperty(LanguageEn ? "Setting for displaying markers on the G-Map" : "Настройка отображения маркеров на G-Map")]
    public MapMarkerDestroyedObject mapMarkerDestroyedObjectSetting;
    internal class MapMarkerDestroyedObject
    {
        [JsonProperty(LanguageEn ? "Display points with destroyed objects on the map" : "Отображать на карте точки с разрушенными объектами")]
        public Boolean useMapMarkerDestroyedObjectPlayer;
        [JsonProperty(LanguageEn ? "Main marker color" : "Основной цвет маркера")]
        public String mainColorMarker;
        [JsonProperty(LanguageEn ? "Outline marker color" : "Цвет обводки маркера")]
        public String additionalColorMarker;
        [JsonProperty(LanguageEn ? "Marker radius on the map" : "Радиус маркера на карте")]
        public Single radiusMarker;
        [JsonProperty(LanguageEn ? "How long the marker will be displayed. Format 1s/1m/1h/1d" : "Сколько будет отображаться маркер. Формат 1s/1m/1h/1d")]
        public String markerLifeTime;
    }

}

internal class MapMarkerDestroyedObject
{
    [JsonProperty(LanguageEn ? "Display points with destroyed objects on the map" : "Отображать на карте точки с разрушенными объектами")]
    public Boolean useMapMarkerDestroyedObjectPlayer;
    [JsonProperty(LanguageEn ? "Main marker color" : "Основной цвет маркера")]
    public String mainColorMarker;
    [JsonProperty(LanguageEn ? "Outline marker color" : "Цвет обводки маркера")]
    public String additionalColorMarker;
    [JsonProperty(LanguageEn ? "Marker radius on the map" : "Радиус маркера на карте")]
    public Single radiusMarker;
    [JsonProperty(LanguageEn ? "How long the marker will be displayed. Format 1s/1m/1h/1d" : "Сколько будет отображаться маркер. Формат 1s/1m/1h/1d")]
    public String markerLifeTime;
}

public class FancyMessage
{
    public String content { get; set; }
    public Boolean tts { get; set; }
    public Embeds[] embeds { get; set; }
    public class Embeds
    {
        public String title { get; set; }
        public Int32 color { get; set; }
        public List<Fields> fields { get; set; }
        public Footer footer { get; set; }
        public Authors author { get; set; }
        public Embeds(String title, Int32 color, List<Fields> fields, Authors author, Footer footer);
    }

    public FancyMessage(String content, bool tts, Embeds[] embeds);
    public String toJSON();
}

public class Embeds
{
    public String title { get; set; }
    public Int32 color { get; set; }
    public List<Fields> fields { get; set; }
    public Footer footer { get; set; }
    public Authors author { get; set; }
    public Embeds(String title, Int32 color, List<Fields> fields, Authors author, Footer footer);
}

public class MarkerRepository
{
    public VendingMachineMapMarker vending;
    public MapMarkerGenericRadius marker;
    public DateTime timeSetMarker;
}

public class Authors
{
    public String name { get; set; }
    public String url { get; set; }
    public String icon_url { get; set; }
    public String proxy_icon_url { get; set; }
    public Authors(String name, String url, String icon_url, String proxy_icon_url);
}


```

---

## IQBearRide

```csharp
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Rust;
using Rust.Ai;
using UnityEngine;
using VLB;
using Color = UnityEngine.Color;
using Debug = UnityEngine.Debug;
using System.Text;
using CompanionServer.Handlers;
using Time = UnityEngine.Time;

Oxide.Plugins
[Info("IQBearRide", "BadMandarin/ Support: Mercury", "0.0.52")]
[Description("IQBearRide")]
 class IQBearRide : RustPlugin
{
    [PluginReference]
     Plugin IQChat;
    public void SendChat(string Message, BasePlayer player, ConVar.Chat.ChatChannel channel);
    private const String PermissionsGiveBear;
    private const String PermissionsGiveTeddyBear;
    private static IQBearRide _plugin;
    private static bool _unloading;
    private static Dictionary<uint, BearController> _bearControllers;
     void OnServerInitialized();
     void Init();
     void OnServerSave();
     void Unload();
     object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo);
     void OnEntitySpawned(BaseCorpse corpse);
     void OnEntityKill(BaseNetworkable entity);
    private void OnEntityDismounted(BaseVehicleSeat chair, BasePlayer player);
     void OnEntityBuilt(Planner plan, GameObject go);
    private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item);
     object OnMaxStackable(Item item);
     object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem);
    [ConsoleCommand("UI_BearControl")]
    private void Console_BearControl(ConsoleSystem.Arg arg);
    [ConsoleCommand("iqbr.bear")]
    private void Console_BearAdd(ConsoleSystem.Arg arg);
    [ConsoleCommand("iqbr.teddy")]
    private void Console_YoungBearAdd(ConsoleSystem.Arg arg);
    private static bool IsFriend(ulong player, ulong friend);
    private void OpenContainer(BasePlayer player, ItemContainer container, int capacity);
    private static double GetCurrentTime();
    public static string GetColor(string hex, float alpha);
    private static void DrawText(BasePlayer player, Vector3 position, string text, float time);
    private IEnumerator UserChecker(BasePlayer player, BaseEntity entity);
    private class BearController : MonoBehaviour
    {
        public List<BasePlayer> PlayersWithUI;
        public bool ShouldGrow;
        public int GrowingSeconds;
        public float currentSpeed;
        public float walkSpeed;
        public float leadSpeed;
        public float runSpeed;
        public float sprintSpeed;
        public float rotateSpeed;
        public float maxWallClimbSlope;
        public float maxStepHeight;
        public float maxStepDownHeight;
        public float obstacleDetectionRadius;
        public float maxWaterDepth;
        private BaseRidableAnimal.RunState currentRunState;
        private BasePlayer _rider;
        private BasePlayer _leadTarget;
        private BaseVehicleSeat _saddle;
        public Bear BearOwner;
        private float acceleration;
        private float desiredRotation;
        private float cachedObstacleDistance;
        private Vector3[] normalOffsets;
        private Vector3 averagedUp;
        private Vector3 targetUp;
        private float nextObstacleCheckTime;
        private float nextGroundNormalUpdateTime;
        private float lastMovementUpdateTime;
        private float nextEatTime;
        private void DoDung();
        private void Awake();
        private void Start();
        public void FixedUpdate();
        private void PlayerInput();
        public bool DropToGround(Vector3 targetPos, bool force);
        public void UpdateGroundNormal(bool force);
        private void LeadUpdate();
        public void SetRider(BasePlayer player);
        public void SetLead(BasePlayer player);
        public bool HasLead();
        public bool HasDriver();
        private float ObstacleSpeed(float obstacleDistance);
        public void MarkObstacleDistanceDirty();
        public float GetObstacleDistance();
        public float ObstacleDistanceCheck(float speed);
        private void EatNearbyFood();
        public float VisionRange;
        public float AttackRange;
        public float AttackRate;
        public float AttackDamage(string targetName);
        public DamageType AttackDamageType;
        private float nextAttackTime;
        [NonSerialized]
        private BaseEntity[] SensesResults;
        private void TryAttack();
        private static bool WithinVisionCone(BaseNpc npc, BaseEntity other);
        public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration);
        public TreeEntity CheckTree(BasePlayer player, Vector3 pos, Vector3 aim);
        private void StartAttack(BaseEntity entity);
        private bool AttackReady();
        private bool IsVisible(Vector3 position, Vector3 target, float maxDistance);
        private bool IsVisible(Ray ray, float maxDistance);
        private static bool AiCaresAbout(BaseEntity ent);
        private float lastEatTime;
        public void AnimalDecay();
        public void SwitchMoveState(BaseRidableAnimal.RunState newState);
        public float MoveStateToVelocity(BaseRidableAnimal.RunState stateToCheck);
        private float GetRunSpeed();
        private void IncreaseState(BaseRidableAnimal.RunState oldState);
        private float lastDdrawUpdate;
        private void PlayersChecker();
        private void AddSaddle();
        private void ClearBear();
        private void RemoveMovement();
        private IEnumerator DoGrow(PluginData.BearData data);
        public float lastInputTime;
        public Vector3 currentVelocity;
        private float timeAlive;
        private TimeUntil dropUntilTime;
        private void OnPhysicsNeighbourChanged();
        public void DelayedDropToGround();
        public virtual float WaterFactor();
        public OBB WorldSpaceBounds();
        public void UpdateMovement(float delta);
        public float GetDesiredVelocity();
        private BaseRidableAnimal.RunState StateFromSpeed(float speedToUse);
        private void UpdateDropToGroundForDuration(float duration);
        private float timeInMoveState;
        private float lastForwardPressedTime;
        private float forwardHeldSeconds;
        private float lastBackwardPressedTime;
        private float backwardHeldSeconds;
        private float lastSprintPressedTime;
        private float sprintHeldSeconds;
        private void RiderInput(InputState inputState, BasePlayer player);
        private void ModifyRunState(int dir);
    }

    private static InterfaceManager _interface;
    private void DrawUI_BearMenu(BasePlayer player, uint bear);
    private void DrawUI_BearMenu(BasePlayer player);
    private class InterfaceManager
    {
        public static InterfaceManager Instance;
        public const string UI_Layer;
        public const string UI_Instruction;
        public Dictionary<string, string> Interfaces;
        public InterfaceManager();
        public static void AddInterface(string name, string json);
        public static string GetInterface(string name);
        public static void DestroyAll();
        private void BuildInstruction();
        private void BuildInterface();
    }

    private static bool _initiated;
    private void StartPluginLoad();
    private void CheckStatus();
    private void FullLoad();
    [PluginReference]
    private Plugin ImageLibrary;
    private string GetSizedImade(string name, int size);
    private string GetImage(string name);
    private void AddImage(string name);
    private static string GetNameByURL(string url);
    private static PluginData _data;
    private class PluginData
    {
        private const string BackpackPrefab;
        private const string DataPath;
        public List<BearData> BearsData;
        public class BearData
        {
            public ulong OwnerId;
            public uint EntityId;
            public float Health;
            public byte[] Inventory;
            public Vector3 LastPosition;
            public bool IsItem;
            public int GrowSeconds;
            [JsonIgnore]
            private ItemContainer _itemContainer;
            [JsonIgnore]
            public ItemContainer Container { get; set; }
            public void Drop(Vector3 position);
        }

        public void BearKilled(Bear bear);
        public static Item BearToItem(uint bear);
        public static Bear ItemToBear(ulong player, uint item, Vector3 position, bool young);
        public static Bear CreateControlledBear(ulong player, Vector3 position, bool young);
        public static BearData Get(uint bear);
        public static ItemContainer ByteToItemContainer(byte[] bItem);
        public static byte[] ItemContainerToByte(ItemContainer item);
        public static void SaveContainer(uint bear, ItemContainer container);
        public static void SaveData();
        public static void LoadData();
    }

    private class PluginConfig
    {
        [JsonProperty("Шанс выпадения медвеженка | Chance of a bear cub falling out")]
        public int YoungDropChance;
        [JsonProperty("Сделать бессмертным медведя (true - да/false - нет) | Make a bear immortal (true - yes/false - no)")]
        public Boolean Immortals;
        [JsonProperty("Количество хп медведя | The number of hp of the bear")]
        public int MaxHealthAmount;
        [JsonProperty("Сколько времени растёт медведь в секундах | How long does a bear grow in seconds")]
        public int GrowSeconds;
        [JsonProperty("Скорость ходьбы | Walking speed")]
        public float WalkSpeed;
        [JsonProperty("Скорость поводка | Leash speed")]
        public float LeadSpeed;
        [JsonProperty("Скорость бега | Running speed")]
        public float RunSpeed;
        [JsonProperty("Скорость бега с шифтом | Running speed with shift")]
        public float SprintSpeed;
        [JsonProperty("Скорость поворота | Turning speed")]
        public float RotateSpeed;
        [JsonProperty("Размер шага вверх (Если вы не знаете что это такое, не трогайте данную функцию) | Step size up (If you don't know what it is, don't touch this function)")]
        public float StepHigh;
        [JsonProperty("Размер шага вниз (Если вы не знаете что это такое, не трогайте данную функцию) | Step size down (If you don't know what it is, don't touch this function)")]
        public float StepDown;
        [JsonProperty("Размер доски длина (Если вы не знаете что это такое, не трогайте данную функцию) | Board size length (If you don't know what it is, don't touch this function)")]
        public float BoardForward;
        [JsonProperty("Размер доски ширина (Если вы не знаете что это такое, не трогайте данную функцию) | Board size width (If you don't know what it is, don't touch this function)")]
        public float BoardRight;
        [JsonProperty("Максимальная высота на которую может залезть | The maximum height that can climb")]
        public float MaxWallClimbSlope;
        [JsonProperty("Радиус проверки на обьекты (Если вы не знаете что это такое, не трогайте данную функцию) | The radius of checking for objects (If you don't know what it is, don't touch this function)")]
        public float ObsCheckDis;
        [JsonProperty("Радиус проверки шариков поворота (Если вы не знаете что это такое, не трогайте данную функцию) | The radius of the rotation balls check (If you do not know what it is, do not touch this function)")]
        public float RotSphereDis;
        [JsonProperty("Максимальная глубина | Maximum depth")]
        public float MaxWaterDepth;
        [JsonProperty("Размер инвентаря | Inventory Size")]
        public int InventorySize;
        [JsonProperty("Наносимый урон идивидуальный | The damage inflicted is individual")]
        public Dictionary<string, float> BearDamage;
        [JsonProperty("Сколько здоровья давать при еде | How much health to give when eating")]
        public float EatHealAmount;
        [JsonProperty("IQChat : Кастомный префикс в чате | IQ Chat : Custom prefix in the chat")]
        public String CustomPrefix;
        [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется) | IQChat : Custom avatar in the chat (If required)")]
        public String CustomAvatar;
        [JsonProperty("IQChat : Использовать UI уведомления | IQChat : Use UI notifications")]
        public Boolean UIAlertUse;
        [JsonProperty("Настройка предмета Медведь | Setting up the Bear Item")]
        public CustomItem BearItem;
        [JsonProperty("Настройка предмета Медвеженок | Setting up the Bear Cub item")]
        public CustomItem YoungBearItem;
        [JsonProperty("Картинка Следовать | Picture To Follow")]
        public string FollowImage;
        [JsonProperty("Картинка Ехать | Picture to ride")]
        public string RideImage;
        [JsonProperty("Картинка Поднять | Picture Raise")]
        public string TakeImage;
        [JsonProperty("Картинка Инвентарь | Picture Inventory")]
        public string InventoryImage;
        [JsonProperty("Картинка Инструкции (С русским переводом - https://i.imgur.com/D5rIpyM.png) | Picture Instructions")]
        public string InstructionImage;
    }

    private static PluginConfig _config;
    protected override void LoadConfig();
    private void ValidateConfig();
    protected override void SaveConfig();
    protected override void LoadDefaultConfig();
    private PluginConfig GetDefaultConfig();
    private static StringBuilder sb;
    public string GetLang(string LangKey, string userID, object[] args);
    private new void LoadDefaultMessages();
}

private class BearController : MonoBehaviour
{
    public List<BasePlayer> PlayersWithUI;
    public bool ShouldGrow;
    public int GrowingSeconds;
    public float currentSpeed;
    public float walkSpeed;
    public float leadSpeed;
    public float runSpeed;
    public float sprintSpeed;
    public float rotateSpeed;
    public float maxWallClimbSlope;
    public float maxStepHeight;
    public float maxStepDownHeight;
    public float obstacleDetectionRadius;
    public float maxWaterDepth;
    private BaseRidableAnimal.RunState currentRunState;
    private BasePlayer _rider;
    private BasePlayer _leadTarget;
    private BaseVehicleSeat _saddle;
    public Bear BearOwner;
    private float acceleration;
    private float desiredRotation;
    private float cachedObstacleDistance;
    private Vector3[] normalOffsets;
    private Vector3 averagedUp;
    private Vector3 targetUp;
    private float nextObstacleCheckTime;
    private float nextGroundNormalUpdateTime;
    private float lastMovementUpdateTime;
    private float nextEatTime;
    private void DoDung();
    private void Awake();
    private void Start();
    public void FixedUpdate();
    private void PlayerInput();
    public bool DropToGround(Vector3 targetPos, bool force);
    public void UpdateGroundNormal(bool force);
    private void LeadUpdate();
    public void SetRider(BasePlayer player);
    public void SetLead(BasePlayer player);
    public bool HasLead();
    public bool HasDriver();
    private float ObstacleSpeed(float obstacleDistance);
    public void MarkObstacleDistanceDirty();
    public float GetObstacleDistance();
    public float ObstacleDistanceCheck(float speed);
    private void EatNearbyFood();
    public float VisionRange;
    public float AttackRange;
    public float AttackRate;
    public float AttackDamage(string targetName);
    public DamageType AttackDamageType;
    private float nextAttackTime;
    [NonSerialized]
    private BaseEntity[] SensesResults;
    private void TryAttack();
    private static bool WithinVisionCone(BaseNpc npc, BaseEntity other);
    public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration);
    public TreeEntity CheckTree(BasePlayer player, Vector3 pos, Vector3 aim);
    private void StartAttack(BaseEntity entity);
    private bool AttackReady();
    private bool IsVisible(Vector3 position, Vector3 target, float maxDistance);
    private bool IsVisible(Ray ray, float maxDistance);
    private static bool AiCaresAbout(BaseEntity ent);
    private float lastEatTime;
    public void AnimalDecay();
    public void SwitchMoveState(BaseRidableAnimal.RunState newState);
    public float MoveStateToVelocity(BaseRidableAnimal.RunState stateToCheck);
    private float GetRunSpeed();
    private void IncreaseState(BaseRidableAnimal.RunState oldState);
    private float lastDdrawUpdate;
    private void PlayersChecker();
    private void AddSaddle();
    private void ClearBear();
    private void RemoveMovement();
    private IEnumerator DoGrow(PluginData.BearData data);
    public float lastInputTime;
    public Vector3 currentVelocity;
    private float timeAlive;
    private TimeUntil dropUntilTime;
    private void OnPhysicsNeighbourChanged();
    public void DelayedDropToGround();
    public virtual float WaterFactor();
    public OBB WorldSpaceBounds();
    public void UpdateMovement(float delta);
    public float GetDesiredVelocity();
    private BaseRidableAnimal.RunState StateFromSpeed(float speedToUse);
    private void UpdateDropToGroundForDuration(float duration);
    private float timeInMoveState;
    private float lastForwardPressedTime;
    private float forwardHeldSeconds;
    private float lastBackwardPressedTime;
    private float backwardHeldSeconds;
    private float lastSprintPressedTime;
    private float sprintHeldSeconds;
    private void RiderInput(InputState inputState, BasePlayer player);
    private void ModifyRunState(int dir);
}

private class InterfaceManager
{
    public static InterfaceManager Instance;
    public const string UI_Layer;
    public const string UI_Instruction;
    public Dictionary<string, string> Interfaces;
    public InterfaceManager();
    public static void AddInterface(string name, string json);
    public static string GetInterface(string name);
    public static void DestroyAll();
    private void BuildInstruction();
    private void BuildInterface();
}

private class PluginData
{
    private const string BackpackPrefab;
    private const string DataPath;
    public List<BearData> BearsData;
    public class BearData
    {
        public ulong OwnerId;
        public uint EntityId;
        public float Health;
        public byte[] Inventory;
        public Vector3 LastPosition;
        public bool IsItem;
        public int GrowSeconds;
        [JsonIgnore]
        private ItemContainer _itemContainer;
        [JsonIgnore]
        public ItemContainer Container { get; set; }
        public void Drop(Vector3 position);
    }

    public void BearKilled(Bear bear);
    public static Item BearToItem(uint bear);
    public static Bear ItemToBear(ulong player, uint item, Vector3 position, bool young);
    public static Bear CreateControlledBear(ulong player, Vector3 position, bool young);
    public static BearData Get(uint bear);
    public static ItemContainer ByteToItemContainer(byte[] bItem);
    public static byte[] ItemContainerToByte(ItemContainer item);
    public static void SaveContainer(uint bear, ItemContainer container);
    public static void SaveData();
    public static void LoadData();
}

public class BearData
{
    public ulong OwnerId;
    public uint EntityId;
    public float Health;
    public byte[] Inventory;
    public Vector3 LastPosition;
    public bool IsItem;
    public int GrowSeconds;
    [JsonIgnore]
    private ItemContainer _itemContainer;
    [JsonIgnore]
    public ItemContainer Container { get; set; }
    public void Drop(Vector3 position);
}

private class PluginConfig
{
    [JsonProperty("Шанс выпадения медвеженка | Chance of a bear cub falling out")]
    public int YoungDropChance;
    [JsonProperty("Сделать бессмертным медведя (true - да/false - нет) | Make a bear immortal (true - yes/false - no)")]
    public Boolean Immortals;
    [JsonProperty("Количество хп медведя | The number of hp of the bear")]
    public int MaxHealthAmount;
    [JsonProperty("Сколько времени растёт медведь в секундах | How long does a bear grow in seconds")]
    public int GrowSeconds;
    [JsonProperty("Скорость ходьбы | Walking speed")]
    public float WalkSpeed;
    [JsonProperty("Скорость поводка | Leash speed")]
    public float LeadSpeed;
    [JsonProperty("Скорость бега | Running speed")]
    public float RunSpeed;
    [JsonProperty("Скорость бега с шифтом | Running speed with shift")]
    public float SprintSpeed;
    [JsonProperty("Скорость поворота | Turning speed")]
    public float RotateSpeed;
    [JsonProperty("Размер шага вверх (Если вы не знаете что это такое, не трогайте данную функцию) | Step size up (If you don't know what it is, don't touch this function)")]
    public float StepHigh;
    [JsonProperty("Размер шага вниз (Если вы не знаете что это такое, не трогайте данную функцию) | Step size down (If you don't know what it is, don't touch this function)")]
    public float StepDown;
    [JsonProperty("Размер доски длина (Если вы не знаете что это такое, не трогайте данную функцию) | Board size length (If you don't know what it is, don't touch this function)")]
    public float BoardForward;
    [JsonProperty("Размер доски ширина (Если вы не знаете что это такое, не трогайте данную функцию) | Board size width (If you don't know what it is, don't touch this function)")]
    public float BoardRight;
    [JsonProperty("Максимальная высота на которую может залезть | The maximum height that can climb")]
    public float MaxWallClimbSlope;
    [JsonProperty("Радиус проверки на обьекты (Если вы не знаете что это такое, не трогайте данную функцию) | The radius of checking for objects (If you don't know what it is, don't touch this function)")]
    public float ObsCheckDis;
    [JsonProperty("Радиус проверки шариков поворота (Если вы не знаете что это такое, не трогайте данную функцию) | The radius of the rotation balls check (If you do not know what it is, do not touch this function)")]
    public float RotSphereDis;
    [JsonProperty("Максимальная глубина | Maximum depth")]
    public float MaxWaterDepth;
    [JsonProperty("Размер инвентаря | Inventory Size")]
    public int InventorySize;
    [JsonProperty("Наносимый урон идивидуальный | The damage inflicted is individual")]
    public Dictionary<string, float> BearDamage;
    [JsonProperty("Сколько здоровья давать при еде | How much health to give when eating")]
    public float EatHealAmount;
    [JsonProperty("IQChat : Кастомный префикс в чате | IQ Chat : Custom prefix in the chat")]
    public String CustomPrefix;
    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется) | IQChat : Custom avatar in the chat (If required)")]
    public String CustomAvatar;
    [JsonProperty("IQChat : Использовать UI уведомления | IQChat : Use UI notifications")]
    public Boolean UIAlertUse;
    [JsonProperty("Настройка предмета Медведь | Setting up the Bear Item")]
    public CustomItem BearItem;
    [JsonProperty("Настройка предмета Медвеженок | Setting up the Bear Cub item")]
    public CustomItem YoungBearItem;
    [JsonProperty("Картинка Следовать | Picture To Follow")]
    public string FollowImage;
    [JsonProperty("Картинка Ехать | Picture to ride")]
    public string RideImage;
    [JsonProperty("Картинка Поднять | Picture Raise")]
    public string TakeImage;
    [JsonProperty("Картинка Инвентарь | Picture Inventory")]
    public string InventoryImage;
    [JsonProperty("Картинка Инструкции (С русским переводом - https://i.imgur.com/D5rIpyM.png) | Picture Instructions")]
    public string InstructionImage;
}


```

---

## IQBreakingTools

```csharp
using System.Collections.Generic;
using Newtonsoft.Json;

Oxide.Plugins
[Info("IQBreakingTools", "Mercury", "0.0.4")]
[Description("Что этот Mercury себе позволяет,он уже заебал клепать хуйню")]
 class IQBreakingTools : RustPlugin
{
     string IQBreakingToolsPermission;
     string IQWeapon;
     string IQTools;
     string IQAttire;
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty("Список предметов,которые не будут ломаться (shortname)")]
        public List<string> ToolsList;
        [JsonProperty("Список исключенных SkinID(Вещи с этим SkinID будут ломаться! Для кастомных предметов)")]
        public List<ulong> BlackList;
        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
     void RegisteredPermissions();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    private void OnServerInitialized();
     void OnLoseCondition(Item item, float amount);
}

private class Configuration
{
    [JsonProperty("Список предметов,которые не будут ломаться (shortname)")]
    public List<string> ToolsList;
    [JsonProperty("Список исключенных SkinID(Вещи с этим SkinID будут ломаться! Для кастомных предметов)")]
    public List<ulong> BlackList;
    public static Configuration GetNewConfiguration();
}


```

---

## IQCases

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using System.Text;

Oxide.Plugins
[Info("IQCases", "SkuliDropek", "0.1.2")]
[Description("Кейсы на ваш сервер | Cases to your server")]
 class IQCases : RustPlugin
{
    [PluginReference]
     Plugin IQChat;
     Plugin IQEconomic;
     Plugin ImageLibrary;
     Plugin IQRankSystem;
    public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel);
    private String GetImage(String fileName, UInt64 skin);
    public Boolean AddImage(String url, String shortname, UInt64 skin);
    public void SendImage(BasePlayer player, String imageName, UInt64 imageId);
    public Boolean HasImage(String imageName);
    public string ImageGetItems(string CaseKey, int ItemKey);
    public string ImageGetItemsInventory(ulong userID, ItemSettings itemSettings);
    private IEnumerator DownloadImages();
     void AddAllImage();
     void CachedImage(BasePlayer player);
     int GetBalance(ulong userID);
     bool IsRemovedBalance(ulong userID, int Amount);
     void SetBalance(ulong userID, int Balance);
     void RemoveBalance(ulong userID, int Balance);
     bool IsRank(ulong userID, string Key);
     string GetRankName(string Key);
    public Dictionary<ulong, List<ItemSettings>> VariblesPrize;
    public class ItemSettings
    {
        [JsonProperty("Команда - ture | Вещь - false | Command - ture | Item - false")]
        public bool CommandUse;
        [JsonProperty("Команда | Command")]
        public string Command;
        [JsonProperty("Иконка для команды | Icon for the team")]
        public string URLCommand;
        [JsonProperty("Shortname предмета | Item shortname")]
        public string Shortname;
        [JsonProperty("Минимальное количество для предмета | Minimum quantity for an item")]
        public int MinAmount;
        [JsonProperty("Максимальное количество для предмета | Maximum quantity for an item")]
        public int MaxAmount;
        [JsonProperty("SkinID предмета | SkinID item")]
        public ulong SkinID;
    }

    private static Configuration config;
    private class Configuration
    {
        [JsonProperty("Настройки плагина | Plugin Settings")]
        public GeneralSettings GeneralSetting;
        [JsonProperty("Настройки кейсов [Каждый кейс настраивается индивидуально,вы можете использовать функционал как вашей душе угодно!] | Case settings [Each case is configured individually, you can use the functionality as your heart desires!]")]
        public Dictionary<string, Cases> CaseList;
        [JsonProperty("Настройки совместной работы с другими плагинами | Settings for collaboration with other plugins")]
        public ReferenceSetting ReferenceSettings;
        internal class GeneralSettings
        {
            [JsonProperty("Включить автоматическую очистку инвентаря в WIPE | Enable automatic inventory cleaning in WIPE")]
            public bool InventoryClearWipe;
        }

        internal class Cases
        {
            [JsonProperty("Права для открытия кейса(если давать доступ всем - оставляйте поле пустым) | Rights to open the case (if you give access to everyone, leave the field empty)")]
            public string PermissionOpenCase;
            [JsonProperty("Название кейса | Case name")]
            public string DisplayName;
            [JsonProperty("Ссылка на иконку кейса | Link to the case icon")]
            public string URLCase;
            [JsonProperty("IQRankSystem : С каким рангом будет доступен данный кейс(Если не нужно,оставляйте строку пустой) | IQRankSystem : With what rank will this case be available (if not necessary, leave the line empty)")]
            public string IQRankKey;
            [JsonProperty("Цена на кейс(IQEconomic) | Case price(IQEconomic)")]
            public int IQEconomicPrice;
            [JsonProperty("IQEconomicUse : Разрешить покупку кейса | IQEconomicUse : Allow case purchase")]
            public bool IQEconomicUse;
            [JsonProperty("IQEconomicUse : Разрешить продажу кейса | IQEconomicUse : Allow case sale")]
            public bool IQEconomicUseSell;
            [JsonProperty("Сколько монет дадут при продаже кейса(IQEconomic) | How many coins will be given when selling the case(IQEconomic)")]
            public int IQEconomicPriceSell;
            [JsonProperty("Выдавать кейс за время | Give case for time online")]
            public bool GiveCaseFromPlaying;
            [JsonProperty("Через сколько секунд выдавать кейс | After how many seconds to issue the case")]
            public int PlayingNormalFromGive;
            [JsonProperty("Включить выпадение кейсов из ящиков с шансом | Enable the drop of cases from the boxes with a chance")]
            public bool UseDropList;
            [JsonProperty("Выпадение кейсов и шанс [ящик] = шанс | Drop cases and chance [box] = chance")]
            public Dictionary<string, int> CasesDropList;
            [JsonProperty("Включить возможность выбрать награду(1 из 3) - true / Выключить возможность выбрать награду(будет один приз) - false | Enable the ability to select a reward (1 of 3) - true / Disable the option to choose a reward (there will be one prize) - false")]
            public bool VariblesPrize;
            [JsonProperty("Предметы , которые будут выпадать из кейсов | Items that will fall out of cases")]
            public List<ItemSettings> ItemSetting;
        }

        internal class ReferenceSetting
        {
            [JsonProperty("IQChat : Настройки чата | IQChat : Chat Settings")]
            public ChatSetting ChatSettings;
            internal class ChatSetting
            {
                [JsonProperty("IQChat : Кастомный префикс в чате | IQChat : Custom prefix in the chat")]
                public string CustomPrefix;
                [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется) | IQChat : Custom avatar in the chat (if required)")]
                public string CustomAvatar;
                [JsonProperty("IQChat : Использовать UI уведомления | IQChat : Use UI notifications")]
                public bool UIAlertUse;
            }

        }

        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    [JsonProperty("Дата времени игроков | Players' time date")]
    public Dictionary<ulong, Dictionary<string, int>> TrackerTimePlayer;
    [JsonProperty("Дата кейсов игроков | Date of player cases")]
    public Dictionary<ulong, Dictionary<string, int>> DataPlayer;
    [JsonProperty("Инвентарь игроков | Player Inventory")]
    public Dictionary<ulong, List<Inventory>> InventoryPlayer;
    public class Inventory
    {
        [JsonProperty("Информация | Information")]
        public ItemSettings ItemClass;
        [JsonProperty("Количество | Amount")]
        public int Amount;
    }

     void ReadData();
     void WriteData();
     void RegisteredDataUser(BasePlayer player);
    private void Init();
    private void OnServerInitialized();
     void OnPlayerConnected(BasePlayer player);
     void Unload();
     void OnNewSave(string filename);
     void OnLootEntity(BasePlayer player, BaseEntity entity);
    [ChatCommand("case")]
     void ChatCommandCase(BasePlayer player);
    [ConsoleCommand("case")]
     void SystemCommandCase(ConsoleSystem.Arg arg);
    [ConsoleCommand("iqcase")]
     void AdminCommandCase(ConsoleSystem.Arg arg);
     void Metods_Open_Case(BasePlayer player, string CaseKey);
     void Metods_Search_Case(BasePlayer player, string CrateName);
     void Metods_Case_Give(ulong userID, string CaseKey, int Amount);
     void Metods_Take_Inventory(BasePlayer player, Inventory inventoryClass);
     void Metods_Take_Prize(BasePlayer player, ItemSettings ItemSetting, int ItemAmount);
     void Metods_IQEconomicBuyCase(BasePlayer player, string CaseKey);
     void Metods_IQEconomicSellCase(BasePlayer player, string CaseKey);
    public void TrackerTime(BasePlayer player);
    public static string UI_MAIN_UI;
    public static string UI_TAKE_ITEM;
    public static string UI_WHY_CASE;
    public static string UI_MY_INVENTORY;
    public static string UI_CASE_ANIMATION;
    public static string UI_CASE_SHOW_REWARD;
    public static string STOP_BLOCK_INFO;
     void Interface_Cases(BasePlayer player);
     void Interface_Take_Element(BasePlayer player, string CaseKey);
     void Interface_Why_Case(BasePlayer player, string CaseKey);
     void Interface_My_Inventory(BasePlayer player);
     void Interface_My_Inventory_LoadeItems(BasePlayer player, Int32 Page);
    public IEnumerator Interface_Animation(BasePlayer player, string CaseKey);
    public void ShowReward(BasePlayer player, string CaseKey, List<int> PossibleAwards);
    private new void LoadDefaultMessages();
    public static StringBuilder sb;
    public string GetLang(string LangKey, string userID, object[] args);
    public bool GetRandomDrop(int RandomInt);
    public bool UserAmountCase(BasePlayer player, string CaseKey);
    public int GetAmountCase(BasePlayer player, string CaseKey);
    static Double CurrentTime { get; set; }
    private static string HexToRustFormat(string hex);
     void RunEffect(BasePlayer player, string path);
     void API_GIVE_CASE(ulong userID, string CaseKey, int Amount);
     bool API_IS_CASE_PLAYER(BasePlayer player, string CaseKey);
     int API_GET_AMOUNT_CASE(BasePlayer player, string CaseKey);
     bool API_IS_CASE_EXIST(string CaseKey);
}

public class ItemSettings
{
    [JsonProperty("Команда - ture | Вещь - false | Command - ture | Item - false")]
    public bool CommandUse;
    [JsonProperty("Команда | Command")]
    public string Command;
    [JsonProperty("Иконка для команды | Icon for the team")]
    public string URLCommand;
    [JsonProperty("Shortname предмета | Item shortname")]
    public string Shortname;
    [JsonProperty("Минимальное количество для предмета | Minimum quantity for an item")]
    public int MinAmount;
    [JsonProperty("Максимальное количество для предмета | Maximum quantity for an item")]
    public int MaxAmount;
    [JsonProperty("SkinID предмета | SkinID item")]
    public ulong SkinID;
}

private class Configuration
{
    [JsonProperty("Настройки плагина | Plugin Settings")]
    public GeneralSettings GeneralSetting;
    [JsonProperty("Настройки кейсов [Каждый кейс настраивается индивидуально,вы можете использовать функционал как вашей душе угодно!] | Case settings [Each case is configured individually, you can use the functionality as your heart desires!]")]
    public Dictionary<string, Cases> CaseList;
    [JsonProperty("Настройки совместной работы с другими плагинами | Settings for collaboration with other plugins")]
    public ReferenceSetting ReferenceSettings;
    internal class GeneralSettings
    {
        [JsonProperty("Включить автоматическую очистку инвентаря в WIPE | Enable automatic inventory cleaning in WIPE")]
        public bool InventoryClearWipe;
    }

    internal class Cases
    {
        [JsonProperty("Права для открытия кейса(если давать доступ всем - оставляйте поле пустым) | Rights to open the case (if you give access to everyone, leave the field empty)")]
        public string PermissionOpenCase;
        [JsonProperty("Название кейса | Case name")]
        public string DisplayName;
        [JsonProperty("Ссылка на иконку кейса | Link to the case icon")]
        public string URLCase;
        [JsonProperty("IQRankSystem : С каким рангом будет доступен данный кейс(Если не нужно,оставляйте строку пустой) | IQRankSystem : With what rank will this case be available (if not necessary, leave the line empty)")]
        public string IQRankKey;
        [JsonProperty("Цена на кейс(IQEconomic) | Case price(IQEconomic)")]
        public int IQEconomicPrice;
        [JsonProperty("IQEconomicUse : Разрешить покупку кейса | IQEconomicUse : Allow case purchase")]
        public bool IQEconomicUse;
        [JsonProperty("IQEconomicUse : Разрешить продажу кейса | IQEconomicUse : Allow case sale")]
        public bool IQEconomicUseSell;
        [JsonProperty("Сколько монет дадут при продаже кейса(IQEconomic) | How many coins will be given when selling the case(IQEconomic)")]
        public int IQEconomicPriceSell;
        [JsonProperty("Выдавать кейс за время | Give case for time online")]
        public bool GiveCaseFromPlaying;
        [JsonProperty("Через сколько секунд выдавать кейс | After how many seconds to issue the case")]
        public int PlayingNormalFromGive;
        [JsonProperty("Включить выпадение кейсов из ящиков с шансом | Enable the drop of cases from the boxes with a chance")]
        public bool UseDropList;
        [JsonProperty("Выпадение кейсов и шанс [ящик] = шанс | Drop cases and chance [box] = chance")]
        public Dictionary<string, int> CasesDropList;
        [JsonProperty("Включить возможность выбрать награду(1 из 3) - true / Выключить возможность выбрать награду(будет один приз) - false | Enable the ability to select a reward (1 of 3) - true / Disable the option to choose a reward (there will be one prize) - false")]
        public bool VariblesPrize;
        [JsonProperty("Предметы , которые будут выпадать из кейсов | Items that will fall out of cases")]
        public List<ItemSettings> ItemSetting;
    }

    internal class ReferenceSetting
    {
        [JsonProperty("IQChat : Настройки чата | IQChat : Chat Settings")]
        public ChatSetting ChatSettings;
        internal class ChatSetting
        {
            [JsonProperty("IQChat : Кастомный префикс в чате | IQChat : Custom prefix in the chat")]
            public string CustomPrefix;
            [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется) | IQChat : Custom avatar in the chat (if required)")]
            public string CustomAvatar;
            [JsonProperty("IQChat : Использовать UI уведомления | IQChat : Use UI notifications")]
            public bool UIAlertUse;
        }

    }

    public static Configuration GetNewConfiguration();
}

internal class GeneralSettings
{
    [JsonProperty("Включить автоматическую очистку инвентаря в WIPE | Enable automatic inventory cleaning in WIPE")]
    public bool InventoryClearWipe;
}

internal class Cases
{
    [JsonProperty("Права для открытия кейса(если давать доступ всем - оставляйте поле пустым) | Rights to open the case (if you give access to everyone, leave the field empty)")]
    public string PermissionOpenCase;
    [JsonProperty("Название кейса | Case name")]
    public string DisplayName;
    [JsonProperty("Ссылка на иконку кейса | Link to the case icon")]
    public string URLCase;
    [JsonProperty("IQRankSystem : С каким рангом будет доступен данный кейс(Если не нужно,оставляйте строку пустой) | IQRankSystem : With what rank will this case be available (if not necessary, leave the line empty)")]
    public string IQRankKey;
    [JsonProperty("Цена на кейс(IQEconomic) | Case price(IQEconomic)")]
    public int IQEconomicPrice;
    [JsonProperty("IQEconomicUse : Разрешить покупку кейса | IQEconomicUse : Allow case purchase")]
    public bool IQEconomicUse;
    [JsonProperty("IQEconomicUse : Разрешить продажу кейса | IQEconomicUse : Allow case sale")]
    public bool IQEconomicUseSell;
    [JsonProperty("Сколько монет дадут при продаже кейса(IQEconomic) | How many coins will be given when selling the case(IQEconomic)")]
    public int IQEconomicPriceSell;
    [JsonProperty("Выдавать кейс за время | Give case for time online")]
    public bool GiveCaseFromPlaying;
    [JsonProperty("Через сколько секунд выдавать кейс | After how many seconds to issue the case")]
    public int PlayingNormalFromGive;
    [JsonProperty("Включить выпадение кейсов из ящиков с шансом | Enable the drop of cases from the boxes with a chance")]
    public bool UseDropList;
    [JsonProperty("Выпадение кейсов и шанс [ящик] = шанс | Drop cases and chance [box] = chance")]
    public Dictionary<string, int> CasesDropList;
    [JsonProperty("Включить возможность выбрать награду(1 из 3) - true / Выключить возможность выбрать награду(будет один приз) - false | Enable the ability to select a reward (1 of 3) - true / Disable the option to choose a reward (there will be one prize) - false")]
    public bool VariblesPrize;
    [JsonProperty("Предметы , которые будут выпадать из кейсов | Items that will fall out of cases")]
    public List<ItemSettings> ItemSetting;
}

internal class ReferenceSetting
{
    [JsonProperty("IQChat : Настройки чата | IQChat : Chat Settings")]
    public ChatSetting ChatSettings;
    internal class ChatSetting
    {
        [JsonProperty("IQChat : Кастомный префикс в чате | IQChat : Custom prefix in the chat")]
        public string CustomPrefix;
        [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется) | IQChat : Custom avatar in the chat (if required)")]
        public string CustomAvatar;
        [JsonProperty("IQChat : Использовать UI уведомления | IQChat : Use UI notifications")]
        public bool UIAlertUse;
    }

}

internal class ChatSetting
{
    [JsonProperty("IQChat : Кастомный префикс в чате | IQChat : Custom prefix in the chat")]
    public string CustomPrefix;
    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется) | IQChat : Custom avatar in the chat (if required)")]
    public string CustomAvatar;
    [JsonProperty("IQChat : Использовать UI уведомления | IQChat : Use UI notifications")]
    public bool UIAlertUse;
}

public class Inventory
{
    [JsonProperty("Информация | Information")]
    public ItemSettings ItemClass;
    [JsonProperty("Количество | Amount")]
    public int Amount;
}


```

---

## IQChat

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

Oxide.Plugins
[Info("IQChat", "Mercury", "0.1.0")]
[Description("aaaaaaaaaaaaaaaaaaa")]
 class IQChat : RustPlugin
{
    public string PermMuteMenu;
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty("Права для смены ника")]
        public string RenamePermission;
        [JsonProperty("Настройка префиксов")]
        public Dictionary<string, string> PrefixList;
        [JsonProperty("Настройка цветов для ников")]
        public Dictionary<string, string> NickColorList;
        [JsonProperty("Настройка цветов для сообщений")]
        public Dictionary<string, string> MessageColorList;
        [JsonProperty("Настройка сообщений в чате")]
        public MessageSettings MessageSetting;
        [JsonProperty("Настройка причин блокировок чата")]
        public Dictionary<string, int> ReasonListChat;
        [JsonProperty("Настройка интерфейса")]
        public InterfaceSettings InterfaceSetting;
        [JsonProperty("Настройка оповещения")]
        public AlertSetting AlertSettings;
        internal class MessageSettings
        {
            [JsonProperty("Наименование оповещения в чат")]
            public string BroadcastTitle;
            [JsonProperty("Цвет сообщения оповещения в чат")]
            public string BroadcastColor;
            [JsonProperty("На какое сообщение заменять плохие слова")]
            public string ReplaceBadWord;
            [JsonProperty("Steam64ID для аватарки в чате")]
            public ulong Steam64IDAvatar;
            [JsonProperty("Список плохих слов")]
            public List<string> BadWords;
            [JsonProperty("Время,через которое удалится сообщение с UI от администратора")]
            public int TimeDeleteAlertUI;
            [JsonProperty("Включить форматирование сообщений")]
            public bool FormatingMessage;
            [JsonProperty("Включить личные сообщения")]
            public bool PMActivate;
            [JsonProperty("Включить Анти-Спам")]
            public bool AntiSpamActivate;
            [JsonProperty("Звук при при получении личного сообщения")]
            public string SoundPM;
            [JsonProperty("Время через которое игрок может отправлять сообщение (АнтиСпам)")]
            public int FloodTime;
        }

        internal class InterfaceSettings
        {
            [JsonProperty("Основной цвет UI")]
            public string MainColor;
            [JsonProperty("Дополнительный #1 цвет UI")]
            public string TwoMainColor;
            [JsonProperty("Дополнительный #2 цвет UI")]
            public string ThreeMainColor;
            [JsonProperty("Основной цвет UI панели МУТОВ")]
            public string MainColorMute;
        }

        internal class AlertSetting
        {
            [JsonProperty("Включить случайное сообщение зашедшему игроку")]
            public bool WelcomeMessageUse;
            [JsonProperty("Список сообщений игроку при входе")]
            public List<string> WelcomeMessage;
            [JsonProperty("Уведомлять о входе игрока в чат")]
            public bool ConnectedAlert;
            [JsonProperty("Уведомлять о выходе игрока в чат")]
            public bool DisconnectedAlert;
            [JsonProperty("При уведомлении о входе/выходе игрока отображать его аватар напротив ника")]
            public bool ConnectedAvatarUse;
            [JsonProperty("Включить автоматические сообщения в чат")]
            public bool AlertMessage;
            [JsonProperty("Настройка отправки автоматических сообщений в чат")]
            public List<string> MessageList;
            [JsonProperty("Интервал отправки сообщений в чат(Броадкастер)")]
            public int MessageListTimer;
        }

        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
     void RegisteredPermissions();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    [JsonProperty("Дата с настройкой чата игрока")]
    public Dictionary<ulong, SettingUser> ChatSettingUser;
    [JsonProperty("Дата с Административной настройкой")]
    public AdminSettings AdminSetting;
    public class SettingUser
    {
        public string ChatPrefix;
        public string NickColor;
        public string MessageColor;
        public double MuteChatTime;
        public double MuteVoiceTime;
    }

    public class AdminSettings
    {
        public bool MuteChatAll;
        public bool MuteVoiceAll;
        public Dictionary<ulong, string> RenameList;
    }

     void ReadData();
     void WriteData();
     void RegisteredDataUser(BasePlayer player);
    private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
     object OnPlayerVoice(BasePlayer player, Byte[] data);
    private void OnServerInitialized();
    private void OnPlayerInit(BasePlayer player);
     void OnPlayerDisconnected(BasePlayer player, string reason);
    private void Message(Chat.ChatChannel channel, BasePlayer player, string message);
    public void ReturnDefaultData(BasePlayer player);
    public void BroadcastAuto();
    public void MutePlayer(BasePlayer player, BasePlayer Initiator, string Format, int ReasonIndex);
    public void MuteAllChatPlayer(BasePlayer player, float TimeMute);
    public void RenameFunc(BasePlayer player, string NewName);
    static string MAIN_PARENT;
    static string MUTE_MENU_PARENT;
    static string ELEMENT_SETTINGS;
    static string MAIN_ALERT_UI;
    public void UI_MainMenu(BasePlayer player);
    public void UI_MuteMenu(BasePlayer player);
    public void UI_MuteTakeAction(BasePlayer player, ulong userID);
     void UI_MuteTakeActionShowListReason(BasePlayer player, ulong userID, string MuteFormat);
    public void NewElementSettings(BasePlayer player);
    public void NewElementPrefixSetting(BasePlayer player);
    public void NewElementNickColorSetting(BasePlayer player);
    public void NewElementMessageColorSetting(BasePlayer player);
    public void UpdateLabel(BasePlayer player, string Parent, string Name, string TextLabel);
     void UIAlert(BasePlayer player, string Message);
    [ChatCommand("chat")]
     void ChatCommandMenu(BasePlayer player);
    [ChatCommand("mute")]
     void ChatMuteCommandMenu(BasePlayer player, string cmd, string[] arg);
    [ChatCommand("alert")]
     void ChatAlertPlayers(BasePlayer player, string cmd, string[] arg);
    [ConsoleCommand("alert")]
     void ChatAlertPlayersCMD(ConsoleSystem.Arg arg);
    [ConsoleCommand("alertui")]
     void ChatAlertPlayersUICMD(ConsoleSystem.Arg arg);
    [ChatCommand("alertui")]
     void ChatAlertPlayersUI(BasePlayer player, string cmd, string[] arg);
    [ChatCommand("rename")]
     void RenameMetods(BasePlayer player, string cmd, string[] arg);
    public Dictionary<BasePlayer, BasePlayer> PMHistory;
    [ChatCommand("pm")]
     void PmChat(BasePlayer player, string cmd, string[] arg);
    [ChatCommand("r")]
     void RChat(BasePlayer player, string cmd, string[] arg);
    [ConsoleCommand("set")]
    private void ConsolesCommandPrefixSet(ConsoleSystem.Arg arg);
    [ConsoleCommand("iq_chat")]
    private void ConsoleCommandIQChat(ConsoleSystem.Arg arg);
    private new void LoadDefaultMessages();
    public void Log(string LoggedMessage);
    public static string FormatTime(TimeSpan time, int maxSubstr, string language);
    private BasePlayer FindPlayer(string nameOrId);
    public static long TimeToSeconds(string time);
    private static string Format(int units, string form1, string form2, string form3);
    private static string HexToRustFormat(string hex);
    public Dictionary<ulong, double> Flooders;
     void ReplyChat(Chat.ChatChannel channel, BasePlayer player, string format);
     void ReplySystem(Chat.ChatChannel channel, BasePlayer player, string Message, string CustomPrefix, string CustomAvatar);
     void ReplyBroadcast(string Message, string CustomPrefix, string CustomAvatar);
    static DateTime epoch;
    static double CurrentTime();
     void API_ALERT(string Message, Chat.ChatChannel channel, string CustomPrefix, string CustomAvatar);
     void API_ALERT_PLAYER(BasePlayer player, string Message, string CustomPrefix, string CustomAvatar);
     bool API_CHECK_MUTE_CHAT(ulong ID);
     bool API_CHECK_VOICE_CHAT(ulong ID);
     string API_GET_PREFIX(ulong ID);
     string API_GET_CHAT_COLOR(ulong ID);
     string API_GET_NICK_COLOR(ulong ID);
}

private class Configuration
{
    [JsonProperty("Права для смены ника")]
    public string RenamePermission;
    [JsonProperty("Настройка префиксов")]
    public Dictionary<string, string> PrefixList;
    [JsonProperty("Настройка цветов для ников")]
    public Dictionary<string, string> NickColorList;
    [JsonProperty("Настройка цветов для сообщений")]
    public Dictionary<string, string> MessageColorList;
    [JsonProperty("Настройка сообщений в чате")]
    public MessageSettings MessageSetting;
    [JsonProperty("Настройка причин блокировок чата")]
    public Dictionary<string, int> ReasonListChat;
    [JsonProperty("Настройка интерфейса")]
    public InterfaceSettings InterfaceSetting;
    [JsonProperty("Настройка оповещения")]
    public AlertSetting AlertSettings;
    internal class MessageSettings
    {
        [JsonProperty("Наименование оповещения в чат")]
        public string BroadcastTitle;
        [JsonProperty("Цвет сообщения оповещения в чат")]
        public string BroadcastColor;
        [JsonProperty("На какое сообщение заменять плохие слова")]
        public string ReplaceBadWord;
        [JsonProperty("Steam64ID для аватарки в чате")]
        public ulong Steam64IDAvatar;
        [JsonProperty("Список плохих слов")]
        public List<string> BadWords;
        [JsonProperty("Время,через которое удалится сообщение с UI от администратора")]
        public int TimeDeleteAlertUI;
        [JsonProperty("Включить форматирование сообщений")]
        public bool FormatingMessage;
        [JsonProperty("Включить личные сообщения")]
        public bool PMActivate;
        [JsonProperty("Включить Анти-Спам")]
        public bool AntiSpamActivate;
        [JsonProperty("Звук при при получении личного сообщения")]
        public string SoundPM;
        [JsonProperty("Время через которое игрок может отправлять сообщение (АнтиСпам)")]
        public int FloodTime;
    }

    internal class InterfaceSettings
    {
        [JsonProperty("Основной цвет UI")]
        public string MainColor;
        [JsonProperty("Дополнительный #1 цвет UI")]
        public string TwoMainColor;
        [JsonProperty("Дополнительный #2 цвет UI")]
        public string ThreeMainColor;
        [JsonProperty("Основной цвет UI панели МУТОВ")]
        public string MainColorMute;
    }

    internal class AlertSetting
    {
        [JsonProperty("Включить случайное сообщение зашедшему игроку")]
        public bool WelcomeMessageUse;
        [JsonProperty("Список сообщений игроку при входе")]
        public List<string> WelcomeMessage;
        [JsonProperty("Уведомлять о входе игрока в чат")]
        public bool ConnectedAlert;
        [JsonProperty("Уведомлять о выходе игрока в чат")]
        public bool DisconnectedAlert;
        [JsonProperty("При уведомлении о входе/выходе игрока отображать его аватар напротив ника")]
        public bool ConnectedAvatarUse;
        [JsonProperty("Включить автоматические сообщения в чат")]
        public bool AlertMessage;
        [JsonProperty("Настройка отправки автоматических сообщений в чат")]
        public List<string> MessageList;
        [JsonProperty("Интервал отправки сообщений в чат(Броадкастер)")]
        public int MessageListTimer;
    }

    public static Configuration GetNewConfiguration();
}

internal class MessageSettings
{
    [JsonProperty("Наименование оповещения в чат")]
    public string BroadcastTitle;
    [JsonProperty("Цвет сообщения оповещения в чат")]
    public string BroadcastColor;
    [JsonProperty("На какое сообщение заменять плохие слова")]
    public string ReplaceBadWord;
    [JsonProperty("Steam64ID для аватарки в чате")]
    public ulong Steam64IDAvatar;
    [JsonProperty("Список плохих слов")]
    public List<string> BadWords;
    [JsonProperty("Время,через которое удалится сообщение с UI от администратора")]
    public int TimeDeleteAlertUI;
    [JsonProperty("Включить форматирование сообщений")]
    public bool FormatingMessage;
    [JsonProperty("Включить личные сообщения")]
    public bool PMActivate;
    [JsonProperty("Включить Анти-Спам")]
    public bool AntiSpamActivate;
    [JsonProperty("Звук при при получении личного сообщения")]
    public string SoundPM;
    [JsonProperty("Время через которое игрок может отправлять сообщение (АнтиСпам)")]
    public int FloodTime;
}

internal class InterfaceSettings
{
    [JsonProperty("Основной цвет UI")]
    public string MainColor;
    [JsonProperty("Дополнительный #1 цвет UI")]
    public string TwoMainColor;
    [JsonProperty("Дополнительный #2 цвет UI")]
    public string ThreeMainColor;
    [JsonProperty("Основной цвет UI панели МУТОВ")]
    public string MainColorMute;
}

internal class AlertSetting
{
    [JsonProperty("Включить случайное сообщение зашедшему игроку")]
    public bool WelcomeMessageUse;
    [JsonProperty("Список сообщений игроку при входе")]
    public List<string> WelcomeMessage;
    [JsonProperty("Уведомлять о входе игрока в чат")]
    public bool ConnectedAlert;
    [JsonProperty("Уведомлять о выходе игрока в чат")]
    public bool DisconnectedAlert;
    [JsonProperty("При уведомлении о входе/выходе игрока отображать его аватар напротив ника")]
    public bool ConnectedAvatarUse;
    [JsonProperty("Включить автоматические сообщения в чат")]
    public bool AlertMessage;
    [JsonProperty("Настройка отправки автоматических сообщений в чат")]
    public List<string> MessageList;
    [JsonProperty("Интервал отправки сообщений в чат(Броадкастер)")]
    public int MessageListTimer;
}

public class SettingUser
{
    public string ChatPrefix;
    public string NickColor;
    public string MessageColor;
    public double MuteChatTime;
    public double MuteVoiceTime;
}

public class AdminSettings
{
    public bool MuteChatAll;
    public bool MuteVoiceAll;
    public Dictionary<ulong, string> RenameList;
}


```

---

## IQChat-2.65.46

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using CompanionServer;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using UnityEngine.Networking;
using Object = System.Object;
using Pool = Facepunch.Pool;

Oxide.Plugins
[Info("IQChat", "Mercury", "2.65.46")]
[Description("The most pleasant chat for your server from the IQ system")]
 class IQChat : RustPlugin
{
    [PluginReference]
     Plugin ImageLibrary;
     Plugin IQFakeActive;
     Plugin IQRankSystem;
     Plugin XLevels;
     Plugin Clans;
     Plugin XPrison;
     Plugin TranslationAPI;
     Plugin RustApp;
     Plugin SkillTree;
     Plugin PlayerRanks;
    private String GetClanTag(BasePlayer.EncryptedValue<UInt64> playerID);
    private String GetClanTag(UInt64 playerID);
    private String PlayerRanks_GetRanks(BasePlayer player);
    private String GetPrestigeLevel(UInt64 player);
    private String SkillTree_GetLevel(BasePlayer player);
    private String SkillTree_GetXP(BasePlayer player);
    private String[] GetInfoSkillTree(BasePlayer player);
    private String XLevel_GetLevel(BasePlayer player);
    private String XLevel_GetPrefix(BasePlayer player);
    public class FakePlayer
    {
        [JsonProperty("userId")]
        public String userId;
        [JsonProperty("displayName")]
        public String displayName;
        public Boolean isMuted;
    }

    public Boolean IsReadyIQFakeActive();
    private List<FakePlayer> GetCombinedPlayerList();
    private Boolean IsFakeUser(String idOrName);
    private Boolean SetMuteFakeUser(String idOrName, Boolean isMuted);
    private String GetFakeName(String idOrName);
     String IQRankGetRank(BasePlayer.EncryptedValue<UInt64> userID);
     String IQRankGetRank(ulong userID);
     String IQRankGetTimeGame(BasePlayer.EncryptedValue<UInt64> userID);
     String IQRankGetTimeGame(ulong userID);
     List<String> IQRankListKey(BasePlayer.EncryptedValue<UInt64> userID);
     List<String> IQRankListKey(ulong userID);
     String IQRankGetNameRankKey(string Key);
     void IQRankSetRank(BasePlayer.EncryptedValue<UInt64> userID, string RankKey);
     void IQRankSetRank(ulong userID, string RankKey);
    private String XPrison_GetPrefix(BasePlayer player);
    private const Boolean LanguageEn;
    private static IQChat _;
    private static ImageUI _imageUI;
    public class TranslationState
    {
        public Boolean IsProcessed { get; set; }
        public String Translation { get; set; }
        public String DoTranslation { get; set; }
    }

    private Dictionary<String, TranslationState> saveTranslate;
    static Double CurrentTime { get; set; }
    public Dictionary<BasePlayer, BasePlayer> PMHistory;
    public Dictionary<BasePlayer, List<String>> LastMessagesChat;
    private const String PermissionUseCmdCnick;
    private const String PermissionUseCmdMsg;
    private const String PermissionTranslationIgnore;
    private const String PermissionHideMuteName;
    private const String PermissionHideOnline;
    private const String PermissionMute;
    private const String PermissionAlert;
    private const String PermissionRename;
    private const String PermissionAntiSpam;
    private const String PermissionHideConnection;
    private const String PermissionHideDisconnection;
    private const String PermissionMutedAdmin;
     class Response
    {
        [JsonProperty("country")]
        public string Country { get; set; }
    }

    public static StringBuilder sb;
    public string GetLang(string LangKey, string userID, object[] args);
    private static Configuration config;
    private class Configuration
    {
        [JsonProperty(LanguageEn ? "Setting up player information" : "Настройка информации о игроке")]
        public ControllerConnection ControllerConnect;
        internal class ControllerConnection
        {
            [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
            public Turned Turneds;
            [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
            public SetupDefault SetupDefaults;
            internal class SetupDefault
            {
                [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
                public String PrefixDefault;
                [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
                public String NickDefault;
                [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
                public String MessageDefault;
            }

            internal class Turned
            {
                [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
                public Boolean TurnAutoSetupPrefix;
                [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
                public Boolean TurnAutoSetupColorNick;
                [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
                public Boolean TurnAutoSetupColorChat;
                [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
                public Boolean TurnAutoDropPrefix;
                [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
                public Boolean TurnAutoDropColorNick;
                [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
                public Boolean TurnAutoDropColorChat;
            }

        }

        [JsonProperty(LanguageEn ? "Setting options for the player" : "Настройка параметров для игрока")]
        public ControllerParameters ControllerParameter;
        internal class ControllerParameters
        {
            [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
            public VisualSettingParametres VisualParametres;
            [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
            public List<AdvancedFuncion> NickColorList;
            [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
            public List<AdvancedFuncion> MessageColorList;
            [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
            public PrefixSetting Prefixes;
            internal class PrefixSetting
            {
                [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
                public Boolean TurnMultiPrefixes;
                [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
                public Int32 MaximumMultiPrefixCount;
                [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
                public List<AdvancedFuncion> Prefixes;
            }

            internal class AdvancedFuncion
            {
                [JsonProperty(LanguageEn ? "Permission" : "Права")]
                public String Permissions;
                [JsonProperty(LanguageEn ? "Argument" : "Значение")]
                public String Argument;
                [JsonProperty(LanguageEn ? "Block the player's ability to select this parameter in the plugin menu (true - yes/false - no)" : "Заблокировать возможность выбрать данный параметр игроком в меню плагина (true - да/false - нет)")]
                public Boolean IsBlockSelected;
            }

            internal class VisualSettingParametres
            {
                [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
                public SelectedParametres PrefixType;
                [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
                public SelectedParametres NickColorType;
                [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
                public SelectedParametres ChatColorType;
                [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
                public SelectedParametres IQRankSystemType;
            }

        }

        [JsonProperty(LanguageEn ? "Plugin mute settings" : "Настройка мута в плагине")]
        public ControllerMute ControllerMutes;
        internal class ControllerMute
        {
            [JsonProperty(LanguageEn ? "Prohibit sending messages in /pm and /r if the player's chat is blocked" : "Запрещать отправлять сообщения в /pm, /r - если у игрока заблокирован чат")]
            public Boolean mutedPM;
            [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
            public AutoMute AutoMuteSettings;
            internal class AutoMute
            {
                [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
                public Boolean UseAutoMute;
                [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
                public Muted AutoMuted;
            }

            [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
            public LoggedFuncion LoggedMute;
            internal class LoggedFuncion
            {
                [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
                public Boolean UseHistoryMessage;
                [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
                public Int32 CountHistoryMessage;
            }

            [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
            public List<Muted> MuteChatReasons;
            [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
            public List<Muted> MuteVoiceReasons;
            internal class Muted
            {
                [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
                public String Reason;
                [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
                public Int32 SecondMute;
            }

        }

        [JsonProperty(LanguageEn ? "Configuring Message Processing" : "Настройка обработки сообщений")]
        public ControllerMessage ControllerMessages;
        internal class ControllerMessage
        {
            [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
            public GeneralSettings GeneralSetting;
            [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
            public TurnedFuncional TurnedFunc;
            [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
            public FormattingMessage Formatting;
            internal class GeneralSettings
            {
                [JsonProperty(LanguageEn ? "Notify the player in chat about receiving a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о получении префикса/цвета ника/цвета чата (true - да/false - нет)")]
                public Boolean alertArgumentsInfoSetup;
                [JsonProperty(LanguageEn ? "Notify the player in chat about the end of a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о окончании префикса/цвета ника/цвета чата (true - да/false - нет)")]
                public Boolean alertArgumentsInfoRemove;
                [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
                public BroadcastSettings BroadcastFormat;
                [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
                public AlertSettings AlertFormat;
                [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
                public OtherSettings OtherSetting;
                internal class BroadcastSettings
                {
                    [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
                    public String BroadcastTitle;
                    [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
                    public String BroadcastColor;
                    [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
                    public String Steam64IDAvatar;
                }

                internal class AlertSettings
                {
                    [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
                    public String AlertPlayerColor;
                    [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
                    public String SoundAlertPlayer;
                }

                internal class OtherSettings
                {
                    [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
                    public Int32 TimeDeleteAlertUI;
                    [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
                    public Int32 SizeMessage;
                    [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
                    public Int32 SizeNick;
                    [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
                    public Int32 SizePrefix;
                    [JsonProperty(LanguageEn ? "Nickname size according to privilege [permission] = size" : "Размер ника по привилегии [permission] = размер")]
                    public Dictionary<String, Int32> sizeNickPrivilages;
                    [JsonProperty(LanguageEn ? "Chat message size according to privilege [permission] = size" : "Размер сообщения в чате по привилегии [permission] = размер")]
                    public Dictionary<String, Int32> sizeMessagePrivilages;
                    public Int32 GetSizeNickOrMessage(BasePlayer player, Boolean nickOrMessage);
                }

            }

            internal class TurnedFuncional
            {
                [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
                public AntiSpam AntiSpamSetting;
                [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
                public AntiNoob AntiNoobSetting;
                [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
                public PM PMSetting;
                internal class AntiNoob
                {
                    [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
                    public Settings AntiNoobPM;
                    [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
                    public Settings AntiNoobChat;
                    internal class Settings
                    {
                        [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                        public Boolean AntiNoobActivate;
                        [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                        public Int32 TimeBlocked;
                    }

                }

                internal class AntiSpam
                {
                    [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
                    public Boolean AntiSpamActivate;
                    [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                    public Int32 FloodTime;
                    [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
                    public AntiSpamDuples AntiSpamDuplesSetting;
                    internal class AntiSpamDuples
                    {
                        [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                        public Boolean AntiSpamDuplesActivate;
                        [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                        public Int32 TryDuples;
                        [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                        public ControllerMute.Muted MuteSetting;
                    }

                }

                internal class PM
                {
                    [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
                    public Boolean PMActivate;
                    [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
                    public String SoundPM;
                }

                [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
                public Boolean IgnoreUsePM;
                [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
                public Boolean HideAdminGave;
                [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
                public Boolean MuteTeamChat;
            }

            internal class FormattingMessage
            {
                [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
                public Boolean FormatMessage;
                [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
                public Boolean UseBadWords;
                [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
                public String ReplaceBadWord;
                [JsonProperty(LanguageEn ? "The list of forbidden words [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных слов [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
                public Dictionary<String, Boolean> BadWords;
                [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
                public NickController ControllerNickname;
                internal class NickController
                {
                    [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
                    public Boolean UseNickController;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
                    public String ReplaceBadNick;
                    [JsonProperty(LanguageEn ? "The list of forbidden nicknames [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных ников [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
                    public Dictionary<String, Boolean> BadNicks;
                    [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
                    public List<String> AllowedLinkNick;
                }

            }

        }

        [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
        public ControllerAlert ControllerAlertSetting;
        internal class ControllerAlert
        {
            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
            public Alert AlertSetting;
            [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
            public PlayerSession PlayerSessionSetting;
            [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
            public AdminSession AdminSessionSetting;
            [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
            public PersonalAlert PersonalAlertSetting;
            internal class Alert
            {
                [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
                public Boolean AlertMessage;
                [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
                public Boolean AlertMessageType;
                [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
                public LanguageController MessageList;
                [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
                public Int32 MessageListTimer;
            }

            internal class PlayerSession
            {
                [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
                public Boolean ConnectedAvatarUse;
                [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
                public Boolean ConnectedAlert;
                [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
                public Boolean ConnectionAlertRandom;
                [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
                public Boolean ConnectedWorld;
                [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
                public Boolean DisconnectedAlert;
                [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
                public Boolean DisconnectedAlertRandom;
                [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
                public Boolean DisconnectedReason;
                [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                public LanguageController RandomConnectionAlert;
                [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                public LanguageController RandomDisconnectedAlert;
            }

            internal class AdminSession
            {
                [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
                public Boolean ConnectedAlertAdmin;
                [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
                public Boolean DisconnectedAlertAdmin;
            }

            internal class PersonalAlert
            {
                [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
                public Boolean UseWelcomeMessage;
                [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
                public LanguageController WelcomeMessage;
            }

        }

        public class LanguageController
        {
            [JsonProperty(LanguageEn ? "Setting up Multilingual Messages [Language Code] = Translation Variations" : "Настройка мультиязычных сообщений [КодЯзыка] = ВариацииПеревода")]
            public Dictionary<String, List<String>> LanguageMessages;
        }

        [JsonProperty(LanguageEn ? "Settings Rust+" : "Настройка Rust+")]
        public RustPlus RustPlusSettings;
        internal class RustPlus
        {
            [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
            public Boolean UseRustPlus;
            [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
            public String DisplayNameAlert;
        }

        [JsonProperty(LanguageEn ? "Configuring support plugins" : "Настройка плагинов поддержки")]
        public ReferenceSettings ReferenceSetting;
        internal class ReferenceSettings
        {
            [JsonProperty(LanguageEn ? "Settings XLevels" : "Настройка XLevels")]
            public XLevels XLevelsSettings;
            [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
            public IQFakeActive IQFakeActiveSettings;
            [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
            public IQRankSystem IQRankSystems;
            [JsonProperty(LanguageEn ? "Settings Clans" : "Настройка Clans")]
            public Clans ClansSettings;
            [JsonProperty(LanguageEn ? "Settings TranslationAPI" : "Настройка TranslationAPI")]
            public TranslataionApi translationApiSettings;
            [JsonProperty(LanguageEn ? "Settings SkillTree" : "Настройка SkillTree")]
            public SkillTree skillTreeSettings;
            [JsonProperty(LanguageEn ? "Settings PlayerRanks" : "Настройка PlayerRanks")]
            public PlayerRanks playerRanksSettings;
            [JsonProperty(LanguageEn ? "Settings XPrison" : "Настройка XPrison")]
            public XPrison xPrisonSettings;
            internal class TranslataionApi
            {
                [JsonProperty(LanguageEn ? "To use automatic message translation using the TranslationAPI" : "Использовать автоматический перевод сообщений с помощью TranslataionAPI")]
                public Boolean useTranslationApi;
                [JsonProperty(LanguageEn ? "Translate team chat" : "Переводить командный чат")]
                public Boolean translateTeamChat;
                [JsonProperty(LanguageEn ? "Translate chat in private messages." : "Переводить чат в личных сообщениях")]
                public Boolean translatePmChat;
                [JsonProperty(LanguageEn ? "The code for the preferred language (leave it empty, and then the translation will be done in each player's language)" : "Код приоритетного языка (оставьте пустым и тогда для каждого игрока будет переводиться на его языке клиента)")]
                public String codeLanguagePrimary;
            }

            internal class Clans
            {
                [JsonProperty(LanguageEn ? "Display a clan tag in the chat (if Clans are installed)" : "Отображать в чате клановый тэг (если установлены Clans)")]
                public Boolean UseClanTag;
                [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                public String colorTag;
            }

            internal class IQRankSystem
            {
                [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
                public String FormatRank;
                [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
                public String FormatRankTime;
                [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
                public Boolean UseRankSystem;
                [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
                public Boolean UseTimeStandart;
            }

            internal class IQFakeActive
            {
                [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
                public Boolean UseIQFakeActive;
            }

            internal class XLevels
            {
                [JsonProperty(LanguageEn ? "Use support XLevels" : "Использовать поддержку XLevels")]
                public Boolean UseXLevels;
                [JsonProperty(LanguageEn ? "Use full prefix with level from XLevel (true) otherwise only level (false)" : "Использовать полный префикс с уровнем из XLevel (true) иначе только уровень (false)")]
                public Boolean UseFullXLevels;
                [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                public String colorTag;
            }

            internal class XPrison
            {
                [JsonProperty(LanguageEn ? "Use support XPrison" : "Использовать поддержку XPrison")]
                public Boolean UseXPrison;
                [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                public String colorTag;
            }

            internal class SkillTree
            {
                [JsonProperty(LanguageEn ? "Use support SkillTree" : "Использовать поддержку SkillTree")]
                public Boolean UseSkillTree;
                [JsonProperty(LanguageEn ? "Use full XP + Level information output (true), use only Level (false)" : "Использовать полный вывод информации XP + Level (true), использовать только Level (false)")]
                public Boolean UseFullSkillTree;
                [JsonProperty(LanguageEn ? "Use prestige" : "Использовать престиж")]
                public Boolean UsePrestigeSkillTree;
                [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                public String colorTag;
            }

            internal class PlayerRanks
            {
                [JsonProperty(LanguageEn ? "Use support PlayerRanks" : "Использовать поддержку PlayerRanks")]
                public Boolean UsePlayerRanks;
                [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                public String colorTag;
            }

        }

        [JsonProperty(LanguageEn ? "Setting up an answering machine" : "Настройка автоответчика")]
        public AnswerMessage AnswerMessages;
        internal class AnswerMessage
        {
            [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
            public bool UseAnswer;
            [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
            public Dictionary<String, LanguageController> AnswerMessageList;
        }

        [JsonProperty(LanguageEn ? "Disable additional chat duplication in RCON" : "Отключить дополнительное дублированиеи чата в RCON")]
        public Boolean disableRconBroadcast;
        [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
        public OtherSettings OtherSetting;
        internal class OtherSettings
        {
            [JsonProperty("SteamApiKey (https://steamcommunity.com/dev/apikey)")]
            public String renameSteamApiKey;
            [JsonProperty(LanguageEn ? "Enable the /online command (true - yes / false - no)" : "Включить команду /online (true - да/ false - нет)")]
            public Boolean UseCommandOnline;
            [JsonProperty(LanguageEn ? "Use shortened format /online (will only display quantity)" : "Использовать сокращенный формат /online (будет отображать только количество)")]
            public Boolean UseCommandShortOnline;
            [JsonProperty(LanguageEn ? "Compact logging of messages" : "Компактное логирование сообщений")]
            public CompactLoggetChat CompactLogsChat;
            [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
            public LoggedChat LogsChat;
            [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
            public General LogsPMChat;
            [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
            public General LogsMuted;
            [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
            public General LogsChatCommands;
            internal class CompactLoggetChat
            {
                [JsonProperty(LanguageEn ? "Display Steam64ID in the log (true - yes/false - no)" : "Отображать в логе Steam64ID (true - да/false - нет)")]
                public Boolean ShowSteamID;
                [JsonProperty(LanguageEn ? "Setting up compact message logging" : "Настройка компактного логирования сообщений")]
                public LoggedChat LogsCompactChat;
            }

            internal class LoggedChat
            {
                [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
                public General GlobalChatSettings;
                [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
                public General TeamChatSettings;
            }

            internal class General
            {
                [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
                public Boolean UseLogged;
                [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
                public String Webhooks;
            }

        }

        public static Configuration GetNewConfiguration();
    }

    protected override void LoadConfig();
    private void RegisteredPermissions();
    protected override void LoadDefaultConfig();
    protected override void SaveConfig();
    public GeneralInformation GeneralInfo;
    public Dictionary<UInt64, User> UserInformation;
    public Dictionary<UInt64, AntiNoob> UserInformationConnection;
    internal class AntiNoob
    {
        public DateTime DateConnection;
        public Boolean IsNoob(Int32 TimeBlocked);
        public Double LeftTime(Int32 TimeBlocked);
    }

    public class User
    {
        public Information Info;
        public Setting Settings;
        public Mute MuteInfo;
        internal class Information
        {
            public String Prefix;
            public String ColorNick;
            public String ColorMessage;
            public String Rank;
            public String CustomColorNick;
            public String CustomColorMessage;
            public List<String> PrefixList;
        }

        internal class Setting
        {
            public Boolean TurnPM;
            public Boolean TurnAlert;
            public Boolean TurnBroadcast;
            public Boolean TurnSound;
            public List<UInt64> IgnoreUsers;
            public Boolean IsIgnored(UInt64 TargetID);
            public void IgnoredAddOrRemove(UInt64 TargetID);
        }

        internal class Mute
        {
            public Double TimeMuteChat;
            public Double TimeMuteVoice;
            public Double GetTime(MuteType Type);
            public void SetMute(MuteType Type, Int32 Time);
            public void UnMute(MuteType Type);
            public Boolean IsMute(MuteType Type);
        }

    }

    public class GeneralInformation
    {
        public Boolean TurnMuteAllChat;
        public Boolean TurnMuteAllVoice;
        public Dictionary<UInt64, RenameInfo> RenameList;
        internal class RenameInfo
        {
            public String RenameNick;
            public UInt64 RenameID;
        }

        public RenameInfo GetInfoRename(UInt64 UserID);
    }

    private void MigrateDataToNoob();
    private void UserConnecteionData(BasePlayer player);
     void ReadData();
     void WriteData();
    private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel);
    private object OnServerMessage(String message, String name);
     void OnPlayerCommand(BasePlayer player, string command, string[] args);
     void OnUserPermissionGranted(string id, string permName);
     void OnUserPermissionRevoked(string id, string permName);
     void OnUserGroupAdded(string id, string groupName);
     void OnUserGroupRemoved(string id, string groupName);
     void OnGroupPermissionGranted(string name, string perm);
     void OnGroupPermissionRevoked(string name, string perm);
     object OnPlayerVoice(BasePlayer player, Byte[] data);
     void Init();
    private void OnServerInitialized();
    private void CheckValidateUsers();
     void OnPlayerConnected(BasePlayer player);
    private void OnUserConnected(IPlayer player);
     void Unload();
     void OnPlayerDisconnected(BasePlayer player, string reason);
    private void DiscordLoggCommand(BasePlayer player, String Command, String[] Args);
    private void DiscordLoggChat(BasePlayer player, Chat.ChatChannel Channel, String MessageLogged);
    private void DiscordCompactLoggChat(BasePlayer player, Chat.ChatChannel Channel, String MessageLogged);
    private void DiscordLoggPM(BasePlayer Sender, BasePlayer Reciepter, String MessageLogged);
    private void DiscordLoggMuted(BasePlayer Target, MuteType Type, String Reason, String TimeBlocked, BasePlayer Moderator);
    public class FancyMessage
    {
        public string content { get; set; }
        public bool tts { get; set; }
        public Embeds[] embeds { get; set; }
        public class Embeds
        {
            public string title { get; set; }
            public int color { get; set; }
            public List<Fields> fields { get; set; }
            public Footer footer { get; set; }
            public Authors author { get; set; }
            public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer);
        }

        public FancyMessage(string content, bool tts, Embeds[] embeds);
        public string toJSON();
    }

    public class Footer
    {
        public string text { get; set; }
        public string icon_url { get; set; }
        public string proxy_icon_url { get; set; }
        public Footer(string text, string icon_url, string proxy_icon_url);
    }

    public class Authors
    {
        public string name { get; set; }
        public string url { get; set; }
        public string icon_url { get; set; }
        public string proxy_icon_url { get; set; }
        public Authors(string name, string url, string icon_url, string proxy_icon_url);
    }

    public class Fields
    {
        public string name { get; set; }
        public string value { get; set; }
        public bool inline { get; set; }
        public Fields(string name, string value, bool inline);
    }

    private void Request(string url, string payload, Action<int> callback);
    public List<String> GetMesagesList(BasePlayer player, Dictionary<String, List<String>> LanguageMessages);
    public String GetMessages(BasePlayer player, Dictionary<String, List<String>> LanguageMessages);
    private void SetupParametres(String ID, String Permissions);
    private void RemoveParametres(String ID, String Permissions);
    private void ReplyPlayerChat(Chat.ChatChannel channel, BasePlayer player, BasePlayer playerSender, String OutMessage, String FormatMessage, String FormatPlayer, UInt64 RenameID);
    private ListHashSet<BasePlayer> GetPlayerList(BasePlayer player, Chat.ChatChannel channel);
    private void ReplyTranslationMessage(Chat.ChatChannel channel, BasePlayer player, BasePlayer playerSender, String OutMessage, String FormatMessage, String FormatPlayer, UInt64 RenameID);
     void ReplyChat(Chat.ChatChannel channel, BasePlayer player, String OutMessage, String FormatMessage, String FormatPlayer);
     void ReplySystem(BasePlayer player, String Message, String CustomPrefix, String CustomAvatar, String CustomHex);
     void ReplyBroadcast(String Message, String CustomPrefix, String CustomAvatar, Boolean AdminAlert);
     void ReplyBroadcast(String CustomPrefix, String CustomAvatar, Boolean AdminAlert, String LangKey, object[] args);
     void ReplyBroadcast(String CustomPrefix, String CustomAvatar, Boolean AdminAlert, Dictionary<String, List<String>> Messages, object[] args);
    public Boolean IsNoob(UInt64 userID, Int32 TimeBlocked);
    public void AnwserMessage(BasePlayer player, String Message);
    private void AddHistoryMessage(BasePlayer player, String Message);
    private String GetLastMessage(BasePlayer player, Int32 Count);
    public Dictionary<UInt64, FlooderInfo> Flooders;
    internal class FlooderInfo
    {
        public Double Time;
        public String LastMessage;
        public Int32 TryFlood;
    }

    private Tuple<String, Boolean> BadWordsCleaner(String formattingMessage, String replaceBadWord, Dictionary<String, Boolean> badWords);
    private String RemoveLinkText(String text);
    private String GetReferenceTags(BasePlayer player);
    public Object IsGradientColorValue(String value);
    public static Regex regex;
    public static String ApplyGradientToText(String text, List<String> colors);
    private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, String Message);
    public void BroadcastAuto();
    private void AlertDisconnected(BasePlayer player, String reason);
    private void AlertController(BasePlayer player);
    private void MutePlayer(BasePlayer Target, MuteType Type, Int32 ReasonIndex, BasePlayer Moderator, String ReasonCustom, Int32 TimeCustom, Boolean HideMute, Boolean Command, String fakeUserId);
    private void UnmutePlayer(BasePlayer Target, MuteType Type, BasePlayer Moderator, Boolean HideUnmute, Boolean Command, String fakeUserId);
     void AlertUI(BasePlayer Sender, string[] arg);
     void AlertUI(BasePlayer Sender, BasePlayer Recipient, string[] arg);
     void Alert(BasePlayer Sender, string[] arg, Boolean IsAdmin);
     void Alert(BasePlayer Sender, BasePlayer Recipient, string[] arg);
    private Int32 GetPlayersOnlineShort();
    private List<String> GetPlayersOnline();
    private String GetPlayerFormat(String displayName, String userId);
    private void ControlledBadNick(IPlayer player);
    private class ImageUI
    {
        private const String _path;
        private const String _printPath;
        private readonly Dictionary<String, ImageData> _images;
        private class ImageData
        {
            public ImageStatus Status;
            public string Id { get; set; }
        }

        public string GetImage(string name);
        public void DownloadImage();
        public void UnloadImages();
        private IEnumerator ProcessDownloadImage(KeyValuePair<string, ImageData> image);
    }

    private static InterfaceBuilder _interface;
    private Dictionary<BasePlayer, InformationOpenedUI> LocalBase;
    private class InformationOpenedUI
    {
        public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsPrefix;
        public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsNick;
        public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsChat;
        public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsRanks;
        public Int32 SlideIndexPrefix;
        public Int32 SlideIndexNick;
        public Int32 SlideIndexChat;
        public Int32 SlideIndexRank;
    }

    private void DrawUI_IQChat_Update_DisplayName(BasePlayer player);
    private void DrawUI_IQChat_Context(BasePlayer player);
    private void DrawUI_IQChat_Context_AdminAndModeration(BasePlayer player);
    private void DrawUI_IQChat_Update_MuteChat_All(BasePlayer player);
    private void DrawUI_IQChat_Update_MuteVoice_All(BasePlayer player);
    private void DrawUI_IQChat_Ignore_Alert(BasePlayer player, BasePlayer Target, UInt64 fakeUserId);
    private void DrawUI_IQChat_Mute_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake);
    private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, MuteType Type, UInt64 IDFake);
    private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, String Reason, Int32 Y, MuteType Type, UInt64 IDFake);
    private void DrawUI_IQChat_Mute_And_Ignore(BasePlayer player, SelectedAction Action);
    private void DrawUI_IQChat_Mute_And_Ignore_Player_Panel(BasePlayer player, SelectedAction Action, Int32 Page, String SearchName);
    private List<FakePlayer> GetFilteredPlayers(string searchName);
    private Boolean TryGetUserIdAsUlong(String userId, UInt64 userIdAsUlong);
    private Boolean HasMorePages(IEnumerable<T> items, Int32 page);
    private IEnumerable<T> GetPageOfPlayers(IEnumerable<T> items, Int32 page);
    private IOrderedEnumerable<BasePlayer> GetPlayerList(String searchName, SelectedAction action);
    private void DrawUI_IQChat_Mute_And_Ignore_Pages(BasePlayer player, Boolean IsNextPage, SelectedAction Action, Int32 Page);
    private void DrawUI_IQChat_Mute_And_Ignore_Player(BasePlayer player, SelectedAction Action, IEnumerable<BasePlayer> PlayerList, IEnumerable<FakePlayer> FakePlayerList);
    private void DrawUI_IQChat_Update_Check_Box(BasePlayer player, ElementsSettingsType Type, String OffsetMin, String OffsetMax, Boolean StatusCheckBox);
    private void DrawUI_IQChat_Sliders(BasePlayer player, String Name, String OffsetMin, String OffsetMax, TakeElementUser ElementType);
    private void DrawUI_IQChat_Slider_Update_Argument(BasePlayer player, TakeElementUser ElementType);
    private void DrawUI_IQChat_DropList(BasePlayer player, String OffsetMin, String OffsetMax, String Title, TakeElementUser ElementType);
    private void DrawUI_IQChat_OpenDropList(BasePlayer player, TakeElementUser ElementType, Int32 Page);
    private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, TakeElementUser ElementType, Configuration.ControllerParameters.AdvancedFuncion Info, Int32 X, Int32 Y, Int32 Count);
    private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, Int32 Count);
    private void DrawUI_IQChat_Alert(BasePlayer player, String Description, String Title);
    private class InterfaceBuilder
    {
        public static InterfaceBuilder Instance;
        public const String UI_Chat_Context;
        public const String UI_Chat_Context_Visual_Nick;
        public const String UI_Chat_Alert;
        public Dictionary<String, String> Interfaces;
        public InterfaceBuilder();
        public static void AddInterface(String name, String json);
        public static string GetInterface(String name);
        public static void DestroyAll();
        private void BuildingVisualNick();
        private void BuildingStaticContext();
        private void BuildingCheckBox();
        private void BuildingSlider();
        private void BuildingSliderUpdateArgument();
        private void BuildingMuteAndIgnore();
        private void BuildingMuteAndIgnorePlayerPanel();
        private void BuildingMuteAndIgnorePlayer();
        private void BuildingMuteAndIgnorePages();
        private void BuildingMuteAndIgnorePanelAlert();
        private void BuildingMuteAlert();
        private void BuildingMuteAlert_DropList_Title();
        private void BuildingMuteAlert_DropList_Reason();
        private void BuildingIgnoreAlert();
        private void BuildingDropList();
        private void BuildingOpenDropList();
        private void BuildingElementDropList();
        private void BuildingElementDropListTakeLine();
        private void BuildingModerationStatic();
        private void BuildingMuteAllChat();
        private void BuildingMuteAllVoice();
        private void BuildingAlertUI();
    }

    [ConsoleCommand("newui.cmd")]
    private void ConsoleCommandFuncional(ConsoleSystem.Arg arg);
    [ChatCommand("chat")]
    private void ChatCommandOpenedUI(BasePlayer player);
    [ChatCommand("cnick")]
    private void ColoredNickSetup(BasePlayer player, String cmd, String[] args);
    [ChatCommand("cmsg")]
    private void ColoredMsgSetup(BasePlayer player, String cmd, String[] args);
    private void ConsoleOrPrintMessage(BasePlayer player, String Messages);
    [ConsoleCommand("hmute")]
     void HideMuteConsole(ConsoleSystem.Arg arg);
    [ChatCommand("hmute")]
     void HideMute(BasePlayer Moderator, string cmd, string[] arg);
    [ConsoleCommand("hunmute")]
     void HideUnMuteConsole(ConsoleSystem.Arg arg);
    [ChatCommand("hunmute")]
     void HideUnMute(BasePlayer Moderator, string cmd, string[] arg);
    [ConsoleCommand("mutefull")]
     void MuteCustomAdminFull(ConsoleSystem.Arg arg);
    [ConsoleCommand("mute")]
     void MuteCustomAdmin(ConsoleSystem.Arg arg);
    [ChatCommand("mute")]
     void MuteCustomChat(BasePlayer Moderator, string cmd, string[] arg);
    [ChatCommand("mutevoice")]
     void MuteVoiceCustomChat(BasePlayer Moderator, string cmd, string[] arg);
    [ConsoleCommand("mutevoice")]
     void MuteCustomVoiceAdmin(ConsoleSystem.Arg arg);
    [ConsoleCommand("unmute")]
     void UnMuteCustomAdmin(ConsoleSystem.Arg arg);
    [ConsoleCommand("unmutevoice")]
     void UnMuteVoiceCustomAdmin(ConsoleSystem.Arg arg);
    [ChatCommand("unmute")]
     void UnMuteCustomChat(BasePlayer Moderator, string cmd, string[] arg);
    [ChatCommand("unmutevoice")]
     void UnMuteVoiceCustomChat(BasePlayer Moderator, string cmd, string[] arg);
    [ChatCommand("online")]
    private void ShowPlayerOnline(BasePlayer player);
    [ConsoleCommand("online")]
    private void ShowPlayerOnlineConsole(ConsoleSystem.Arg arg);
    [ChatCommand("alert")]
    private void AlertChatCommand(BasePlayer Sender, String cmd, String[] args);
    [ChatCommand("adminalert")]
    private void AdminAlertChatCommand(BasePlayer Sender, String cmd, String[] args);
    [ChatCommand("alertui")]
    private void AlertUIChatCommand(BasePlayer Sender, String cmd, String[] args);
    [ChatCommand("alertuip")]
    private void AlertUIPChatCommand(BasePlayer Sender, String cmd, String[] args);
    [ChatCommand("saybro")]
    private void AlertOnlyPlayerChatCommand(BasePlayer Sender, String cmd, String[] args);
    [ConsoleCommand("alert")]
    private void AlertConsoleCommand(ConsoleSystem.Arg args);
    [ConsoleCommand("adminalert")]
    private void AdminAlertConsoleCommand(ConsoleSystem.Arg args);
    [ConsoleCommand("alertui")]
    private void AlertUIConsoleCommand(ConsoleSystem.Arg args);
    [ConsoleCommand("alertuip")]
    private void AlertUIPConsoleCommand(ConsoleSystem.Arg args);
    [ConsoleCommand("saybro")]
    private void AlertOnlyPlayerConsoleCommand(ConsoleSystem.Arg args);
    [ChatCommand("rename")]
    private void ChatCommandRename(BasePlayer Renamer, string command, string[] args);
    [ChatCommand("rename.reset")]
    private void ChatCommandRenameReset(BasePlayer Renamer);
    [ConsoleCommand("rename.reset")]
    private void ConsoleCommandRenameReset(ConsoleSystem.Arg args);
    [ConsoleCommand("rename")]
    private void ConsoleCommandRename(ConsoleSystem.Arg args);
    private void RenameUpdate(BasePlayer Renamer, String NewName);
    private void RenameReset(BasePlayer Renamer);
    [ConsoleCommand("set")]
    private void CommandSet(ConsoleSystem.Arg args);
    private void ReplyTranslationPM(BasePlayer Sender, BasePlayer TargetUser, String Message, String DisplayNameSender, String TargetDisplayName);
    [ChatCommand("pm")]
     void PmChat(BasePlayer Sender, String cmd, String[] arg);
    [ChatCommand("r")]
     void RChat(BasePlayer Sender, string cmd, string[] arg);
    [ChatCommand("ignore")]
     void IgnorePlayerPM(BasePlayer player, String cmd, String[] arg);
    private Boolean HasInvalidHexColor(List<String> colorList, String invalidHex);
    private Boolean IsValidHexColor(String color);
    private String JoinStringList(List<String> inputList);
    private List<String> ConvertStringToList(String input);
    private BasePlayer GetPlayerNickOrID(String Info);
    private new void LoadDefaultMessages();
    private void Log(String LoggedMessage);
    public String FormatTime(Double Second, String UserID);
    private String GetMessageInArgs(BasePlayer Sender, String[] arg);
    private String Format(Int32 units, String form1, String form2, String form3);
     void API_SEND_PLAYER(BasePlayer player, String PlayerFormat, String Message, String Avatar, Chat.ChatChannel channel);
     void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, String userID, string Message);
     void API_SEND_PLAYER_CONNECTED(String DisplayName, String country, String userID);
     void API_SEND_PLAYER_DISCONNECTED(String DisplayName, String reason, String userID);
     void API_ALERT(String Message, Chat.ChatChannel channel, String CustomPrefix, String CustomAvatar, String CustomHex);
     void API_ALERT_PLAYER(BasePlayer player, String Message, String CustomPrefix, String CustomAvatar, String CustomHex);
     void API_ALERT_PLAYER_UI(BasePlayer player, String Message);
     Boolean API_CHECK_MUTE_CHAT(BasePlayer.EncryptedValue<UInt64> ID);
     Boolean API_CHECK_MUTE_CHAT(UInt64 ID);
     Boolean API_CHECK_VOICE_CHAT(BasePlayer.EncryptedValue<UInt64> ID);
     Boolean API_CHECK_VOICE_CHAT(UInt64 ID);
     Boolean API_IS_IGNORED(BasePlayer.EncryptedValue<UInt64> UserHas, BasePlayer.EncryptedValue<UInt64> User);
     Boolean API_IS_IGNORED(UInt64 UserHas, UInt64 User);
     String API_GET_PREFIX(BasePlayer.EncryptedValue<UInt64> ID);
     String API_GET_PREFIX(UInt64 ID);
     String API_GET_CHAT_COLOR(BasePlayer.EncryptedValue<UInt64> ID);
     String API_GET_CHAT_COLOR(UInt64 ID);
     String API_GET_NICK_COLOR(BasePlayer.EncryptedValue<UInt64> ID);
     String API_GET_NICK_COLOR(ulong ID);
     String API_GET_DEFAULT_PREFIX();
     String API_GET_DEFAULT_NICK_COLOR();
     String API_GET_DEFAULT_MESSAGE_COLOR();
     Int32 API_GET_DEFAULT_SIZE_MESSAGE();
     Int32 API_GET_DEFAULT_SIZE_NICK();
}

public class FakePlayer
{
    [JsonProperty("userId")]
    public String userId;
    [JsonProperty("displayName")]
    public String displayName;
    public Boolean isMuted;
}

public class TranslationState
{
    public Boolean IsProcessed { get; set; }
    public String Translation { get; set; }
    public String DoTranslation { get; set; }
}

 class Response
{
    [JsonProperty("country")]
    public string Country { get; set; }
}

private class Configuration
{
    [JsonProperty(LanguageEn ? "Setting up player information" : "Настройка информации о игроке")]
    public ControllerConnection ControllerConnect;
    internal class ControllerConnection
    {
        [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
        public Turned Turneds;
        [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
        public SetupDefault SetupDefaults;
        internal class SetupDefault
        {
            [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
            public String PrefixDefault;
            [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
            public String NickDefault;
            [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
            public String MessageDefault;
        }

        internal class Turned
        {
            [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
            public Boolean TurnAutoSetupPrefix;
            [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
            public Boolean TurnAutoSetupColorNick;
            [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
            public Boolean TurnAutoSetupColorChat;
            [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
            public Boolean TurnAutoDropPrefix;
            [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
            public Boolean TurnAutoDropColorNick;
            [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
            public Boolean TurnAutoDropColorChat;
        }

    }

    [JsonProperty(LanguageEn ? "Setting options for the player" : "Настройка параметров для игрока")]
    public ControllerParameters ControllerParameter;
    internal class ControllerParameters
    {
        [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
        public VisualSettingParametres VisualParametres;
        [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
        public List<AdvancedFuncion> NickColorList;
        [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
        public List<AdvancedFuncion> MessageColorList;
        [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
        public PrefixSetting Prefixes;
        internal class PrefixSetting
        {
            [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
            public Boolean TurnMultiPrefixes;
            [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
            public Int32 MaximumMultiPrefixCount;
            [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
            public List<AdvancedFuncion> Prefixes;
        }

        internal class AdvancedFuncion
        {
            [JsonProperty(LanguageEn ? "Permission" : "Права")]
            public String Permissions;
            [JsonProperty(LanguageEn ? "Argument" : "Значение")]
            public String Argument;
            [JsonProperty(LanguageEn ? "Block the player's ability to select this parameter in the plugin menu (true - yes/false - no)" : "Заблокировать возможность выбрать данный параметр игроком в меню плагина (true - да/false - нет)")]
            public Boolean IsBlockSelected;
        }

        internal class VisualSettingParametres
        {
            [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
            public SelectedParametres PrefixType;
            [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
            public SelectedParametres NickColorType;
            [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
            public SelectedParametres ChatColorType;
            [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
            public SelectedParametres IQRankSystemType;
        }

    }

    [JsonProperty(LanguageEn ? "Plugin mute settings" : "Настройка мута в плагине")]
    public ControllerMute ControllerMutes;
    internal class ControllerMute
    {
        [JsonProperty(LanguageEn ? "Prohibit sending messages in /pm and /r if the player's chat is blocked" : "Запрещать отправлять сообщения в /pm, /r - если у игрока заблокирован чат")]
        public Boolean mutedPM;
        [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
        public AutoMute AutoMuteSettings;
        internal class AutoMute
        {
            [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
            public Boolean UseAutoMute;
            [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
            public Muted AutoMuted;
        }

        [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
        public LoggedFuncion LoggedMute;
        internal class LoggedFuncion
        {
            [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
            public Boolean UseHistoryMessage;
            [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
            public Int32 CountHistoryMessage;
        }

        [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
        public List<Muted> MuteChatReasons;
        [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
        public List<Muted> MuteVoiceReasons;
        internal class Muted
        {
            [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
            public String Reason;
            [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
            public Int32 SecondMute;
        }

    }

    [JsonProperty(LanguageEn ? "Configuring Message Processing" : "Настройка обработки сообщений")]
    public ControllerMessage ControllerMessages;
    internal class ControllerMessage
    {
        [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
        public GeneralSettings GeneralSetting;
        [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
        public TurnedFuncional TurnedFunc;
        [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
        public FormattingMessage Formatting;
        internal class GeneralSettings
        {
            [JsonProperty(LanguageEn ? "Notify the player in chat about receiving a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о получении префикса/цвета ника/цвета чата (true - да/false - нет)")]
            public Boolean alertArgumentsInfoSetup;
            [JsonProperty(LanguageEn ? "Notify the player in chat about the end of a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о окончании префикса/цвета ника/цвета чата (true - да/false - нет)")]
            public Boolean alertArgumentsInfoRemove;
            [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
            public BroadcastSettings BroadcastFormat;
            [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
            public AlertSettings AlertFormat;
            [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
            public OtherSettings OtherSetting;
            internal class BroadcastSettings
            {
                [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
                public String BroadcastTitle;
                [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
                public String BroadcastColor;
                [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
                public String Steam64IDAvatar;
            }

            internal class AlertSettings
            {
                [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
                public String AlertPlayerColor;
                [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
                public String SoundAlertPlayer;
            }

            internal class OtherSettings
            {
                [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
                public Int32 TimeDeleteAlertUI;
                [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
                public Int32 SizeMessage;
                [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
                public Int32 SizeNick;
                [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
                public Int32 SizePrefix;
                [JsonProperty(LanguageEn ? "Nickname size according to privilege [permission] = size" : "Размер ника по привилегии [permission] = размер")]
                public Dictionary<String, Int32> sizeNickPrivilages;
                [JsonProperty(LanguageEn ? "Chat message size according to privilege [permission] = size" : "Размер сообщения в чате по привилегии [permission] = размер")]
                public Dictionary<String, Int32> sizeMessagePrivilages;
                public Int32 GetSizeNickOrMessage(BasePlayer player, Boolean nickOrMessage);
            }

        }

        internal class TurnedFuncional
        {
            [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
            public AntiSpam AntiSpamSetting;
            [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
            public AntiNoob AntiNoobSetting;
            [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
            public PM PMSetting;
            internal class AntiNoob
            {
                [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
                public Settings AntiNoobPM;
                [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
                public Settings AntiNoobChat;
                internal class Settings
                {
                    [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                    public Boolean AntiNoobActivate;
                    [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                    public Int32 TimeBlocked;
                }

            }

            internal class AntiSpam
            {
                [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
                public Boolean AntiSpamActivate;
                [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                public Int32 FloodTime;
                [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
                public AntiSpamDuples AntiSpamDuplesSetting;
                internal class AntiSpamDuples
                {
                    [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                    public Boolean AntiSpamDuplesActivate;
                    [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                    public Int32 TryDuples;
                    [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                    public ControllerMute.Muted MuteSetting;
                }

            }

            internal class PM
            {
                [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
                public Boolean PMActivate;
                [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
                public String SoundPM;
            }

            [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
            public Boolean IgnoreUsePM;
            [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
            public Boolean HideAdminGave;
            [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
            public Boolean MuteTeamChat;
        }

        internal class FormattingMessage
        {
            [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
            public Boolean FormatMessage;
            [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
            public Boolean UseBadWords;
            [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
            public String ReplaceBadWord;
            [JsonProperty(LanguageEn ? "The list of forbidden words [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных слов [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
            public Dictionary<String, Boolean> BadWords;
            [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
            public NickController ControllerNickname;
            internal class NickController
            {
                [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
                public Boolean UseNickController;
                [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
                public String ReplaceBadNick;
                [JsonProperty(LanguageEn ? "The list of forbidden nicknames [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных ников [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
                public Dictionary<String, Boolean> BadNicks;
                [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
                public List<String> AllowedLinkNick;
            }

        }

    }

    [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
    public ControllerAlert ControllerAlertSetting;
    internal class ControllerAlert
    {
        [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
        public Alert AlertSetting;
        [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
        public PlayerSession PlayerSessionSetting;
        [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
        public AdminSession AdminSessionSetting;
        [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
        public PersonalAlert PersonalAlertSetting;
        internal class Alert
        {
            [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
            public Boolean AlertMessage;
            [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
            public Boolean AlertMessageType;
            [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
            public LanguageController MessageList;
            [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
            public Int32 MessageListTimer;
        }

        internal class PlayerSession
        {
            [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
            public Boolean ConnectedAvatarUse;
            [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
            public Boolean ConnectedAlert;
            [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
            public Boolean ConnectionAlertRandom;
            [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
            public Boolean ConnectedWorld;
            [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
            public Boolean DisconnectedAlert;
            [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
            public Boolean DisconnectedAlertRandom;
            [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
            public Boolean DisconnectedReason;
            [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
            public LanguageController RandomConnectionAlert;
            [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
            public LanguageController RandomDisconnectedAlert;
        }

        internal class AdminSession
        {
            [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
            public Boolean ConnectedAlertAdmin;
            [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
            public Boolean DisconnectedAlertAdmin;
        }

        internal class PersonalAlert
        {
            [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
            public Boolean UseWelcomeMessage;
            [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
            public LanguageController WelcomeMessage;
        }

    }

    public class LanguageController
    {
        [JsonProperty(LanguageEn ? "Setting up Multilingual Messages [Language Code] = Translation Variations" : "Настройка мультиязычных сообщений [КодЯзыка] = ВариацииПеревода")]
        public Dictionary<String, List<String>> LanguageMessages;
    }

    [JsonProperty(LanguageEn ? "Settings Rust+" : "Настройка Rust+")]
    public RustPlus RustPlusSettings;
    internal class RustPlus
    {
        [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
        public Boolean UseRustPlus;
        [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
        public String DisplayNameAlert;
    }

    [JsonProperty(LanguageEn ? "Configuring support plugins" : "Настройка плагинов поддержки")]
    public ReferenceSettings ReferenceSetting;
    internal class ReferenceSettings
    {
        [JsonProperty(LanguageEn ? "Settings XLevels" : "Настройка XLevels")]
        public XLevels XLevelsSettings;
        [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
        public IQFakeActive IQFakeActiveSettings;
        [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
        public IQRankSystem IQRankSystems;
        [JsonProperty(LanguageEn ? "Settings Clans" : "Настройка Clans")]
        public Clans ClansSettings;
        [JsonProperty(LanguageEn ? "Settings TranslationAPI" : "Настройка TranslationAPI")]
        public TranslataionApi translationApiSettings;
        [JsonProperty(LanguageEn ? "Settings SkillTree" : "Настройка SkillTree")]
        public SkillTree skillTreeSettings;
        [JsonProperty(LanguageEn ? "Settings PlayerRanks" : "Настройка PlayerRanks")]
        public PlayerRanks playerRanksSettings;
        [JsonProperty(LanguageEn ? "Settings XPrison" : "Настройка XPrison")]
        public XPrison xPrisonSettings;
        internal class TranslataionApi
        {
            [JsonProperty(LanguageEn ? "To use automatic message translation using the TranslationAPI" : "Использовать автоматический перевод сообщений с помощью TranslataionAPI")]
            public Boolean useTranslationApi;
            [JsonProperty(LanguageEn ? "Translate team chat" : "Переводить командный чат")]
            public Boolean translateTeamChat;
            [JsonProperty(LanguageEn ? "Translate chat in private messages." : "Переводить чат в личных сообщениях")]
            public Boolean translatePmChat;
            [JsonProperty(LanguageEn ? "The code for the preferred language (leave it empty, and then the translation will be done in each player's language)" : "Код приоритетного языка (оставьте пустым и тогда для каждого игрока будет переводиться на его языке клиента)")]
            public String codeLanguagePrimary;
        }

        internal class Clans
        {
            [JsonProperty(LanguageEn ? "Display a clan tag in the chat (if Clans are installed)" : "Отображать в чате клановый тэг (если установлены Clans)")]
            public Boolean UseClanTag;
            [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
            public String colorTag;
        }

        internal class IQRankSystem
        {
            [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
            public String FormatRank;
            [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
            public String FormatRankTime;
            [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
            public Boolean UseRankSystem;
            [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
            public Boolean UseTimeStandart;
        }

        internal class IQFakeActive
        {
            [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
            public Boolean UseIQFakeActive;
        }

        internal class XLevels
        {
            [JsonProperty(LanguageEn ? "Use support XLevels" : "Использовать поддержку XLevels")]
            public Boolean UseXLevels;
            [JsonProperty(LanguageEn ? "Use full prefix with level from XLevel (true) otherwise only level (false)" : "Использовать полный префикс с уровнем из XLevel (true) иначе только уровень (false)")]
            public Boolean UseFullXLevels;
            [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
            public String colorTag;
        }

        internal class XPrison
        {
            [JsonProperty(LanguageEn ? "Use support XPrison" : "Использовать поддержку XPrison")]
            public Boolean UseXPrison;
            [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
            public String colorTag;
        }

        internal class SkillTree
        {
            [JsonProperty(LanguageEn ? "Use support SkillTree" : "Использовать поддержку SkillTree")]
            public Boolean UseSkillTree;
            [JsonProperty(LanguageEn ? "Use full XP + Level information output (true), use only Level (false)" : "Использовать полный вывод информации XP + Level (true), использовать только Level (false)")]
            public Boolean UseFullSkillTree;
            [JsonProperty(LanguageEn ? "Use prestige" : "Использовать престиж")]
            public Boolean UsePrestigeSkillTree;
            [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
            public String colorTag;
        }

        internal class PlayerRanks
        {
            [JsonProperty(LanguageEn ? "Use support PlayerRanks" : "Использовать поддержку PlayerRanks")]
            public Boolean UsePlayerRanks;
            [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
            public String colorTag;
        }

    }

    [JsonProperty(LanguageEn ? "Setting up an answering machine" : "Настройка автоответчика")]
    public AnswerMessage AnswerMessages;
    internal class AnswerMessage
    {
        [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
        public bool UseAnswer;
        [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
        public Dictionary<String, LanguageController> AnswerMessageList;
    }

    [JsonProperty(LanguageEn ? "Disable additional chat duplication in RCON" : "Отключить дополнительное дублированиеи чата в RCON")]
    public Boolean disableRconBroadcast;
    [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
    public OtherSettings OtherSetting;
    internal class OtherSettings
    {
        [JsonProperty("SteamApiKey (https://steamcommunity.com/dev/apikey)")]
        public String renameSteamApiKey;
        [JsonProperty(LanguageEn ? "Enable the /online command (true - yes / false - no)" : "Включить команду /online (true - да/ false - нет)")]
        public Boolean UseCommandOnline;
        [JsonProperty(LanguageEn ? "Use shortened format /online (will only display quantity)" : "Использовать сокращенный формат /online (будет отображать только количество)")]
        public Boolean UseCommandShortOnline;
        [JsonProperty(LanguageEn ? "Compact logging of messages" : "Компактное логирование сообщений")]
        public CompactLoggetChat CompactLogsChat;
        [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
        public LoggedChat LogsChat;
        [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
        public General LogsPMChat;
        [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
        public General LogsMuted;
        [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
        public General LogsChatCommands;
        internal class CompactLoggetChat
        {
            [JsonProperty(LanguageEn ? "Display Steam64ID in the log (true - yes/false - no)" : "Отображать в логе Steam64ID (true - да/false - нет)")]
            public Boolean ShowSteamID;
            [JsonProperty(LanguageEn ? "Setting up compact message logging" : "Настройка компактного логирования сообщений")]
            public LoggedChat LogsCompactChat;
        }

        internal class LoggedChat
        {
            [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
            public General GlobalChatSettings;
            [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
            public General TeamChatSettings;
        }

        internal class General
        {
            [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
            public Boolean UseLogged;
            [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
            public String Webhooks;
        }

    }

    public static Configuration GetNewConfiguration();
}

internal class ControllerConnection
{
    [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
    public Turned Turneds;
    [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
    public SetupDefault SetupDefaults;
    internal class SetupDefault
    {
        [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
        public String PrefixDefault;
        [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
        public String NickDefault;
        [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
        public String MessageDefault;
    }

    internal class Turned
    {
        [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
        public Boolean TurnAutoSetupPrefix;
        [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
        public Boolean TurnAutoSetupColorNick;
        [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
        public Boolean TurnAutoSetupColorChat;
        [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
        public Boolean TurnAutoDropPrefix;
        [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
        public Boolean TurnAutoDropColorNick;
        [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
        public Boolean TurnAutoDropColorChat;
    }

}

internal class SetupDefault
{
    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
    public String PrefixDefault;
    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
    public String NickDefault;
    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
    public String MessageDefault;
}

internal class Turned
{
    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
    public Boolean TurnAutoSetupPrefix;
    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
    public Boolean TurnAutoSetupColorNick;
    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
    public Boolean TurnAutoSetupColorChat;
    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
    public Boolean TurnAutoDropPrefix;
    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
    public Boolean TurnAutoDropColorNick;
    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
    public Boolean TurnAutoDropColorChat;
}

internal class ControllerParameters
{
    [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
    public VisualSettingParametres VisualParametres;
    [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
    public List<AdvancedFuncion> NickColorList;
    [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
    public List<AdvancedFuncion> MessageColorList;
    [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
    public PrefixSetting Prefixes;
    internal class PrefixSetting
    {
        [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
        public Boolean TurnMultiPrefixes;
        [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
        public Int32 MaximumMultiPrefixCount;
        [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
        public List<AdvancedFuncion> Prefixes;
    }

    internal class AdvancedFuncion
    {
        [JsonProperty(LanguageEn ? "Permission" : "Права")]
        public String Permissions;
        [JsonProperty(LanguageEn ? "Argument" : "Значение")]
        public String Argument;
        [JsonProperty(LanguageEn ? "Block the player's ability to select this parameter in the plugin menu (true - yes/false - no)" : "Заблокировать возможность выбрать данный параметр игроком в меню плагина (true - да/false - нет)")]
        public Boolean IsBlockSelected;
    }

    internal class VisualSettingParametres
    {
        [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
        public SelectedParametres PrefixType;
        [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
        public SelectedParametres NickColorType;
        [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
        public SelectedParametres ChatColorType;
        [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
        public SelectedParametres IQRankSystemType;
    }

}

internal class PrefixSetting
{
    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
    public Boolean TurnMultiPrefixes;
    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
    public Int32 MaximumMultiPrefixCount;
    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
    public List<AdvancedFuncion> Prefixes;
}

internal class AdvancedFuncion
{
    [JsonProperty(LanguageEn ? "Permission" : "Права")]
    public String Permissions;
    [JsonProperty(LanguageEn ? "Argument" : "Значение")]
    public String Argument;
    [JsonProperty(LanguageEn ? "Block the player's ability to select this parameter in the plugin menu (true - yes/false - no)" : "Заблокировать возможность выбрать данный параметр игроком в меню плагина (true - да/false - нет)")]
    public Boolean IsBlockSelected;
}

internal class VisualSettingParametres
{
    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
    public SelectedParametres PrefixType;
    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
    public SelectedParametres NickColorType;
    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
    public SelectedParametres ChatColorType;
    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
    public SelectedParametres IQRankSystemType;
}

internal class ControllerMute
{
    [JsonProperty(LanguageEn ? "Prohibit sending messages in /pm and /r if the player's chat is blocked" : "Запрещать отправлять сообщения в /pm, /r - если у игрока заблокирован чат")]
    public Boolean mutedPM;
    [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
    public AutoMute AutoMuteSettings;
    internal class AutoMute
    {
        [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
        public Boolean UseAutoMute;
        [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
        public Muted AutoMuted;
    }

    [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
    public LoggedFuncion LoggedMute;
    internal class LoggedFuncion
    {
        [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
        public Boolean UseHistoryMessage;
        [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
        public Int32 CountHistoryMessage;
    }

    [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
    public List<Muted> MuteChatReasons;
    [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
    public List<Muted> MuteVoiceReasons;
    internal class Muted
    {
        [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
        public String Reason;
        [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
        public Int32 SecondMute;
    }

}

internal class AutoMute
{
    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
    public Boolean UseAutoMute;
    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
    public Muted AutoMuted;
}

internal class LoggedFuncion
{
    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
    public Boolean UseHistoryMessage;
    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
    public Int32 CountHistoryMessage;
}

internal class Muted
{
    [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
    public String Reason;
    [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
    public Int32 SecondMute;
}

internal class ControllerMessage
{
    [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
    public GeneralSettings GeneralSetting;
    [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
    public TurnedFuncional TurnedFunc;
    [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
    public FormattingMessage Formatting;
    internal class GeneralSettings
    {
        [JsonProperty(LanguageEn ? "Notify the player in chat about receiving a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о получении префикса/цвета ника/цвета чата (true - да/false - нет)")]
        public Boolean alertArgumentsInfoSetup;
        [JsonProperty(LanguageEn ? "Notify the player in chat about the end of a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о окончании префикса/цвета ника/цвета чата (true - да/false - нет)")]
        public Boolean alertArgumentsInfoRemove;
        [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
        public BroadcastSettings BroadcastFormat;
        [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
        public AlertSettings AlertFormat;
        [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
        public OtherSettings OtherSetting;
        internal class BroadcastSettings
        {
            [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
            public String BroadcastTitle;
            [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
            public String BroadcastColor;
            [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
            public String Steam64IDAvatar;
        }

        internal class AlertSettings
        {
            [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
            public String AlertPlayerColor;
            [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
            public String SoundAlertPlayer;
        }

        internal class OtherSettings
        {
            [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
            public Int32 TimeDeleteAlertUI;
            [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
            public Int32 SizeMessage;
            [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
            public Int32 SizeNick;
            [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
            public Int32 SizePrefix;
            [JsonProperty(LanguageEn ? "Nickname size according to privilege [permission] = size" : "Размер ника по привилегии [permission] = размер")]
            public Dictionary<String, Int32> sizeNickPrivilages;
            [JsonProperty(LanguageEn ? "Chat message size according to privilege [permission] = size" : "Размер сообщения в чате по привилегии [permission] = размер")]
            public Dictionary<String, Int32> sizeMessagePrivilages;
            public Int32 GetSizeNickOrMessage(BasePlayer player, Boolean nickOrMessage);
        }

    }

    internal class TurnedFuncional
    {
        [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
        public AntiSpam AntiSpamSetting;
        [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
        public AntiNoob AntiNoobSetting;
        [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
        public PM PMSetting;
        internal class AntiNoob
        {
            [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
            public Settings AntiNoobPM;
            [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
            public Settings AntiNoobChat;
            internal class Settings
            {
                [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                public Boolean AntiNoobActivate;
                [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                public Int32 TimeBlocked;
            }

        }

        internal class AntiSpam
        {
            [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
            public Boolean AntiSpamActivate;
            [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
            public Int32 FloodTime;
            [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
            public AntiSpamDuples AntiSpamDuplesSetting;
            internal class AntiSpamDuples
            {
                [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                public Boolean AntiSpamDuplesActivate;
                [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                public Int32 TryDuples;
                [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                public ControllerMute.Muted MuteSetting;
            }

        }

        internal class PM
        {
            [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
            public Boolean PMActivate;
            [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
            public String SoundPM;
        }

        [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
        public Boolean IgnoreUsePM;
        [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
        public Boolean HideAdminGave;
        [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
        public Boolean MuteTeamChat;
    }

    internal class FormattingMessage
    {
        [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
        public Boolean FormatMessage;
        [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
        public Boolean UseBadWords;
        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
        public String ReplaceBadWord;
        [JsonProperty(LanguageEn ? "The list of forbidden words [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных слов [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
        public Dictionary<String, Boolean> BadWords;
        [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
        public NickController ControllerNickname;
        internal class NickController
        {
            [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
            public Boolean UseNickController;
            [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
            public String ReplaceBadNick;
            [JsonProperty(LanguageEn ? "The list of forbidden nicknames [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных ников [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
            public Dictionary<String, Boolean> BadNicks;
            [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
            public List<String> AllowedLinkNick;
        }

    }

}

internal class GeneralSettings
{
    [JsonProperty(LanguageEn ? "Notify the player in chat about receiving a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о получении префикса/цвета ника/цвета чата (true - да/false - нет)")]
    public Boolean alertArgumentsInfoSetup;
    [JsonProperty(LanguageEn ? "Notify the player in chat about the end of a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о окончании префикса/цвета ника/цвета чата (true - да/false - нет)")]
    public Boolean alertArgumentsInfoRemove;
    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
    public BroadcastSettings BroadcastFormat;
    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
    public AlertSettings AlertFormat;
    [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
    public OtherSettings OtherSetting;
    internal class BroadcastSettings
    {
        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
        public String BroadcastTitle;
        [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
        public String BroadcastColor;
        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
        public String Steam64IDAvatar;
    }

    internal class AlertSettings
    {
        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
        public String AlertPlayerColor;
        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
        public String SoundAlertPlayer;
    }

    internal class OtherSettings
    {
        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
        public Int32 TimeDeleteAlertUI;
        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
        public Int32 SizeMessage;
        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
        public Int32 SizeNick;
        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
        public Int32 SizePrefix;
        [JsonProperty(LanguageEn ? "Nickname size according to privilege [permission] = size" : "Размер ника по привилегии [permission] = размер")]
        public Dictionary<String, Int32> sizeNickPrivilages;
        [JsonProperty(LanguageEn ? "Chat message size according to privilege [permission] = size" : "Размер сообщения в чате по привилегии [permission] = размер")]
        public Dictionary<String, Int32> sizeMessagePrivilages;
        public Int32 GetSizeNickOrMessage(BasePlayer player, Boolean nickOrMessage);
    }

}

internal class BroadcastSettings
{
    [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
    public String BroadcastTitle;
    [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
    public String BroadcastColor;
    [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
    public String Steam64IDAvatar;
}

internal class AlertSettings
{
    [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
    public String AlertPlayerColor;
    [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
    public String SoundAlertPlayer;
}

internal class OtherSettings
{
    [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
    public Int32 TimeDeleteAlertUI;
    [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
    public Int32 SizeMessage;
    [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
    public Int32 SizeNick;
    [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
    public Int32 SizePrefix;
    [JsonProperty(LanguageEn ? "Nickname size according to privilege [permission] = size" : "Размер ника по привилегии [permission] = размер")]
    public Dictionary<String, Int32> sizeNickPrivilages;
    [JsonProperty(LanguageEn ? "Chat message size according to privilege [permission] = size" : "Размер сообщения в чате по привилегии [permission] = размер")]
    public Dictionary<String, Int32> sizeMessagePrivilages;
    public Int32 GetSizeNickOrMessage(BasePlayer player, Boolean nickOrMessage);
}

internal class TurnedFuncional
{
    [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
    public AntiSpam AntiSpamSetting;
    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
    public AntiNoob AntiNoobSetting;
    [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
    public PM PMSetting;
    internal class AntiNoob
    {
        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
        public Settings AntiNoobPM;
        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
        public Settings AntiNoobChat;
        internal class Settings
        {
            [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
            public Boolean AntiNoobActivate;
            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
            public Int32 TimeBlocked;
        }

    }

    internal class AntiSpam
    {
        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
        public Boolean AntiSpamActivate;
        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
        public Int32 FloodTime;
        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
        public AntiSpamDuples AntiSpamDuplesSetting;
        internal class AntiSpamDuples
        {
            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
            public Boolean AntiSpamDuplesActivate;
            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
            public Int32 TryDuples;
            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
            public ControllerMute.Muted MuteSetting;
        }

    }

    internal class PM
    {
        [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
        public Boolean PMActivate;
        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
        public String SoundPM;
    }

    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
    public Boolean IgnoreUsePM;
    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
    public Boolean HideAdminGave;
    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
    public Boolean MuteTeamChat;
}

internal class AntiNoob
{
    [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
    public Settings AntiNoobPM;
    [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
    public Settings AntiNoobChat;
    internal class Settings
    {
        [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
        public Boolean AntiNoobActivate;
        [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
        public Int32 TimeBlocked;
    }

}

internal class Settings
{
    [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
    public Boolean AntiNoobActivate;
    [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
    public Int32 TimeBlocked;
}

internal class AntiSpam
{
    [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
    public Boolean AntiSpamActivate;
    [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
    public Int32 FloodTime;
    [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
    public AntiSpamDuples AntiSpamDuplesSetting;
    internal class AntiSpamDuples
    {
        [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
        public Boolean AntiSpamDuplesActivate;
        [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
        public Int32 TryDuples;
        [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
        public ControllerMute.Muted MuteSetting;
    }

}

internal class AntiSpamDuples
{
    [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
    public Boolean AntiSpamDuplesActivate;
    [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
    public Int32 TryDuples;
    [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
    public ControllerMute.Muted MuteSetting;
}

internal class PM
{
    [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
    public Boolean PMActivate;
    [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
    public String SoundPM;
}

internal class FormattingMessage
{
    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
    public Boolean FormatMessage;
    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
    public Boolean UseBadWords;
    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
    public String ReplaceBadWord;
    [JsonProperty(LanguageEn ? "The list of forbidden words [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных слов [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
    public Dictionary<String, Boolean> BadWords;
    [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
    public NickController ControllerNickname;
    internal class NickController
    {
        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
        public Boolean UseNickController;
        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
        public String ReplaceBadNick;
        [JsonProperty(LanguageEn ? "The list of forbidden nicknames [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных ников [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
        public Dictionary<String, Boolean> BadNicks;
        [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
        public List<String> AllowedLinkNick;
    }

}

internal class NickController
{
    [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
    public Boolean UseNickController;
    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
    public String ReplaceBadNick;
    [JsonProperty(LanguageEn ? "The list of forbidden nicknames [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных ников [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
    public Dictionary<String, Boolean> BadNicks;
    [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
    public List<String> AllowedLinkNick;
}

internal class ControllerAlert
{
    [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
    public Alert AlertSetting;
    [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
    public PlayerSession PlayerSessionSetting;
    [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
    public AdminSession AdminSessionSetting;
    [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
    public PersonalAlert PersonalAlertSetting;
    internal class Alert
    {
        [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
        public Boolean AlertMessage;
        [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
        public Boolean AlertMessageType;
        [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
        public LanguageController MessageList;
        [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
        public Int32 MessageListTimer;
    }

    internal class PlayerSession
    {
        [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
        public Boolean ConnectedAvatarUse;
        [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
        public Boolean ConnectedAlert;
        [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
        public Boolean ConnectionAlertRandom;
        [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
        public Boolean ConnectedWorld;
        [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
        public Boolean DisconnectedAlert;
        [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
        public Boolean DisconnectedAlertRandom;
        [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
        public Boolean DisconnectedReason;
        [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
        public LanguageController RandomConnectionAlert;
        [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
        public LanguageController RandomDisconnectedAlert;
    }

    internal class AdminSession
    {
        [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
        public Boolean ConnectedAlertAdmin;
        [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
        public Boolean DisconnectedAlertAdmin;
    }

    internal class PersonalAlert
    {
        [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
        public Boolean UseWelcomeMessage;
        [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
        public LanguageController WelcomeMessage;
    }

}

internal class Alert
{
    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
    public Boolean AlertMessage;
    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
    public Boolean AlertMessageType;
    [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
    public LanguageController MessageList;
    [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
    public Int32 MessageListTimer;
}

internal class PlayerSession
{
    [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
    public Boolean ConnectedAvatarUse;
    [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
    public Boolean ConnectedAlert;
    [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
    public Boolean ConnectionAlertRandom;
    [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
    public Boolean ConnectedWorld;
    [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
    public Boolean DisconnectedAlert;
    [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
    public Boolean DisconnectedAlertRandom;
    [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
    public Boolean DisconnectedReason;
    [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
    public LanguageController RandomConnectionAlert;
    [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
    public LanguageController RandomDisconnectedAlert;
}

internal class AdminSession
{
    [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
    public Boolean ConnectedAlertAdmin;
    [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
    public Boolean DisconnectedAlertAdmin;
}

internal class PersonalAlert
{
    [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
    public Boolean UseWelcomeMessage;
    [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
    public LanguageController WelcomeMessage;
}

public class LanguageController
{
    [JsonProperty(LanguageEn ? "Setting up Multilingual Messages [Language Code] = Translation Variations" : "Настройка мультиязычных сообщений [КодЯзыка] = ВариацииПеревода")]
    public Dictionary<String, List<String>> LanguageMessages;
}

internal class RustPlus
{
    [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
    public Boolean UseRustPlus;
    [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
    public String DisplayNameAlert;
}

internal class ReferenceSettings
{
    [JsonProperty(LanguageEn ? "Settings XLevels" : "Настройка XLevels")]
    public XLevels XLevelsSettings;
    [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
    public IQFakeActive IQFakeActiveSettings;
    [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
    public IQRankSystem IQRankSystems;
    [JsonProperty(LanguageEn ? "Settings Clans" : "Настройка Clans")]
    public Clans ClansSettings;
    [JsonProperty(LanguageEn ? "Settings TranslationAPI" : "Настройка TranslationAPI")]
    public TranslataionApi translationApiSettings;
    [JsonProperty(LanguageEn ? "Settings SkillTree" : "Настройка SkillTree")]
    public SkillTree skillTreeSettings;
    [JsonProperty(LanguageEn ? "Settings PlayerRanks" : "Настройка PlayerRanks")]
    public PlayerRanks playerRanksSettings;
    [JsonProperty(LanguageEn ? "Settings XPrison" : "Настройка XPrison")]
    public XPrison xPrisonSettings;
    internal class TranslataionApi
    {
        [JsonProperty(LanguageEn ? "To use automatic message translation using the TranslationAPI" : "Использовать автоматический перевод сообщений с помощью TranslataionAPI")]
        public Boolean useTranslationApi;
        [JsonProperty(LanguageEn ? "Translate team chat" : "Переводить командный чат")]
        public Boolean translateTeamChat;
        [JsonProperty(LanguageEn ? "Translate chat in private messages." : "Переводить чат в личных сообщениях")]
        public Boolean translatePmChat;
        [JsonProperty(LanguageEn ? "The code for the preferred language (leave it empty, and then the translation will be done in each player's language)" : "Код приоритетного языка (оставьте пустым и тогда для каждого игрока будет переводиться на его языке клиента)")]
        public String codeLanguagePrimary;
    }

    internal class Clans
    {
        [JsonProperty(LanguageEn ? "Display a clan tag in the chat (if Clans are installed)" : "Отображать в чате клановый тэг (если установлены Clans)")]
        public Boolean UseClanTag;
        [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
        public String colorTag;
    }

    internal class IQRankSystem
    {
        [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
        public String FormatRank;
        [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
        public String FormatRankTime;
        [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
        public Boolean UseRankSystem;
        [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
        public Boolean UseTimeStandart;
    }

    internal class IQFakeActive
    {
        [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
        public Boolean UseIQFakeActive;
    }

    internal class XLevels
    {
        [JsonProperty(LanguageEn ? "Use support XLevels" : "Использовать поддержку XLevels")]
        public Boolean UseXLevels;
        [JsonProperty(LanguageEn ? "Use full prefix with level from XLevel (true) otherwise only level (false)" : "Использовать полный префикс с уровнем из XLevel (true) иначе только уровень (false)")]
        public Boolean UseFullXLevels;
        [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
        public String colorTag;
    }

    internal class XPrison
    {
        [JsonProperty(LanguageEn ? "Use support XPrison" : "Использовать поддержку XPrison")]
        public Boolean UseXPrison;
        [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
        public String colorTag;
    }

    internal class SkillTree
    {
        [JsonProperty(LanguageEn ? "Use support SkillTree" : "Использовать поддержку SkillTree")]
        public Boolean UseSkillTree;
        [JsonProperty(LanguageEn ? "Use full XP + Level information output (true), use only Level (false)" : "Использовать полный вывод информации XP + Level (true), использовать только Level (false)")]
        public Boolean UseFullSkillTree;
        [JsonProperty(LanguageEn ? "Use prestige" : "Использовать престиж")]
        public Boolean UsePrestigeSkillTree;
        [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
        public String colorTag;
    }

    internal class PlayerRanks
    {
        [JsonProperty(LanguageEn ? "Use support PlayerRanks" : "Использовать поддержку PlayerRanks")]
        public Boolean UsePlayerRanks;
        [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
        public String colorTag;
    }

}

internal class TranslataionApi
{
    [JsonProperty(LanguageEn ? "To use automatic message translation using the TranslationAPI" : "Использовать автоматический перевод сообщений с помощью TranslataionAPI")]
    public Boolean useTranslationApi;
    [JsonProperty(LanguageEn ? "Translate team chat" : "Переводить командный чат")]
    public Boolean translateTeamChat;
    [JsonProperty(LanguageEn ? "Translate chat in private messages." : "Переводить чат в личных сообщениях")]
    public Boolean translatePmChat;
    [JsonProperty(LanguageEn ? "The code for the preferred language (leave it empty, and then the translation will be done in each player's language)" : "Код приоритетного языка (оставьте пустым и тогда для каждого игрока будет переводиться на его языке клиента)")]
    public String codeLanguagePrimary;
}

internal class Clans
{
    [JsonProperty(LanguageEn ? "Display a clan tag in the chat (if Clans are installed)" : "Отображать в чате клановый тэг (если установлены Clans)")]
    public Boolean UseClanTag;
    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
    public String colorTag;
}

internal class IQRankSystem
{
    [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
    public String FormatRank;
    [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
    public String FormatRankTime;
    [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
    public Boolean UseRankSystem;
    [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
    public Boolean UseTimeStandart;
}

internal class IQFakeActive
{
    [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
    public Boolean UseIQFakeActive;
}

internal class XLevels
{
    [JsonProperty(LanguageEn ? "Use support XLevels" : "Использовать поддержку XLevels")]
    public Boolean UseXLevels;
    [JsonProperty(LanguageEn ? "Use full prefix with level from XLevel (true) otherwise only level (false)" : "Использовать полный префикс с уровнем из XLevel (true) иначе только уровень (false)")]
    public Boolean UseFullXLevels;
    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
    public String colorTag;
}

internal class XPrison
{
    [JsonProperty(LanguageEn ? "Use support XPrison" : "Использовать поддержку XPrison")]
    public Boolean UseXPrison;
    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
    public String colorTag;
}

internal class SkillTree
{
    [JsonProperty(LanguageEn ? "Use support SkillTree" : "Использовать поддержку SkillTree")]
    public Boolean UseSkillTree;
    [JsonProperty(LanguageEn ? "Use full XP + Level information output (true), use only Level (false)" : "Использовать полный вывод информации XP + Level (true), использовать только Level (false)")]
    public Boolean UseFullSkillTree;
    [JsonProperty(LanguageEn ? "Use prestige" : "Использовать престиж")]
    public Boolean UsePrestigeSkillTree;
    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
    public String colorTag;
}

internal class PlayerRanks
{
    [JsonProperty(LanguageEn ? "Use support PlayerRanks" : "Использовать поддержку PlayerRanks")]
    public Boolean UsePlayerRanks;
    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
    public String colorTag;
}

internal class AnswerMessage
{
    [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
    public bool UseAnswer;
    [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
    public Dictionary<String, LanguageController> AnswerMessageList;
}

internal class OtherSettings
{
    [JsonProperty("SteamApiKey (https://steamcommunity.com/dev/apikey)")]
    public String renameSteamApiKey;
    [JsonProperty(LanguageEn ? "Enable the /online command (true - yes / false - no)" : "Включить команду /online (true - да/ false - нет)")]
    public Boolean UseCommandOnline;
    [JsonProperty(LanguageEn ? "Use shortened format /online (will only display quantity)" : "Использовать сокращенный формат /online (будет отображать только количество)")]
    public Boolean UseCommandShortOnline;
    [JsonProperty(LanguageEn ? "Compact logging of messages" : "Компактное логирование сообщений")]
    public CompactLoggetChat CompactLogsChat;
    [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
    public LoggedChat LogsChat;
    [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
    public General LogsPMChat;
    [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
    public General LogsMuted;
    [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
    public General LogsChatCommands;
    internal class CompactLoggetChat
    {
        [JsonProperty(LanguageEn ? "Display Steam64ID in the log (true - yes/false - no)" : "Отображать в логе Steam64ID (true - да/false - нет)")]
        public Boolean ShowSteamID;
        [JsonProperty(LanguageEn ? "Setting up compact message logging" : "Настройка компактного логирования сообщений")]
        public LoggedChat LogsCompactChat;
    }

    internal class LoggedChat
    {
        [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
        public General GlobalChatSettings;
        [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
        public General TeamChatSettings;
    }

    internal class General
    {
        [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
        public Boolean UseLogged;
        [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
        public String Webhooks;
    }

}

internal class CompactLoggetChat
{
    [JsonProperty(LanguageEn ? "Display Steam64ID in the log (true - yes/false - no)" : "Отображать в логе Steam64ID (true - да/false - нет)")]
    public Boolean ShowSteamID;
    [JsonProperty(LanguageEn ? "Setting up compact message logging" : "Настройка компактного логирования сообщений")]
    public LoggedChat LogsCompactChat;
}

internal class LoggedChat
{
    [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
    public General GlobalChatSettings;
    [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
    public General TeamChatSettings;
}

internal class General
{
    [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
    public Boolean UseLogged;
    [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
    public String Webhooks;
}

internal class AntiNoob
{
    public DateTime DateConnection;
    public Boolean IsNoob(Int32 TimeBlocked);
    public Double LeftTime(Int32 TimeBlocked);
}

public class User
{
    public Information Info;
    public Setting Settings;
    public Mute MuteInfo;
    internal class Information
    {
        public String Prefix;
        public String ColorNick;
        public String ColorMessage;
        public String Rank;
        public String CustomColorNick;
        public String CustomColorMessage;
        public List<String> PrefixList;
    }

    internal class Setting
    {
        public Boolean TurnPM;
        public Boolean TurnAlert;
        public Boolean TurnBroadcast;
        public Boolean TurnSound;
        public List<UInt64> IgnoreUsers;
        public Boolean IsIgnored(UInt64 TargetID);
        public void IgnoredAddOrRemove(UInt64 TargetID);
    }

    internal class Mute
    {
        public Double TimeMuteChat;
        public Double TimeMuteVoice;
        public Double GetTime(MuteType Type);
        public void SetMute(MuteType Type, Int32 Time);
        public void UnMute(MuteType Type);
        public Boolean IsMute(MuteType Type);
    }

}

internal class Information
{
    public String Prefix;
    public String ColorNick;
    public String ColorMessage;
    public String Rank;
    public String CustomColorNick;
    public String CustomColorMessage;
    public List<String> PrefixList;
}

internal class Setting
{
    public Boolean TurnPM;
    public Boolean TurnAlert;
    public Boolean TurnBroadcast;
    public Boolean TurnSound;
    public List<UInt64> IgnoreUsers;
    public Boolean IsIgnored(UInt64 TargetID);
    public void IgnoredAddOrRemove(UInt64 TargetID);
}

internal class Mute
{
    public Double TimeMuteChat;
    public Double TimeMuteVoice;
    public Double GetTime(MuteType Type);
    public void SetMute(MuteType Type, Int32 Time);
    public void UnMute(MuteType Type);
    public Boolean IsMute(MuteType Type);
}

public class GeneralInformation
{
    public Boolean TurnMuteAllChat;
    public Boolean TurnMuteAllVoice;
    public Dictionary<UInt64, RenameInfo> RenameList;
    internal class RenameInfo
    {
        public String RenameNick;
        public UInt64 RenameID;
    }

    public RenameInfo GetInfoRename(UInt64 UserID);
}

internal class RenameInfo
{
    public String RenameNick;
    public UInt64 RenameID;
}

public class FancyMessage
{
    public string content { get; set; }
    public bool tts { get; set; }
    public Embeds[] embeds { get; set; }
    public class Embeds
    {
        public string title { get; set; }
        public int color { get; set; }
        public List<Fields> fields { get; set; }
        public Footer footer { get; set; }
        public Authors author { get; set; }
        public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer);
    }

    public FancyMessage(string content, bool tts, Embeds[] embeds);
    public string toJSON();
}

public class Embeds
{
    public string title { get; set; }
    public int color { get; set; }
    public List<Fields> fields { get; set; }
    public Footer footer { get; set; }
    public Authors author { get; set; }
    public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer);
}

public class Footer
{
    public string text { get; set; }
    public string icon_url { get; set; }
    public string proxy_icon_url { get; set; }
    public Footer(string text, string icon_url, string proxy_icon_url);
}

public class Authors
{
    public string name { get; set; }
    public string url { get; set; }
    public string icon_url { get; set; }
    public string proxy_icon_url { get; set; }
    public Authors(string name, string url, string icon_url, string proxy_icon_url);
}

public class Fields
{
    public string name { get; set; }
    public string value { get; set; }
    public bool inline { get; set; }
    public Fields(string name, string value, bool inline);
}

internal class FlooderInfo
{
    public Double Time;
    public String LastMessage;
    public Int32 TryFlood;
}

private class ImageUI
{
    private const String _path;
    private const String _printPath;
    private readonly Dictionary<String, ImageData> _images;
    private class ImageData
    {
        public ImageStatus Status;
        public string Id { get; set; }
    }

    public string GetImage(string name);
    public void DownloadImage();
    public void UnloadImages();
    private IEnumerator ProcessDownloadImage(KeyValuePair<string, ImageData> image);
}

private class ImageData
{
    public ImageStatus Status;
    public string Id { get; set; }
}

private class InformationOpenedUI
{
    public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsPrefix;
    public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsNick;
    public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsChat;
    public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsRanks;
    public Int32 SlideIndexPrefix;
    public Int32 SlideIndexNick;
    public Int32 SlideIndexChat;
    public Int32 SlideIndexRank;
}

private class InterfaceBuilder
{
    public static InterfaceBuilder Instance;
    public const String UI_Chat_Context;
    public const String UI_Chat_Context_Visual_Nick;
    public const String UI_Chat_Alert;
    public Dictionary<String, String> Interfaces;
    public InterfaceBuilder();
    public static void AddInterface(String name, String json);
    public static string GetInterface(String name);
    public static void DestroyAll();
    private void BuildingVisualNick();
    private void BuildingStaticContext();
    private void BuildingCheckBox();
    private void BuildingSlider();
    private void BuildingSliderUpdateArgument();
    private void BuildingMuteAndIgnore();
    private void BuildingMuteAndIgnorePlayerPanel();
    private void BuildingMuteAndIgnorePlayer();
    private void BuildingMuteAndIgnorePages();
    private void BuildingMuteAndIgnorePanelAlert();
    private void BuildingMuteAlert();
    private void BuildingMuteAlert_DropList_Title();
    private void BuildingMuteAlert_DropList_Reason();
    private void BuildingIgnoreAlert();
    private void BuildingDropList();
    private void BuildingOpenDropList();
    private void BuildingElementDropList();
    private void BuildingElementDropListTakeLine();
    private void BuildingModerationStatic();
    private void BuildingMuteAllChat();
    private void BuildingMuteAllVoice();
    private void BuildingAlertUI();
}


```

---

